begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|fluent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DefaultDocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|BinaryDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|ExtArrayNodeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  *<p>A named collection of XML documents in the database.  Each document belongs  * to precisely one folder.  Folders can be nested, with queries carried out  * within either the scope of a single folder or of a whole subtree.</p>  *   *<p>Though the name<code>Collection</code> is commonly used for these  * constructs in the context of XML databases, the name<code>Folder</code> was  * chosen instead to avoid conflicting with the ubiquitous Java<code>java.util.Collection</code>  * interface.</p>  *   *<p>Instances of this class are not thread-safe.</p>  *     * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a>  * @version $Revision: 1.31 $ ($Date: 2006/09/04 06:09:05 $)  */
end_comment

begin_class
specifier|public
class|class
name|Folder
extends|extends
name|NamedResource
implements|implements
name|Cloneable
block|{
comment|/** 	 * Listener for events affecting folders.  The three possible actions are folder 	 * creation, renaming (update), and deletion. 	 *  	 *<em>WARNING:</em>  as of September 1, 2005, eXist does not implement 	 * folder triggers so folder listeners are ineffective.  This warning will be removed 	 * when the situation is known to have been corrected. 	 * 	 * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a> 	 */
specifier|public
interface|interface
name|Listener
extends|extends
name|org
operator|.
name|exist
operator|.
name|fluent
operator|.
name|Listener
block|{
comment|/** 		 * Respond to a folder event.  		 * 		 * @param ev the details of the event 		 */
name|void
name|handle
parameter_list|(
name|Folder
operator|.
name|Event
name|ev
parameter_list|)
function_decl|;
block|}
comment|/** 	 * An event that concerns a folder. 	 * 	 * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a> 	 */
specifier|public
specifier|static
class|class
name|Event
extends|extends
name|org
operator|.
name|exist
operator|.
name|fluent
operator|.
name|Listener
operator|.
name|Event
block|{
comment|/** 		 * The folder that's the subject of this event. 		 * Note that for some timing/action combinations, this field might be<code>null</code>. 		 */
specifier|public
specifier|final
name|Folder
name|folder
decl_stmt|;
name|Event
parameter_list|(
name|Trigger
name|trigger
parameter_list|,
name|String
name|path
parameter_list|,
name|Folder
name|folder
parameter_list|)
block|{
name|super
argument_list|(
name|trigger
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|folder
operator|=
name|folder
expr_stmt|;
block|}
name|Event
parameter_list|(
name|ListenerManager
operator|.
name|EventKey
name|key
parameter_list|,
name|Folder
name|folder
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|this
operator|.
name|folder
operator|=
name|folder
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
operator|&&
operator|(
name|folder
operator|==
literal|null
condition|?
operator|(
operator|(
name|Event
operator|)
name|o
operator|)
operator|.
name|folder
operator|==
literal|null
else|:
name|folder
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Event
operator|)
name|o
operator|)
operator|.
name|folder
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
operator|*
literal|37
operator|+
operator|(
name|folder
operator|==
literal|null
condition|?
literal|0
else|:
name|folder
operator|.
name|hashCode
argument_list|()
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|super
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|buf
operator|.
name|insert
argument_list|(
literal|3
argument_list|,
literal|"Folder."
argument_list|)
expr_stmt|;
name|buf
operator|.
name|insert
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|", "
operator|+
name|folder
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** 	 * The children (subfolders) facet of a collection.  Permits operations on subfolders, 	 * both immediate and indirect. 	 * 	 * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a> 	 */
specifier|public
class|class
name|ChildrenFacet
implements|implements
name|Iterable
argument_list|<
name|Folder
argument_list|>
block|{
specifier|private
name|ChildrenFacet
parameter_list|()
block|{
block|}
comment|/** 		 * Return an existing descendant this of this folder, inheriting this one's namespace mappings. 		 *  		 * @param descendantName the relative name of the child folder to get; must not start with '/' 		 * @return the descendant folder with the given name 		 */
specifier|public
name|Folder
name|get
parameter_list|(
name|String
name|descendantName
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|descendantName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"descendant name starts with '/': "
operator|+
name|descendantName
argument_list|)
throw|;
name|String
name|parentPath
init|=
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentPath
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
name|parentPath
operator|=
literal|""
expr_stmt|;
return|return
operator|new
name|Folder
argument_list|(
name|parentPath
operator|+
literal|"/"
operator|+
name|descendantName
argument_list|,
literal|false
argument_list|,
name|Folder
operator|.
name|this
argument_list|)
return|;
block|}
comment|/** 		 * Get a descendant folder of this folder, or create it if it doesn't exist.  It inherits 		 * this folder's namespace mappings. 		 *  		 * @param descendantName the relative name of the descendant folder to create; must not start with '/' 		 * @return the child folder with the given name 		 */
specifier|public
name|Folder
name|create
parameter_list|(
name|String
name|descendantName
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|descendantName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"descendant name starts with '/': "
operator|+
name|descendantName
argument_list|)
throw|;
name|String
name|parentPath
init|=
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentPath
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
name|parentPath
operator|=
literal|""
expr_stmt|;
return|return
operator|new
name|Folder
argument_list|(
name|parentPath
operator|+
literal|"/"
operator|+
name|descendantName
argument_list|,
literal|true
argument_list|,
name|Folder
operator|.
name|this
argument_list|)
return|;
block|}
comment|/** 		 * Return the number of immediate child folders of this folder. 		 * 		 * @return the number of child subfolders 		 */
specifier|public
name|int
name|size
parameter_list|()
block|{
name|DBBroker
name|_broker
init|=
literal|null
decl_stmt|;
try|try
block|{
name|_broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
return|return
name|getQuickHandle
argument_list|()
operator|.
name|getChildCollectionCount
argument_list|(
name|_broker
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 		 * Return whether this folder has a descendant folder with the given name. 		 * 		 * @param descendantName the relative name of the descendant folder; must not start with '/' 		 * @return<code>true</code> if this folder has a descendant wich the given name,<code>false</code> otherwise 		 */
specifier|public
name|boolean
name|contains
parameter_list|(
name|String
name|descendantName
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|descendantName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"child name starts with '/': "
operator|+
name|descendantName
argument_list|)
throw|;
name|DBBroker
name|_broker
init|=
literal|null
decl_stmt|;
try|try
block|{
name|_broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
return|return
name|_broker
operator|.
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|path
argument_list|()
operator|+
literal|"/"
operator|+
name|descendantName
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 		 * Export these children folders to the given directory. 		 * If the directory does not exist it will be created.  A subdirectory will be created 		 * for each child folder. 		 * 		 * @param destination the destination folder to export into 		 * @throws IOException if the export failed due to an I/O error 		 */
specifier|public
name|void
name|export
parameter_list|(
name|File
name|destination
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|destination
operator|.
name|exists
argument_list|()
condition|)
name|destination
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|destination
operator|.
name|isDirectory
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"export destination not a directory: "
operator|+
name|destination
argument_list|)
throw|;
for|for
control|(
name|Folder
name|child
range|:
name|this
control|)
block|{
name|child
operator|.
name|export
argument_list|(
operator|new
name|File
argument_list|(
name|destination
argument_list|,
name|child
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
class|class
name|FolderIterator
implements|implements
name|Iterator
argument_list|<
name|Folder
argument_list|>
block|{
specifier|private
name|Folder
name|last
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|delegate
init|=
literal|null
decl_stmt|;
specifier|private
name|DBBroker
name|broker
init|=
literal|null
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|getDelegate
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|delegate
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
name|delegate
operator|=
name|getQuickHandle
argument_list|()
operator|.
name|collectionIterator
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"no collection to remove"
argument_list|)
throw|;
block|}
name|last
operator|.
name|delete
argument_list|()
expr_stmt|;
name|last
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
name|boolean
name|result
init|=
name|getDelegate
argument_list|()
operator|.
name|hasNext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|Folder
name|next
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
name|last
operator|=
name|get
argument_list|(
name|getDelegate
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
block|}
comment|/** 		 * Return an iterator over the immediate child subfolders.  You can use this iterator to 		 * selectively delete subfolders as well. 		 *  		 * @return an iterator over the child subfolders  		 */
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Folder
argument_list|>
name|iterator
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
operator|new
name|FolderIterator
argument_list|()
return|;
block|}
block|}
comment|/** 	 * The immediate documents facet of a folder.  Gives access to the (conceptual) set of 	 * documents contained directly in a folder.  All functions will<em>not</em> consider 	 * documents contained in subfolders. 	 * 	 * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a> 	 */
specifier|public
class|class
name|DocumentsFacet
extends|extends
name|Resource
implements|implements
name|Iterable
argument_list|<
name|Document
argument_list|>
block|{
specifier|private
name|ListenersFacet
name|listeners
decl_stmt|;
comment|/** 		 * The facet that gives control over listeners for documents contained directly within 		 * a folder. 		 * 		 * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a> 		 */
specifier|public
class|class
name|ListenersFacet
block|{
comment|/** 			 * Add a listener for all documents directly in this folder.  Equivalent to<code>add(EnumSet.of(trigger), listener)</code>. 			 * 			 * @see #add(Set, Document.Listener) 			 * @param trigger the kind of event the listener should be notified of 			 * @param listener the listener to notify of events 			 */
specifier|public
name|void
name|add
parameter_list|(
name|Trigger
name|trigger
parameter_list|,
name|Document
operator|.
name|Listener
name|listener
parameter_list|)
block|{
name|add
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|trigger
argument_list|)
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/** 			 * Add a listener for all documents directly in this folder. 			 *  			 * @param triggers the kinds of events the listener should be notified of; the set must not be empty 			 * @param listener the listener to notify of events  			 */
specifier|public
name|void
name|add
parameter_list|(
name|Set
argument_list|<
name|Trigger
argument_list|>
name|triggers
parameter_list|,
name|Document
operator|.
name|Listener
name|listener
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
name|ListenerManager
operator|.
name|INSTANCE
operator|.
name|add
argument_list|(
name|path
argument_list|()
argument_list|,
name|ListenerManager
operator|.
name|Depth
operator|.
name|ONE
argument_list|,
name|triggers
argument_list|,
name|listener
argument_list|,
name|Folder
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** 			 * Remove a listener previously added through this facet.  This will remove the listener from 			 * all combinations of timing and action for this folder, even if added via multiple invocations 			 * of the<code>add</code> methods.  However, it will not remove the listener from combinations 			 * added through other facets. 			 * 			 * @param listener the listener to remove 			 */
specifier|public
name|void
name|remove
parameter_list|(
name|Document
operator|.
name|Listener
name|listener
parameter_list|)
block|{
name|ListenerManager
operator|.
name|INSTANCE
operator|.
name|remove
argument_list|(
name|path
argument_list|()
argument_list|,
name|ListenerManager
operator|.
name|Depth
operator|.
name|ONE
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|DocumentsFacet
parameter_list|()
block|{
name|super
argument_list|(
name|Folder
operator|.
name|this
operator|.
name|namespaceBindings
argument_list|,
name|Folder
operator|.
name|this
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|Sequence
name|convertToSequence
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
name|getDocsSequence
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/** 		 * Return the facet that allows control over listenersof the folder's immediate documents.  		 * 		 * @return the immediate documents' listener facet 		 */
specifier|public
name|ListenersFacet
name|listeners
parameter_list|()
block|{
if|if
condition|(
name|listeners
operator|==
literal|null
condition|)
name|listeners
operator|=
operator|new
name|ListenersFacet
argument_list|()
expr_stmt|;
return|return
name|listeners
return|;
block|}
comment|/** 		 * Build a new XML document in this collection, with the given relative path.  Remember to {@link ElementBuilder#commit commit} 		 * commit the builder when done.  If the builder doesn't commit, no document is created. 		 *  		 * @param name the relative path to the new document 		 * @return a builder to use to create the document 		 */
specifier|public
name|ElementBuilder
argument_list|<
name|XMLDocument
argument_list|>
name|build
parameter_list|(
specifier|final
name|Name
name|name
parameter_list|)
block|{
name|Folder
name|target
init|=
name|name
operator|.
name|stripPathPrefix
argument_list|(
name|Folder
operator|.
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|!=
name|Folder
operator|.
name|this
condition|)
return|return
name|target
operator|.
name|documents
argument_list|()
operator|.
name|build
argument_list|(
name|name
argument_list|)
return|;
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
operator|new
name|ElementBuilder
argument_list|<
name|XMLDocument
argument_list|>
argument_list|(
name|Folder
operator|.
name|this
operator|.
name|namespaceBindings
argument_list|()
argument_list|,
literal|false
argument_list|,
operator|new
name|ElementBuilder
operator|.
name|CompletedCallback
argument_list|<
name|XMLDocument
argument_list|>
argument_list|()
block|{
specifier|public
name|XMLDocument
name|completed
parameter_list|(
name|Node
index|[]
name|nodes
parameter_list|)
block|{
assert|assert
name|nodes
operator|.
name|length
operator|==
literal|1
assert|;
name|Node
name|node
init|=
name|nodes
index|[
literal|0
index|]
decl_stmt|;
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|name
operator|.
name|setContext
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|IndexInfo
name|info
init|=
name|handle
operator|.
name|validateXMLResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|node
argument_list|)
decl_stmt|;
comment|//changeLock(LockMode.NO_LOCK);
name|handle
operator|.
name|store
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|get
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|xml
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** 		 * Return whether this facet's folder contains a document with the given relative path. 		 * 		 * @param documentPath the relative path of the document to check for 		 * @return<code>true</code> if the folder contains a document with the given path,<code>false</code> otherwise 		 */
specifier|public
name|boolean
name|contains
parameter_list|(
name|String
name|documentPath
parameter_list|)
block|{
name|checkIsRelativeDocPath
argument_list|(
name|documentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|documentPath
operator|.
name|contains
argument_list|(
literal|"/"
argument_list|)
condition|)
return|return
name|database
argument_list|()
operator|.
name|contains
argument_list|(
name|Folder
operator|.
name|this
operator|.
name|path
argument_list|()
operator|+
literal|"/"
operator|+
name|documentPath
argument_list|)
return|;
name|DBBroker
name|_broker
init|=
literal|null
decl_stmt|;
try|try
block|{
name|_broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
return|return
name|getQuickHandle
argument_list|()
operator|.
name|getDocument
argument_list|(
name|_broker
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|documentPath
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|_broker
operator|!=
literal|null
condition|)
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 		 * Create an XML document with the given relative path, takings its contents from the given source. 		 * 		 * @param name the desired relative path of the document 		 * @param source the source of XML data to read in the document contents from; the folder's namespace bindings are<em>not</em> applied 		 * @return the newly created document 		 * @throws DatabaseException if anything else goes wrong 		 */
specifier|public
name|XMLDocument
name|load
parameter_list|(
name|Name
name|name
parameter_list|,
name|Source
operator|.
name|XML
name|source
parameter_list|)
block|{
name|Folder
name|target
init|=
name|name
operator|.
name|stripPathPrefix
argument_list|(
name|Folder
operator|.
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|!=
name|Folder
operator|.
name|this
condition|)
return|return
name|target
operator|.
name|documents
argument_list|()
operator|.
name|load
argument_list|(
name|name
argument_list|,
name|source
argument_list|)
return|;
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|source
operator|.
name|applyOldName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|.
name|setContext
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|IndexInfo
name|info
init|=
name|handle
operator|.
name|validateXMLResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|source
operator|.
name|toInputSource
argument_list|()
argument_list|)
decl_stmt|;
comment|//changeLock(LockMode.NO_LOCK);
name|handle
operator|.
name|store
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|source
operator|.
name|toInputSource
argument_list|()
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|get
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|xml
argument_list|()
return|;
block|}
comment|/** 		 * Create a binary document with the given relative path, takings its contents from the given source. 		 * 		 * @param name the desired relative path of the document 		 * @param source the source to read the document contents from 		 * @return the newly created document 		 * @throws DatabaseException if anything else goes wrong 		 */
specifier|public
name|Document
name|load
parameter_list|(
name|Name
name|name
parameter_list|,
name|Source
operator|.
name|Blob
name|source
parameter_list|)
block|{
name|Folder
name|target
init|=
name|name
operator|.
name|stripPathPrefix
argument_list|(
name|Folder
operator|.
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|!=
name|Folder
operator|.
name|this
condition|)
return|return
name|target
operator|.
name|documents
argument_list|()
operator|.
name|load
argument_list|(
name|name
argument_list|,
name|source
argument_list|)
return|;
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|source
operator|.
name|applyOldName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|.
name|setContext
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|InputStream
name|inputStream
init|=
name|source
operator|.
name|toInputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|handle
operator|.
name|addBinaryResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|inputStream
argument_list|,
literal|null
argument_list|,
name|source
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|inputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"failed to create document '"
operator|+
name|name
operator|+
literal|"' from source "
operator|+
name|source
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|get
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
comment|/** 		 * Get the contained document with the given relative path.  		 * 		 * @param documentPath the relative path of the document to find 		 * @return the document with the given path 		 * @throws DatabaseException if unable to find or access the desired document 		 */
specifier|public
name|Document
name|get
parameter_list|(
name|String
name|documentPath
parameter_list|)
block|{
name|checkIsRelativeDocPath
argument_list|(
name|documentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|documentPath
operator|.
name|contains
argument_list|(
literal|"/"
argument_list|)
condition|)
return|return
name|database
argument_list|()
operator|.
name|getDocument
argument_list|(
name|Folder
operator|.
name|this
operator|.
name|path
argument_list|()
operator|+
literal|"/"
operator|+
name|documentPath
argument_list|)
return|;
name|DBBroker
name|_broker
init|=
literal|null
decl_stmt|;
try|try
block|{
name|_broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
name|DocumentImpl
name|dimpl
init|=
name|getQuickHandle
argument_list|()
operator|.
name|getDocument
argument_list|(
name|_broker
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|documentPath
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dimpl
operator|==
literal|null
condition|)
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"no such document: "
operator|+
name|documentPath
argument_list|)
throw|;
return|return
name|Document
operator|.
name|newInstance
argument_list|(
name|dimpl
argument_list|,
name|Folder
operator|.
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|_broker
operator|!=
literal|null
condition|)
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|checkIsRelativeDocPath
parameter_list|(
name|String
name|docPath
parameter_list|)
block|{
if|if
condition|(
name|docPath
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"relative path cannot start with '/': "
operator|+
name|docPath
argument_list|)
throw|;
if|if
condition|(
name|docPath
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"relative path cannot end with '/': "
operator|+
name|docPath
argument_list|)
throw|;
block|}
comment|/** 		 * Return the number of documents immediately contained in the folder. 		 * 		 * @return the number of child documents 		 */
specifier|public
name|int
name|size
parameter_list|()
block|{
name|DBBroker
name|_broker
init|=
literal|null
decl_stmt|;
try|try
block|{
name|_broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
return|return
name|getQuickHandle
argument_list|()
operator|.
name|getDocumentCount
argument_list|(
name|_broker
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 		 * Export the immediately contained documents to the given directory. 		 * If the directory does not exist it will be created.  Documents in this 		 * folder will appear directly in the given directory. 		 * 		 * @param destination the destination folder to export into 		 * @throws IOException if the export failed due to an I/O error 		 */
specifier|public
name|void
name|export
parameter_list|(
name|File
name|destination
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|destination
operator|.
name|exists
argument_list|()
condition|)
name|destination
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|destination
operator|.
name|isDirectory
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"export destination not a directory: "
operator|+
name|destination
argument_list|)
throw|;
for|for
control|(
name|Document
name|doc
range|:
name|this
control|)
block|{
name|doc
operator|.
name|export
argument_list|(
operator|new
name|File
argument_list|(
name|destination
argument_list|,
name|doc
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 		 * Query over the documents immediately contained in the folder, ignoring any documents 		 * in subfolders. 		 *  		 * @return a query service over the folder's immediate documents 		 */
annotation|@
name|Override
specifier|public
name|QueryService
name|query
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|query
argument_list|()
return|;
block|}
annotation|@
name|Override
name|QueryService
name|createQueryService
parameter_list|()
block|{
return|return
operator|new
name|QueryService
argument_list|(
name|Folder
operator|.
name|this
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|prepareContext
parameter_list|(
name|DBBroker
name|broker_
parameter_list|)
block|{
name|acquire
argument_list|(
name|LockMode
operator|.
name|READ_LOCK
argument_list|,
name|broker_
argument_list|)
expr_stmt|;
try|try
block|{
name|docs
operator|=
name|handle
operator|.
name|allDocs
argument_list|(
name|broker_
argument_list|,
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|baseUri
operator|=
operator|new
name|AnyURIValue
argument_list|(
name|handle
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/** 		 * Return an iterator over the folder's immediate documents.  This iterator can be used 		 * to selectively delete documents as well. 		 *  		 * @return an iterator over the folder's immediate documents 		 */
specifier|public
name|Iterator
argument_list|<
name|Document
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Document
argument_list|>
argument_list|()
block|{
specifier|private
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|delegate
decl_stmt|;
specifier|private
name|Document
name|last
decl_stmt|;
block|{
name|acquire
parameter_list|(
name|LockMode
operator|.
name|READ_LOCK
parameter_list|)
constructor_decl|;
try|try
block|{
name|delegate
operator|=
name|handle
operator|.
name|iterator
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"no document to remove"
argument_list|)
throw|;
name|last
operator|.
name|delete
argument_list|()
expr_stmt|;
name|last
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Document
name|next
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
name|last
operator|=
name|Document
operator|.
name|newInstance
argument_list|(
name|delegate
operator|.
name|next
argument_list|()
argument_list|,
name|Folder
operator|.
name|this
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
block|}
return|;
block|}
block|}
comment|/** 	 * The facet that allwos control over listeners to the folder, and all its descendant folders and 	 * documents. 	 * 	 * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a> 	 */
specifier|public
class|class
name|ListenersFacet
block|{
comment|/** 		 * Add a listener for either folder or document events on this folder, its contents, and all 		 * its descendants and their contents as well.  Equivalent to<code>add(EnumSet.of(trigger), listener)</code>. 		 * 		 * @see #add(Set, org.exist.fluent.Listener) 		 * @param trigger the kind of event the listener should be notified of 		 * @param listener the listener to notify of events 		 */
specifier|public
name|void
name|add
parameter_list|(
name|Trigger
name|trigger
parameter_list|,
name|org
operator|.
name|exist
operator|.
name|fluent
operator|.
name|Listener
name|listener
parameter_list|)
block|{
name|add
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|trigger
argument_list|)
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Add a listener for either folder or document events on this folder, its contents, and all 		 * its descendants and their contents as well.  The listener's type (either {@link Document.Listener} 		 * or {@link Folder.Listener}) will determine the kinds of events it will receive.  Note that 		 * if the listener implements both interfaces it will be notified of events that concern both 		 * documents and folders (and satisfy the timing and action characteristics requested). 		 *  		 * @param triggers the kinds of events the listener should be notified of; the set must not be empty 		 * @param listener the listener to notify of events  		 */
specifier|public
name|void
name|add
parameter_list|(
name|Set
argument_list|<
name|Trigger
argument_list|>
name|triggers
parameter_list|,
name|org
operator|.
name|exist
operator|.
name|fluent
operator|.
name|Listener
name|listener
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
name|ListenerManager
operator|.
name|INSTANCE
operator|.
name|add
argument_list|(
name|path
argument_list|()
argument_list|,
name|ListenerManager
operator|.
name|Depth
operator|.
name|MANY
argument_list|,
name|triggers
argument_list|,
name|listener
argument_list|,
name|Folder
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Remove a listener previously added through this facet.  This will remove the listener from 		 * all combinations of timing and action for this folder, even if added via multiple invocations 		 * of the<code>add</code> methods.  However, it will not remove the listener from combinations 		 * added through other facets, even this folder's documents facet or the facets of any descendants. 		 * 		 * @param listener the listener to remove 		 */
specifier|public
name|void
name|remove
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|fluent
operator|.
name|Listener
name|listener
parameter_list|)
block|{
name|ListenerManager
operator|.
name|INSTANCE
operator|.
name|remove
argument_list|(
name|path
argument_list|()
argument_list|,
name|ListenerManager
operator|.
name|Depth
operator|.
name|MANY
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|path
decl_stmt|;
specifier|private
name|StaleMarker
name|staleMarker
decl_stmt|;
specifier|private
name|ChildrenFacet
name|children
decl_stmt|;
specifier|private
name|DocumentsFacet
name|documents
decl_stmt|;
specifier|private
name|ListenersFacet
name|listeners
decl_stmt|;
specifier|private
name|MetadataFacet
name|metadata
decl_stmt|;
comment|// the following are only valid while we're holding a broker
specifier|private
name|DBBroker
name|broker
decl_stmt|;
specifier|private
name|Collection
name|handle
decl_stmt|;
specifier|private
name|Transaction
name|tx
decl_stmt|;
specifier|private
name|LockMode
name|lockMode
decl_stmt|;
specifier|private
name|boolean
name|ownBroker
decl_stmt|;
comment|/** 	 * Create a wrapper around the given collection. 	 *  	 * @param path the absolute path to the desired collection, must start with '/' 	 * @param createIfMissing what to do if the given collection doesn't exist; if<code>true</code>, create it, otherwise signal an error 	 * @param origin the origin, indicating the database instance and namespace bindings to be extended 	 * @throws DatabaseException if the collection cannot be found and is not supposed to be created 	 */
name|Folder
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|createIfMissing
parameter_list|,
name|Resource
name|origin
parameter_list|)
block|{
name|this
argument_list|(
name|path
argument_list|,
name|createIfMissing
argument_list|,
name|origin
operator|.
name|namespaceBindings
argument_list|()
operator|.
name|extend
argument_list|()
argument_list|,
name|origin
operator|.
name|database
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Folder
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|createIfMissing
parameter_list|,
name|NamespaceMap
name|namespaceBindings
parameter_list|,
name|Database
name|db
parameter_list|)
block|{
name|super
argument_list|(
name|namespaceBindings
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|path
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path must start with /, got "
operator|+
name|path
argument_list|)
throw|;
try|try
block|{
name|broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
name|Collection
name|collection
decl_stmt|;
if|if
condition|(
name|createIfMissing
condition|)
block|{
name|tx
operator|=
name|Database
operator|.
name|requireTransaction
argument_list|()
expr_stmt|;
try|try
block|{
name|collection
operator|=
name|createInternal
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|collection
operator|=
name|broker
operator|.
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"collection not found '"
operator|+
name|path
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
block|}
comment|// store the normalized path, minus the root prefix if possible
name|changePath
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|broker
argument_list|)
expr_stmt|;
name|broker
operator|=
literal|null
expr_stmt|;
name|tx
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|changePath
parameter_list|(
name|String
name|newPath
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|Database
operator|.
name|normalizePath
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
name|staleMarker
operator|=
operator|new
name|StaleMarker
argument_list|()
expr_stmt|;
name|staleMarker
operator|.
name|track
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Return this folder's listeners facet, giving control over listeners to events on this folder, 	 * its contents, and all its descendants. 	 * 	 * @return this folder's listeners facet 	 */
specifier|public
name|ListenersFacet
name|listeners
parameter_list|()
block|{
if|if
condition|(
name|listeners
operator|==
literal|null
condition|)
name|listeners
operator|=
operator|new
name|ListenersFacet
argument_list|()
expr_stmt|;
return|return
name|listeners
return|;
block|}
annotation|@
name|Override
specifier|public
name|MetadataFacet
name|metadata
parameter_list|()
block|{
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
name|metadata
operator|=
operator|new
name|MetadataFacet
argument_list|(
name|getQuickHandle
argument_list|()
argument_list|,
name|db
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Date
name|creationDate
parameter_list|()
block|{
return|return
operator|new
name|Date
argument_list|(
name|getQuickHandle
argument_list|()
operator|.
name|getCreationTime
argument_list|()
argument_list|)
return|;
block|}
block|}
expr_stmt|;
return|return
name|metadata
return|;
block|}
comment|/** 	 * Create a duplicate handle that copies the original's path and namespace bindings. 	 * No copy is created of the underlying folder.  The namespace bindings will copy the 	 * original's immediate namespace map and namespace bindings inheritance chain. 	 *  	 * @return a duplicate of this collection wrapper 	 */
annotation|@
name|Override
specifier|public
name|Folder
name|clone
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
operator|new
name|Folder
argument_list|(
name|path
argument_list|()
argument_list|,
literal|false
argument_list|,
name|namespaceBindings
operator|.
name|clone
argument_list|()
argument_list|,
name|db
argument_list|)
return|;
block|}
specifier|public
name|Folder
name|cloneWithoutNamespaceBindings
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
operator|new
name|Folder
argument_list|(
name|path
argument_list|()
argument_list|,
literal|false
argument_list|,
operator|new
name|NamespaceMap
argument_list|()
argument_list|,
name|db
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Folder
condition|)
return|return
name|path
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Folder
operator|)
name|o
operator|)
operator|.
name|path
argument_list|()
argument_list|)
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|path
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"folder '"
operator|+
name|path
argument_list|()
operator|+
literal|"'"
return|;
block|}
specifier|private
name|Collection
name|createInternal
parameter_list|(
name|String
name|targetPath
parameter_list|)
block|{
try|try
block|{
name|Collection
name|collection
init|=
name|broker
operator|.
name|getOrCreateCollection
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|targetPath
argument_list|)
argument_list|)
decl_stmt|;
name|broker
operator|.
name|saveCollection
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|collection
argument_list|)
expr_stmt|;
name|broker
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|collection
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|void
name|transact
parameter_list|(
name|LockMode
name|_lockMode
parameter_list|)
block|{
if|if
condition|(
name|tx
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"transaction already in progress"
argument_list|)
throw|;
name|tx
operator|=
name|Database
operator|.
name|requireTransaction
argument_list|()
expr_stmt|;
name|acquire
argument_list|(
name|_lockMode
argument_list|)
expr_stmt|;
block|}
name|void
name|commit
parameter_list|()
block|{
if|if
condition|(
name|tx
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"no transaction in progress"
argument_list|)
throw|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// later aborts will do nothing
block|}
name|void
name|acquire
parameter_list|(
name|LockMode
name|_lockMode
parameter_list|)
block|{
name|DBBroker
name|_broker
init|=
name|db
operator|.
name|acquireBroker
argument_list|()
decl_stmt|;
name|ownBroker
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|acquire
argument_list|(
name|_lockMode
argument_list|,
name|_broker
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
name|ownBroker
operator|=
literal|false
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
name|void
name|acquire
parameter_list|(
name|LockMode
name|_lockMode
parameter_list|,
name|DBBroker
name|_broker
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|broker
operator|!=
literal|null
operator|||
name|handle
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"broker already acquired"
argument_list|)
throw|;
name|broker
operator|=
name|_broker
expr_stmt|;
try|try
block|{
name|handle
operator|=
name|broker
operator|.
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|path
argument_list|()
argument_list|)
argument_list|,
name|_lockMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"collection not found '"
operator|+
name|path
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|this
operator|.
name|lockMode
operator|=
name|_lockMode
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|broker
operator|=
literal|null
expr_stmt|;
name|handle
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
name|broker
operator|=
literal|null
expr_stmt|;
name|handle
operator|=
literal|null
expr_stmt|;
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
block|}
name|void
name|release
parameter_list|()
block|{
if|if
condition|(
name|broker
operator|==
literal|null
operator|||
name|handle
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"broker not acquired"
argument_list|)
throw|;
if|if
condition|(
name|tx
operator|!=
literal|null
condition|)
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
name|handle
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|ownBroker
condition|)
name|db
operator|.
name|releaseBroker
argument_list|(
name|broker
argument_list|)
expr_stmt|;
name|ownBroker
operator|=
literal|false
expr_stmt|;
name|broker
operator|=
literal|null
expr_stmt|;
name|handle
operator|=
literal|null
expr_stmt|;
name|tx
operator|=
literal|null
expr_stmt|;
block|}
name|void
name|changeLock
parameter_list|(
name|LockMode
name|newLockMode
parameter_list|)
block|{
if|if
condition|(
name|broker
operator|==
literal|null
operator|||
name|handle
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"broker not acquired"
argument_list|)
throw|;
if|if
condition|(
name|lockMode
operator|==
name|newLockMode
condition|)
return|return;
if|if
condition|(
name|lockMode
operator|==
name|LockMode
operator|.
name|NO_LOCK
condition|)
block|{
try|try
block|{
switch|switch
condition|(
name|newLockMode
condition|)
block|{
case|case
name|READ_LOCK
case|:
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getLockManager
argument_list|()
operator|.
name|acquireCollectionReadLock
argument_list|(
name|handle
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRITE_LOCK
case|:
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getLockManager
argument_list|()
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|handle
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_LOCK
case|:
break|break;
block|}
name|lockMode
operator|=
name|newLockMode
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|newLockMode
operator|!=
name|LockMode
operator|.
name|NO_LOCK
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot change between read and write lock modes"
argument_list|)
throw|;
name|handle
operator|.
name|close
argument_list|()
expr_stmt|;
name|lockMode
operator|=
name|newLockMode
expr_stmt|;
block|}
block|}
specifier|private
name|Collection
name|getQuickHandle
parameter_list|()
block|{
name|acquire
argument_list|(
name|LockMode
operator|.
name|NO_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|handle
return|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Return whether this folder is empty, i.e. has no documents or subfolders in it. 	 * 	 * @return whether this folder is empty 	 */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
name|acquire
argument_list|(
name|LockMode
operator|.
name|NO_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|handle
operator|.
name|getDocumentCount
argument_list|(
name|broker
argument_list|)
operator|==
literal|0
operator|&&
name|handle
operator|.
name|getChildCollectionCount
argument_list|(
name|broker
argument_list|)
operator|==
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Remove all resources and subfolders from this folder, but keep the folder itself. 	 */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|handle
operator|.
name|getDocumentCount
argument_list|(
name|broker
argument_list|)
operator|==
literal|0
operator|&&
name|handle
operator|.
name|getChildCollectionCount
argument_list|(
name|broker
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|broker
operator|.
name|removeCollection
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|createInternal
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
name|changePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// reset stale marker
block|}
comment|/** 	 * Delete this folder, including all documents and descendants.  If invoked on the root folder, 	 * deletes all documents and descendants but does not delete the root folder itself. 	 */
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|()
block|{
name|transact
argument_list|(
name|LockMode
operator|.
name|NO_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
comment|// TODO: temporary hack, remove once removing root collection works in eXist
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|it
init|=
name|handle
operator|.
name|iterator
argument_list|(
name|broker
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|dimpl
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimpl
operator|instanceof
name|BinaryDocument
condition|)
block|{
name|handle
operator|.
name|removeBinaryResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|dimpl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handle
operator|.
name|removeXMLResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|dimpl
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// end hack
name|broker
operator|.
name|removeCollection
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Move this folder to another spot in the folder hierarchy, possibly changing its name in the process. 	 * This folder will refer to the newly relocated folder when this method returns.  You can use this 	 * method to move a folder without changing its name (<code>folder.move(destFolder, Name.keepCreate())</code>) 	 * or to rename it without changing its location (<code>folder.move(folder.parent(), Name.create(newName))</code>). 	 * 	 * @param destination the new parent folder of this folder 	 * @param name the new name for this folder 	 */
annotation|@
name|Override
specifier|public
name|void
name|move
parameter_list|(
name|Folder
name|destination
parameter_list|,
name|Name
name|name
parameter_list|)
block|{
name|changePath
argument_list|(
name|moveOrCopyThisFolder
argument_list|(
name|destination
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Copy this folder to another place in the folder hierarchy, returning the newly copied folder 	 * with namespace bindings inherited from this one. 	 * 	 * @param destination the desired parent folder of the copy 	 * @param name the desired name of the copy 	 * @return a reference to the copied folder 	 */
annotation|@
name|Override
specifier|public
name|Folder
name|copy
parameter_list|(
name|Folder
name|destination
parameter_list|,
name|Name
name|name
parameter_list|)
block|{
return|return
operator|new
name|Folder
argument_list|(
name|moveOrCopyThisFolder
argument_list|(
name|destination
argument_list|,
name|name
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|false
argument_list|,
name|this
argument_list|)
return|;
block|}
specifier|private
name|String
name|moveOrCopyThisFolder
parameter_list|(
name|Folder
name|destination
parameter_list|,
name|Name
name|name
parameter_list|,
name|boolean
name|copy
parameter_list|)
block|{
name|db
operator|.
name|checkSame
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|destination
operator|.
name|acquire
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|,
name|broker
argument_list|)
expr_stmt|;
try|try
block|{
name|name
operator|.
name|setOldName
argument_list|(
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|.
name|setContext
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
name|broker
operator|.
name|copyCollection
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|handle
argument_list|,
name|destination
operator|.
name|handle
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|broker
operator|.
name|moveCollection
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|handle
argument_list|,
name|destination
operator|.
name|handle
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|destination
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|destination
operator|.
name|path
argument_list|()
operator|+
literal|"/"
operator|+
name|name
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** 	 * Provide access to the documents facet of this folder.  The documents facet is 	 * the conceptual set of documents contained directly in this collection (and therefore 	 * excludes documents contained in any subfolders). 	 *  	 * @return the documents facet 	 */
specifier|public
name|DocumentsFacet
name|documents
parameter_list|()
block|{
if|if
condition|(
name|documents
operator|==
literal|null
condition|)
name|documents
operator|=
operator|new
name|DocumentsFacet
argument_list|()
expr_stmt|;
return|return
name|documents
return|;
block|}
comment|/** 	 * Return whether this folder or one of its descendants contains the given named resource. 	 *  	 * @param res the resource to check for 	 * @return<code>true</code> if the resource is contained (directly or indirectly) in this folder,<code>false</code> otherwise 	 */
specifier|public
name|boolean
name|contains
parameter_list|(
name|NamedResource
name|res
parameter_list|)
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
name|db
operator|.
name|checkSame
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|res
operator|.
name|path
argument_list|()
operator|.
name|startsWith
argument_list|(
name|path
argument_list|()
operator|+
operator|(
name|path
argument_list|()
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|?
literal|""
else|:
literal|"/"
operator|)
argument_list|)
return|;
block|}
comment|/** 	 * Return the given path stripped of this folder's prefix path, i.e. relative to this folder. 	 * The given path can be either to a document or to a subfolder.  If the given path is to 	 * this folder itself, return the empty string. 	 * 	 * @param subPath the path to relativize 	 * @return the given path relative to this folder 	 */
specifier|public
name|String
name|relativePath
parameter_list|(
name|String
name|subPath
parameter_list|)
block|{
if|if
condition|(
name|subPath
operator|.
name|equals
argument_list|(
name|path
argument_list|()
argument_list|)
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|path
argument_list|()
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|subPath
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'/'
condition|)
return|return
name|subPath
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
operator|!
name|subPath
operator|.
name|startsWith
argument_list|(
name|path
argument_list|()
operator|+
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path '"
operator|+
name|subPath
operator|+
literal|"' does not fall under this collection's path '"
operator|+
name|path
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
return|return
name|subPath
operator|.
name|substring
argument_list|(
name|path
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** 	 * Return the full path to the folder; always starts with '/'. 	 *  	 * @return the full path to the folder 	 */
annotation|@
name|Override
specifier|public
name|String
name|path
parameter_list|()
block|{
return|return
name|path
return|;
block|}
comment|/** 	 * Return the local name of the folder; this is the last segment of its path. 	 *  	 * @return the local name of the folder 	 */
annotation|@
name|Override
specifier|public
name|String
name|name
parameter_list|()
block|{
return|return
name|path
argument_list|()
operator|.
name|substring
argument_list|(
name|path
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** 	 * Return the parent folder of this folder.  It will inherit this folder's namespace bindings. 	 *  	 * @return the parent folder that this folder is a child of 	 * @throws DatabaseException if this is the root folder 	 */
specifier|public
name|Folder
name|parent
parameter_list|()
block|{
name|String
name|parentPath
init|=
name|getQuickHandle
argument_list|()
operator|.
name|getURI
argument_list|()
operator|.
name|removeLastSegment
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentPath
operator|==
literal|null
operator|||
name|parentPath
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"this is the root collection"
argument_list|)
throw|;
return|return
operator|new
name|Folder
argument_list|(
name|parentPath
argument_list|,
literal|false
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** 	 * Return the children facet of this folder that gives access to operations on its subfolders 	 * and descendants. 	 * 	 * @return the children facet of this folder 	 */
specifier|public
name|ChildrenFacet
name|children
parameter_list|()
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
name|children
operator|=
operator|new
name|ChildrenFacet
argument_list|()
expr_stmt|;
return|return
name|children
return|;
block|}
comment|/** 	 * Export the contents of this folder (both documents and subfolders) to the given 	 * directory.  If the directory does not exist it will be created.  Documents in this 	 * folder will appear directly in the given directory, i.e. a subdirectory matching this 	 * folder will<em>not</em> be created. 	 * 	 * @param destination the destination folder to export into 	 * @throws IOException if the export failed due to an I/O error 	 */
specifier|public
name|void
name|export
parameter_list|(
name|File
name|destination
parameter_list|)
throws|throws
name|IOException
block|{
name|documents
argument_list|()
operator|.
name|export
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|children
argument_list|()
operator|.
name|export
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|Sequence
name|convertToSequence
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
name|getDocsSequence
argument_list|(
literal|true
argument_list|)
return|;
block|}
specifier|private
name|Sequence
name|getDocsSequence
parameter_list|(
name|boolean
name|recursive
parameter_list|)
block|{
try|try
block|{
name|DocumentSet
name|docs
decl_stmt|;
name|acquire
argument_list|(
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|docs
operator|=
name|handle
operator|.
name|allDocs
argument_list|(
name|broker
argument_list|,
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
name|Sequence
name|result
init|=
operator|new
name|ExtArrayNodeSet
argument_list|(
name|docs
operator|.
name|getDocumentCount
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|i
init|=
name|docs
operator|.
name|getDocumentIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected exception converting document set to sequence"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Return a query service for executing queries over the contents of this folder and the contents 	 * of all its descendants.  If you only want to query the documents contained directly in this folder, 	 * see {@link #documents() the documents facet}. 	 *  	 * @return a query service over this folder's contents and all its descendants' contents  	 */
annotation|@
name|Override
specifier|public
name|QueryService
name|query
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|query
argument_list|()
return|;
block|}
annotation|@
name|Override
name|QueryService
name|createQueryService
parameter_list|()
block|{
return|return
operator|new
name|QueryService
argument_list|(
name|this
argument_list|)
block|{
annotation|@
name|Override
name|void
name|prepareContext
parameter_list|(
name|DBBroker
name|broker_
parameter_list|)
block|{
name|acquire
argument_list|(
name|LockMode
operator|.
name|READ_LOCK
argument_list|,
name|broker_
argument_list|)
expr_stmt|;
try|try
block|{
name|docs
operator|=
name|handle
operator|.
name|allDocs
argument_list|(
name|broker_
argument_list|,
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|baseUri
operator|=
operator|new
name|AnyURIValue
argument_list|(
name|handle
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
name|void
name|removeDocument
parameter_list|(
name|DocumentImpl
name|dimpl
parameter_list|)
block|{
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|dimpl
operator|instanceof
name|BinaryDocument
condition|)
block|{
name|handle
operator|.
name|removeBinaryResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|dimpl
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handle
operator|.
name|removeXMLResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|broker
argument_list|,
name|dimpl
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|IOException
decl||
name|LockException
decl||
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|DocumentImpl
name|moveOrCopyDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|Name
name|name
parameter_list|,
name|boolean
name|copy
parameter_list|)
block|{
name|XmldbURI
name|uri
decl_stmt|;
name|transact
argument_list|(
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|name
operator|.
name|setContext
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|uri
operator|=
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
name|tx
operator|.
name|lockRead
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|broker
operator|.
name|copyResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|doc
argument_list|,
name|handle
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|.
name|lockWrite
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|broker
operator|.
name|moveResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|doc
argument_list|,
name|handle
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"lock denied"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|release
argument_list|()
expr_stmt|;
block|}
name|DBBroker
name|_broker
init|=
literal|null
decl_stmt|;
name|Collection
name|_handle
init|=
name|getQuickHandle
argument_list|()
decl_stmt|;
try|try
block|{
name|_broker
operator|=
name|db
operator|.
name|acquireBroker
argument_list|()
expr_stmt|;
return|return
name|_handle
operator|.
name|getDocument
argument_list|(
name|_broker
argument_list|,
name|uri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|_broker
operator|!=
literal|null
condition|)
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|_broker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

