begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|fluent
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * A map of short keys to namespace uris that can be cascaded.  Use the empty string as the  * key for the default namespace.  *  * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a>  */
end_comment

begin_class
specifier|public
class|class
name|NamespaceMap
implements|implements
name|Cloneable
block|{
specifier|private
specifier|static
class|class
name|ReservedMap
extends|extends
name|NamespaceMap
block|{
specifier|public
name|ReservedMap
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// bootstrap root node directly to avoid checks
name|map
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"xml"
argument_list|,
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"xmlns"
argument_list|,
literal|"http://www.w3.org/2000/xmlns/"
argument_list|)
expr_stmt|;
assert|assert
name|parent
operator|==
literal|null
assert|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCombinedMap
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
return|;
block|}
block|}
comment|/** 	 * Reserved keys and URIs, always declared and not overwriteable or overrideable. 	 * Note that the reserved map's parent will be<code>null</code>, even though 	 * it goes through the common constructor, since at construction time the 	 *<code>RESERVED</code> field has not yet been initialized.  It is the only map 	 * that will have a<code>null</code> parent. 	 */
specifier|private
specifier|static
specifier|final
name|NamespaceMap
name|RESERVED
init|=
operator|new
name|ReservedMap
argument_list|()
decl_stmt|;
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
decl_stmt|;
comment|/** 	 * The parent map from which bindings are inherited.  It cannot be modified 	 * or accessed through its children. 	 */
specifier|protected
name|NamespaceMap
name|parent
decl_stmt|;
comment|/** 	 * Create a new namespace map with no inherited bindings.  Immediate bindings can 	 * be specified as a list of key-URI pairs. 	 * @param args a list interleaving keys and their associated URIs; its length must be even 	 */
specifier|public
name|NamespaceMap
parameter_list|(
name|String
modifier|...
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|%
literal|2
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"incomplete pair, "
operator|+
name|args
operator|.
name|length
operator|+
literal|" arguments received"
argument_list|)
throw|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|put
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|RESERVED
expr_stmt|;
block|}
comment|/** 	 * Create a namespace map inheriting from this one. 	 * If this new map lacks a binding, it will be looked up in the parent. 	 * New bindings will always be entered in this map, and may override 	 * the parent's bindings. 	 *  	 * @return an extension of this map 	 */
specifier|public
name|NamespaceMap
name|extend
parameter_list|()
block|{
name|NamespaceMap
name|extension
init|=
operator|new
name|NamespaceMap
argument_list|()
decl_stmt|;
name|extension
operator|.
name|parent
operator|=
name|this
expr_stmt|;
return|return
name|extension
return|;
block|}
comment|/** 	 * Return a clone of this map.  The immediate bindings are cloned, but the ineritance 	 * chain remains unaltered. 	 *  	 * @return a combined clone of this map cascade 	 */
annotation|@
name|Override
specifier|public
name|NamespaceMap
name|clone
parameter_list|()
block|{
try|try
block|{
name|NamespaceMap
name|clone
init|=
operator|(
name|NamespaceMap
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|map
operator|!=
literal|null
condition|)
name|clone
operator|.
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|this
operator|.
name|map
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected exception"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Sever this namespace map from its parents.  The contents are collapsed prior to 	 * the map being severed, so the mappings are not affected.  However, any future 	 * changes to the previous parents will have no effect on this map.  Calling {@link #clear()} 	 * on a severed map is guaranteed to clear all bindings. 	 */
specifier|public
name|void
name|sever
parameter_list|()
block|{
name|map
operator|=
name|getCombinedMap
argument_list|()
expr_stmt|;
name|parent
operator|=
name|RESERVED
expr_stmt|;
block|}
comment|/** 	 * Get the URI bound to the given key, either in this map or the closest inherited one. 	 * If the key is not bound, return<code>null</code>. 	 * 	 * @param key the key to look up 	 * @return the bound URI or<code>null</code> if none 	 */
specifier|public
name|String
name|get
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"null key"
argument_list|)
throw|;
name|String
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|&&
name|map
operator|!=
literal|null
condition|)
name|result
operator|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|&&
name|parent
operator|!=
literal|null
condition|)
name|result
operator|=
name|parent
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|void
name|checkKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"null key"
argument_list|)
throw|;
if|if
condition|(
name|RESERVED
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reserved key '"
operator|+
name|key
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|/** 	 * Bind the given key to the given URI in this map.  If the key was already bound in this 	 * map, the binding is overwritten.  If the key was bound in an inherited map, it is 	 * overriden. 	 * 	 * @param key the key to use 	 * @param uri the namespace URI to bind 	 */
specifier|public
name|void
name|put
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
name|checkKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|RESERVED
operator|.
name|map
operator|.
name|containsValue
argument_list|(
name|uri
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reserved URI '"
operator|+
name|uri
operator|+
literal|"'"
argument_list|)
throw|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
name|map
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Remove any binding for the given key from the map.  Has no effect if the key is 	 * not bound in this map.  If the key binding is inherited, the binding is not affected. 	 * 	 * @param key the key to remove 	 */
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|checkKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Clear all bindings from this map.  Does not affect any inherited bindings. 	 */
specifier|public
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * Put all bindings from the given map into this one.  Bindings inherited by 	 * the given map are included.  Existing bindings may be overwritten or 	 * overriden, as appropriate. 	 * 	 * @param that the map to copy bindings from 	 */
specifier|public
name|void
name|putAll
parameter_list|(
name|NamespaceMap
name|that
parameter_list|)
block|{
if|if
condition|(
name|map
operator|==
literal|null
condition|)
name|map
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|map
operator|.
name|putAll
argument_list|(
name|that
operator|.
name|getCombinedMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Sever inheritance connections and replace all bindings with ones from the given 	 * map.  Equivalent to calling {@link #sever()}, {@link #clear()} and {@link #putAll(NamespaceMap)} 	 * in sequence. 	 * 	 * @param that the map to copy bindings from 	 */
specifier|public
name|void
name|replaceWith
parameter_list|(
name|NamespaceMap
name|that
parameter_list|)
block|{
name|parent
operator|=
name|RESERVED
expr_stmt|;
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|that
operator|.
name|getCombinedMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Return a realized map of keys to URIs that combines all information inherited 	 * from parents.  This is effectively the map that is used for lookups, but it is 	 * normally kept in virtual form for efficiency.  The map returned is a copy and 	 * is safe for mutation.  The map does not include reserved bindings. 	 * 	 * @return a combined map of keys to namespace uris 	 */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCombinedMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|all
init|=
name|parent
operator|.
name|getCombinedMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
name|all
operator|.
name|putAll
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|all
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|NamespaceMap
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|getCombinedMap
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|NamespaceMap
operator|)
name|o
operator|)
operator|.
name|getCombinedMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|getCombinedMap
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
end_class

end_unit

