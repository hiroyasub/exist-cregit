begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|fluent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|backup
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DefaultDocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|MutableDocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|NodeHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|TextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|MessageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<p>The global entry point to an embedded instance of the<a href='http://exist-db.org'>eXist</a>database.  * The static methods on this class control the lifecycle of the database connection.  It follows that  * there can be only one embedded database running in the JVM (or rather one per classloader, but  * that would probably be a bit confusing).  To gain access to the contents of the database, you  * need to acquire a handle instance by logging in.  All operations performed based on that instance  * will be executed using the permissions of the user associated with that instance.  You can have  * any number of instances (including multiple ones for the same user), but cannot mix resources  * obtained from different instances.  There is no need to explicitly release instances.</p>  *   *<p>Here's a short example of how to start up the database, perform a query, and shut down:  *<pre> Database.startup(new File("conf.xml"));  * Database db = Database.login("admin", "passwd");  * for (String name : db.getFolder("/").query().all("//user/@name").values())  *   System.out.println("user: " + name);  * Database.shutdown();</pre></p>  *   * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a>  * @version $Revision: 1.26 $ ($Date: 2006/09/04 06:09:05 $)  */
end_comment

begin_class
specifier|public
class|class
name|Database
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|Database
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** 	 * Start up the database, configured using the given config file.  This method must be 	 * called precisely once before making use of any facilities offered in this package.  The 	 * configuration file is typically called 'conf.xml' and you can find a sample one in the root 	 * directory of eXist's distribution. 	 * 	 * @param configFile the config file that specifies the database to use 	 * @throws IllegalStateException if the database has already been started 	 */
specifier|public
specifier|static
name|void
name|startup
parameter_list|(
name|Path
name|configFile
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|isStarted
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"database already started"
argument_list|)
throw|;
name|configFile
operator|=
name|configFile
operator|.
name|toAbsolutePath
argument_list|()
expr_stmt|;
name|Configuration
name|config
init|=
operator|new
name|Configuration
argument_list|(
name|FileUtils
operator|.
name|fileName
argument_list|(
name|configFile
argument_list|)
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|configFile
operator|.
name|getParent
argument_list|()
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|BrokerPool
operator|.
name|configure
argument_list|(
name|dbName
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|pool
operator|=
name|BrokerPool
operator|.
name|getInstance
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|txManager
operator|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
expr_stmt|;
name|configureRootCollection
argument_list|(
name|configFile
argument_list|)
expr_stmt|;
name|defragmenter
operator|.
name|start
argument_list|()
expr_stmt|;
name|QueryService
operator|.
name|statistics
argument_list|()
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DatabaseConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|static
name|void
name|configureRootCollection
parameter_list|(
name|Path
name|configFile
parameter_list|)
block|{
name|Database
name|db
init|=
operator|new
name|Database
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|configXml
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|configXml
operator|.
name|append
argument_list|(
literal|"<collection xmlns='http://exist-db.org/collection-config/1.0'>"
argument_list|)
expr_stmt|;
name|configXml
operator|.
name|append
argument_list|(
name|ListenerManager
operator|.
name|getTriggerConfigXml
argument_list|()
argument_list|)
expr_stmt|;
block|{
name|XMLDocument
name|configDoc
init|=
name|db
operator|.
name|getFolder
argument_list|(
literal|"/"
argument_list|)
operator|.
name|documents
argument_list|()
operator|.
name|load
argument_list|(
name|Name
operator|.
name|generate
argument_list|(
name|db
argument_list|)
argument_list|,
name|Source
operator|.
name|xml
argument_list|(
name|configFile
operator|.
name|toFile
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Node
name|indexNode
init|=
name|configDoc
operator|.
name|query
argument_list|()
operator|.
name|optional
argument_list|(
literal|"/exist/indexer/index"
argument_list|)
operator|.
name|node
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexNode
operator|.
name|extant
argument_list|()
condition|)
name|configXml
operator|.
name|append
argument_list|(
name|indexNode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|configDoc
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
name|configXml
operator|.
name|append
argument_list|(
literal|"</collection>"
argument_list|)
expr_stmt|;
comment|// If the config is already *exactly* how we want it, no need to reload and reindex.
try|try
block|{
name|Node
name|currentConfig
init|=
name|db
operator|.
name|getFolder
argument_list|(
name|XmldbURI
operator|.
name|CONFIG_COLLECTION
operator|+
name|Database
operator|.
name|ROOT_PREFIX
argument_list|)
operator|.
name|documents
argument_list|()
operator|.
name|get
argument_list|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE
argument_list|)
operator|.
name|xml
argument_list|()
operator|.
name|root
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentConfig
operator|.
name|query
argument_list|()
operator|.
name|presub
argument_list|()
operator|.
name|single
argument_list|(
literal|"deep-equal(., $1)"
argument_list|,
name|configXml
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|booleanValue
argument_list|()
condition|)
return|return;
block|}
catch|catch
parameter_list|(
name|DatabaseException
name|e
parameter_list|)
block|{
comment|// fall through
block|}
comment|// Now force reload and reindex so it'll pick up the new settings.
name|Transaction
name|tx
init|=
name|db
operator|.
name|requireTransactionWithBroker
argument_list|()
decl_stmt|;
try|try
block|{
name|pool
operator|.
name|getConfigurationManager
argument_list|()
operator|.
name|addConfiguration
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|tx
operator|.
name|broker
argument_list|,
name|tx
operator|.
name|broker
operator|.
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
argument_list|,
name|configXml
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
name|DBBroker
name|broker
init|=
name|db
operator|.
name|acquireBroker
argument_list|()
decl_stmt|;
try|try
block|{
name|broker
operator|.
name|reindexCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|db
operator|.
name|releaseBroker
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|IOException
decl||
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Shut down the database connection.  If the database is not started, do nothing. 	 */
specifier|public
specifier|static
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
return|return;
name|defragmenter
operator|.
name|stop
argument_list|()
expr_stmt|;
name|pool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|pool
operator|=
literal|null
expr_stmt|;
block|}
comment|/** 	 * Ensure the database is started.  If the database is not started, start it with the 	 * given config file.  If it is already started, make sure it was started with the same 	 * config file. 	 *  	 * @param configFile the config file that specifies the database to use 	 * @throws IllegalStateException if the database was already started with a different config file 	 *  	 * @deprecated Please use a combination of {@link #isStarted()} and {@link #startup(Path)}. 	 */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|ensureStarted
parameter_list|(
specifier|final
name|Path
name|configFile
parameter_list|)
block|{
if|if
condition|(
name|isStarted
argument_list|()
condition|)
block|{
specifier|final
name|Optional
argument_list|<
name|Path
argument_list|>
name|currentPath
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getConfigFilePath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|currentPath
operator|.
name|map
argument_list|(
name|cp
lambda|->
name|cp
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|equals
argument_list|(
name|configFile
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
argument_list|)
operator|.
name|orElse
argument_list|(
literal|false
argument_list|)
condition|)
block|{
throw|throw
argument_list|new
name|IllegalStateException
argument_list|(
literal|"database already started with different configuration "
operator|+
name|currentPath
argument_list|)
block|; 			}
block|}
else|else
block|{
name|startup
argument_list|(
name|configFile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Return whether the database has been started and is currently running in this JVM.  This will 	 * be the case if {@link #startup(Path)} or {@link #ensureStarted(Path)} was previously called 	 * successfully and {@link #shutdown()} was not yet called. 	 * 	 * @return<code>true</code> if the database has been started with any configuration file 	 */
specifier|public
specifier|static
name|boolean
name|isStarted
parameter_list|()
block|{
return|return
name|BrokerPool
operator|.
name|isConfigured
argument_list|(
name|dbName
argument_list|)
return|;
block|}
comment|/** 	 * Flush the contents of the database to disk.  This ensures that all transactions are written out 	 * and the state of the database is synced.  It shouldn't be necessary any more with the newly 	 * implemented transaction recovery and this method will probably be deprecated in the future. 	 */
specifier|public
specifier|static
name|void
name|flush
parameter_list|()
block|{
if|if
condition|(
operator|!
name|BrokerPool
operator|.
name|isConfigured
argument_list|(
name|dbName
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"database not started"
argument_list|)
throw|;
try|try
init|(
specifier|final
name|DBBroker
name|broker
init|=
name|pool
operator|.
name|get
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|broker
operator|.
name|flush
argument_list|()
expr_stmt|;
name|broker
operator|.
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Verify the internal consistency of the database's data structures.  Log a fatal message if the 	 * database is corrupted, as well as error-level messages for all the problems found.  If the 	 * database is corrupted, you can try using admin tools to reindex it, or back it up and restore 	 * it.  However, there's a good chance it's unrecoverable. 	 *  	 * @return<code>true</code> if the database's internal data structures are consistent, 	 *<code>false</code> if the database is corrupted 	 */
specifier|public
specifier|static
name|boolean
name|checkConsistency
parameter_list|()
block|{
synchronized|synchronized
init|(
name|pool
init|)
block|{
try|try
block|{
name|DBBroker
name|broker
init|=
name|pool
operator|.
name|enterServiceMode
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|ErrorReport
argument_list|>
name|errors
init|=
operator|new
name|ConsistencyCheck
argument_list|(
name|broker
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
operator|.
name|checkAll
argument_list|(
name|NULL_PROGRESS_CALLBACK
argument_list|)
decl_stmt|;
if|if
condition|(
name|errors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"database corrupted"
argument_list|)
expr_stmt|;
for|for
control|(
name|ErrorReport
name|error
range|:
name|errors
control|)
name|LOG
operator|.
name|error
argument_list|(
name|error
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|"\n"
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|pool
operator|.
name|exitServiceMode
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ConsistencyCheck
operator|.
name|ProgressCallback
name|NULL_PROGRESS_CALLBACK
init|=
operator|new
name|ConsistencyCheck
operator|.
name|ProgressCallback
argument_list|()
block|{
specifier|public
name|void
name|error
parameter_list|(
name|ErrorReport
name|error
parameter_list|)
block|{
block|}
specifier|public
name|void
name|startCollection
parameter_list|(
name|String
name|path
parameter_list|)
block|{
block|}
specifier|public
name|void
name|startDocument
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|current
parameter_list|,
name|int
name|count
parameter_list|)
block|{
block|}
block|}
decl_stmt|;
comment|/** 	 * Login to obtain access to the database.  The password should be passed in the clear. 	 * If a user does not have a password set, pass in<code>null</code>. 	 * Note that all newly created databases have a user<code>admin</code> with no password set. 	 * 	 * @param username the username of the user being logged in 	 * @param password the password corresponding to that user name, or<code>null</code> if none 	 * @return an instance of the database configured for access by the given user 	 * @throws DatabaseException if the user could not be logged in 	 */
specifier|public
specifier|static
name|Database
name|login
parameter_list|(
name|String
name|username
parameter_list|,
name|String
name|password
parameter_list|)
block|{
name|Subject
name|user
decl_stmt|;
try|try
block|{
name|user
operator|=
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|authenticate
argument_list|(
name|username
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AuthenticationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
operator|new
name|Database
argument_list|(
name|user
argument_list|)
return|;
block|}
comment|/**      * Get database if was already login in current thread.       *      * @return an instance of the database configured for access      * @throws DatabaseException if the user could not be logged in      */
specifier|public
specifier|static
name|Database
name|current
parameter_list|()
throws|throws
name|DatabaseException
block|{
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
block|{
comment|//if (isStarted()) throw new IllegalStateException("database already started");
try|try
block|{
name|pool
operator|=
name|BrokerPool
operator|.
name|getInstance
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
name|txManager
operator|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
expr_stmt|;
comment|//configureRootCollection(configFile);
comment|//defragmenter.start();
comment|//QueryService.statistics().reset();
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|DBBroker
name|broker
decl_stmt|;
try|try
block|{
name|broker
operator|=
name|pool
operator|.
name|getActiveBroker
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
operator|new
name|Database
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|)
return|;
block|}
comment|/** 	 * Remove the given listener from all trigger points on all sources. 	 * 	 * @param listener the listener to remove 	 */
specifier|public
specifier|static
name|void
name|remove
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|ListenerManager
operator|.
name|INSTANCE
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
specifier|static
name|String
name|normalizePath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|ROOT_PREFIX
argument_list|)
condition|)
block|{
name|path
operator|=
name|path
operator|.
name|equals
argument_list|(
name|ROOT_PREFIX
argument_list|)
condition|?
literal|"/"
else|:
name|path
operator|.
name|substring
argument_list|(
name|Database
operator|.
name|ROOT_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
specifier|private
specifier|static
name|String
name|dbName
init|=
literal|"exist"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ROOT_PREFIX
init|=
name|XmldbURI
operator|.
name|ROOT_COLLECTION
decl_stmt|;
specifier|private
specifier|static
specifier|volatile
name|BrokerPool
name|pool
decl_stmt|;
specifier|private
specifier|static
name|TransactionManager
name|txManager
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Transaction
argument_list|>
name|localTransaction
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Transaction
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|WeakHashMap
argument_list|<
name|NativeBroker
argument_list|,
name|Boolean
argument_list|>
name|instrumentedBrokers
init|=
operator|new
name|WeakHashMap
argument_list|<
name|NativeBroker
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Subject
name|user
decl_stmt|;
specifier|private
specifier|final
name|NamespaceMap
name|namespaceBindings
decl_stmt|;
name|String
name|defaultCharacterEncoding
init|=
literal|"UTF-8"
decl_stmt|;
name|Database
parameter_list|(
name|Subject
name|user
parameter_list|)
block|{
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
name|this
operator|.
name|namespaceBindings
operator|=
operator|new
name|NamespaceMap
argument_list|()
expr_stmt|;
block|}
name|Database
parameter_list|(
name|Database
name|parent
parameter_list|,
name|NamespaceMap
name|namespaceBindings
parameter_list|)
block|{
name|this
operator|.
name|user
operator|=
name|parent
operator|.
name|user
expr_stmt|;
name|this
operator|.
name|namespaceBindings
operator|=
name|namespaceBindings
operator|.
name|extend
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * @deprecated Renamed to {@link #setDefaultCharacterEncoding(String)}. 	 */
annotation|@
name|Deprecated
specifier|public
name|void
name|setDefaultExportEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
name|setDefaultCharacterEncoding
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set the default character encoding to be used when exporting XML files from the database. 	 * If not explicitly set, it defaults to UTF-8. 	 * 	 * @param encoding 	 */
specifier|public
name|void
name|setDefaultCharacterEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
name|defaultCharacterEncoding
operator|=
name|encoding
expr_stmt|;
block|}
name|DBBroker
name|acquireBroker
parameter_list|()
block|{
try|try
block|{
name|NativeBroker
name|broker
init|=
operator|(
name|NativeBroker
operator|)
name|pool
operator|.
name|get
argument_list|(
name|Optional
operator|.
name|ofNullable
argument_list|(
name|user
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|instrumentedBrokers
operator|.
name|get
argument_list|(
name|broker
argument_list|)
operator|==
literal|null
condition|)
block|{
name|broker
operator|.
name|addContentLoadingObserver
argument_list|(
name|contentObserver
argument_list|)
expr_stmt|;
name|instrumentedBrokers
operator|.
name|put
argument_list|(
name|broker
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|broker
return|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|void
name|releaseBroker
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
name|broker
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * Return the namespace bindings for this database instance.  They will be inherited by 	 * all resources derived from this instance. 	 * 	 * @return the namespace bindings for this database instance 	 */
specifier|public
name|NamespaceMap
name|namespaceBindings
parameter_list|()
block|{
return|return
name|namespaceBindings
return|;
block|}
specifier|private
name|Sequence
name|adoptInternal
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|DBBroker
name|broker
init|=
name|acquireBroker
argument_list|()
decl_stmt|;
try|try
block|{
name|XQueryContext
name|context
init|=
operator|new
name|XQueryContext
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
argument_list|)
decl_stmt|;
name|context
operator|.
name|declareNamespaces
argument_list|(
name|namespaceBindings
operator|.
name|getCombinedMap
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|setBackwardsCompatibility
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|context
operator|.
name|setStaticallyKnownDocuments
argument_list|(
name|DocumentSet
operator|.
name|EMPTY_DOCUMENT_SET
argument_list|)
expr_stmt|;
return|return
name|XPathUtil
operator|.
name|javaObjectToXPath
argument_list|(
name|o
argument_list|,
name|context
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|releaseBroker
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|ItemList
name|adopt
parameter_list|(
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
name|node
parameter_list|)
block|{
comment|// this works for DocumentFragments too, they'll be automatically expanded
return|return
operator|new
name|ItemList
argument_list|(
name|adoptInternal
argument_list|(
name|node
argument_list|)
argument_list|,
name|namespaceBindings
operator|.
name|extend
argument_list|()
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** 	 * Check whether the database contains a document or a folder with the given absolute path. 	 * 	 * @param path the absolute path of the document or folder to check 	 * @return<code>true</code> if there is a document or folder at the given path,<code>false</code> otherwise 	 */
specifier|public
name|boolean
name|contains
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"empty path: "
operator|+
name|path
argument_list|)
throw|;
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|path
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path not absolute: "
operator|+
name|path
argument_list|)
throw|;
if|if
condition|(
name|path
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path ends with '/': "
operator|+
name|path
argument_list|)
throw|;
name|int
name|i
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
assert|assert
name|i
operator|!=
operator|-
literal|1
assert|;
name|DBBroker
name|broker
init|=
name|acquireBroker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|broker
operator|.
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|path
argument_list|)
argument_list|)
operator|!=
literal|null
condition|)
return|return
literal|true
return|;
name|String
name|folderPath
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|path
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Collection
name|collection
init|=
name|broker
operator|.
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|folderPath
argument_list|)
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|collection
operator|.
name|getDocument
argument_list|(
name|broker
argument_list|,
name|XmldbURI
operator|.
name|create
argument_list|(
name|name
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
finally|finally
block|{
name|releaseBroker
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Get the document for the given absolute path.  Namespace bindings will be inherited 	 * from this database. 	 * 	 * @param path the absolute path of the desired document 	 * @return the document at the given path 	 * @throws DatabaseException if the document is not found or something else goes wrong 	 */
specifier|public
name|Document
name|getDocument
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"empty document path: "
operator|+
name|path
argument_list|)
throw|;
if|if
condition|(
operator|!
name|path
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"document path not absolute: "
operator|+
name|path
argument_list|)
throw|;
if|if
condition|(
name|path
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"document path ends with '/': "
operator|+
name|path
argument_list|)
throw|;
name|int
name|i
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
assert|assert
name|i
operator|!=
operator|-
literal|1
assert|;
return|return
name|getFolder
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|"/"
else|:
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|.
name|documents
argument_list|()
operator|.
name|get
argument_list|(
name|path
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * Get the folder for the given path.  Namespace mappings will be inherited from this 	 * database. 	 *  	 * @param path the address of the desired collection 	 * @return a collection bound to the given path 	 * @throws DatabaseException if the path does not identify a valid collection 	 */
specifier|public
name|Folder
name|getFolder
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
operator|new
name|Folder
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
name|namespaceBindings
operator|.
name|extend
argument_list|()
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** 	 * Create the folder for the given path.  Namespace mappings will be inherited from this 	 * database.  If the folder does not exist, it is created along with all required ancestors. 	 *  	 * @param path the address of the desired collection 	 * @return a collection bound to the given path 	 */
specifier|public
name|Folder
name|createFolder
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
operator|new
name|Folder
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
name|namespaceBindings
operator|.
name|extend
argument_list|()
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** 	 * Return a query service that runs queries over the given list of resources. 	 * The resources can be of different kinds, and come from different locations in the 	 * folder hierarchy.  The service will inherit the database's namespace bindings, 	 * rather than the bindings of any given context resource. 	 * 	 * @param context the arbitrary collection of database objects over which to query 	 * @return a query service over the given resources 	 */
specifier|public
name|QueryService
name|query
parameter_list|(
name|Resource
modifier|...
name|context
parameter_list|)
block|{
return|return
name|query
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|context
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * Return a query service that runs queries over the given list of resources. 	 * The resources can be of different kinds, and come from different locations in the 	 * folder hierarchy.  The service will inherit the database's namespace bindings, 	 * rather than the bindings of any given context resource. 	 * 	 * @param context the arbitrary collection of database objects over which to query; 	 * 	the collection is not copied, and the collection's contents are re-read every time the query is performed 	 * @return a query service over the given resources 	 */
specifier|public
name|QueryService
name|query
parameter_list|(
specifier|final
name|java
operator|.
name|util
operator|.
name|Collection
argument_list|<
name|?
extends|extends
name|Resource
argument_list|>
name|context
parameter_list|)
block|{
return|return
operator|new
name|QueryService
argument_list|(
name|getFolder
argument_list|(
literal|"/"
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|void
name|prepareContext
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
name|MutableDocumentSet
name|mdocs
init|=
operator|new
name|DefaultDocumentSet
argument_list|()
decl_stmt|;
name|base
operator|=
operator|new
name|ValueSequence
argument_list|()
expr_stmt|;
for|for
control|(
name|Resource
name|res
range|:
name|context
control|)
block|{
name|QueryService
name|qs
init|=
name|res
operator|.
name|query
argument_list|()
decl_stmt|;
if|if
condition|(
name|qs
operator|.
name|docs
operator|!=
literal|null
condition|)
name|mdocs
operator|.
name|addAll
argument_list|(
name|qs
operator|.
name|docs
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|.
name|base
operator|!=
literal|null
condition|)
try|try
block|{
name|base
operator|.
name|addAll
argument_list|(
name|qs
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"unexpected item type conflict"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|docs
operator|=
name|mdocs
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/** 	 * Return a transaction for use with database operations.  If a transaction is already in progress 	 * then join it, otherwise begin a new one.  If a transaction is joined, calling<code>commit</code> 	 * or<code>abort</code> on the returned instance will have no effect; only the outermost  	 * transaction object can do this. 	 * 	 * @return a transaction object 	 */
specifier|static
name|Transaction
name|requireTransaction
parameter_list|()
block|{
name|Transaction
name|t
init|=
name|localTransaction
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|t
operator|==
literal|null
condition|?
operator|new
name|Transaction
argument_list|(
name|txManager
argument_list|,
literal|null
argument_list|)
else|:
operator|new
name|Transaction
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
name|Transaction
name|requireTransactionWithBroker
parameter_list|()
block|{
name|Transaction
name|t
init|=
name|localTransaction
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|t
operator|==
literal|null
condition|?
operator|new
name|Transaction
argument_list|(
name|txManager
argument_list|,
name|this
argument_list|)
else|:
operator|new
name|Transaction
argument_list|(
name|t
argument_list|,
name|this
argument_list|)
return|;
block|}
name|void
name|checkSame
parameter_list|(
name|Resource
name|o
parameter_list|)
block|{
comment|// allow other resource to be a NULL, as those are safe and database-neutral
if|if
condition|(
operator|!
operator|(
name|o
operator|.
name|database
argument_list|()
operator|==
literal|null
operator|||
name|o
operator|.
name|database
argument_list|()
operator|.
name|user
operator|==
name|this
operator|.
name|user
operator|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot combine objects from two database instances in one operation"
argument_list|)
throw|;
block|}
specifier|private
specifier|static
specifier|final
name|WeakMultiValueHashMap
argument_list|<
name|String
argument_list|,
name|StaleMarker
argument_list|>
name|staleMap
init|=
operator|new
name|WeakMultiValueHashMap
argument_list|<
name|String
argument_list|,
name|StaleMarker
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|void
name|stale
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|int
name|updated
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|staleMap
init|)
block|{
for|for
control|(
name|StaleMarker
name|value
range|:
name|staleMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
control|)
block|{
name|value
operator|.
name|mark
argument_list|()
expr_stmt|;
name|updated
operator|++
expr_stmt|;
block|}
name|staleMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|trackStale
parameter_list|(
name|String
name|key
parameter_list|,
name|StaleMarker
name|value
parameter_list|)
block|{
name|staleMap
operator|.
name|put
argument_list|(
name|normalizePath
argument_list|(
name|key
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|ContentLoadingObserver
name|contentObserver
init|=
operator|new
name|ContentLoadingObserver
argument_list|()
block|{
specifier|public
name|void
name|dropIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|stale
argument_list|(
name|normalizePath
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|dropIndex
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|stale
argument_list|(
name|normalizePath
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeNode
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
name|stale
argument_list|(
name|normalizePath
argument_list|(
operator|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|)
operator|.
name|getURI
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
argument_list|)
operator|+
literal|"#"
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
block|}
specifier|public
name|void
name|setDocument
parameter_list|(
name|DocumentImpl
name|document
parameter_list|)
block|{
block|}
specifier|public
name|void
name|storeAttribute
parameter_list|(
name|AttrImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|RangeIndexSpec
name|spec
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
block|}
specifier|public
name|void
name|storeText
parameter_list|(
name|TextImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
block|}
specifier|public
name|void
name|sync
parameter_list|()
block|{
block|}
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
block|}
specifier|public
name|void
name|closeAndRemove
parameter_list|()
block|{
comment|// TODO:  do nothing OK here?  indexes just got wiped and recreated, and this listener
comment|// was removed...
block|}
block|}
decl_stmt|;
specifier|static
name|void
name|queueDefrag
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|defragmenter
operator|.
name|queue
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|Defragmenter
name|defragmenter
init|=
operator|new
name|Defragmenter
argument_list|()
decl_stmt|;
specifier|private
specifier|static
class|class
name|Defragmenter
implements|implements
name|Runnable
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
literal|"org.exist.fluent.Database.defragmenter"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|DEFRAG_INTERVAL
init|=
literal|10000
decl_stmt|;
comment|// ms
specifier|private
name|Set
argument_list|<
name|DocumentImpl
argument_list|>
name|docsToDefrag
init|=
operator|new
name|TreeSet
argument_list|<
name|DocumentImpl
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Thread
name|thread
decl_stmt|;
specifier|public
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
name|thread
operator|!=
literal|null
condition|)
return|return;
name|thread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
literal|"Database defragmenter"
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setPriority
argument_list|(
name|Thread
operator|.
name|NORM_PRIORITY
operator|-
literal|3
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|thread
operator|==
literal|null
condition|)
return|return;
name|thread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// oh well
block|}
name|thread
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|queue
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|docsToDefrag
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|DEFRAG_INTERVAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
break|break;
block|}
comment|// Grab copy of docsToDefrag to avoid potential deadlocks (if an executing query has a lock on
comment|// the document we want to defrag, we block, then if it tries to queue another document for
comment|// defrag it blocks, and it's deadlock time).
name|Set
argument_list|<
name|DocumentImpl
argument_list|>
name|docsToDefragCopy
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
operator|new
name|MessageFormat
argument_list|(
literal|"checking for documents to defragment, {0,choice,0#no candidates|1#1 candidate|1<{0,number,integer} candidates}"
argument_list|)
operator|.
name|format
argument_list|(
operator|new
name|Object
index|[]
block|{
name|docsToDefrag
operator|.
name|size
argument_list|()
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|docsToDefragCopy
operator|=
name|docsToDefrag
expr_stmt|;
name|docsToDefrag
operator|=
operator|new
name|TreeSet
argument_list|<
name|DocumentImpl
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
init|(
specifier|final
name|DBBroker
name|broker
init|=
name|pool
operator|.
name|get
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|Integer
name|fragmentationLimitObject
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInteger
argument_list|(
name|DBBroker
operator|.
name|PROPERTY_XUPDATE_FRAGMENTATION_FACTOR
argument_list|)
decl_stmt|;
name|int
name|fragmentationLimit
init|=
name|fragmentationLimitObject
operator|==
literal|null
condition|?
literal|0
else|:
name|fragmentationLimitObject
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|it
init|=
name|docsToDefragCopy
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|doc
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getSplitCount
argument_list|()
operator|<=
name|fragmentationLimit
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Must hold write lock on doc before checking stale map to avoid race condition
if|if
condition|(
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|attempt
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
condition|)
try|try
block|{
name|String
name|docPath
init|=
name|normalizePath
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|staleMap
operator|.
name|containsKey
argument_list|(
name|docPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"defragmenting "
operator|+
name|docPath
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|Transaction
name|tx
init|=
name|Database
operator|.
name|requireTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|broker
operator|.
name|defragXMLResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unable to get broker with system privileges to defragment documents"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
operator|new
name|MessageFormat
argument_list|(
literal|"defragmented {0,choice,0#0 documents|1#1 document|1<{0,number,integer} documents}, next cycle in {1,number,integer}s"
argument_list|)
operator|.
name|format
argument_list|(
operator|new
name|Object
index|[]
block|{
name|count
block|,
name|DEFRAG_INTERVAL
operator|/
literal|1000
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|emptyIterator
parameter_list|()
block|{
return|return
name|EMPTY_ITERATOR
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
specifier|final
name|Iterator
name|EMPTY_ITERATOR
init|=
operator|new
name|Iterator
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Object
name|next
parameter_list|()
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
specifier|final
name|Iterable
name|EMPTY_ITERABLE
init|=
operator|new
name|Iterable
argument_list|()
block|{
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
return|return
name|EMPTY_ITERATOR
return|;
block|}
block|}
decl_stmt|;
block|}
end_class

end_unit

