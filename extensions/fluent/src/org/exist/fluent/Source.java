begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|fluent
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_comment
comment|/**  * A source of data to be loaded into the database, distinguishing between XML documents  * and other (binary) documents.  While you can load XML documents as binary without  * problem, but will not be able to query them or otherwise access their structure in the  * database.  *  * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a>  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Source
block|{
specifier|private
specifier|final
name|String
name|oldName
decl_stmt|;
specifier|protected
name|String
name|encoding
decl_stmt|;
specifier|private
name|Source
parameter_list|(
name|String
name|oldName
parameter_list|)
block|{
name|this
operator|.
name|oldName
operator|=
name|oldName
expr_stmt|;
block|}
comment|/** 	 * Set an encoding that indicates how the supplied bytes should be converted to characters 	 * or vice-versa.  Whether and how the encoding is used depends on the source.  If the 	 * encoding is needed but has not been set, the system will make a best guess or default 	 * to UTF-8 as appropriate. 	 * 	 * @param characterEncoding the character encoding to use when dealing with this source 	 * @return this source 	 */
specifier|public
name|Source
name|encoding
parameter_list|(
name|String
name|characterEncoding
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"encoding already set"
argument_list|)
throw|;
name|encoding
operator|=
name|characterEncoding
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|final
name|void
name|applyOldName
parameter_list|(
name|Name
name|name
parameter_list|)
block|{
name|name
operator|.
name|setOldName
argument_list|(
name|oldName
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * A source of XML data to be loaded into the database.  You should acquire instances by 	 * using the static methods in the {@link Source} class. 	 */
specifier|public
specifier|static
specifier|abstract
class|class
name|XML
extends|extends
name|Source
block|{
specifier|private
name|XML
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|XML
parameter_list|(
name|String
name|oldName
parameter_list|)
block|{
name|super
argument_list|(
name|oldName
argument_list|)
expr_stmt|;
block|}
specifier|final
name|InputSource
name|toInputSource
parameter_list|()
throws|throws
name|IOException
block|{
name|InputSource
name|source
init|=
name|createInputSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
name|source
operator|.
name|setEncoding
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|source
return|;
block|}
specifier|abstract
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
function_decl|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"xml "
return|;
block|}
block|}
comment|/** 	 * A source of binary data to be loaded into the database.  You should acquire instances by 	 * using the static methods in the {@link Source} class. 	 */
specifier|public
specifier|static
specifier|abstract
class|class
name|Blob
extends|extends
name|Source
block|{
specifier|protected
name|byte
index|[]
name|contents
decl_stmt|;
specifier|protected
name|int
name|offset
decl_stmt|,
name|length
decl_stmt|;
specifier|private
name|Blob
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Blob
parameter_list|(
name|String
name|oldName
parameter_list|)
block|{
name|super
argument_list|(
name|oldName
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|InputStream
name|toInputStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|contents
operator|==
literal|null
condition|)
name|createBytes
argument_list|()
expr_stmt|;
assert|assert
name|contents
operator|!=
literal|null
assert|;
return|return
operator|new
name|ByteArrayInputStream
argument_list|(
name|contents
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|protected
name|int
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
specifier|protected
name|void
name|createBytes
parameter_list|()
throws|throws
name|IOException
block|{
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"blob "
return|;
block|}
specifier|protected
name|void
name|encode
parameter_list|(
name|CharBuffer
name|buf
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
name|Charset
name|charset
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|encoding
operator|==
literal|null
condition|?
literal|"UTF-8"
else|:
name|encoding
argument_list|)
decl_stmt|;
name|ByteBuffer
name|bb
init|=
name|charset
operator|.
name|newEncoder
argument_list|()
operator|.
name|encode
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|contents
operator|=
name|bb
operator|.
name|array
argument_list|()
expr_stmt|;
name|offset
operator|=
name|bb
operator|.
name|arrayOffset
argument_list|()
expr_stmt|;
name|length
operator|=
name|bb
operator|.
name|limit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Create a source that reads an XML document from an external file. 	 * 	 * @param file the XML file 	 * @return a source that reads XML from the file 	 */
specifier|public
specifier|static
name|Source
operator|.
name|XML
name|xml
parameter_list|(
specifier|final
name|File
name|file
parameter_list|)
block|{
specifier|final
name|String
name|uri
init|=
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toASCIIString
argument_list|()
decl_stmt|;
return|return
operator|new
name|XML
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
block|{
name|InputSource
name|src
init|=
operator|new
name|InputSource
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
name|src
operator|.
name|setEncoding
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"file '"
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|"'"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source that reads a binary document from an external file. 	 * 	 * @param file the binary file 	 * @return a source that reads binary from the file 	 */
specifier|public
specifier|static
name|Source
operator|.
name|Blob
name|blob
parameter_list|(
specifier|final
name|File
name|file
parameter_list|)
block|{
return|return
operator|new
name|Blob
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|InputStream
name|toInputStream
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|fileLength
init|=
name|file
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileLength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"file too large"
argument_list|)
throw|;
name|length
operator|=
operator|(
name|int
operator|)
name|fileLength
expr_stmt|;
return|return
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"file '"
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|"'"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of XML data that reads from the given input stream.  Note that the 	 * contents of the stream will need to be read<em>twice</em>, so if the stream is transient 	 * (i.e., its contents are not available for random access, such as for a socket input stream) its 	 * contents will be automatically saved in memory.  This could be very inefficient if the 	 * document being streamed is large. 	 * 	 * @param stream the input stream to read the XML from 	 * @return a source that reads from the given input stream 	 */
specifier|public
specifier|static
name|Source
operator|.
name|XML
name|xml
parameter_list|(
specifier|final
name|InputStream
name|stream
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|XML
argument_list|()
block|{
specifier|private
name|InputStream
name|markedStream
decl_stmt|;
annotation|@
name|Override
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|markedStream
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|stream
operator|.
name|markSupported
argument_list|()
condition|)
block|{
name|markedStream
operator|=
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: if stream size exceeds some threshold, save contents to a temporary file instead
name|markedStream
operator|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|readInputStream
argument_list|(
name|stream
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|markedStream
operator|.
name|mark
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
name|markedStream
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
operator|new
name|InputSource
argument_list|(
name|markedStream
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"input stream"
operator|+
operator|(
name|markedStream
operator|==
name|stream
condition|?
literal|""
else|:
literal|" (cached)"
operator|)
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of binary data that reads from the given input stream.  At this time, 	 * eXist doesn't support streaming into the database, so the contents of the stream will 	 * be read entirely into memory before being persisted. 	 * 	 * @param stream the binary stream to read from 	 * @return a source that reads from the given input stream 	 */
specifier|public
specifier|static
name|Source
operator|.
name|Blob
name|blob
parameter_list|(
specifier|final
name|InputStream
name|stream
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|Blob
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|createBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|contents
operator|=
name|readInputStream
argument_list|(
name|stream
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|length
operator|=
name|contents
operator|.
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"input stream"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of XML data that reads from the given reader.  Note that the 	 * contents of the reader will need to be read<em>twice</em>, so its 	 * contents will be automatically saved in memory.  This could be very inefficient if the 	 * document being streamed is large. 	 * 	 * @param reader the reader to read the XML from 	 * @return a source that reads from the given reader 	 */
specifier|public
specifier|static
name|Source
operator|.
name|XML
name|xml
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|XML
argument_list|()
block|{
specifier|private
name|char
index|[]
name|contents
decl_stmt|;
annotation|@
name|Override
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|contents
operator|==
literal|null
condition|)
name|contents
operator|=
name|readReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
operator|new
name|InputSource
argument_list|(
operator|new
name|CharArrayReader
argument_list|(
name|contents
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"reader"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of binary data that reads from the given reader.  The characters 	 * will be converted into bytes by using the encoding specified for this source, or UTF-8 	 * by default.  At this time, eXist doesn't support streaming into the database, so the 	 * contents of the reader will be read entirely into memory before being persisted. 	 * 	 * @param reader the reader to read from 	 * @return a source that reads from the given reader 	 */
specifier|public
specifier|static
name|Source
operator|.
name|Blob
name|blob
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|Blob
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|createBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|encode
argument_list|(
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|readReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"reader"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of XML data from the given byte array.  If this source specifies an 	 * encoding, it will be used to decode the characters, otherwise the encoding will be 	 * guessed using standard XML parsing techniques. 	 * 	 * @param bytes the source bytes 	 * @return a source that reads XML from the given byte array 	 */
specifier|public
specifier|static
name|Source
operator|.
name|XML
name|xml
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|XML
argument_list|()
block|{
annotation|@
name|Override
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|InputSource
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"byte array ["
operator|+
name|bytes
operator|.
name|length
operator|+
literal|"]"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of binary data from the given byte array.  The bytes will be stored in 	 * the database verbatim. 	 * 	 * @param bytes the source bytes 	 * @return a source that reads binary data from the given byte array 	 */
specifier|public
specifier|static
name|Source
operator|.
name|Blob
name|blob
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|Blob
argument_list|()
block|{
block|{
name|contents
operator|=
name|bytes
expr_stmt|;
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"byte array ["
operator|+
name|bytes
operator|.
name|length
operator|+
literal|"]"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of XML data from the given string literal.  The string should contain 	 * an XML document, not a filename or URI. 	 * 	 * @param literal the contents of an XML document 	 * @return a source that reads XML from the given literal string 	 */
specifier|public
specifier|static
name|Source
operator|.
name|XML
name|xml
parameter_list|(
specifier|final
name|String
name|literal
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|XML
argument_list|()
block|{
annotation|@
name|Override
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
name|literal
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"literal string:\n"
operator|+
name|literal
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of binary data from the given string literal.  The string should contain 	 * the actual data, not a filename or URI.  The string's characters will be converted into 	 * bytes by using the encoding specified for this source, or UTF-8 by default. 	 * 	 * @param literal the contents of the document 	 * @return a source that reads binary data from the given literal string 	 */
specifier|public
specifier|static
name|Source
operator|.
name|Blob
name|blob
parameter_list|(
specifier|final
name|String
name|literal
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|Blob
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|createBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|encode
argument_list|(
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|literal
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"literal string"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of XML that reads from the given URL.  Note that the URL's contents 	 * will have to be retrieved twice, so if the connection is slow or expensive it might be 	 * worthwhile to cache them and use a different (local) source constructor. 	 * 	 * @param url the URL to read XML from 	 * @return a source that reads XML from the given URL 	 * @throws URISyntaxException if the URL syntax is not strictly spec-compliant 	 */
specifier|public
specifier|static
name|Source
operator|.
name|XML
name|xml
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|URISyntaxException
block|{
specifier|final
name|String
name|uri
init|=
name|url
operator|.
name|toURI
argument_list|()
operator|.
name|toASCIIString
argument_list|()
decl_stmt|;
return|return
operator|new
name|Source
operator|.
name|XML
argument_list|(
name|urlToFilename
argument_list|(
name|url
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|InputSource
name|createInputSource
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|InputSource
argument_list|(
name|uri
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"at URL '"
operator|+
name|uri
operator|+
literal|"'"
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * Create a source of binary data that reads from the given URL. 	 * 	 * @param url the URL to read binary data from 	 * @return a source that reads binary data from the given URL 	 */
specifier|public
specifier|static
name|Source
operator|.
name|Blob
name|blob
parameter_list|(
specifier|final
name|URL
name|url
parameter_list|)
block|{
return|return
operator|new
name|Source
operator|.
name|Blob
argument_list|(
name|urlToFilename
argument_list|(
name|url
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|InputStream
name|toInputStream
parameter_list|()
throws|throws
name|IOException
block|{
name|URLConnection
name|connection
init|=
name|url
operator|.
name|openConnection
argument_list|()
decl_stmt|;
name|connection
operator|.
name|setAllowUserInteraction
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|connection
operator|.
name|connect
argument_list|()
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|getContentLength
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
init|=
literal|null
decl_stmt|;
name|bytes
operator|=
name|readInputStream
argument_list|(
name|connection
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
return|return
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
return|;
block|}
finally|finally
block|{
name|connection
operator|.
name|getInputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|=
name|connection
operator|.
name|getContentLength
argument_list|()
expr_stmt|;
return|return
name|connection
operator|.
name|getInputStream
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"at URL '"
operator|+
name|url
operator|+
literal|"'"
return|;
block|}
block|}
return|;
block|}
specifier|private
specifier|static
name|String
name|urlToFilename
parameter_list|(
name|URL
name|url
parameter_list|)
block|{
name|String
name|path
init|=
name|url
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
operator|||
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|int
name|k
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
name|path
operator|=
name|path
operator|.
name|substring
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|path
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_SIZE
init|=
literal|16384
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|readInputStream
parameter_list|(
name|InputStream
name|stream
parameter_list|,
name|byte
index|[]
name|chunk
parameter_list|)
throws|throws
name|IOException
block|{
name|PushbackInputStream
name|in
init|=
operator|new
name|PushbackInputStream
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
name|chunk
operator|=
operator|new
name|byte
index|[
name|CHUNK_SIZE
index|]
expr_stmt|;
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|chunks
init|=
operator|new
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|chunks
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|chunk
argument_list|,
name|k
argument_list|,
name|chunk
operator|.
name|length
operator|-
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
break|break;
name|totalSize
operator|+=
name|n
expr_stmt|;
name|k
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|chunk
operator|.
name|length
condition|)
block|{
comment|// probe next byte to avoid allocating another chunk if contents fit perfectly
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
break|break;
name|in
operator|.
name|unread
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|new
name|byte
index|[
name|CHUNK_SIZE
index|]
expr_stmt|;
name|chunks
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chunks
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|chunks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|length
operator|==
name|totalSize
condition|)
return|return
name|chunks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
name|chunk
operator|=
operator|new
name|byte
index|[
name|totalSize
index|]
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|a
range|:
name|chunks
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|,
name|k
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|totalSize
operator|-
name|k
argument_list|,
name|a
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|+=
name|a
operator|.
name|length
expr_stmt|;
block|}
return|return
name|chunk
return|;
block|}
specifier|private
specifier|static
name|char
index|[]
name|readReader
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|char
index|[]
name|chunk
parameter_list|)
throws|throws
name|IOException
block|{
name|PushbackReader
name|in
init|=
operator|new
name|PushbackReader
argument_list|(
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
name|chunk
operator|=
operator|new
name|char
index|[
name|CHUNK_SIZE
index|]
expr_stmt|;
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|char
index|[]
argument_list|>
name|chunks
init|=
operator|new
name|LinkedList
argument_list|<
name|char
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|chunks
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|chunk
argument_list|,
name|k
argument_list|,
name|chunk
operator|.
name|length
operator|-
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
break|break;
name|totalSize
operator|+=
name|n
expr_stmt|;
name|k
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|chunk
operator|.
name|length
condition|)
block|{
comment|// probe next byte to avoid allocating another chunk if contents fit perfectly
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
break|break;
name|in
operator|.
name|unread
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|new
name|char
index|[
name|CHUNK_SIZE
index|]
expr_stmt|;
name|chunks
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chunks
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|chunks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|length
operator|==
name|totalSize
condition|)
return|return
name|chunks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
name|chunk
operator|=
operator|new
name|char
index|[
name|totalSize
index|]
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|char
index|[]
name|a
range|:
name|chunks
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|,
name|k
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|totalSize
operator|-
name|k
argument_list|,
name|a
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|+=
name|a
operator|.
name|length
expr_stmt|;
block|}
return|return
name|chunk
return|;
block|}
block|}
end_class

end_unit

