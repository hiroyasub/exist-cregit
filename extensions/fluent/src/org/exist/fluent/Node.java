begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|fluent
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * A node in the database.  Nodes are most often contained in XML documents, but can also  * be transient in-memory nodes created by a query.  *  * @author<a href="mailto:piotr@ideanest.com">Piotr Kaminski</a>  */
end_comment

begin_class
specifier|public
class|class
name|Node
extends|extends
name|Item
block|{
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|Collection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|XMLDocument
name|document
decl_stmt|;
specifier|final
name|StaleMarker
name|staleMarker
init|=
operator|new
name|StaleMarker
argument_list|()
decl_stmt|;
specifier|private
name|Node
parameter_list|()
block|{
block|}
name|Node
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|NodeValue
name|item
parameter_list|,
name|NamespaceMap
name|namespaceBindings
parameter_list|,
name|Database
name|db
parameter_list|)
block|{
name|super
argument_list|(
name|item
argument_list|,
name|namespaceBindings
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|instanceof
name|NodeProxy
condition|)
block|{
name|NodeProxy
name|proxy
init|=
operator|(
name|NodeProxy
operator|)
name|item
decl_stmt|;
name|String
name|docPath
init|=
name|proxy
operator|.
name|getDocument
argument_list|()
operator|.
name|getURI
argument_list|()
operator|.
name|getCollectionPath
argument_list|()
decl_stmt|;
name|staleMarker
operator|.
name|track
argument_list|(
name|docPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|docPath
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// folder
name|staleMarker
operator|.
name|track
argument_list|(
name|docPath
argument_list|)
expr_stmt|;
comment|// document
name|staleMarker
operator|.
name|track
argument_list|(
name|docPath
operator|+
literal|"#"
operator|+
name|proxy
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// node
block|}
block|}
annotation|@
name|Override
name|Sequence
name|convertToSequence
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|convertToSequence
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|extant
parameter_list|()
block|{
return|return
operator|!
name|staleMarker
operator|.
name|stale
argument_list|()
return|;
block|}
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
name|getDOMNode
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
try|try
block|{
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
name|domNode
init|=
operator|(
operator|(
name|NodeValue
operator|)
name|item
operator|)
operator|.
name|getNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|domNode
operator|==
literal|null
condition|)
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"unable to load node data"
argument_list|)
throw|;
return|return
name|domNode
return|;
block|}
catch|catch
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|sanity
operator|.
name|AssertFailure
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Return this node. 	 *  	 * @return this node 	 */
annotation|@
name|Override
specifier|public
name|Node
name|node
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Comparable
argument_list|<
name|Object
argument_list|>
name|comparableValue
parameter_list|()
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"nodes are not comparable"
argument_list|)
throw|;
block|}
comment|/** 	 * Return whether this node represents the same node in the database as the given object. 	 */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Node
operator|)
condition|)
return|return
literal|false
return|;
name|Node
name|that
init|=
operator|(
name|Node
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|item
operator|==
name|that
operator|.
name|item
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|this
operator|.
name|item
operator|instanceof
name|NodeProxy
operator|&&
name|that
operator|.
name|item
operator|instanceof
name|NodeProxy
condition|)
block|{
try|try
block|{
return|return
operator|(
operator|(
name|NodeProxy
operator|)
name|this
operator|.
name|item
operator|)
operator|.
name|equals
argument_list|(
operator|(
name|NodeProxy
operator|)
name|that
operator|.
name|item
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|e
parameter_list|)
block|{
comment|// fall through to return false below
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** 	 * Warning:  computing a node's hash code is surprisingly expensive, and the value is not cached. 	 * You should not use nodes in situations where they might get hashed. 	 */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|computeHashCode
argument_list|()
return|;
block|}
specifier|private
name|int
name|computeHashCode
parameter_list|()
block|{
if|if
condition|(
name|item
operator|instanceof
name|NodeProxy
condition|)
block|{
name|NodeProxy
name|proxy
init|=
operator|(
name|NodeProxy
operator|)
name|item
decl_stmt|;
name|VariableByteOutputStream
name|buf
init|=
operator|new
name|VariableByteOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|proxy
operator|.
name|getNodeId
argument_list|()
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unable to serialize node's id to compute hashCode"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|proxy
operator|.
name|getDocument
argument_list|()
operator|.
name|getURI
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|^
name|Arrays
operator|.
name|hashCode
argument_list|(
name|buf
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|item
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
comment|/** 	 * Return the namespace bindings in force in the scope of this node.  Only works on nodes 	 * that are XML elements.  Namespaces reserved by the XML spec, and implicitly in scope 	 * for all XML elements, are not reported. 	 * 	 * @return the namespace bindings in force for this node 	 */
specifier|public
name|NamespaceMap
name|inScopeNamespaces
parameter_list|()
block|{
name|NamespaceMap
name|namespaceMap
init|=
operator|new
name|NamespaceMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|query
argument_list|()
operator|.
name|all
argument_list|(
literal|"for $prefix in in-scope-prefixes($_1) return ($prefix, namespace-uri-for-prefix($prefix, $_1))"
argument_list|,
name|this
argument_list|)
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|prefix
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|,
name|namespace
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|NamespaceMap
operator|.
name|isReservedPrefix
argument_list|(
name|prefix
argument_list|)
condition|)
name|namespaceMap
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
return|return
name|namespaceMap
return|;
block|}
comment|/** 	 * Compare the order of two nodes in a document.  	 * 	 * @param node the node to compare this one to 	 * @return node 0 if this node is the same as the given node, a value less than 0 if it precedes the 	 * 	given node in the document, and a value great than 0 if it follows the given node in the document 	 * @throws DatabaseException if this node and the given one are not in the same document 	 */
specifier|public
name|int
name|compareDocumentOrderTo
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|item
operator|==
name|node
operator|.
name|item
condition|)
return|return
literal|0
return|;
name|NodeValue
name|nv1
init|=
operator|(
name|NodeValue
operator|)
name|this
operator|.
name|item
decl_stmt|,
name|nv2
init|=
operator|(
name|NodeValue
operator|)
name|node
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|nv1
operator|.
name|getImplementationType
argument_list|()
operator|!=
name|nv2
operator|.
name|getImplementationType
argument_list|()
condition|)
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"can't compare different node types, since they can never be in the same document"
argument_list|)
throw|;
if|if
condition|(
name|nv1
operator|.
name|getImplementationType
argument_list|()
operator|==
name|NodeValue
operator|.
name|PERSISTENT_NODE
condition|)
block|{
name|NodeProxy
name|n1
init|=
operator|(
name|NodeProxy
operator|)
name|item
decl_stmt|,
name|n2
init|=
operator|(
name|NodeProxy
operator|)
name|node
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|n1
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|!=
name|n2
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"can't compare document order of nodes in disparate documents:  this node is in "
operator|+
name|document
argument_list|()
operator|+
literal|" and the argument node in "
operator|+
name|node
operator|.
name|document
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|n1
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|n2
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
try|try
block|{
return|return
name|n1
operator|.
name|before
argument_list|(
name|n2
argument_list|,
literal|false
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|+
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"unable to compare nodes"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|else if
condition|(
name|nv1
operator|.
name|getImplementationType
argument_list|()
operator|==
name|NodeValue
operator|.
name|IN_MEMORY_NODE
condition|)
block|{
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|NodeImpl
name|n1
init|=
operator|(
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|NodeImpl
operator|)
name|nv1
decl_stmt|,
name|n2
init|=
operator|(
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|NodeImpl
operator|)
name|nv2
decl_stmt|;
if|if
condition|(
name|n1
operator|.
name|getDocument
argument_list|()
operator|!=
name|n2
operator|.
name|getDocument
argument_list|()
condition|)
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"can't compare document order of in-memory nodes created separately"
argument_list|)
throw|;
try|try
block|{
return|return
name|n1
operator|.
name|before
argument_list|(
name|n2
argument_list|,
literal|false
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|+
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"unable to compare nodes"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"unknown node implementation type: "
operator|+
name|nv1
operator|.
name|getImplementationType
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Return the document to which this node belongs. 	 *  	 * @return the document to which this node belongs 	 * @throws UnsupportedOperationException if this node does not belong to a document 	 */
specifier|public
name|XMLDocument
name|document
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
if|if
condition|(
name|document
operator|==
literal|null
condition|)
try|try
block|{
name|document
operator|=
name|Document
operator|.
name|newInstance
argument_list|(
operator|(
operator|(
name|NodeProxy
operator|)
name|item
operator|)
operator|.
name|getDocument
argument_list|()
argument_list|,
name|this
argument_list|)
operator|.
name|xml
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"node is not part of a document in the database"
argument_list|)
throw|;
block|}
return|return
name|document
return|;
block|}
comment|/** 	 * Return a builder that will append elements to this node's children.  The builder will return the 	 * appended node if a single node was appended, otherwise<code>null</code>. 	 * 	 * @return a builder that will append nodes to this node 	 */
specifier|public
name|ElementBuilder
argument_list|<
name|Node
argument_list|>
name|append
parameter_list|()
block|{
name|staleMarker
operator|.
name|check
argument_list|()
expr_stmt|;
comment|// do an early check to fail-fast, we'll check again on completion
try|try
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|getDOMNode
argument_list|()
decl_stmt|;
return|return
operator|new
name|ElementBuilder
argument_list|<
name|Node
argument_list|>
argument_list|(
name|namespaceBindings
argument_list|,
literal|true
argument_list|,
operator|new
name|ElementBuilder
operator|.
name|CompletedCallback
argument_list|<
name|Node
argument_list|>
argument_list|()
block|{
specifier|public
name|Node
name|completed
parameter_list|(
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
index|[]
name|nodes
parameter_list|)
block|{
name|Transaction
name|tx
init|=
name|db
operator|.
name|requireTransactionWithBroker
argument_list|()
decl_stmt|;
try|try
block|{
name|tx
operator|.
name|lockWrite
argument_list|(
name|node
operator|.
name|getDocument
argument_list|()
argument_list|)
expr_stmt|;
name|DocumentTrigger
name|trigger
init|=
name|fireTriggerBefore
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|node
operator|.
name|appendChildren
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|toNodeList
argument_list|(
name|nodes
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|StoredNode
name|result
init|=
operator|(
name|StoredNode
operator|)
name|node
operator|.
name|getLastChild
argument_list|()
decl_stmt|;
name|touchDefragAndFireTriggerAfter
argument_list|(
name|tx
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|NodeProxy
name|proxy
init|=
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|result
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|result
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|result
operator|.
name|getNodeType
argument_list|()
argument_list|,
name|result
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Node
argument_list|(
name|proxy
argument_list|,
name|namespaceBindings
operator|.
name|extend
argument_list|()
argument_list|,
name|db
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DOMException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"append aborted by listener"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
if|if
condition|(
name|getDOMNode
argument_list|()
operator|instanceof
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|NodeImpl
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"appends to in-memory nodes are not supported"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot append to a "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|item
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** 	 * Delete this node from its parent.  This can delete an element from a document, 	 * or an attribute from an element, etc.  Trying to delete the root element of a 	 * document will delete the document instead.  If the node cannot be found, assume 	 * it's already been deleted and return silently. 	 */
specifier|public
name|void
name|delete
parameter_list|()
block|{
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
name|child
decl_stmt|;
try|try
block|{
name|child
operator|=
name|getDOMNode
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DatabaseException
name|e
parameter_list|)
block|{
return|return;
block|}
name|NodeImpl
name|parent
init|=
operator|(
name|NodeImpl
operator|)
name|child
operator|.
name|getParentNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
operator|||
name|parent
operator|instanceof
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
condition|)
block|{
name|document
argument_list|()
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"cannot delete node with no parent"
argument_list|)
throw|;
block|}
else|else
block|{
name|Transaction
name|tx
init|=
name|db
operator|.
name|requireTransactionWithBroker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|parent
operator|instanceof
name|StoredNode
condition|)
name|tx
operator|.
name|lockWrite
argument_list|(
operator|(
operator|(
name|StoredNode
operator|)
name|parent
operator|)
operator|.
name|getDocument
argument_list|()
argument_list|)
expr_stmt|;
name|DocumentTrigger
name|trigger
init|=
name|fireTriggerBefore
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|parent
operator|.
name|removeChild
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|touchDefragAndFireTriggerAfter
argument_list|(
name|tx
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DOMException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"delete aborted by listener"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Return the name of this node, in the "prefix:localName" form. 	 * 	 * @return the name of this node 	 */
specifier|public
name|String
name|name
parameter_list|()
block|{
return|return
name|getDOMNode
argument_list|()
operator|.
name|getNodeName
argument_list|()
return|;
block|}
comment|/** 	 * Return the qualified name of this node, including its namespace URI, local name and prefix. 	 * 	 * @return the qname of this node 	 */
specifier|public
name|QName
name|qname
parameter_list|()
block|{
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
name|node
init|=
name|getDOMNode
argument_list|()
decl_stmt|;
name|String
name|localName
init|=
name|node
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|localName
operator|==
literal|null
condition|)
name|localName
operator|=
name|node
operator|.
name|getNodeName
argument_list|()
expr_stmt|;
return|return
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|localName
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
return|;
block|}
comment|/** 	 * Return a builder that will replace this node.  The builder returns<code>null</code>. 	 * 	 * @return a builder that will replace this node 	 * @throws UnsupportedOperationException if the node does not have a parent 	 */
specifier|public
name|ElementBuilder
argument_list|<
name|?
argument_list|>
name|replace
parameter_list|()
block|{
comment|// TODO: right now, can only replace an element; what about other nodes?
comment|// TODO: right now, can only replace with a single node, investigate multiple replace
try|try
block|{
specifier|final
name|NodeImpl
name|oldNode
init|=
operator|(
name|NodeImpl
operator|)
name|getDOMNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldNode
operator|.
name|getParentNode
argument_list|()
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot replace a "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|item
operator|.
name|getType
argument_list|()
argument_list|)
operator|+
literal|" with no parent"
argument_list|)
throw|;
if|if
condition|(
name|oldNode
operator|.
name|getParentNode
argument_list|()
operator|.
name|getNodeType
argument_list|()
operator|==
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
operator|.
name|DOCUMENT_NODE
condition|)
return|return
name|document
argument_list|()
operator|.
name|folder
argument_list|()
operator|.
name|documents
argument_list|()
operator|.
name|build
argument_list|(
name|Name
operator|.
name|overwrite
argument_list|(
name|db
argument_list|,
name|document
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
return|;
return|return
operator|new
name|ElementBuilder
argument_list|<
name|Object
argument_list|>
argument_list|(
name|namespaceBindings
argument_list|,
literal|false
argument_list|,
operator|new
name|ElementBuilder
operator|.
name|CompletedCallback
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|completed
parameter_list|(
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
index|[]
name|nodes
parameter_list|)
block|{
assert|assert
name|nodes
operator|.
name|length
operator|==
literal|1
assert|;
name|Transaction
name|tx
init|=
name|db
operator|.
name|requireTransactionWithBroker
argument_list|()
decl_stmt|;
try|try
block|{
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|oldNode
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|tx
operator|.
name|lockWrite
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|DocumentTrigger
name|trigger
init|=
name|fireTriggerBefore
argument_list|(
name|tx
argument_list|)
decl_stmt|;
operator|(
operator|(
name|NodeImpl
operator|)
name|oldNode
operator|.
name|getParentNode
argument_list|()
operator|)
operator|.
name|replaceChild
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|nodes
index|[
literal|0
index|]
argument_list|,
name|oldNode
argument_list|)
expr_stmt|;
name|touchDefragAndFireTriggerAfter
argument_list|(
name|tx
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// no point in returning the old node; we'd rather return the newly inserted one,
comment|// but it's not easily available
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|DOMException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"append aborted by listener"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
if|if
condition|(
name|getDOMNode
argument_list|()
operator|instanceof
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|NodeImpl
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"replacement of in-memory nodes is not supported"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot replace a "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|item
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** 	 * Return a builder for updating the attribute values of this element. 	 * 	 * @return an attribute builder for this element 	 * @throws UnsupportedOperationException if this node is not an element 	 */
specifier|public
name|AttributeBuilder
name|update
parameter_list|()
block|{
try|try
block|{
specifier|final
name|ElementImpl
name|elem
init|=
operator|(
name|ElementImpl
operator|)
name|getDOMNode
argument_list|()
decl_stmt|;
return|return
operator|new
name|AttributeBuilder
argument_list|(
name|elem
argument_list|,
name|namespaceBindings
argument_list|,
operator|new
name|AttributeBuilder
operator|.
name|CompletedCallback
argument_list|()
block|{
specifier|public
name|void
name|completed
parameter_list|(
name|NodeList
name|removeList
parameter_list|,
name|NodeList
name|addList
parameter_list|)
block|{
name|Transaction
name|tx
init|=
name|db
operator|.
name|requireTransactionWithBroker
argument_list|()
decl_stmt|;
try|try
block|{
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|elem
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|tx
operator|.
name|lockWrite
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|DocumentTrigger
name|trigger
init|=
name|fireTriggerBefore
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|elem
operator|.
name|removeAppendAttributes
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|removeList
argument_list|,
name|addList
argument_list|)
expr_stmt|;
name|touchDefragAndFireTriggerAfter
argument_list|(
name|tx
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DatabaseException
argument_list|(
literal|"append aborted by listener"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|tx
operator|.
name|abortIfIncomplete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
if|if
condition|(
name|getDOMNode
argument_list|()
operator|instanceof
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|ElementImpl
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"updates on in-memory nodes are not supported"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot update attributes on a "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|item
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|DocumentTrigger
name|fireTriggerBefore
parameter_list|(
name|Transaction
name|tx
parameter_list|)
throws|throws
name|TriggerException
block|{
if|if
condition|(
operator|!
operator|(
name|item
operator|instanceof
name|NodeProxy
operator|)
condition|)
return|return
literal|null
return|;
name|DocumentImpl
name|docimpl
init|=
operator|(
operator|(
name|NodeProxy
operator|)
name|item
operator|)
operator|.
name|getDocument
argument_list|()
decl_stmt|;
comment|//		try {
name|DocumentTrigger
name|trigger
init|=
name|docimpl
operator|.
name|getCollection
argument_list|()
operator|.
name|getConfiguration
argument_list|(
name|tx
operator|.
name|broker
argument_list|)
operator|.
name|getDocumentTriggerProxies
argument_list|()
operator|.
name|instantiateVisitor
argument_list|(
name|tx
operator|.
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|trigger
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|trigger
operator|.
name|beforeUpdateDocument
argument_list|(
name|tx
operator|.
name|broker
argument_list|,
name|tx
operator|.
name|tx
argument_list|,
name|docimpl
argument_list|)
expr_stmt|;
return|return
name|trigger
return|;
comment|//		} catch (CollectionConfigurationException e) {
comment|//			throw new DatabaseException(e);
comment|//		}
block|}
specifier|private
name|void
name|touchDefragAndFireTriggerAfter
parameter_list|(
name|Transaction
name|tx
parameter_list|,
name|DocumentTrigger
name|trigger
parameter_list|)
throws|throws
name|TriggerException
block|{
name|DocumentImpl
name|doc
init|=
operator|(
operator|(
name|NodeProxy
operator|)
name|item
operator|)
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setLastModified
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|tx
operator|.
name|broker
operator|.
name|storeXMLResource
argument_list|(
name|tx
operator|.
name|tx
argument_list|,
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|instanceof
name|NodeProxy
condition|)
name|Database
operator|.
name|queueDefrag
argument_list|(
operator|(
operator|(
name|NodeProxy
operator|)
name|item
operator|)
operator|.
name|getDocument
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|==
literal|null
condition|)
return|return;
name|DocumentImpl
name|docimpl
init|=
operator|(
operator|(
name|NodeProxy
operator|)
name|item
operator|)
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|trigger
operator|.
name|afterUpdateDocument
argument_list|(
name|tx
operator|.
name|broker
argument_list|,
name|tx
operator|.
name|tx
argument_list|,
name|docimpl
argument_list|)
expr_stmt|;
block|}
specifier|static
name|NodeList
name|toNodeList
parameter_list|(
specifier|final
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
index|[]
name|nodes
parameter_list|)
block|{
return|return
operator|new
name|NodeList
argument_list|()
block|{
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|nodes
operator|.
name|length
return|;
block|}
specifier|public
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
name|item
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|nodes
index|[
name|index
index|]
return|;
block|}
block|}
return|;
block|}
comment|/** 	 * A null node, used as a placeholder where an actual<code>null</code> would be inappropriate. 	 */
specifier|static
specifier|final
name|Node
name|NULL
init|=
operator|new
name|Node
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ElementBuilder
argument_list|<
name|Node
argument_list|>
name|append
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot append to a null resource"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|()
block|{
block|}
annotation|@
name|Override
specifier|public
name|XMLDocument
name|document
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"null resource does not have a document"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|name
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"null resource does not have a name"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QName
name|qname
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"null resource does not have a qname"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|ElementBuilder
argument_list|<
name|?
argument_list|>
name|replace
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot replace a null resource"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AttributeBuilder
name|update
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"cannot update a null resource"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|booleanValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|booleanValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|doubleValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|doubleValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|intValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|intValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|longValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Duration
name|durationValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|durationValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|XMLGregorianCalendar
name|dateTimeValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|dateTimeValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Date
name|instantValue
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|instantValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Node
name|node
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|node
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|extant
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|extant
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryService
name|query
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|query
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|value
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|value
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|valueWithDefault
parameter_list|(
name|String
name|defaultValue
parameter_list|)
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|value
argument_list|()
return|;
block|}
annotation|@
name|Override
name|Sequence
name|convertToSequence
parameter_list|()
block|{
return|return
name|Item
operator|.
name|NULL
operator|.
name|convertToSequence
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NULL Node"
return|;
block|}
block|}
decl_stmt|;
block|}
end_class

end_unit

