begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * ====================================================================  * Copyright (c) 2004-2010 TMate Software Ltd.  All rights reserved.  *  * This software is licensed as described in the file COPYING, which  * you should have received as part of this distribution.  The terms  * are also available at http://svnkit.com/license.html  * If newer versions of this license are posted there, you may use a  * newer version instead, at your option.  * ====================================================================  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|wc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|SVNAnnotationGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|internal
operator|.
name|util
operator|.
name|SVNDate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|internal
operator|.
name|wc
operator|.
name|SVNErrorManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|internal
operator|.
name|wc
operator|.
name|SVNFileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|internal
operator|.
name|wc
operator|.
name|admin
operator|.
name|SVNAdminArea
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|internal
operator|.
name|wc
operator|.
name|admin
operator|.
name|SVNEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|versioning
operator|.
name|svn
operator|.
name|internal
operator|.
name|wc
operator|.
name|admin
operator|.
name|SVNWCAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|ISVNDirEntryHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|ISVNLogEntryHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNDepth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNDirEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNErrorCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNErrorMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNLogEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNNodeKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNRevisionProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|SVNURL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|auth
operator|.
name|ISVNAuthenticationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|internal
operator|.
name|io
operator|.
name|dav
operator|.
name|DAVRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|internal
operator|.
name|util
operator|.
name|SVNEncodingUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|internal
operator|.
name|util
operator|.
name|SVNHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|internal
operator|.
name|util
operator|.
name|SVNPathUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|internal
operator|.
name|util
operator|.
name|SVNURLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|io
operator|.
name|SVNRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|wc
operator|.
name|ISVNAnnotateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|wc
operator|.
name|ISVNRepositoryPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|wc
operator|.
name|SVNDiffOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|wc
operator|.
name|SVNRevision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|core
operator|.
name|wc
operator|.
name|SVNRevisionRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tmatesoft
operator|.
name|svn
operator|.
name|util
operator|.
name|SVNLogType
import|;
end_import

begin_comment
comment|/**  * The<b>SVNLogClient</b> class is intended for such purposes as getting  * revisions history, browsing repository entries and annotating file contents.  *   *<p>  * Here's a list of the<b>SVNLogClient</b>'s methods   * matched against corresponing commands of the<b>SVN</b> command line   * client:  *   *<table cellpadding="3" cellspacing="1" border="0" width="40%" bgcolor="#999933">  *<tr bgcolor="#ADB8D9" align="left">  *<td><b>SVNKit</b></td>  *<td><b>Subversion</b></td>  *</tr>     *<tr bgcolor="#EAEAEA" align="left">  *<td>doLog()</td><td>'svn log'</td>  *</tr>  *<tr bgcolor="#EAEAEA" align="left">  *<td>doList()</td><td>'svn list'</td>  *</tr>  *<tr bgcolor="#EAEAEA" align="left">  *<td>doAnnotate()</td><td>'svn blame'</td>  *</tr>  *</table>  *   * @version 1.3  * @author  TMate Software Ltd.  * @since   1.2  */
end_comment

begin_class
specifier|public
class|class
name|SVNLogClient
extends|extends
name|SVNBasicClient
block|{
specifier|private
name|SVNDiffOptions
name|myDiffOptions
decl_stmt|;
comment|/**      * Constructs and initializes an<b>SVNLogClient</b> object      * with the specified run-time configuration and authentication       * drivers.      *       *<p>      * If<code>options</code> is<span class="javakeyword">null</span>,      * then this<b>SVNLogClient</b> will be using a default run-time      * configuration driver  which takes client-side settings from the       * default SVN's run-time configuration area but is not able to      * change those settings (read more on {@link ISVNOptions} and {@link SVNWCUtil}).        *       *<p>      * If<code>authManager</code> is<span class="javakeyword">null</span>,      * then this<b>SVNLogClient</b> will be using a default authentication      * and network layers driver (see {@link SVNWCUtil#createDefaultAuthenticationManager()})      * which uses server-side settings and auth storage from the       * default SVN's run-time configuration area (or system properties      * if that area is not found).      *       * @param authManager an authentication and network layers driver      * @param options     a run-time configuration options driver           */
specifier|public
name|SVNLogClient
parameter_list|(
name|ISVNAuthenticationManager
name|authManager
parameter_list|,
name|ISVNOptions
name|options
parameter_list|)
block|{
name|super
argument_list|(
name|authManager
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs and initializes an<b>SVNLogClient</b> object      * with the specified run-time configuration and authentication       * drivers.      *       *<p>      * If<code>options</code> is<span class="javakeyword">null</span>,      * then this<b>SVNLogClient</b> will be using a default run-time      * configuration driver  which takes client-side settings from the       * default SVN's run-time configuration area but is not able to      * change those settings (read more on {@link ISVNOptions} and {@link SVNWCUtil}).        *       *<p/>      * If<code>repositoryPool</code> is<span class="javakeyword">null</span>,      * then {@link org.tmatesoft.svn.core.io.SVNRepositoryFactory} will be used to create {@link SVNRepository repository access objects}.      *      * @param repositoryPool   a repository pool object      * @param options          a run-time configuration options driver      */
specifier|public
name|SVNLogClient
parameter_list|(
name|ISVNRepositoryPool
name|repositoryPool
parameter_list|,
name|ISVNOptions
name|options
parameter_list|)
block|{
name|super
argument_list|(
name|repositoryPool
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets diff options for this client to use in annotate operations.      *       * @param diffOptions diff options object      */
specifier|public
name|void
name|setDiffOptions
parameter_list|(
name|SVNDiffOptions
name|diffOptions
parameter_list|)
block|{
name|myDiffOptions
operator|=
name|diffOptions
expr_stmt|;
block|}
comment|/**      * Gets the diff options that are used in annotate operations       * by this client. Creates a new one if none was used before.      *       * @return diff options      */
specifier|public
name|SVNDiffOptions
name|getDiffOptions
parameter_list|()
block|{
if|if
condition|(
name|myDiffOptions
operator|==
literal|null
condition|)
block|{
name|myDiffOptions
operator|=
operator|new
name|SVNDiffOptions
argument_list|()
expr_stmt|;
block|}
return|return
name|myDiffOptions
return|;
block|}
comment|/**      * Obtains annotation information for each file text line from a repository      * (using a Working Copy path to get a corresponding URL) and passes it to a       * provided annotation handler.       *       *<p/>      * This method is equivalent to a call to       *<code>doAnnotate(path, pegRevision, startRevision, endRevision, false, false, handler, null)</code>.      *       * @param  path           a WC file item to be annotated      * @param  pegRevision    a revision in which<code>path</code> is first looked up      *                        in the repository      * @param  startRevision  a revision for an operation to start from      * @param  endRevision    a revision for an operation to stop at      * @param  handler        a caller's handler to process annotation information      * @throws SVNException   if<code>startRevision> endRevision</code>      * @see                   #doAnnotate(File, SVNRevision, SVNRevision, SVNRevision, boolean, boolean, ISVNAnnotateHandler, String)      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|File
name|path
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doAnnotate
argument_list|(
name|path
argument_list|,
name|pegRevision
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|handler
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Obtains annotation information for each file text line from a repository      * (using a Working Copy path to get a corresponding URL) and passes it to a       * provided annotation handler.       *       *<p/>      * This method is equivalent to a call to       *<code>doAnnotate(path, pegRevision, startRevision, endRevision, ignoreMimeType, false, handler, null)</code>.      *       * @param  path            a WC file item to be annotated      * @param  pegRevision     a revision in which<code>path</code> is first looked up      *                         in the repository      * @param  startRevision   a revision for an operation to start from      * @param  endRevision     a revision for an operation to stop at      * @param  ignoreMimeType  forces operation to run (all files to be treated as       *                         text, no matter what SVNKit has inferred from the mime-type       *                         property)       * @param  handler         a caller's handler to process annotation information      * @throws SVNException      * @see                    #doAnnotate(File, SVNRevision, SVNRevision, SVNRevision, boolean, boolean, ISVNAnnotateHandler, String)      * @since                  1.1      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|File
name|path
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|ignoreMimeType
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doAnnotate
argument_list|(
name|path
argument_list|,
name|pegRevision
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
name|ignoreMimeType
argument_list|,
literal|false
argument_list|,
name|handler
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Invokes<code>handler</code> on each line-blame item associated with revision<code>endRevision</code> of       *<code>path</code>, using<code>startRevision</code> as the default source of all blame.       *       *<p/>      *<code>pegRevision</code> indicates in which revision<code>path</code> is valid.  If<code>pegRevision</code>      * is {@link SVNRevision#UNDEFINED}, then it defaults to {@link SVNRevision#WORKING}.      *       *<p/>      * If<code>startRevision</code> is<span class="javakeyword">null</span> or {@link SVNRevision#isValid() invalid},      * then it defaults to revision 1. If<code>endRevision</code> is<span class="javakeyword">null</span> or       * {@link SVNRevision#isValid() invalid}, then in defaults to {@link SVNRevision#HEAD}.      *       *<p/>      *  Note: this routine requires repository access.      *        * @param  path                        a WC file item to be annotated                    * @param  pegRevision                 a revision in which<code>path</code> is first looked up      *                                     in the repository      * @param  startRevision               a revision for an operation to start from      * @param  endRevision                 a revision for an operation to stop at      * @param  ignoreMimeType              forces operation to run (all files to be treated as       *                                     text, no matter what SVNKit has inferred from the mime-type       *                                     property)       * @param  includeMergedRevisions      if<span class="javakeyword">true</span>, then also returns data based upon revisions which have       *                                     been merged to<code>path</code>      * @param  handler                     a caller's handler to process annotation information      * @param  inputEncoding               character set to decode input bytes with      * @throws SVNException                in the following cases:      *<ul>      *<li/>exception with {@link SVNErrorCode#CLIENT_BAD_REVISION} error code - if both       *<code>startRevision</code> and<code>endRevision</code> are either<span class="javakeyword">null</span>       *                                     or {@link SVNRevision#isValid() invalid}       *<li/>exception with {@link SVNErrorCode#UNSUPPORTED_FEATURE} error code - if either of       *<code>startRevision</code> or<code>endRevision</code> is {@link SVNRevision#WORKING}       *<li/>exception with {@link SVNErrorCode#CLIENT_IS_BINARY_FILE} error code - if any of the       *                                     revisions of<code>path</code> have a binary mime-type, unless<code>ignoreMimeType</code> is       *<span class="javakeyword">true</span>, in which case blame information will be generated regardless       *                                     of the MIME types of the revisions         *</ul>      * @since  1.2, SVN 1.5      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|File
name|path
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|ignoreMimeType
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|,
name|String
name|inputEncoding
parameter_list|)
throws|throws
name|SVNException
block|{
if|if
condition|(
name|startRevision
operator|==
literal|null
operator|||
operator|!
name|startRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|startRevision
operator|=
name|SVNRevision
operator|.
name|create
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endRevision
operator|==
literal|null
operator|||
operator|!
name|endRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|endRevision
operator|=
name|pegRevision
expr_stmt|;
block|}
if|if
condition|(
name|startRevision
operator|==
name|SVNRevision
operator|.
name|WORKING
operator|||
name|endRevision
operator|==
name|SVNRevision
operator|.
name|WORKING
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|UNSUPPORTED_FEATURE
argument_list|,
literal|"Blame of the WORKING revision is not supported"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
name|SVNRepository
name|repos
init|=
name|createRepository
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
name|pegRevision
argument_list|,
name|endRevision
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|endRev
init|=
name|getRevisionNumber
argument_list|(
name|endRevision
argument_list|,
name|repos
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|long
name|startRev
init|=
name|getRevisionNumber
argument_list|(
name|startRevision
argument_list|,
name|repos
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|endRev
operator|<
name|startRev
condition|)
block|{
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|CLIENT_BAD_REVISION
argument_list|,
literal|"Start revision must precede end revision"
argument_list|)
argument_list|,
name|SVNLogType
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
name|File
name|tmpFile
init|=
operator|new
name|File
argument_list|(
name|path
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|SVNFileUtil
operator|.
name|getAdminDirectoryName
argument_list|()
argument_list|)
decl_stmt|;
name|tmpFile
operator|=
operator|new
name|File
argument_list|(
name|tmpFile
argument_list|,
literal|"tmp/text-base"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|tmpFile
operator|=
name|SVNFileUtil
operator|.
name|createTempDirectory
argument_list|(
literal|"annotate"
argument_list|)
expr_stmt|;
block|}
name|doAnnotate
argument_list|(
name|path
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|startRev
argument_list|,
name|tmpFile
argument_list|,
name|repos
argument_list|,
name|endRev
argument_list|,
name|ignoreMimeType
argument_list|,
name|handler
argument_list|,
name|inputEncoding
argument_list|,
name|includeMergedRevisions
argument_list|)
expr_stmt|;
block|}
comment|/**      * Obtains annotation information for each file text line from a repository      * and passes it to a provided annotation handler.       *       *<p>      * This method is equivalent to a call to<code>doAnnotate(url, pegRevision, startRevision, endRevision, false, false, handler, null)</code>.      *       * @param  url            a URL of a text file that is to be annotated       * @param  pegRevision    a revision in which<code>path</code> is first looked up      *                        in the repository      * @param  startRevision  a revision for an operation to start from      * @param  endRevision    a revision for an operation to stop at      * @param  handler        a caller's handler to process annotation information      * @throws SVNException   if<code>startRevision> endRevision</code>      * @see                   #doAnnotate(SVNURL, SVNRevision, SVNRevision, SVNRevision, boolean, boolean, ISVNAnnotateHandler, String)      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doAnnotate
argument_list|(
name|url
argument_list|,
name|pegRevision
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|handler
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Obtains annotation information for each file text line from a repository      * and passes it to a provided annotation handler.       *       *<p>      * This method is equivalent to a call to<code>doAnnotate(url, pegRevision, startRevision, endRevision, false, false, handler, inputEncoding)</code>.      *       * @param  url            a URL of a text file that is to be annotated       * @param  pegRevision    a revision in which<code>path</code> is first looked up      *                        in the repository      * @param  startRevision  a revision for an operation to start from      * @param  endRevision    a revision for an operation to stop at      * @param  handler        a caller's handler to process annotation information      * @param  inputEncoding  a desired character set (encoding) of text lines      * @throws SVNException      * @see                   #doAnnotate(SVNURL, SVNRevision, SVNRevision, SVNRevision, boolean, boolean, ISVNAnnotateHandler, String)      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|,
name|String
name|inputEncoding
parameter_list|)
throws|throws
name|SVNException
block|{
name|doAnnotate
argument_list|(
name|url
argument_list|,
name|pegRevision
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|handler
argument_list|,
name|inputEncoding
argument_list|)
expr_stmt|;
block|}
comment|/**      * Obtains annotation information for each file text line from a repository and passes it to a provided annotation handler.       *       *<p>      * This method is equivalent to a call to<code>doAnnotate(url, pegRevision, startRevision, endRevision, ignoreMimeType, false, handler, inputEncoding)</code>.      *        * @param  url            a URL of a text file that is to be annotated       * @param  pegRevision    a revision in which<code>path</code> is first looked up      *                        in the repository      * @param  startRevision  a revision for an operation to start from      * @param  endRevision    a revision for an operation to stop at      * @param  ignoreMimeType forces operation to run (all files to be treated as       *                        text, no matter what SVNKit has inferred from the mime-type       *                        property)       * @param  handler        a caller's handler to process annotation information      * @param  inputEncoding  a desired character set (encoding) of text lines      * @throws SVNException      * @see                   #doAnnotate(SVNURL, SVNRevision, SVNRevision, SVNRevision, boolean, boolean, ISVNAnnotateHandler, String)      * @since                 1.1      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|ignoreMimeType
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|,
name|String
name|inputEncoding
parameter_list|)
throws|throws
name|SVNException
block|{
name|doAnnotate
argument_list|(
name|url
argument_list|,
name|pegRevision
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
name|ignoreMimeType
argument_list|,
literal|false
argument_list|,
name|handler
argument_list|,
name|inputEncoding
argument_list|)
expr_stmt|;
block|}
comment|/**      * Invokes<code>handler</code> on each line-blame item associated with revision<code>endRevision</code> of       *<code>url</code>, using<code>startRevision</code> as the default source of all blame.       *       *<p/>      *<code>pegRevision</code> indicates in which revision<code>url</code> is valid. If<code>pegRevision</code>      * is {@link SVNRevision#UNDEFINED}, then it defaults to {@link SVNRevision#HEAD}.      *       *<p/>      * If<code>startRevision</code> is<span class="javakeyword">null</span> or {@link SVNRevision#isValid() invalid},      * then it defaults to revision 1. If<code>endRevision</code> is<span class="javakeyword">null</span> or       * {@link SVNRevision#isValid() invalid}, then in defaults to {@link SVNRevision#HEAD}.      *       *<p/>      *  Note: this routine requires repository access      *        * @param  url                         a URL of a text file that is to be annotated       * @param  pegRevision                 a revision in which<code>url</code> is first looked up      *                                     in the repository      * @param  startRevision               a revision for an operation to start from      * @param  endRevision                 a revision for an operation to stop at      * @param  ignoreMimeType              forces operation to run (all files to be treated as       *                                     text, no matter what SVNKit has inferred from the mime-type       *                                     property)       * @param  includeMergedRevisions      if<span class="javakeyword">true</span>, then also returns data based upon revisions which have       *                                     been merged to<code>url</code>      * @param  handler                     a caller's handler to process annotation information      * @param  inputEncoding               character set to decode input bytes with      * @throws SVNException                in the following cases:      *<ul>      *<li/>exception with {@link SVNErrorCode#CLIENT_BAD_REVISION} error code - if both       *<code>startRevision</code> and<code>endRevision</code> are either<span class="javakeyword">null</span>       *                                     or {@link SVNRevision#isValid() invalid}       *<li/>exception with {@link SVNErrorCode#UNSUPPORTED_FEATURE} error code - if either of       *<code>startRevision</code> or<code>endRevision</code> is {@link SVNRevision#WORKING}       *<li/>exception with {@link SVNErrorCode#CLIENT_IS_BINARY_FILE} error code - if any of the       *                                     revisions of<code>url</code> have a binary mime-type, unless<code>ignoreMimeType</code> is       *<span class="javakeyword">true</span>, in which case blame information will be generated regardless       *                                     of the MIME types of the revisions         *</ul>      * @since  1.2, SVN 1.5      */
specifier|public
name|void
name|doAnnotate
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|ignoreMimeType
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|,
name|String
name|inputEncoding
parameter_list|)
throws|throws
name|SVNException
block|{
if|if
condition|(
name|startRevision
operator|==
literal|null
operator|||
operator|!
name|startRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|startRevision
operator|=
name|SVNRevision
operator|.
name|create
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endRevision
operator|==
literal|null
operator|||
operator|!
name|endRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|endRevision
operator|=
name|pegRevision
expr_stmt|;
block|}
if|if
condition|(
name|startRevision
operator|==
name|SVNRevision
operator|.
name|WORKING
operator|||
name|endRevision
operator|==
name|SVNRevision
operator|.
name|WORKING
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|UNSUPPORTED_FEATURE
argument_list|,
literal|"Blame of the WORKING revision is not supported"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
name|SVNRepository
name|repos
init|=
name|createRepository
argument_list|(
name|url
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pegRevision
argument_list|,
name|endRevision
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|endRev
init|=
name|getRevisionNumber
argument_list|(
name|endRevision
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|startRev
init|=
name|getRevisionNumber
argument_list|(
name|startRevision
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|endRev
operator|<
name|startRev
condition|)
block|{
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|CLIENT_BAD_REVISION
argument_list|,
literal|"Start revision must precede end revision"
argument_list|)
argument_list|,
name|SVNLogType
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
name|File
name|tmpFile
init|=
name|SVNFileUtil
operator|.
name|createTempDirectory
argument_list|(
literal|"annotate"
argument_list|)
decl_stmt|;
name|doAnnotate
argument_list|(
name|repos
operator|.
name|getLocation
argument_list|()
operator|.
name|toDecodedString
argument_list|()
argument_list|,
name|startRev
argument_list|,
name|tmpFile
argument_list|,
name|repos
argument_list|,
name|endRev
argument_list|,
name|ignoreMimeType
argument_list|,
name|handler
argument_list|,
name|inputEncoding
argument_list|,
name|includeMergedRevisions
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets commit log messages with other revision specific information from a repository       * (using Working Copy paths to get corresponding URLs) and passes them to a log entry handler for      * processing. Useful for observing the history of affected paths, author, date and log comments       * information per revision.      *       *<p>      * Calling this method is equivalent to       *<code>doLog(paths, startRevision, endRevision, SVNRevision.UNDEFINED, stopOnCopy, discoverChangedPaths, false, limit, null, handler)</code>.      *       * @param  paths                  an array of Working Copy paths,      *                                should not be<span class="javakeyword">null</span>      * @param  startRevision          a revision for an operation to start from (including      *                                this revision)          * @param  endRevision            a revision for an operation to stop at (including      *                                this revision)      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                                copies while traversing history, otherwise copies history      *                                will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                                of all changed paths for every revision being processed       *                                (those paths will be available by calling       *                                {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  limit                  a maximum number of log entries to be processed       * @param  handler                a caller's log entry handler      * @throws SVNException           if one of the following is true:      *<ul>      *<li>a path is not under version control      *<li>can not obtain a URL of a WC path - there's no such      *                                entry in the Working Copy      *<li><code>paths</code> contain entries that belong to      *                                different repositories      *</ul>      * @see                           #doLog(File[], SVNRevision, SVNRevision, SVNRevision, boolean, boolean, boolean, long, String[], ISVNLogEntryHandler)                                                          */
specifier|public
name|void
name|doLog
parameter_list|(
name|File
index|[]
name|paths
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|long
name|limit
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doLog
argument_list|(
name|paths
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
name|SVNRevision
operator|.
name|UNDEFINED
argument_list|,
name|stopOnCopy
argument_list|,
name|discoverChangedPaths
argument_list|,
literal|false
argument_list|,
name|limit
argument_list|,
literal|null
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Invokes<code>handler</code> on each log message from<code>startRevision</code> to<code>endRevision</code> in turn, inclusive       * (but never invokes<code>handler</code> on a given log message more than once).      *       *<p/>      *<code>handler</code> is invoked only on messages whose revisions involved a change to some path in<code>paths</code>.       *<code>pegRevision</code> indicates in which revision<code>paths</code> are valid. If<code>pegRevision</code> is      * {@link SVNRevision#isValid() invalid}, it defaults to {@link SVNRevision#WORKING}.      *       *<p/>      * If<code>limit</code> is non-zero, only invokes<code>handler</code> on the first<code>limit</code> logs.      *      *<p/>      * If<code>discoverChangedPaths</code> is set, then the changed paths<code>Map</code> argument      * will be passed to a constructor of {@link SVNLogEntry} on each invocation of<code>handler</code>.      *      *<p/>      * If<code>stopOnCopy</code> is set, copy history (if any exists) will not be traversed while harvesting       * revision logs for each target.      *       *<p/>      * If<code>includeMergedRevisions</code> is set, log information for revisions which have been merged to       *<code>paths</code> will also be returned.      *       *<p/>       * Refer to {@link org.tmatesoft.svn.core.SVNLogEntry#hasChildren()} for additional information on how       * to handle mergeinfo information during a log operation.      *       *<p/>      * If<code>revisionProperties is<span class="javakeyword">null</span>, retrieves all revision properties;       * else, retrieves only the revprops named in the array (i.e. retrieves none if the array is empty).      *       *<p/>      * If<code>startRevision</code> is {@link SVNRevision#isValid() valid} but<code>endRevision</code>       * is not, then<code>endRevision</code> defaults to<code>startRevision</code>. If both       *<code>startRevision</code> and<code>endRevision</code> are invalid, then<code>endRevision</code>       * defaults to revision<code>0</code>, and<code>startRevision</code> defaults either to       *<code>pegRevision</code> in case the latter one is valid, or to {@link SVNRevision#BASE}, if it is not.      *       *<p/>      * Important: to avoid an exception with the {@link SVNErrorCode#FS_NO_SUCH_REVISION} error code        * when invoked against an empty repository (i.e. one not containing a revision 1), callers should specify       * the range {@link SVNRevision#HEAD}:<code>0</code>.       *      *<p/>      * If the caller has provided a non-<span class="javakeyword">null</span> {@link ISVNEventHandler},      * it will be called with the {@link SVNEventAction#SKIP} event action on any unversioned paths.       *      *<p/>      * Note: this routine requires repository access.      *       * @param  paths                  an array of Working Copy paths, for which log messages are desired      * @param  startRevision          a revision for an operation to start from (including      *                                this revision)          * @param  endRevision            a revision for an operation to stop at (including      *                                this revision)      * @param  pegRevision            a revision in which<code>paths</code> are first looked up      *                                in the repository      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                                copies while traversing history, otherwise copies history      *                                will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                                of all changed paths for every revision being processed       *                                (those paths will be available by calling       *                                {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  includeMergedRevisions if<span class="javakeyword">true</span>, merged revisions will be also       *                                reported      * @param  limit                  a maximum number of log entries to be processed       * @param  revisionProperties     names of revision properties to retrieve           * @param  handler                a caller's log entry handler      * @throws SVNException           if one of the following is true:      *<ul>      *<li>can not obtain a URL of a WC path - there's no such      *                                entry in the Working Copy      *<li><code>paths</code> contain entries that belong to      *                                different repositories      *</ul>      * @since                         1.2, SVN 1.5       */
specifier|public
name|void
name|doLog
parameter_list|(
name|File
index|[]
name|paths
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|,
name|long
name|limit
parameter_list|,
name|String
index|[]
name|revisionProperties
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|Collection
name|revisionRanges
init|=
operator|new
name|ArrayList
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|revisionRanges
operator|.
name|add
argument_list|(
operator|new
name|SVNRevisionRange
argument_list|(
name|startRevision
argument_list|,
name|endRevision
argument_list|)
argument_list|)
expr_stmt|;
name|doLog
argument_list|(
name|paths
argument_list|,
name|revisionRanges
argument_list|,
name|pegRevision
argument_list|,
name|stopOnCopy
argument_list|,
name|discoverChangedPaths
argument_list|,
name|includeMergedRevisions
argument_list|,
name|limit
argument_list|,
name|revisionProperties
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Invokes<code>handler</code> on each log message from the given<code>revisionRanges</code> in turn, inclusive       * (but never invokes<code>handler</code> on a given log message more than once).      *       *<p/>      *<code>handler</code> is invoked only on messages whose revisions involved a change to some path in<code>paths</code>.       *<code>pegRevision</code> indicates in which revision<code>paths</code> are valid. If<code>pegRevision</code> is      * {@link SVNRevision#isValid() invalid}, it defaults to {@link SVNRevision#WORKING}.      *       *<p/>      * If<code>limit</code> is non-zero, only invokes<code>handler</code> on the first<code>limit</code> logs.      *      *<p/>      * If<code>discoverChangedPaths</code> is set, then the changed paths<code>Map</code> argument      * will be passed to a constructor of {@link SVNLogEntry} on each invocation of<code>handler</code>.      *      *<p/>      * If<code>stopOnCopy</code> is set, copy history (if any exists) will not be traversed while harvesting       * revision logs for each target.      *       *<p/>      * If<code>includeMergedRevisions</code> is set, log information for revisions which have been merged to       *<code>paths</code> will also be returned.      *       *<p/>       * Refer to {@link org.tmatesoft.svn.core.SVNLogEntry#hasChildren()} for additional information on how       * to handle mergeinfo information during a log operation.      *       *<p/>      * If<code>revisionProperties is<span class="javakeyword">null</span>, retrieves all revision properties;       * else, retrieves only the revprops named in the array (i.e. retrieves none if the array is empty).      *       *<p/>      * For every {@link SVNRevisionRange} in<code>revisionRanges</code>:      *<b/>      * If<code>startRevision</code> is {@link SVNRevision#isValid() valid} but<code>endRevision</code>       * is not, then<code>endRevision</code> defaults to<code>startRevision</code>. If both       *<code>startRevision</code> and<code>endRevision</code> are invalid, then<code>endRevision</code>       * defaults to revision<code>0</code>, and<code>startRevision</code> defaults either to       *<code>pegRevision</code> in case the latter one is valid, or to {@link SVNRevision#BASE}, if it is not.      *       *<p/>      * Important: to avoid an exception with the {@link SVNErrorCode#FS_NO_SUCH_REVISION} error code        * when invoked against an empty repository (i.e. one not containing a revision 1), callers should specify       * the range {@link SVNRevision#HEAD}:<code>0</code>.       *      *<p/>      * If the caller has provided a non-<span class="javakeyword">null</span> {@link ISVNEventHandler},      * it will be called with the {@link SVNEventAction#SKIP} event action on any unversioned paths.       *      *<p/>      * Note: this routine requires repository access.      *       * @param  paths                  an array of Working Copy paths, for which log messages are desired      * @param  revisionRanges         collection of {@link SVNRevisionRange} objects       * @param  pegRevision            a revision in which<code>paths</code> are first looked up      *                                in the repository      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                                copies while traversing history, otherwise copies history      *                                will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                                of all changed paths for every revision being processed       *                                (those paths will be available by calling       *                                {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  includeMergedRevisions if<span class="javakeyword">true</span>, merged revisions will be also       *                                reported      * @param  limit                  a maximum number of log entries to be processed       * @param  revisionProperties     names of revision properties to retrieve           * @param  handler                a caller's log entry handler      * @throws SVNException           if one of the following is true:      *<ul>      *<li>can not obtain a URL of a WC path - there's no such      *                                entry in the Working Copy      *<li><code>paths</code> contain entries that belong to      *                                different repositories      *</ul>      * @since                         1.3, SVN 1.6       */
specifier|public
name|void
name|doLog
parameter_list|(
name|File
index|[]
name|paths
parameter_list|,
name|Collection
name|revisionRanges
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|,
name|long
name|limit
parameter_list|,
name|String
index|[]
name|revisionProperties
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
if|if
condition|(
name|paths
operator|==
literal|null
operator|||
name|paths
operator|.
name|length
operator|==
literal|0
operator|||
name|handler
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|SVNRevision
name|sessionRevision
init|=
name|SVNRevision
operator|.
name|UNDEFINED
decl_stmt|;
name|List
name|editedRevisionRanges
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|revRangesIter
init|=
name|revisionRanges
operator|.
name|iterator
argument_list|()
init|;
name|revRangesIter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SVNRevisionRange
name|revRange
init|=
operator|(
name|SVNRevisionRange
operator|)
name|revRangesIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|revRange
operator|.
name|getStartRevision
argument_list|()
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|revRange
operator|.
name|getEndRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|revRange
operator|=
operator|new
name|SVNRevisionRange
argument_list|(
name|revRange
operator|.
name|getStartRevision
argument_list|()
argument_list|,
name|revRange
operator|.
name|getStartRevision
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|revRange
operator|.
name|getStartRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|SVNRevision
name|start
init|=
name|SVNRevision
operator|.
name|UNDEFINED
decl_stmt|;
name|SVNRevision
name|end
init|=
name|SVNRevision
operator|.
name|UNDEFINED
decl_stmt|;
if|if
condition|(
operator|!
name|pegRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|start
operator|=
name|SVNRevision
operator|.
name|BASE
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|pegRevision
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|revRange
operator|.
name|getEndRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|end
operator|=
name|SVNRevision
operator|.
name|create
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|revRange
operator|=
operator|new
name|SVNRevisionRange
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|revRange
operator|.
name|getStartRevision
argument_list|()
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|revRange
operator|.
name|getEndRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|CLIENT_BAD_REVISION
argument_list|,
literal|"Missing required revision specification"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
name|editedRevisionRanges
operator|.
name|add
argument_list|(
name|revRange
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sessionRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|SVNRevision
name|start
init|=
name|revRange
operator|.
name|getStartRevision
argument_list|()
decl_stmt|;
name|SVNRevision
name|end
init|=
name|revRange
operator|.
name|getEndRevision
argument_list|()
decl_stmt|;
if|if
condition|(
name|SVNRevision
operator|.
name|isValidRevisionNumber
argument_list|(
name|start
operator|.
name|getNumber
argument_list|()
argument_list|)
operator|&&
name|SVNRevision
operator|.
name|isValidRevisionNumber
argument_list|(
name|end
operator|.
name|getNumber
argument_list|()
argument_list|)
condition|)
block|{
name|sessionRevision
operator|=
name|start
operator|.
name|getNumber
argument_list|()
operator|>
name|end
operator|.
name|getNumber
argument_list|()
condition|?
name|start
else|:
name|end
expr_stmt|;
block|}
if|else if
condition|(
name|start
operator|.
name|getDate
argument_list|()
operator|!=
literal|null
operator|&&
name|end
operator|.
name|getDate
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sessionRevision
operator|=
name|start
operator|.
name|getDate
argument_list|()
operator|.
name|compareTo
argument_list|(
name|end
operator|.
name|getDate
argument_list|()
argument_list|)
operator|>
literal|0
condition|?
name|start
else|:
name|end
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|limit
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|limit
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|ISVNLogEntryHandler
name|wrappingHandler
init|=
operator|new
name|ISVNLogEntryHandler
argument_list|()
block|{
specifier|public
name|void
name|handleLogEntry
parameter_list|(
name|SVNLogEntry
name|logEntry
parameter_list|)
throws|throws
name|SVNException
block|{
name|checkCancelled
argument_list|()
expr_stmt|;
name|handler
operator|.
name|handleLogEntry
argument_list|(
name|logEntry
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|SVNURL
index|[]
name|urls
init|=
operator|new
name|SVNURL
index|[
name|paths
operator|.
name|length
index|]
decl_stmt|;
name|SVNWCAccess
name|wcAccess
init|=
name|createWCAccess
argument_list|()
decl_stmt|;
name|Collection
name|wcPaths
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|checkCancelled
argument_list|()
expr_stmt|;
name|File
name|path
init|=
name|paths
index|[
name|i
index|]
decl_stmt|;
name|wcPaths
operator|.
name|add
argument_list|(
name|path
operator|.
name|getAbsolutePath
argument_list|()
operator|.
name|replace
argument_list|(
name|File
operator|.
name|separatorChar
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|SVNAdminArea
name|area
init|=
name|wcAccess
operator|.
name|probeOpen
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SVNEntry
name|entry
init|=
name|wcAccess
operator|.
name|getVersionedEntry
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getURL
argument_list|()
operator|==
literal|null
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|ENTRY_MISSING_URL
argument_list|,
literal|"Entry ''{0}'' has no URL"
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
name|urls
index|[
name|i
index|]
operator|=
name|entry
operator|.
name|getSVNURL
argument_list|()
expr_stmt|;
if|if
condition|(
name|area
operator|!=
literal|null
condition|)
block|{
name|wcAccess
operator|.
name|closeAdminArea
argument_list|(
name|area
operator|.
name|getRoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|urls
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|String
index|[]
name|wcPathsArray
init|=
operator|(
name|String
index|[]
operator|)
name|wcPaths
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|wcPaths
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|String
name|rootWCPath
init|=
name|SVNPathUtil
operator|.
name|condencePaths
argument_list|(
name|wcPathsArray
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Collection
name|targets
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
name|SVNURL
name|baseURL
init|=
name|SVNURLUtil
operator|.
name|condenceURLs
argument_list|(
name|urls
argument_list|,
name|targets
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseURL
operator|==
literal|null
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|ILLEGAL_TARGET
argument_list|,
literal|"target log paths belong to different repositories"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|targets
operator|.
name|add
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pegRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|pegRevision
operator|=
name|SVNRevision
operator|.
name|WORKING
expr_stmt|;
block|}
name|SVNRepository
name|repos
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rootWCPath
operator|!=
literal|null
operator|&&
name|needsWC
argument_list|(
name|pegRevision
argument_list|)
condition|)
block|{
comment|// open and use wc to create repository.
name|File
name|root
init|=
operator|new
name|File
argument_list|(
name|rootWCPath
argument_list|)
decl_stmt|;
name|SVNAdminArea
name|area
init|=
name|wcAccess
operator|.
name|probeOpen
argument_list|(
name|root
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|repos
operator|=
name|createRepository
argument_list|(
literal|null
argument_list|,
name|root
argument_list|,
name|area
argument_list|,
name|pegRevision
argument_list|,
name|sessionRevision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|area
operator|!=
literal|null
condition|)
block|{
name|wcAccess
operator|.
name|closeAdminArea
argument_list|(
name|area
operator|.
name|getRoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|repos
operator|=
name|createRepository
argument_list|(
name|baseURL
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pegRevision
argument_list|,
name|sessionRevision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|targetPaths
init|=
operator|(
name|String
index|[]
operator|)
name|targets
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|targets
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|targetPaths
index|[
name|i
index|]
operator|=
name|SVNEncodingUtil
operator|.
name|uriDecode
argument_list|(
name|targetPaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|revRangesIter
init|=
name|editedRevisionRanges
operator|.
name|iterator
argument_list|()
init|;
name|revRangesIter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|checkCancelled
argument_list|()
expr_stmt|;
name|SVNRevisionRange
name|revRange
init|=
operator|(
name|SVNRevisionRange
operator|)
name|revRangesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|SVNRevision
name|startRevision
init|=
name|revRange
operator|.
name|getStartRevision
argument_list|()
decl_stmt|;
name|SVNRevision
name|endRevision
init|=
name|revRange
operator|.
name|getEndRevision
argument_list|()
decl_stmt|;
if|if
condition|(
name|startRevision
operator|.
name|isLocal
argument_list|()
operator|||
name|endRevision
operator|.
name|isLocal
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|checkCancelled
argument_list|()
expr_stmt|;
name|long
name|startRev
init|=
name|getRevisionNumber
argument_list|(
name|startRevision
argument_list|,
name|repos
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|long
name|endRev
init|=
name|getRevisionNumber
argument_list|(
name|endRevision
argument_list|,
name|repos
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|repos
operator|.
name|log
argument_list|(
name|targetPaths
argument_list|,
name|startRev
argument_list|,
name|endRev
argument_list|,
name|discoverChangedPaths
argument_list|,
name|stopOnCopy
argument_list|,
name|limit
argument_list|,
name|includeMergedRevisions
argument_list|,
name|revisionProperties
argument_list|,
name|wrappingHandler
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|long
name|startRev
init|=
name|getRevisionNumber
argument_list|(
name|startRevision
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|endRev
init|=
name|getRevisionNumber
argument_list|(
name|endRevision
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|repos
operator|.
name|log
argument_list|(
name|targetPaths
argument_list|,
name|startRev
argument_list|,
name|endRev
argument_list|,
name|discoverChangedPaths
argument_list|,
name|stopOnCopy
argument_list|,
name|limit
argument_list|,
name|includeMergedRevisions
argument_list|,
name|revisionProperties
argument_list|,
name|wrappingHandler
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Gets commit log messages with other revision specific information from a repository (using Working Copy       * paths to get corresponding URLs) and passes them to a log entry handler for processing. Useful for       * observing the history of affected paths, author, date and log comments information per revision.      *       *<p>      * Calling this method is equivalent to       *<code>doLog(paths, startRevision, endRevision, pegRevision, stopOnCopy, discoverChangedPaths, false, limit, null, handler)</code>.      *       * @param  paths                 an array of Working Copy paths,      *                               should not be<span class="javakeyword">null</span>      * @param  pegRevision           a revision in which<code>path</code> is first looked up      *                               in the repository      * @param  startRevision         a revision for an operation to start from (including      *                               this revision)          * @param  endRevision           a revision for an operation to stop at (including      *                               this revision)      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                               copies while traversing history, otherwise copies history      *                               will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                               of all changed paths for every revision being processed       *                               (those paths will be available by calling       *                               {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  limit                 a maximum number of log entries to be processed       * @param  handler               a caller's log entry handler      * @throws SVNException          if one of the following is true:      *<ul>      *<li>a path is not under version control      *<li>can not obtain a URL of a WC path - there's no such      *                               entry in the Working Copy      *<li><code>paths</code> contain entries that belong to      *                               different repositories      *</ul>      * @see                          #doLog(File[], SVNRevision, SVNRevision, SVNRevision, boolean, boolean, boolean, long, String[], ISVNLogEntryHandler)      */
specifier|public
name|void
name|doLog
parameter_list|(
name|File
index|[]
name|paths
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|long
name|limit
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doLog
argument_list|(
name|paths
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
name|pegRevision
argument_list|,
name|stopOnCopy
argument_list|,
name|discoverChangedPaths
argument_list|,
literal|false
argument_list|,
name|limit
argument_list|,
literal|null
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets commit log messages with other revision specific information from a repository and passes them to       * a log entry handler for processing. Useful for observing the history of affected paths, author, date and       * log comments information per revision.      *       *<p>      * Calling this method is equivalent to       *<code> doLog(url, paths, pegRevision, startRevision, endRevision, stopOnCopy, discoverChangedPaths, false, limit, null, handler)</code>.      *        * @param  url                   a target URL                  * @param  paths                 an array of paths relative to the target       *<code>url</code>      * @param  pegRevision           a revision in which<code>url</code> is first looked up      * @param  startRevision         a revision for an operation to start from (including      *                               this revision)          * @param  endRevision           a revision for an operation to stop at (including      *                               this revision)      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                               copies while traversing history, otherwise copies history      *                               will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                               of all changed paths for every revision being processed       *                               (those paths will be available by calling       *                               {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  limit                 a maximum number of log entries to be processed       * @param  handler               a caller's log entry handler      * @throws SVNException      * @see                          #doLog(SVNURL, String[], SVNRevision, SVNRevision, SVNRevision, boolean, boolean, boolean, long, String[], ISVNLogEntryHandler)      * @since                        1.1, new in Subversion 1.4      */
specifier|public
name|void
name|doLog
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|String
index|[]
name|paths
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|long
name|limit
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doLog
argument_list|(
name|url
argument_list|,
name|paths
argument_list|,
name|pegRevision
argument_list|,
name|startRevision
argument_list|,
name|endRevision
argument_list|,
name|stopOnCopy
argument_list|,
name|discoverChangedPaths
argument_list|,
literal|false
argument_list|,
name|limit
argument_list|,
literal|null
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Invokes<code>handler</code> on each log message from<code>startRevision</code> to<code>endRevision</code> in turn, inclusive       * (but never invokes<code>handler</code> on a given log message more than once).      *       *<p/>      *<code>handler</code> is invoked only on messages whose revisions involved a change to some path in<code>paths</code>.       *<code>pegRevision</code> indicates in which revision<code>paths</code> are valid. If<code>pegRevision</code> is      * {@link SVNRevision#isValid() invalid}, it defaults to {@link SVNRevision#HEAD}.      *       *<p/>      * If<code>limit</code> is non-zero, only invokes<code>handler</code> on the first<code>limit</code> logs.      *      *<p/>      * If<code>discoverChangedPaths</code> is set, then the changed paths<code>Map</code> argument      * will be passed to a constructor of {@link SVNLogEntry} on each invocation of<code>handler</code>.      *      *<p/>      * If<code>stopOnCopy</code> is set, copy history (if any exists) will not be traversed while harvesting       * revision logs for each target.      *       *<p/>      * If<code>includeMergedRevisions</code> is set, log information for revisions which have been merged to       *<code>paths</code> will also be returned.      *       *<p/>      * If<code>revisionProperties is<span class="javakeyword">null</span>, retrieves all revision properties;       * else, retrieves only the revision properties named in the array (i.e. retrieves none if the array is empty).      *       *<p/>      * Important: to avoid an exception with the {@link SVNErrorCode#FS_NO_SUCH_REVISION} error code        * when invoked against an empty repository (i.e. one not containing a revision 1), callers should specify       * the range {@link SVNRevision#HEAD}:<code>0</code>.       *      *<p/>      * Note: this routine requires repository access.      *       * @param  url                     repository URL                  * @param  paths                   an array of paths relative to<code>url</code>      * @param  pegRevision             a revision in which<code>paths</code> are first looked up      *                                 in the repository      * @param  startRevision           a revision for an operation to start from (including      *                                 this revision)          * @param  endRevision             a revision for an operation to stop at (including      *                                 this revision)      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                                 copies while traversing history, otherwise copies history      *                                 will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                                 of all changed paths for every revision being processed       *                                 (those paths will be available by calling       *                                 {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  includeMergedRevisions  if<span class="javakeyword">true</span>, merged revisions will be also       *                                 reported      * @param  limit                   a maximum number of log entries to be processed      * @param  revisionProperties      names of revision properties to retrieve           * @param  handler                 a caller's log entry handler      * @throws SVNException       * @since                          1.2, SVN 1.5       */
specifier|public
name|void
name|doLog
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|String
index|[]
name|paths
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|startRevision
parameter_list|,
name|SVNRevision
name|endRevision
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|,
name|long
name|limit
parameter_list|,
name|String
index|[]
name|revisionProperties
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|Collection
name|revisionRanges
init|=
operator|new
name|ArrayList
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|revisionRanges
operator|.
name|add
argument_list|(
operator|new
name|SVNRevisionRange
argument_list|(
name|startRevision
argument_list|,
name|endRevision
argument_list|)
argument_list|)
expr_stmt|;
name|doLog
argument_list|(
name|url
argument_list|,
name|paths
argument_list|,
name|pegRevision
argument_list|,
name|revisionRanges
argument_list|,
name|stopOnCopy
argument_list|,
name|discoverChangedPaths
argument_list|,
name|includeMergedRevisions
argument_list|,
name|limit
argument_list|,
name|revisionProperties
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Invokes<code>handler</code> on each log message from the given<code></code> in turn, inclusive       * (but never invokes<code>handler</code> on a given log message more than once).      *       *<p/>      *<code>handler</code> is invoked only on messages whose revisions involved a change to some path in<code>paths</code>.       *<code>pegRevision</code> indicates in which revision<code>paths</code> are valid. If<code>pegRevision</code> is      * {@link SVNRevision#isValid() invalid}, it defaults to {@link SVNRevision#HEAD}.      *       *<p/>      * If<code>limit</code> is non-zero, only invokes<code>handler</code> on the first<code>limit</code> logs.      *      *<p/>      * If<code>discoverChangedPaths</code> is set, then the changed paths<code>Map</code> argument      * will be passed to a constructor of {@link SVNLogEntry} on each invocation of<code>handler</code>.      *      *<p/>      * If<code>stopOnCopy</code> is set, copy history (if any exists) will not be traversed while harvesting       * revision logs for each target.      *       *<p/>      * If<code>includeMergedRevisions</code> is set, log information for revisions which have been merged to       *<code>paths</code> will also be returned.      *       *<p/>      * If<code>revisionProperties is<span class="javakeyword">null</span>, retrieves all revision properties;       * else, retrieves only the revision properties named in the array (i.e. retrieves none if the array is empty).      *       *<p/>      * Important: to avoid an exception with the {@link SVNErrorCode#FS_NO_SUCH_REVISION} error code        * when invoked against an empty repository (i.e. one not containing a revision 1), callers should specify       * the range {@link SVNRevision#HEAD}:<code>0</code>.       *      *<p/>      * Note: this routine requires repository access.      *       * @param  url                     repository URL                  * @param  paths                   an array of paths relative to<code>url</code>      * @param  pegRevision             a revision in which<code>paths</code> are first looked up      *                                 in the repository      * @param  revisionRanges          collection of {@link SVNRevisionRange} objects      * @param  stopOnCopy<span class="javakeyword">true</span> not to cross      *                                 copies while traversing history, otherwise copies history      *                                 will be also included into processing      * @param  discoverChangedPaths<span class="javakeyword">true</span> to report      *                                 of all changed paths for every revision being processed       *                                 (those paths will be available by calling       *                                 {@link org.tmatesoft.svn.core.SVNLogEntry#getChangedPaths()})      * @param  includeMergedRevisions  if<span class="javakeyword">true</span>, merged revisions will be also       *                                 reported      * @param  limit                   a maximum number of log entries to be processed      * @param  revisionProperties      names of revision properties to retrieve           * @param  handler                 a caller's log entry handler      * @throws SVNException       * @since                          1.3, SVN 1.6       */
specifier|public
name|void
name|doLog
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|String
index|[]
name|paths
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|Collection
name|revisionRanges
parameter_list|,
name|boolean
name|stopOnCopy
parameter_list|,
name|boolean
name|discoverChangedPaths
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|,
name|long
name|limit
parameter_list|,
name|String
index|[]
name|revisionProperties
parameter_list|,
specifier|final
name|ISVNLogEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|SVNRevision
name|sessionRevision
init|=
name|SVNRevision
operator|.
name|UNDEFINED
decl_stmt|;
name|List
name|editedRevisionRanges
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|revRangesIter
init|=
name|revisionRanges
operator|.
name|iterator
argument_list|()
init|;
name|revRangesIter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SVNRevisionRange
name|revRange
init|=
operator|(
name|SVNRevisionRange
operator|)
name|revRangesIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|revRange
operator|.
name|getStartRevision
argument_list|()
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|revRange
operator|.
name|getEndRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|revRange
operator|=
operator|new
name|SVNRevisionRange
argument_list|(
name|revRange
operator|.
name|getStartRevision
argument_list|()
argument_list|,
name|revRange
operator|.
name|getStartRevision
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|revRange
operator|.
name|getStartRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|SVNRevision
name|start
init|=
name|SVNRevision
operator|.
name|UNDEFINED
decl_stmt|;
name|SVNRevision
name|end
init|=
name|SVNRevision
operator|.
name|UNDEFINED
decl_stmt|;
if|if
condition|(
operator|!
name|pegRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|start
operator|=
name|SVNRevision
operator|.
name|HEAD
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|pegRevision
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|revRange
operator|.
name|getEndRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|end
operator|=
name|SVNRevision
operator|.
name|create
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|revRange
operator|=
operator|new
name|SVNRevisionRange
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|revRange
operator|.
name|getStartRevision
argument_list|()
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|revRange
operator|.
name|getEndRevision
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|CLIENT_BAD_REVISION
argument_list|,
literal|"Missing required revision specification"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needsWC
argument_list|(
name|revRange
operator|.
name|getStartRevision
argument_list|()
argument_list|)
operator|||
name|needsWC
argument_list|(
name|revRange
operator|.
name|getEndRevision
argument_list|()
argument_list|)
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|CLIENT_BAD_REVISION
argument_list|,
literal|"Revision type requires a working copy path, not a URL"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
name|editedRevisionRanges
operator|.
name|add
argument_list|(
name|revRange
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sessionRevision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|SVNRevision
name|start
init|=
name|revRange
operator|.
name|getStartRevision
argument_list|()
decl_stmt|;
name|SVNRevision
name|end
init|=
name|revRange
operator|.
name|getEndRevision
argument_list|()
decl_stmt|;
if|if
condition|(
name|SVNRevision
operator|.
name|isValidRevisionNumber
argument_list|(
name|start
operator|.
name|getNumber
argument_list|()
argument_list|)
operator|&&
name|SVNRevision
operator|.
name|isValidRevisionNumber
argument_list|(
name|end
operator|.
name|getNumber
argument_list|()
argument_list|)
condition|)
block|{
name|sessionRevision
operator|=
name|start
operator|.
name|getNumber
argument_list|()
operator|>
name|end
operator|.
name|getNumber
argument_list|()
condition|?
name|start
else|:
name|end
expr_stmt|;
block|}
if|else if
condition|(
name|start
operator|.
name|getDate
argument_list|()
operator|!=
literal|null
operator|&&
name|end
operator|.
name|getDate
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sessionRevision
operator|=
name|start
operator|.
name|getDate
argument_list|()
operator|.
name|compareTo
argument_list|(
name|end
operator|.
name|getDate
argument_list|()
argument_list|)
operator|>
literal|0
condition|?
name|start
else|:
name|end
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|needsWC
argument_list|(
name|pegRevision
argument_list|)
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|CLIENT_BAD_REVISION
argument_list|,
literal|"Revision type requires a working copy path, not a URL"
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|limit
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|paths
operator|=
name|paths
operator|==
literal|null
operator|||
name|paths
operator|.
name|length
operator|==
literal|0
condition|?
operator|new
name|String
index|[]
block|{
literal|""
block|}
else|:
name|paths
expr_stmt|;
name|ISVNLogEntryHandler
name|wrappingHandler
init|=
operator|new
name|ISVNLogEntryHandler
argument_list|()
block|{
specifier|public
name|void
name|handleLogEntry
parameter_list|(
name|SVNLogEntry
name|logEntry
parameter_list|)
throws|throws
name|SVNException
block|{
name|checkCancelled
argument_list|()
expr_stmt|;
name|handler
operator|.
name|handleLogEntry
argument_list|(
name|logEntry
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|SVNRepository
name|repos
init|=
name|sessionRevision
operator|.
name|isValid
argument_list|()
condition|?
name|createRepository
argument_list|(
name|url
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pegRevision
argument_list|,
name|sessionRevision
argument_list|,
literal|null
argument_list|)
else|:
name|createRepository
argument_list|(
name|url
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|revRangesIter
init|=
name|editedRevisionRanges
operator|.
name|iterator
argument_list|()
init|;
name|revRangesIter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|checkCancelled
argument_list|()
expr_stmt|;
name|SVNRevisionRange
name|revRange
init|=
operator|(
name|SVNRevisionRange
operator|)
name|revRangesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|startRev
init|=
name|getRevisionNumber
argument_list|(
name|revRange
operator|.
name|getStartRevision
argument_list|()
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|endRev
init|=
name|getRevisionNumber
argument_list|(
name|revRange
operator|.
name|getEndRevision
argument_list|()
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|repos
operator|.
name|log
argument_list|(
name|paths
argument_list|,
name|startRev
argument_list|,
name|endRev
argument_list|,
name|discoverChangedPaths
argument_list|,
name|stopOnCopy
argument_list|,
name|limit
argument_list|,
name|includeMergedRevisions
argument_list|,
name|revisionProperties
argument_list|,
name|wrappingHandler
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Browses directory entries from a repository (using Working       * Copy paths to get corresponding URLs) and uses the provided dir       * entry handler to process them.      *       *<p>      * On every entry that this method stops it gets some useful entry       * information which is packed into an {@link org.tmatesoft.svn.core.SVNDirEntry}      * object and passed to the<code>handler</code>'s       * {@link org.tmatesoft.svn.core.ISVNDirEntryHandler#handleDirEntry(SVNDirEntry) handleDirEntry()} method.      *        * @param  path           a WC item to get its repository location                  * @param  pegRevision    a revision in which the item's URL is first looked up      * @param  revision       a target revision      * @param  fetchLocks<span class="javakeyword">true</span> to fetch locks       *                        information from a repository      * @param  recursive<span class="javakeyword">true</span> to      *                        descend recursively (relevant for directories)          * @param  handler        a caller's directory entry handler (to process      *                        info on an entry)      * @throws SVNException       *       * @deprecated            use {@link #doList(File, SVNRevision, SVNRevision, boolean, SVNDepth, int, ISVNDirEntryHandler)}       *                        instead        */
specifier|public
name|void
name|doList
parameter_list|(
name|File
name|path
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|revision
parameter_list|,
name|boolean
name|fetchLocks
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doList
argument_list|(
name|path
argument_list|,
name|pegRevision
argument_list|,
name|revision
argument_list|,
name|fetchLocks
argument_list|,
name|recursive
condition|?
name|SVNDepth
operator|.
name|INFINITY
else|:
name|SVNDepth
operator|.
name|IMMEDIATES
argument_list|,
name|SVNDirEntry
operator|.
name|DIRENT_ALL
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reports the directory entry, and possibly children, for<code>path</code> at<code>revision</code>.       * The actual node revision selected is determined by the path as it exists in<code>pegRevision</code>.       * If<code>pegRevision</code> is {@link SVNRevision#isValid() invalid}, then it defaults to       * {@link SVNRevision#WORKING}.      *       *<p/>      * Reports directory entries by invoking<code>handler</code>,       * {@link SVNDirEntry#setRelativePath(String) setting} a relative to<code>path</code> path to the       * {@link SVNDirEntry} object. The directory entry for<code>path</code> is reported using an empty path.       * If<code>path</code> is a directory, also reports its children.      *       *<p/>      * If<code>depth</code> is {@link SVNDepth#EMPTY}, lists just<code>path</code> itself.      * If<code>depth</code> is {@link SVNDepth#FILES}, lists<code>path</code> and its file      * entries. If {@link SVNDepth#IMMEDIATES}, lists its immediate file and directory entries.       * If {@link SVNDepth#INFINITY}, lists file entries and recurses (with {@link SVNDepth#INFINITY}) on       * directory entries.      *       *<p/>      *<code>entryFields</code> controls which fields in the {@link SVNDirEntry} are filled in.       * To have them totally filled in use {@link SVNDirEntry#DIRENT_ALL}, otherwise simply bitwise OR       * together the combination of fields you care about.      *      *<p/>      * Note: this routine requires repository access.      *       * @param  path           a WC item to get its repository location                  * @param  pegRevision    a revision in which the item's URL is first looked up      * @param  revision       a target revision      * @param  fetchLocks<span class="javakeyword">true</span>, includes locks when       *                        reporting directory entries      * @param  depth          tree depth to process       * @param  entryFields    entry fields to fill      * @param  handler        a caller's directory entry handler (to process info on an entry)      * @throws SVNException   in the following cases:      *<ul>      *<li/>exception with {@link SVNErrorCode#FS_NOT_FOUND} error code -       *                        if<code>path</code> is non-existent in the repository       *<ul/>      * @since                 1.2, SVN 1.5      */
specifier|public
name|void
name|doList
parameter_list|(
name|File
name|path
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|revision
parameter_list|,
name|boolean
name|fetchLocks
parameter_list|,
name|SVNDepth
name|depth
parameter_list|,
name|int
name|entryFields
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
if|if
condition|(
name|revision
operator|==
literal|null
operator|||
operator|!
name|revision
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|revision
operator|=
name|SVNRevision
operator|.
name|BASE
expr_stmt|;
block|}
name|SVNRepository
name|repos
init|=
name|createRepository
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
name|pegRevision
argument_list|,
name|revision
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|rev
init|=
name|getRevisionNumber
argument_list|(
name|revision
argument_list|,
name|repos
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|doList
argument_list|(
name|repos
argument_list|,
name|rev
argument_list|,
name|handler
argument_list|,
name|fetchLocks
argument_list|,
name|depth
argument_list|,
name|entryFields
argument_list|)
expr_stmt|;
block|}
comment|/**      * Browses directory entries from a repository (using Working       * Copy paths to get corresponding URLs) and uses the provided dir       * entry handler to process them.      *       *<p>      * On every entry that this method stops it gets some useful entry       * information which is packed into an {@link org.tmatesoft.svn.core.SVNDirEntry}      * object and passed to the<code>handler</code>'s       * {@link org.tmatesoft.svn.core.ISVNDirEntryHandler#handleDirEntry(SVNDirEntry) handleDirEntry()} method.      *        * @param  path           a WC item to get its repository location                  * @param  pegRevision    a revision in which the item's URL is first looked up      * @param  revision       a target revision      * @param  recursive<span class="javakeyword">true</span> to      *                        descend recursively (relevant for directories)          * @param  handler        a caller's directory entry handler (to process      *                        info on an entry)      * @throws SVNException      * @deprecated            use {@link #doList(File, SVNRevision, SVNRevision, boolean, SVNDepth, int, ISVNDirEntryHandler)}      *                        instead       */
specifier|public
name|void
name|doList
parameter_list|(
name|File
name|path
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|revision
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doList
argument_list|(
name|path
argument_list|,
name|pegRevision
argument_list|,
name|revision
argument_list|,
literal|false
argument_list|,
name|recursive
condition|?
name|SVNDepth
operator|.
name|INFINITY
else|:
name|SVNDepth
operator|.
name|IMMEDIATES
argument_list|,
name|SVNDirEntry
operator|.
name|DIRENT_ALL
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Browses directory entries from a repository and uses the provided       * dir entry handler to process them. This method is       * especially useful when having no Working Copy.       *       *<p>      * On every entry that this method stops it gets some useful entry       * information which is packed into an {@link org.tmatesoft.svn.core.SVNDirEntry}      * object and passed to the<code>handler</code>'s       * {@link org.tmatesoft.svn.core.ISVNDirEntryHandler#handleDirEntry(SVNDirEntry) handleDirEntry()} method.      *       * @param  url            a repository location to be "listed"      * @param  pegRevision    a revision in which the item's URL is first looked up      * @param  revision       a target revision      * @param  fetchLocks<span class="javakeyword">true</span> to       *                        fetch locks information from repository      * @param  recursive<span class="javakeyword">true</span> to      *                        descend recursively (relevant for directories)          * @param  handler        a caller's directory entry handler (to process      *                        info on an entry)      * @throws SVNException      * @see                   #doList(File, SVNRevision, SVNRevision, boolean, ISVNDirEntryHandler)         */
specifier|public
name|void
name|doList
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|revision
parameter_list|,
name|boolean
name|fetchLocks
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doList
argument_list|(
name|url
argument_list|,
name|pegRevision
argument_list|,
name|revision
argument_list|,
name|fetchLocks
argument_list|,
name|recursive
condition|?
name|SVNDepth
operator|.
name|INFINITY
else|:
name|SVNDepth
operator|.
name|IMMEDIATES
argument_list|,
name|SVNDirEntry
operator|.
name|DIRENT_ALL
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reports the directory entry, and possibly children, for<code>url</code> at<code>revision</code>.       * The actual node revision selected is determined by the path as it exists in<code>pegRevision</code>.       * If<code>pegRevision</code> is {@link SVNRevision#isValid() invalid}, then it defaults to       * {@link SVNRevision#HEAD}.      *       *<p/>      * Reports directory entries by invoking<code>handler</code>,       * {@link SVNDirEntry#setRelativePath(String) setting} a relative to<code>url</code> path to the       * {@link SVNDirEntry} object. The directory entry for<code>url</code> is reported using an empty path.       * If<code>url</code> is a directory, also reports its children.      *       *<p/>      * If<code>depth</code> is {@link SVNDepth#EMPTY}, lists just<code>url</code> itself.      * If<code>depth</code> is {@link SVNDepth#FILES}, lists<code>url</code> and its file      * entries. If {@link SVNDepth#IMMEDIATES}, lists its immediate file and directory entries.       * If {@link SVNDepth#INFINITY}, lists file entries and recurses (with {@link SVNDepth#INFINITY}) on       * directory entries.      *       *<p/>      *<code>entryFields</code> controls which fields in the {@link SVNDirEntry} are filled in.       * To have them totally filled in use {@link SVNDirEntry#DIRENT_ALL}, otherwise simply bitwise OR       * together the combination of fields you care about.      *      *<p/>      * Note: this routine requires repository access.      *       * @param  url            a repository url to be "listed"      * @param  pegRevision    a revision in which the item's URL is first looked up      * @param  revision       a target revision      * @param  fetchLocks<span class="javakeyword">true</span>, includes locks when       *                        reporting directory entries      * @param  depth          tree depth to process       * @param  entryFields    entry fields to fill      * @param  handler        a caller's directory entry handler (to process info on an entry)      * @throws SVNException   in the following cases:      *<ul>      *<li/>exception with {@link SVNErrorCode#FS_NOT_FOUND} error code -       *                        if<code>url</code> is non-existent in the repository       *<ul/>      * @since                 1.2, SVN 1.5      */
specifier|public
name|void
name|doList
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|revision
parameter_list|,
name|boolean
name|fetchLocks
parameter_list|,
name|SVNDepth
name|depth
parameter_list|,
name|int
name|entryFields
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|long
index|[]
name|pegRev
init|=
operator|new
name|long
index|[]
block|{
operator|-
literal|1
block|}
decl_stmt|;
name|SVNRepository
name|repos
init|=
name|createRepository
argument_list|(
name|url
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pegRevision
argument_list|,
name|revision
argument_list|,
name|pegRev
argument_list|)
decl_stmt|;
if|if
condition|(
name|pegRev
index|[
literal|0
index|]
operator|<
literal|0
condition|)
block|{
name|pegRev
index|[
literal|0
index|]
operator|=
name|getRevisionNumber
argument_list|(
name|revision
argument_list|,
name|repos
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|doList
argument_list|(
name|repos
argument_list|,
name|pegRev
index|[
literal|0
index|]
argument_list|,
name|handler
argument_list|,
name|fetchLocks
argument_list|,
name|depth
argument_list|,
name|entryFields
argument_list|)
expr_stmt|;
block|}
comment|/**      * Browses directory entries from a repository and uses the provided       * dir entry handler to process them. This method is       * especially useful when having no Working Copy.       *       *<p>      * On every entry that this method stops it gets some useful entry       * information which is packed into an {@link org.tmatesoft.svn.core.SVNDirEntry}      * object and passed to the<code>handler</code>'s       * {@link org.tmatesoft.svn.core.ISVNDirEntryHandler#handleDirEntry(SVNDirEntry) handleDirEntry()} method.      *       * @param  url            a repository location to be "listed"      * @param  pegRevision    a revision in which the item's URL is first looked up      * @param  revision       a target revision      * @param  recursive<span class="javakeyword">true</span> to      *                        descend recursively (relevant for directories)          * @param  handler        a caller's directory entry handler (to process      *                        info on an entry)      * @throws SVNException      * @deprecated            use {@link #doList(SVNURL, SVNRevision, SVNRevision, boolean, SVNDepth, int, ISVNDirEntryHandler)}       *                        instead      */
specifier|public
name|void
name|doList
parameter_list|(
name|SVNURL
name|url
parameter_list|,
name|SVNRevision
name|pegRevision
parameter_list|,
name|SVNRevision
name|revision
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
name|doList
argument_list|(
name|url
argument_list|,
name|pegRevision
argument_list|,
name|revision
argument_list|,
literal|false
argument_list|,
name|recursive
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|needsWC
parameter_list|(
name|SVNRevision
name|revision
parameter_list|)
block|{
return|return
name|revision
operator|==
name|SVNRevision
operator|.
name|BASE
operator|||
name|revision
operator|==
name|SVNRevision
operator|.
name|COMMITTED
operator|||
name|revision
operator|==
name|SVNRevision
operator|.
name|WORKING
operator|||
name|revision
operator|==
name|SVNRevision
operator|.
name|PREVIOUS
return|;
block|}
specifier|private
name|void
name|doAnnotate
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|startRev
parameter_list|,
name|File
name|tmpFile
parameter_list|,
name|SVNRepository
name|repos
parameter_list|,
name|long
name|endRev
parameter_list|,
name|boolean
name|ignoreMimeType
parameter_list|,
name|ISVNAnnotateHandler
name|handler
parameter_list|,
name|String
name|inputEncoding
parameter_list|,
name|boolean
name|includeMergedRevisions
parameter_list|)
throws|throws
name|SVNException
block|{
name|SVNAnnotationGenerator
name|generator
init|=
operator|new
name|SVNAnnotationGenerator
argument_list|(
name|path
argument_list|,
name|tmpFile
argument_list|,
name|startRev
argument_list|,
name|ignoreMimeType
argument_list|,
name|includeMergedRevisions
argument_list|,
name|getDiffOptions
argument_list|()
argument_list|,
name|inputEncoding
argument_list|,
name|handler
argument_list|,
name|this
argument_list|)
decl_stmt|;
comment|// always spool HTTP response for non-standard annotation handlers.
name|boolean
name|useSpool
init|=
name|handler
operator|!=
literal|null
operator|&&
operator|!
name|handler
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"org.tmatesoft.svn."
argument_list|)
decl_stmt|;
name|boolean
name|oldSpool
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|useSpool
operator|&&
name|repos
operator|instanceof
name|DAVRepository
condition|)
block|{
name|oldSpool
operator|=
operator|(
operator|(
name|DAVRepository
operator|)
name|repos
operator|)
operator|.
name|isSpoolResponse
argument_list|()
expr_stmt|;
operator|(
operator|(
name|DAVRepository
operator|)
name|repos
operator|)
operator|.
name|setSpoolResponse
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|repos
operator|.
name|getFileRevisions
argument_list|(
literal|""
argument_list|,
name|startRev
operator|>
literal|0
condition|?
name|startRev
operator|-
literal|1
else|:
name|startRev
argument_list|,
name|endRev
argument_list|,
name|includeMergedRevisions
argument_list|,
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generator
operator|.
name|isLastRevisionReported
argument_list|()
condition|)
block|{
name|generator
operator|.
name|reportAnnotations
argument_list|(
name|handler
argument_list|,
name|inputEncoding
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|useSpool
operator|&&
name|repos
operator|instanceof
name|DAVRepository
condition|)
block|{
operator|(
operator|(
name|DAVRepository
operator|)
name|repos
operator|)
operator|.
name|setSpoolResponse
argument_list|(
name|oldSpool
argument_list|)
expr_stmt|;
block|}
name|generator
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|SVNFileUtil
operator|.
name|deleteAll
argument_list|(
name|tmpFile
argument_list|,
operator|!
literal|"text-base"
operator|.
name|equals
argument_list|(
name|tmpFile
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doList
parameter_list|(
name|SVNRepository
name|repos
parameter_list|,
name|long
name|rev
parameter_list|,
specifier|final
name|ISVNDirEntryHandler
name|handler
parameter_list|,
name|boolean
name|fetchLocks
parameter_list|,
name|SVNDepth
name|depth
parameter_list|,
name|int
name|entryFields
parameter_list|)
throws|throws
name|SVNException
block|{
name|SVNURL
name|url
init|=
name|repos
operator|.
name|getLocation
argument_list|()
decl_stmt|;
name|SVNURL
name|reposRoot
init|=
name|repos
operator|.
name|getRepositoryRoot
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|SVNDirEntry
name|entry
init|=
literal|null
decl_stmt|;
name|SVNException
name|error
init|=
literal|null
decl_stmt|;
try|try
block|{
name|entry
operator|=
name|repos
operator|.
name|info
argument_list|(
literal|""
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SVNException
name|svne
parameter_list|)
block|{
if|if
condition|(
name|svne
operator|.
name|getErrorMessage
argument_list|()
operator|.
name|getErrorCode
argument_list|()
operator|==
name|SVNErrorCode
operator|.
name|RA_NOT_IMPLEMENTED
condition|)
block|{
name|error
operator|=
name|svne
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|svne
throw|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
name|SVNNodeKind
name|kind
init|=
name|repos
operator|.
name|checkPath
argument_list|(
literal|""
argument_list|,
name|rev
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|!=
name|SVNNodeKind
operator|.
name|NONE
condition|)
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|equals
argument_list|(
name|reposRoot
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|SVNPathUtil
operator|.
name|tail
argument_list|(
name|repos
operator|.
name|getLocation
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|repos
operator|.
name|setLocation
argument_list|(
name|repos
operator|.
name|getLocation
argument_list|()
operator|.
name|removePathTail
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Collection
name|dirEntries
init|=
name|repos
operator|.
name|getDir
argument_list|(
literal|""
argument_list|,
name|rev
argument_list|,
literal|null
argument_list|,
name|entryFields
argument_list|,
operator|(
name|Collection
operator|)
literal|null
argument_list|)
decl_stmt|;
name|repos
operator|.
name|setLocation
argument_list|(
name|url
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|ents
init|=
name|dirEntries
operator|.
name|iterator
argument_list|()
init|;
name|ents
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SVNDirEntry
name|dirEntry
init|=
operator|(
name|SVNDirEntry
operator|)
name|ents
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|dirEntry
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|entry
operator|=
name|dirEntry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setRelativePath
argument_list|(
name|kind
operator|==
name|SVNNodeKind
operator|.
name|FILE
condition|?
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SVNProperties
name|props
init|=
operator|new
name|SVNProperties
argument_list|()
decl_stmt|;
name|repos
operator|.
name|getDir
argument_list|(
literal|""
argument_list|,
name|rev
argument_list|,
name|props
argument_list|,
name|entryFields
argument_list|,
operator|(
name|Collection
operator|)
literal|null
argument_list|)
expr_stmt|;
name|SVNProperties
name|revProps
init|=
name|repos
operator|.
name|getRevisionProperties
argument_list|(
name|rev
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|String
name|author
init|=
name|revProps
operator|.
name|getStringValue
argument_list|(
name|SVNRevisionProperty
operator|.
name|AUTHOR
argument_list|)
decl_stmt|;
name|String
name|dateStr
init|=
name|revProps
operator|.
name|getStringValue
argument_list|(
name|SVNRevisionProperty
operator|.
name|DATE
argument_list|)
decl_stmt|;
name|Date
name|datestamp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dateStr
operator|!=
literal|null
condition|)
block|{
name|datestamp
operator|=
name|SVNDate
operator|.
name|parseDateString
argument_list|(
name|dateStr
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
operator|new
name|SVNDirEntry
argument_list|(
name|url
argument_list|,
name|reposRoot
argument_list|,
literal|""
argument_list|,
name|kind
argument_list|,
literal|0
argument_list|,
operator|!
name|props
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|rev
argument_list|,
name|datestamp
argument_list|,
name|author
argument_list|)
expr_stmt|;
name|entry
operator|.
name|setRelativePath
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setRelativePath
argument_list|(
name|entry
operator|.
name|getKind
argument_list|()
operator|==
name|SVNNodeKind
operator|.
name|DIR
condition|?
literal|""
else|:
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|SVNErrorMessage
name|err
init|=
name|SVNErrorMessage
operator|.
name|create
argument_list|(
name|SVNErrorCode
operator|.
name|FS_NOT_FOUND
argument_list|,
literal|"URL ''{0}'' non-existent in that revision"
argument_list|,
name|url
argument_list|)
decl_stmt|;
name|SVNErrorManager
operator|.
name|error
argument_list|(
name|err
argument_list|,
name|SVNLogType
operator|.
name|WC
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
name|locksMap
init|=
operator|new
name|SVNHashMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|fetchLocks
condition|)
block|{
name|SVNLock
index|[]
name|locks
init|=
operator|new
name|SVNLock
index|[
literal|0
index|]
decl_stmt|;
try|try
block|{
name|locks
operator|=
name|repos
operator|.
name|getLocks
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SVNException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|.
name|getErrorMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getErrorMessage
argument_list|()
operator|.
name|getErrorCode
argument_list|()
operator|==
name|SVNErrorCode
operator|.
name|RA_NOT_IMPLEMENTED
operator|)
condition|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|locks
operator|!=
literal|null
operator|&&
name|locks
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|SVNURL
name|root
init|=
name|repos
operator|.
name|getRepositoryRoot
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|repositoryPath
init|=
name|locks
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|locksMap
operator|.
name|put
argument_list|(
name|root
operator|.
name|appendPath
argument_list|(
name|repositoryPath
argument_list|,
literal|false
argument_list|)
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ISVNDirEntryHandler
name|nestedHandler
init|=
operator|new
name|ISVNDirEntryHandler
argument_list|()
block|{
specifier|public
name|void
name|handleDirEntry
parameter_list|(
name|SVNDirEntry
name|dirEntry
parameter_list|)
throws|throws
name|SVNException
block|{
name|dirEntry
operator|.
name|setLock
argument_list|(
operator|(
name|SVNLock
operator|)
name|locksMap
operator|.
name|get
argument_list|(
name|dirEntry
operator|.
name|getURL
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|.
name|handleDirEntry
argument_list|(
name|dirEntry
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|nestedHandler
operator|.
name|handleDirEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|getKind
argument_list|()
operator|==
name|SVNNodeKind
operator|.
name|DIR
operator|&&
operator|(
name|depth
operator|==
name|SVNDepth
operator|.
name|FILES
operator|||
name|depth
operator|==
name|SVNDepth
operator|.
name|IMMEDIATES
operator|||
name|depth
operator|==
name|SVNDepth
operator|.
name|INFINITY
operator|)
condition|)
block|{
name|list
argument_list|(
name|repos
argument_list|,
literal|""
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|entryFields
argument_list|,
name|nestedHandler
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|list
parameter_list|(
name|SVNRepository
name|repository
parameter_list|,
name|String
name|path
parameter_list|,
name|long
name|rev
parameter_list|,
name|SVNDepth
name|depth
parameter_list|,
name|int
name|entryFields
parameter_list|,
name|ISVNDirEntryHandler
name|handler
parameter_list|)
throws|throws
name|SVNException
block|{
if|if
condition|(
name|depth
operator|==
name|SVNDepth
operator|.
name|EMPTY
condition|)
block|{
return|return;
block|}
name|Collection
name|entries
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
name|entries
operator|=
name|repository
operator|.
name|getDir
argument_list|(
name|path
argument_list|,
name|rev
argument_list|,
literal|null
argument_list|,
name|entryFields
argument_list|,
name|entries
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|iterator
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SVNDirEntry
name|entry
init|=
operator|(
name|SVNDirEntry
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|childPath
init|=
name|SVNPathUtil
operator|.
name|append
argument_list|(
name|path
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setRelativePath
argument_list|(
name|childPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|getKind
argument_list|()
operator|==
name|SVNNodeKind
operator|.
name|FILE
operator|||
name|depth
operator|==
name|SVNDepth
operator|.
name|IMMEDIATES
operator|||
name|depth
operator|==
name|SVNDepth
operator|.
name|INFINITY
condition|)
block|{
name|handler
operator|.
name|handleDirEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|getKind
argument_list|()
operator|==
name|SVNNodeKind
operator|.
name|DIR
operator|&&
name|entry
operator|.
name|getDate
argument_list|()
operator|!=
literal|null
operator|&&
name|depth
operator|==
name|SVNDepth
operator|.
name|INFINITY
condition|)
block|{
name|list
argument_list|(
name|repository
argument_list|,
name|childPath
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|entryFields
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

