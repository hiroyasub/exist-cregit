begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * $Log: Diff.java,v $  * Revision 1.6  2003/03/06 22:51:32  stuart  * Convert to CVS  *  * Revision 1.5  2002/07/19  19:14:40  stuart  * fix reverseScript, make change ctor public, update docs  *  * Revision 1.4  2002/04/09  17:53:39  stuart  * More flexible interface for diff() function.  *  * Revision 1.3  2000/03/03 21:58:03  stuart  * move discard_confusing_lines and shift_boundaries to class file_data  *  * Revision 1.2  2000/03/02  16:37:38  stuart  * Add GPL and copyright  *  */
end_comment

begin_package
package|package
name|bmsi
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_comment
comment|/** A class to compare vectors of objects.  The result of comparison     is a list of<code>change</code> objects which form an     edit script.  The objects compared are traditionally lines     of text from two files.  Comparison options such as "ignore     whitespace" are implemented by modifying the<code>equals</code>     and<code>hashcode</code> methods for the objects compared.<p>    The basic algorithm is described in:</br>    "An O(ND) Difference Algorithm and its Variations", Eugene Myers,    Algorithmica Vol. 1 No. 2, 1986, p 251.<p>    This class outputs different results from GNU diff 1.15 on some    inputs.  Our results are actually better (smaller change list, smaller    total size of changes), but it would be nice to know why.  Perhaps    there is a memory overwrite bug in GNU diff 1.15.    @author Stuart D. Gathman, translated from GNU diff 1.15     Copyright (C) 2000  Business Management Systems, Inc.<p>     This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.<p>     This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.<p>     You should have received a copy of the<a href=COPYING.txt>     GNU General Public License</a>     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   */
end_comment

begin_class
specifier|public
class|class
name|Diff
block|{
comment|/** Prepare to find differences between two arrays.  Each element of       the arrays is translated to an "equivalence number" based on       the result of<code>equals</code>.  The original Object arrays       are no longer needed for computing the differences.  They will       be needed again later to print the results of the comparison as       an edit script, if desired.    */
specifier|public
name|Diff
parameter_list|(
name|Object
index|[]
name|a
parameter_list|,
name|Object
index|[]
name|b
parameter_list|)
block|{
name|Hashtable
name|h
init|=
operator|new
name|Hashtable
argument_list|(
name|a
operator|.
name|length
operator|+
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
name|filevec
index|[
literal|0
index|]
operator|=
operator|new
name|file_data
argument_list|(
name|a
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|=
operator|new
name|file_data
argument_list|(
name|b
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
comment|/** 1 more than the maximum equivalence value used for this or its      sibling file. */
specifier|private
name|int
name|equiv_max
init|=
literal|1
decl_stmt|;
comment|/** When set to true, the comparison uses a heuristic to speed it up.     With this heuristic, for files with a constant small density     of changes, the algorithm is linear in the file size.  */
specifier|public
name|boolean
name|heuristic
init|=
literal|false
decl_stmt|;
comment|/** When set to true, the algorithm returns a guarranteed minimal       set of changes.  This makes things slower, sometimes much slower. */
specifier|public
name|boolean
name|no_discards
init|=
literal|false
decl_stmt|;
specifier|private
name|int
index|[]
name|xvec
decl_stmt|,
name|yvec
decl_stmt|;
comment|/* Vectors being compared. */
specifier|private
name|int
index|[]
name|fdiag
decl_stmt|;
comment|/* Vector, indexed by diagonal, containing 				   the X coordinate of the point furthest 				   along the given diagonal in the forward 				   search of the edit matrix. */
specifier|private
name|int
index|[]
name|bdiag
decl_stmt|;
comment|/* Vector, indexed by diagonal, containing 				   the X coordinate of the point furthest 				   along the given diagonal in the backward 				   search of the edit matrix. */
specifier|private
name|int
name|fdiagoff
decl_stmt|,
name|bdiagoff
decl_stmt|;
specifier|private
specifier|final
name|file_data
index|[]
name|filevec
init|=
operator|new
name|file_data
index|[
literal|2
index|]
decl_stmt|;
specifier|private
name|int
name|cost
decl_stmt|;
comment|/** Find the midpoint of the shortest edit script for a specified      portion of the two files.       We scan from the beginnings of the files, and simultaneously from the ends,      doing a breadth-first search through the space of edit-sequence.      When the two searches meet, we have found the midpoint of the shortest      edit sequence.       The value returned is the number of the diagonal on which the midpoint lies.      The diagonal number equals the number of inserted lines minus the number      of deleted lines (counting only lines before the midpoint).      The edit cost is stored into COST; this is the total number of      lines inserted or deleted (counting only lines before the midpoint).       This function assumes that the first lines of the specified portions      of the two files do not match, and likewise that the last lines do not      match.  The caller must trim matching lines from the beginning and end      of the portions it is going to specify.       Note that if we return the "wrong" diagonal value, or if      the value of bdiag at that diagonal is "wrong",      the worst this can do is cause suboptimal diff output.      It cannot cause incorrect diff output.  */
specifier|private
name|int
name|diag
parameter_list|(
name|int
name|xoff
parameter_list|,
name|int
name|xlim
parameter_list|,
name|int
name|yoff
parameter_list|,
name|int
name|ylim
parameter_list|)
block|{
specifier|final
name|int
index|[]
name|fd
init|=
name|fdiag
decl_stmt|;
comment|// Give the compiler a chance.
specifier|final
name|int
index|[]
name|bd
init|=
name|bdiag
decl_stmt|;
comment|// Additional help for the compiler.
specifier|final
name|int
index|[]
name|xv
init|=
name|xvec
decl_stmt|;
comment|// Still more help for the compiler.
specifier|final
name|int
index|[]
name|yv
init|=
name|yvec
decl_stmt|;
comment|// And more and more . . .
specifier|final
name|int
name|dmin
init|=
name|xoff
operator|-
name|ylim
decl_stmt|;
comment|// Minimum valid diagonal.
specifier|final
name|int
name|dmax
init|=
name|xlim
operator|-
name|yoff
decl_stmt|;
comment|// Maximum valid diagonal.
specifier|final
name|int
name|fmid
init|=
name|xoff
operator|-
name|yoff
decl_stmt|;
comment|// Center diagonal of top-down search.
specifier|final
name|int
name|bmid
init|=
name|xlim
operator|-
name|ylim
decl_stmt|;
comment|// Center diagonal of bottom-up search.
name|int
name|fmin
init|=
name|fmid
decl_stmt|,
name|fmax
init|=
name|fmid
decl_stmt|;
comment|// Limits of top-down search.
name|int
name|bmin
init|=
name|bmid
decl_stmt|,
name|bmax
init|=
name|bmid
decl_stmt|;
comment|// Limits of bottom-up search.
comment|/* True if southeast corner is on an odd 				     diagonal with respect to the northwest. */
specifier|final
name|boolean
name|odd
init|=
operator|(
name|fmid
operator|-
name|bmid
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|fd
index|[
name|fdiagoff
operator|+
name|fmid
index|]
operator|=
name|xoff
expr_stmt|;
name|bd
index|[
name|bdiagoff
operator|+
name|bmid
index|]
operator|=
name|xlim
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|1
init|;
condition|;
operator|++
name|c
control|)
block|{
name|int
name|d
decl_stmt|;
comment|/* Active diagonal. */
name|boolean
name|big_snake
init|=
literal|false
decl_stmt|;
comment|/* Extend the top-down search by an edit step in each diagonal. */
if|if
condition|(
name|fmin
operator|>
name|dmin
condition|)
name|fd
index|[
name|fdiagoff
operator|+
operator|--
name|fmin
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|++
name|fmin
expr_stmt|;
if|if
condition|(
name|fmax
operator|<
name|dmax
condition|)
name|fd
index|[
name|fdiagoff
operator|+
operator|++
name|fmax
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|--
name|fmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|oldx
decl_stmt|,
name|tlo
init|=
name|fd
index|[
name|fdiagoff
operator|+
name|d
operator|-
literal|1
index|]
decl_stmt|,
name|thi
init|=
name|fd
index|[
name|fdiagoff
operator|+
name|d
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tlo
operator|>=
name|thi
condition|)
name|x
operator|=
name|tlo
operator|+
literal|1
expr_stmt|;
else|else
name|x
operator|=
name|thi
expr_stmt|;
name|oldx
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|d
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|xlim
operator|&&
name|y
operator|<
name|ylim
operator|&&
name|xv
index|[
name|x
index|]
operator|==
name|yv
index|[
name|y
index|]
condition|)
block|{
operator|++
name|x
expr_stmt|;
operator|++
name|y
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|-
name|oldx
operator|>
literal|20
condition|)
name|big_snake
operator|=
literal|true
expr_stmt|;
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|odd
operator|&&
name|bmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|bmax
operator|&&
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|<=
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
condition|)
block|{
name|cost
operator|=
literal|2
operator|*
name|c
operator|-
literal|1
expr_stmt|;
return|return
name|d
return|;
block|}
block|}
comment|/* Similar extend the bottom-up search. */
if|if
condition|(
name|bmin
operator|>
name|dmin
condition|)
name|bd
index|[
name|bdiagoff
operator|+
operator|--
name|bmin
operator|-
literal|1
index|]
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
else|else
operator|++
name|bmin
expr_stmt|;
if|if
condition|(
name|bmax
operator|<
name|dmax
condition|)
name|bd
index|[
name|bdiagoff
operator|+
operator|++
name|bmax
operator|+
literal|1
index|]
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
else|else
operator|--
name|bmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|oldx
decl_stmt|,
name|tlo
init|=
name|bd
index|[
name|bdiagoff
operator|+
name|d
operator|-
literal|1
index|]
decl_stmt|,
name|thi
init|=
name|bd
index|[
name|bdiagoff
operator|+
name|d
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tlo
operator|<
name|thi
condition|)
name|x
operator|=
name|tlo
expr_stmt|;
else|else
name|x
operator|=
name|thi
operator|-
literal|1
expr_stmt|;
name|oldx
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|d
expr_stmt|;
while|while
condition|(
name|x
operator|>
name|xoff
operator|&&
name|y
operator|>
name|yoff
operator|&&
name|xv
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|yv
index|[
name|y
operator|-
literal|1
index|]
condition|)
block|{
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
if|if
condition|(
name|oldx
operator|-
name|x
operator|>
literal|20
condition|)
name|big_snake
operator|=
literal|true
expr_stmt|;
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|odd
operator|&&
name|fmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|fmax
operator|&&
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|<=
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
condition|)
block|{
name|cost
operator|=
literal|2
operator|*
name|c
expr_stmt|;
return|return
name|d
return|;
block|}
block|}
comment|/* Heuristic: check occasionally for a diagonal that has made 	   lots of progress compared with the edit distance. 	   If we have any such, find the one that has made the most 	   progress and return it as if it had succeeded.  	   With this heuristic, for files with a constant small density 	   of changes, the algorithm is linear in the file size.  */
if|if
condition|(
name|c
operator|>
literal|200
operator|&&
name|big_snake
operator|&&
name|heuristic
condition|)
block|{
name|int
name|best
init|=
literal|0
decl_stmt|;
name|int
name|bestpos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|dd
init|=
name|d
operator|-
name|fmid
decl_stmt|;
if|if
condition|(
operator|(
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
operator|-
name|xoff
operator|)
operator|*
literal|2
operator|-
name|dd
operator|>
literal|12
operator|*
operator|(
name|c
operator|+
operator|(
name|dd
operator|>
literal|0
condition|?
name|dd
else|:
operator|-
name|dd
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
operator|*
literal|2
operator|-
name|dd
operator|>
name|best
operator|&&
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
operator|-
name|xoff
operator|>
literal|20
operator|&&
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
operator|-
name|d
operator|-
name|yoff
operator|>
literal|20
condition|)
block|{
name|int
name|k
decl_stmt|;
name|int
name|x
init|=
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
decl_stmt|;
comment|/* We have a good enough best diagonal; 			   now insist that it end with a significant snake.  */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
literal|20
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|xvec
index|[
name|x
operator|-
name|k
index|]
operator|!=
name|yvec
index|[
name|x
operator|-
name|d
operator|-
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|==
literal|21
condition|)
block|{
name|best
operator|=
name|fd
index|[
name|fdiagoff
operator|+
name|d
index|]
operator|*
literal|2
operator|-
name|dd
expr_stmt|;
name|bestpos
operator|=
name|d
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
name|cost
operator|=
literal|2
operator|*
name|c
operator|-
literal|1
expr_stmt|;
return|return
name|bestpos
return|;
block|}
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|dd
init|=
name|d
operator|-
name|bmid
decl_stmt|;
if|if
condition|(
operator|(
name|xlim
operator|-
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|)
operator|*
literal|2
operator|+
name|dd
operator|>
literal|12
operator|*
operator|(
name|c
operator|+
operator|(
name|dd
operator|>
literal|0
condition|?
name|dd
else|:
operator|-
name|dd
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|xlim
operator|-
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|)
operator|*
literal|2
operator|+
name|dd
operator|>
name|best
operator|&&
name|xlim
operator|-
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|>
literal|20
operator|&&
name|ylim
operator|-
operator|(
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|-
name|d
operator|)
operator|>
literal|20
condition|)
block|{
comment|/* We have a good enough best diagonal; 			   now insist that it end with a significant snake.  */
name|int
name|k
decl_stmt|;
name|int
name|x
init|=
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|20
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|xvec
index|[
name|x
operator|+
name|k
index|]
operator|!=
name|yvec
index|[
name|x
operator|-
name|d
operator|+
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|==
literal|20
condition|)
block|{
name|best
operator|=
operator|(
name|xlim
operator|-
name|bd
index|[
name|bdiagoff
operator|+
name|d
index|]
operator|)
operator|*
literal|2
operator|+
name|dd
expr_stmt|;
name|bestpos
operator|=
name|d
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
name|cost
operator|=
literal|2
operator|*
name|c
operator|-
literal|1
expr_stmt|;
return|return
name|bestpos
return|;
block|}
block|}
block|}
block|}
comment|/** Compare in detail contiguous subsequences of the two files      which are known, as a whole, to match each other.       The results are recorded in the vectors filevec[N].changed_flag, by      storing a 1 in the element for each line that is an insertion or deletion.       The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.       Note that XLIM, YLIM are exclusive bounds.      All line numbers are origin-0 and discarded lines are not counted.  */
specifier|private
name|void
name|compareseq
parameter_list|(
name|int
name|xoff
parameter_list|,
name|int
name|xlim
parameter_list|,
name|int
name|yoff
parameter_list|,
name|int
name|ylim
parameter_list|)
block|{
comment|/* Slide down the bottom initial diagonal. */
while|while
condition|(
name|xoff
operator|<
name|xlim
operator|&&
name|yoff
operator|<
name|ylim
operator|&&
name|xvec
index|[
name|xoff
index|]
operator|==
name|yvec
index|[
name|yoff
index|]
condition|)
block|{
operator|++
name|xoff
expr_stmt|;
operator|++
name|yoff
expr_stmt|;
block|}
comment|/* Slide up the top initial diagonal. */
while|while
condition|(
name|xlim
operator|>
name|xoff
operator|&&
name|ylim
operator|>
name|yoff
operator|&&
name|xvec
index|[
name|xlim
operator|-
literal|1
index|]
operator|==
name|yvec
index|[
name|ylim
operator|-
literal|1
index|]
condition|)
block|{
operator|--
name|xlim
expr_stmt|;
operator|--
name|ylim
expr_stmt|;
block|}
comment|/* Handle simple cases. */
if|if
condition|(
name|xoff
operator|==
name|xlim
condition|)
while|while
condition|(
name|yoff
operator|<
name|ylim
condition|)
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
index|[
literal|1
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|realindexes
index|[
name|yoff
operator|++
index|]
index|]
operator|=
literal|true
expr_stmt|;
if|else if
condition|(
name|yoff
operator|==
name|ylim
condition|)
while|while
condition|(
name|xoff
operator|<
name|xlim
condition|)
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
index|[
literal|1
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|realindexes
index|[
name|xoff
operator|++
index|]
index|]
operator|=
literal|true
expr_stmt|;
else|else
block|{
comment|/* Find a point of correspondence in the middle of the files.  */
name|int
name|d
init|=
name|diag
argument_list|(
name|xoff
argument_list|,
name|xlim
argument_list|,
name|yoff
argument_list|,
name|ylim
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|cost
decl_stmt|;
name|int
name|f
init|=
name|fdiag
index|[
name|fdiagoff
operator|+
name|d
index|]
decl_stmt|;
name|int
name|b
init|=
name|bdiag
index|[
name|bdiagoff
operator|+
name|d
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
condition|)
block|{
comment|/* This should be impossible, because it implies that 	       one of the two subsequences is empty, 	       and that case was handled above without calling `diag'. 	       Let's verify that this is true.  */
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Empty subsequence"
argument_list|)
throw|;
block|}
else|else
block|{
comment|/* Use that point to split this problem into two subproblems.  */
name|compareseq
argument_list|(
name|xoff
argument_list|,
name|b
argument_list|,
name|yoff
argument_list|,
name|b
operator|-
name|d
argument_list|)
expr_stmt|;
comment|/* This used to use f instead of b, 	       but that is incorrect! 	       It is not necessarily the case that diagonal d 	       has a snake from b to f.  */
name|compareseq
argument_list|(
name|b
argument_list|,
name|xlim
argument_list|,
name|b
operator|-
name|d
argument_list|,
name|ylim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Discard lines from one file that have no matches in the other file.    */
specifier|private
name|void
name|discard_confusing_lines
parameter_list|()
block|{
name|filevec
index|[
literal|0
index|]
operator|.
name|discard_confusing_lines
argument_list|(
name|filevec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|discard_confusing_lines
argument_list|(
name|filevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|inhibit
init|=
literal|false
decl_stmt|;
comment|/** Adjust inserts/deletes of blank lines to join changes      as much as possible.    */
specifier|private
name|void
name|shift_boundaries
parameter_list|()
block|{
if|if
condition|(
name|inhibit
condition|)
return|return;
name|filevec
index|[
literal|0
index|]
operator|.
name|shift_boundaries
argument_list|(
name|filevec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|shift_boundaries
argument_list|(
name|filevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
specifier|public
interface|interface
name|ScriptBuilder
block|{
comment|/** Scan the tables of which lines are inserted and deleted,      producing an edit script.     @param changed0 true for lines in first file which do not match 2nd    @param len0 number of lines in first file    @param changed1 true for lines in 2nd file which do not match 1st    @param len1 number of lines in 2nd file    @return a linked list of changes - or null    */
specifier|public
name|change
name|build_script
parameter_list|(
name|boolean
index|[]
name|changed0
parameter_list|,
name|int
name|len0
parameter_list|,
name|boolean
index|[]
name|changed1
parameter_list|,
name|int
name|len1
parameter_list|)
function_decl|;
block|}
comment|/** Scan the tables of which lines are inserted and deleted,      producing an edit script in reverse order.  */
specifier|static
class|class
name|ReverseScript
implements|implements
name|ScriptBuilder
block|{
specifier|public
name|change
name|build_script
parameter_list|(
specifier|final
name|boolean
index|[]
name|changed0
parameter_list|,
name|int
name|len0
parameter_list|,
specifier|final
name|boolean
index|[]
name|changed1
parameter_list|,
name|int
name|len1
parameter_list|)
block|{
name|change
name|script
init|=
literal|null
decl_stmt|;
name|int
name|i0
init|=
literal|0
decl_stmt|,
name|i1
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i0
operator|<
name|len0
operator|||
name|i1
operator|<
name|len1
condition|)
block|{
if|if
condition|(
name|changed0
index|[
literal|1
operator|+
name|i0
index|]
operator|||
name|changed1
index|[
literal|1
operator|+
name|i1
index|]
condition|)
block|{
name|int
name|line0
init|=
name|i0
decl_stmt|,
name|line1
init|=
name|i1
decl_stmt|;
comment|/* Find # lines changed here in each file.  */
while|while
condition|(
name|changed0
index|[
literal|1
operator|+
name|i0
index|]
condition|)
operator|++
name|i0
expr_stmt|;
while|while
condition|(
name|changed1
index|[
literal|1
operator|+
name|i1
index|]
condition|)
operator|++
name|i1
expr_stmt|;
comment|/* Record this change.  */
name|script
operator|=
operator|new
name|change
argument_list|(
name|line0
argument_list|,
name|line1
argument_list|,
name|i0
operator|-
name|line0
argument_list|,
name|i1
operator|-
name|line1
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
comment|/* We have reached lines in the two files that match each other.  */
name|i0
operator|++
expr_stmt|;
name|i1
operator|++
expr_stmt|;
block|}
return|return
name|script
return|;
block|}
block|}
specifier|static
class|class
name|ForwardScript
implements|implements
name|ScriptBuilder
block|{
comment|/** Scan the tables of which lines are inserted and deleted,        producing an edit script in forward order.  */
specifier|public
name|change
name|build_script
parameter_list|(
specifier|final
name|boolean
index|[]
name|changed0
parameter_list|,
name|int
name|len0
parameter_list|,
specifier|final
name|boolean
index|[]
name|changed1
parameter_list|,
name|int
name|len1
parameter_list|)
block|{
name|change
name|script
init|=
literal|null
decl_stmt|;
name|int
name|i0
init|=
name|len0
decl_stmt|,
name|i1
init|=
name|len1
decl_stmt|;
while|while
condition|(
name|i0
operator|>=
literal|0
operator|||
name|i1
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|changed0
index|[
name|i0
index|]
operator|||
name|changed1
index|[
name|i1
index|]
condition|)
block|{
name|int
name|line0
init|=
name|i0
decl_stmt|,
name|line1
init|=
name|i1
decl_stmt|;
comment|/* Find # lines changed here in each file.  */
while|while
condition|(
name|changed0
index|[
name|i0
index|]
condition|)
operator|--
name|i0
expr_stmt|;
while|while
condition|(
name|changed1
index|[
name|i1
index|]
condition|)
operator|--
name|i1
expr_stmt|;
comment|/* Record this change.  */
name|script
operator|=
operator|new
name|change
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|,
name|line0
operator|-
name|i0
argument_list|,
name|line1
operator|-
name|i1
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
comment|/* We have reached lines in the two files that match each other.  */
name|i0
operator|--
expr_stmt|;
name|i1
operator|--
expr_stmt|;
block|}
return|return
name|script
return|;
block|}
block|}
comment|/** Standard ScriptBuilders. */
specifier|public
specifier|final
specifier|static
name|ScriptBuilder
name|forwardScript
init|=
operator|new
name|ForwardScript
argument_list|()
decl_stmt|,
name|reverseScript
init|=
operator|new
name|ReverseScript
argument_list|()
decl_stmt|;
comment|/* Report the differences of two files.  DEPTH is the current directory      depth. */
specifier|public
specifier|final
name|change
name|diff_2
parameter_list|(
specifier|final
name|boolean
name|reverse
parameter_list|)
block|{
return|return
name|diff
argument_list|(
name|reverse
condition|?
name|reverseScript
else|:
name|forwardScript
argument_list|)
return|;
block|}
comment|/** Get the results of comparison as an edit script.  The script       is described by a list of changes.  The standard ScriptBuilder      implementations provide for forward and reverse edit scripts.      Alternate implementations could, for instance, list common elements       instead of differences.      @param bld	an object to build the script from change flags      @return the head of a list of changes    */
specifier|public
name|change
name|diff
parameter_list|(
specifier|final
name|ScriptBuilder
name|bld
parameter_list|)
block|{
comment|/* Some lines are obviously insertions or deletions        because they don't match anything.  Detect them now,        and avoid even thinking about them in the main comparison algorithm.  */
name|discard_confusing_lines
argument_list|()
expr_stmt|;
comment|/* Now do the main comparison algorithm, considering just the        undiscarded lines.  */
name|xvec
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|undiscarded
expr_stmt|;
name|yvec
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|undiscarded
expr_stmt|;
name|int
name|diags
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|3
decl_stmt|;
name|fdiag
operator|=
operator|new
name|int
index|[
name|diags
index|]
expr_stmt|;
name|fdiagoff
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|bdiag
operator|=
operator|new
name|int
index|[
name|diags
index|]
expr_stmt|;
name|bdiagoff
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|compareseq
argument_list|(
literal|0
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
argument_list|,
literal|0
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
argument_list|)
expr_stmt|;
name|fdiag
operator|=
literal|null
expr_stmt|;
name|bdiag
operator|=
literal|null
expr_stmt|;
comment|/* Modify the results slightly to make them prettier        in cases where that can validly be done.  */
name|shift_boundaries
argument_list|()
expr_stmt|;
comment|/* Get the results of comparison in the form of a chain        of `struct change's -- an edit script.  */
return|return
name|bld
operator|.
name|build_script
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
argument_list|)
return|;
block|}
comment|/** The result of comparison is an "edit script": a chain of change objects.      Each change represents one place where some lines are deleted      and some are inserted.            LINE0 and LINE1 are the first affected lines in the two files (origin 0).      DELETED is the number of lines deleted here from file 0.      INSERTED is the number of lines inserted here in file 1.       If DELETED is 0 then LINE0 is the number of the line before      which the insertion was done; vice versa for INSERTED and LINE1.  */
specifier|public
specifier|static
class|class
name|change
block|{
comment|/** Previous or next edit command. */
specifier|public
name|change
name|link
decl_stmt|;
comment|/** # lines of file 1 changed here.  */
specifier|public
specifier|final
name|int
name|inserted
decl_stmt|;
comment|/** # lines of file 0 changed here.  */
specifier|public
specifier|final
name|int
name|deleted
decl_stmt|;
comment|/** Line number of 1st deleted line.  */
specifier|public
specifier|final
name|int
name|line0
decl_stmt|;
comment|/** Line number of 1st inserted line.  */
specifier|public
specifier|final
name|int
name|line1
decl_stmt|;
comment|/** Cons an additional entry onto the front of an edit script OLD.        LINE0 and LINE1 are the first affected lines in the two files (origin 0).        DELETED is the number of lines deleted here from file 0.        INSERTED is the number of lines inserted here in file 1.         If DELETED is 0 then LINE0 is the number of the line before        which the insertion was done; vice versa for INSERTED and LINE1.  */
specifier|public
name|change
parameter_list|(
name|int
name|line0
parameter_list|,
name|int
name|line1
parameter_list|,
name|int
name|deleted
parameter_list|,
name|int
name|inserted
parameter_list|,
name|change
name|old
parameter_list|)
block|{
name|this
operator|.
name|line0
operator|=
name|line0
expr_stmt|;
name|this
operator|.
name|line1
operator|=
name|line1
expr_stmt|;
name|this
operator|.
name|inserted
operator|=
name|inserted
expr_stmt|;
name|this
operator|.
name|deleted
operator|=
name|deleted
expr_stmt|;
name|this
operator|.
name|link
operator|=
name|old
expr_stmt|;
comment|//System.err.println(line0+","+line1+","+inserted+","+deleted);
block|}
block|}
comment|/** Data on one input file being compared.      */
class|class
name|file_data
block|{
comment|/** Allocate changed array for the results of comparison.  */
name|void
name|clear
parameter_list|()
block|{
comment|/* Allocate a flag for each line of each file, saying whether that line 	 is an insertion or deletion. 	 Allocate an extra element, always zero, at each end of each vector.        */
name|changed_flag
operator|=
operator|new
name|boolean
index|[
name|buffered_lines
operator|+
literal|2
index|]
expr_stmt|;
block|}
comment|/** Return equiv_count[I] as the number of lines in this file        that fall in equivalence class I.          @return the array of equivalence class counts.      */
name|int
index|[]
name|equivCount
parameter_list|()
block|{
name|int
index|[]
name|equiv_count
init|=
operator|new
name|int
index|[
name|equiv_max
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buffered_lines
condition|;
operator|++
name|i
control|)
operator|++
name|equiv_count
index|[
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
return|return
name|equiv_count
return|;
block|}
comment|/** Discard lines that have no matches in another file.         A line which is discarded will not be considered by the actual        comparison algorithm; it will be as if that line were not in the file.        The file's `realindexes' table maps virtual line numbers        (which don't count the discarded lines) into real line numbers;        this is how the actual comparison algorithm produces results        that are comprehensible when the discarded lines are counted.<p>        When we discard a line, we also mark it as a deletion or insertion        so that it will be printed in the output.         @param f the other file         */
name|void
name|discard_confusing_lines
parameter_list|(
name|file_data
name|f
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
comment|/* Set up table of which lines are going to be discarded. */
specifier|final
name|byte
index|[]
name|discarded
init|=
name|discardable
argument_list|(
name|f
operator|.
name|equivCount
argument_list|()
argument_list|)
decl_stmt|;
comment|/* Don't really discard the provisional lines except when they occur        in a run of discardables, with nonprovisionals at the beginning        and end.  */
name|filterDiscards
argument_list|(
name|discarded
argument_list|)
expr_stmt|;
comment|/* Actually discard the lines. */
name|discard
argument_list|(
name|discarded
argument_list|)
expr_stmt|;
block|}
comment|/** Mark to be discarded each line that matches no line of another file.        If a line matches many lines, mark it as provisionally discardable.          @see equivCount()        @param counts The count of each equivalence number for the other file.        @return 0=nondiscardable, 1=discardable or 2=provisionally discardable        	for each line      */
specifier|private
name|byte
index|[]
name|discardable
parameter_list|(
specifier|final
name|int
index|[]
name|counts
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|buffered_lines
decl_stmt|;
specifier|final
name|byte
index|[]
name|discards
init|=
operator|new
name|byte
index|[
name|end
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|equivs
init|=
name|this
operator|.
name|equivs
decl_stmt|;
name|int
name|many
init|=
literal|5
decl_stmt|;
name|int
name|tem
init|=
name|end
operator|/
literal|64
decl_stmt|;
comment|/* Multiply MANY by approximate square root of number of lines. 	 That is the threshold for provisionally discardable lines.  */
while|while
condition|(
operator|(
name|tem
operator|=
name|tem
operator|>>
literal|2
operator|)
operator|>
literal|0
condition|)
name|many
operator|*=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nmatch
decl_stmt|;
if|if
condition|(
name|equivs
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|nmatch
operator|=
name|counts
index|[
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nmatch
operator|==
literal|0
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|else if
condition|(
name|nmatch
operator|>
name|many
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|discards
return|;
block|}
comment|/** Don't really discard the provisional lines except when they occur        in a run of discardables, with nonprovisionals at the beginning        and end.  */
specifier|private
name|void
name|filterDiscards
parameter_list|(
specifier|final
name|byte
index|[]
name|discards
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|buffered_lines
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
comment|/* Cancel provisional discards not in middle of run of discards.  */
if|if
condition|(
name|discards
index|[
name|i
index|]
operator|==
literal|2
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|else if
condition|(
name|discards
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We have found a nonprovisional discard.  */
name|int
name|j
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|provisional
init|=
literal|0
decl_stmt|;
comment|/* Find end of this run of discardable lines. 		   Count how many are provisionally discardable.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|discards
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|j
index|]
operator|==
literal|2
condition|)
operator|++
name|provisional
expr_stmt|;
block|}
comment|/* Cancel provisional discards at end, and shrink the run.  */
while|while
condition|(
name|j
operator|>
name|i
operator|&&
name|discards
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|2
condition|)
block|{
name|discards
index|[
operator|--
name|j
index|]
operator|=
literal|0
expr_stmt|;
operator|--
name|provisional
expr_stmt|;
block|}
comment|/* Now we have the length of a run of discardable lines 		   whose first and last are not provisional.  */
name|length
operator|=
name|j
operator|-
name|i
expr_stmt|;
comment|/* If 1/4 of the lines in the run are provisional, 		   cancel discarding of all provisional lines in the run.  */
if|if
condition|(
name|provisional
operator|*
literal|4
operator|>
name|length
condition|)
block|{
while|while
condition|(
name|j
operator|>
name|i
condition|)
if|if
condition|(
name|discards
index|[
operator|--
name|j
index|]
operator|==
literal|2
condition|)
name|discards
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|consec
decl_stmt|;
name|int
name|minimum
init|=
literal|1
decl_stmt|;
name|int
name|tem
init|=
name|length
operator|/
literal|4
decl_stmt|;
comment|/* MINIMUM is approximate square root of LENGTH/4. 		       A subrun of two or more provisionals can stand 		       when LENGTH is at least 16. 		       A subrun of 4 or more can stand when LENGTH>= 64.  */
while|while
condition|(
operator|(
name|tem
operator|=
name|tem
operator|>>
literal|2
operator|)
operator|>
literal|0
condition|)
name|minimum
operator|*=
literal|2
expr_stmt|;
name|minimum
operator|++
expr_stmt|;
comment|/* Cancel any subrun of MINIMUM or more provisionals 		       within the larger run.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|2
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
if|else if
condition|(
name|minimum
operator|==
operator|++
name|consec
condition|)
comment|/* Back up to start of subrun, to cancel it all.  */
name|j
operator|-=
name|consec
expr_stmt|;
if|else if
condition|(
name|minimum
operator|<
name|consec
condition|)
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Scan from beginning of run 		       until we find 3 or more nonprovisionals in a row 		       or until the first nonprovisional at least 8 lines in. 		       Until that point, cancel any provisionals.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|8
operator|&&
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|2
condition|)
block|{
name|consec
operator|=
literal|0
expr_stmt|;
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|else if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|0
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
else|else
name|consec
operator|++
expr_stmt|;
if|if
condition|(
name|consec
operator|==
literal|3
condition|)
break|break;
block|}
comment|/* I advances to the last line of the run.  */
name|i
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
comment|/* Same thing, from end.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|8
operator|&&
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|2
condition|)
block|{
name|consec
operator|=
literal|0
expr_stmt|;
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|else if
condition|(
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|0
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
else|else
name|consec
operator|++
expr_stmt|;
if|if
condition|(
name|consec
operator|==
literal|3
condition|)
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/** Actually discard the lines.       @param discards flags lines to be discarded      */
specifier|private
name|void
name|discard
parameter_list|(
specifier|final
name|byte
index|[]
name|discards
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|buffered_lines
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|no_discards
operator|||
name|discards
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|undiscarded
index|[
name|j
index|]
operator|=
name|equivs
index|[
name|i
index|]
expr_stmt|;
name|realindexes
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
name|changed_flag
index|[
literal|1
operator|+
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|nondiscarded_lines
operator|=
name|j
expr_stmt|;
block|}
name|file_data
parameter_list|(
name|Object
index|[]
name|data
parameter_list|,
name|Hashtable
name|h
parameter_list|)
block|{
name|buffered_lines
operator|=
name|data
operator|.
name|length
expr_stmt|;
name|equivs
operator|=
operator|new
name|int
index|[
name|buffered_lines
index|]
expr_stmt|;
name|undiscarded
operator|=
operator|new
name|int
index|[
name|buffered_lines
index|]
expr_stmt|;
name|realindexes
operator|=
operator|new
name|int
index|[
name|buffered_lines
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Integer
name|ir
init|=
operator|(
name|Integer
operator|)
name|h
operator|.
name|get
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ir
operator|==
literal|null
condition|)
name|h
operator|.
name|put
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
operator|new
name|Integer
argument_list|(
name|equivs
index|[
name|i
index|]
operator|=
name|equiv_max
operator|++
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|equivs
index|[
name|i
index|]
operator|=
name|ir
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Adjust inserts/deletes of blank lines to join changes        as much as possible.         We do something when a run of changed lines include a blank        line at one end and have an excluded blank line at the other.        We are free to choose which blank line is included.        `compareseq' always chooses the one at the beginning,        but usually it is cleaner to consider the following blank line        to be the "change".  The only exception is if the preceding blank line        would join this change to other changes.         @param f the file being compared against     */
name|void
name|shift_boundaries
parameter_list|(
name|file_data
name|f
parameter_list|)
block|{
specifier|final
name|boolean
index|[]
name|changed
init|=
name|changed_flag
decl_stmt|;
specifier|final
name|boolean
index|[]
name|other_changed
init|=
name|f
operator|.
name|changed_flag
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|i_end
init|=
name|buffered_lines
decl_stmt|;
name|int
name|preceding
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|other_preceding
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|other_start
decl_stmt|;
comment|/* Scan forwards to find beginning of another run of changes. 	     Also keep track of the corresponding point in the other file.  */
while|while
condition|(
name|i
operator|<
name|i_end
operator|&&
operator|!
name|changed
index|[
literal|1
operator|+
name|i
index|]
condition|)
block|{
while|while
condition|(
name|other_changed
index|[
literal|1
operator|+
name|j
operator|++
index|]
condition|)
comment|/* Non-corresponding lines in the other file 		   will count as the preceding batch of changes.  */
name|other_preceding
operator|=
name|j
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|i_end
condition|)
break|break;
name|start
operator|=
name|i
expr_stmt|;
name|other_start
operator|=
name|j
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Now find the end of this run of changes.  */
while|while
condition|(
name|i
operator|<
name|i_end
operator|&&
name|changed
index|[
literal|1
operator|+
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
comment|/* If the first changed line matches the following unchanged one, 		 and this run does not follow right after a previous run, 		 and there are no lines deleted from the other file here, 		 then classify the first changed line as unchanged 		 and the following line as changed in its place.  */
comment|/* You might ask, how could this run follow right after another? 		 Only because the previous run was shifted here.  */
if|if
condition|(
name|end
operator|!=
name|i_end
operator|&&
name|equivs
index|[
name|start
index|]
operator|==
name|equivs
index|[
name|end
index|]
operator|&&
operator|!
name|other_changed
index|[
literal|1
operator|+
name|j
index|]
operator|&&
name|end
operator|!=
name|i_end
operator|&&
operator|!
operator|(
operator|(
name|preceding
operator|>=
literal|0
operator|&&
name|start
operator|==
name|preceding
operator|)
operator|||
operator|(
name|other_preceding
operator|>=
literal|0
operator|&&
name|other_start
operator|==
name|other_preceding
operator|)
operator|)
condition|)
block|{
name|changed
index|[
literal|1
operator|+
name|end
operator|++
index|]
operator|=
literal|true
expr_stmt|;
name|changed
index|[
literal|1
operator|+
name|start
operator|++
index|]
operator|=
literal|false
expr_stmt|;
operator|++
name|i
expr_stmt|;
comment|/* Since one line-that-matches is now before this run 		     instead of after, we must advance in the other file 		     to keep in synch.  */
operator|++
name|j
expr_stmt|;
block|}
else|else
break|break;
block|}
name|preceding
operator|=
name|i
expr_stmt|;
name|other_preceding
operator|=
name|j
expr_stmt|;
block|}
block|}
comment|/** Number of elements (lines) in this file. */
specifier|final
name|int
name|buffered_lines
decl_stmt|;
comment|/** Vector, indexed by line number, containing an equivalence code for        each line.  It is this vector that is actually compared with that        of another file to generate differences. */
specifier|private
specifier|final
name|int
index|[]
name|equivs
decl_stmt|;
comment|/** Vector, like the previous one except that        the elements for discarded lines have been squeezed out.  */
specifier|final
name|int
index|[]
name|undiscarded
decl_stmt|;
comment|/** Vector mapping virtual line numbers (not counting discarded lines)        to real ones (counting those lines).  Both are origin-0.  */
specifier|final
name|int
index|[]
name|realindexes
decl_stmt|;
comment|/** Total number of nondiscarded lines. */
name|int
name|nondiscarded_lines
decl_stmt|;
comment|/** Array, indexed by real origin-1 line number,        containing true for a line that is an insertion or a deletion.        The results of comparison are stored here.  */
name|boolean
index|[]
name|changed_flag
decl_stmt|;
block|}
block|}
end_class

end_unit

