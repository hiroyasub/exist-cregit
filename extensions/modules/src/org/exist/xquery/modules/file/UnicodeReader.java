begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2010 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  *  *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|file
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Generic unicode textreader, which will use BOM mark  * to identify the encoding to be used. If BOM is not found  * then use a given default or system encoding.  This is a bug fix   * workaround for a known issue with InputStreamReader not detecting and  * ignoring the UTF-* BOM (EF BB BF).  *  * http://www.unicode.org/unicode/faq/utf_bom.html  * BOMs:  *   00 00 FE FF    = UTF-32, big-endian  *   FF FE 00 00    = UTF-32, little-endian  *   EF BB BF       = UTF-8,  *   FE FF          = UTF-16, big-endian  *   FF FE          = UTF-16, little-endian  *   * Win2k Notepad:  *   Unicode format = UTF-16LE  *  * Based on code by Thomas Weidenfeller and  Aki Nieminen  *  * @author Andrzej Taramina<andrzej@chaeron.com>  * @serial 2008-03-06  * @version 1.1  */
end_comment

begin_class
specifier|public
class|class
name|UnicodeReader
extends|extends
name|Reader
block|{
name|PushbackInputStream
name|internalIn
decl_stmt|;
name|InputStreamReader
name|internalIn2
init|=
literal|null
decl_stmt|;
name|String
name|defaultEnc
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|BOM_SIZE
init|=
literal|4
decl_stmt|;
comment|/**     *     * @param in  inputstream to be read     */
specifier|public
name|UnicodeReader
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|internalIn
operator|=
operator|new
name|PushbackInputStream
argument_list|(
name|in
argument_list|,
name|BOM_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultEnc
operator|=
literal|null
expr_stmt|;
block|}
comment|/**     *     * @param in  inputstream to be read     * @param defaultEnc default encoding if stream does not have      *                   BOM marker. Give NULL to use system-level default.     */
specifier|public
name|UnicodeReader
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|String
name|defaultEnc
parameter_list|)
block|{
name|internalIn
operator|=
operator|new
name|PushbackInputStream
argument_list|(
name|in
argument_list|,
name|BOM_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultEnc
operator|=
name|defaultEnc
expr_stmt|;
block|}
specifier|public
name|String
name|getDefaultEncoding
parameter_list|()
block|{
return|return
operator|(
name|defaultEnc
operator|)
return|;
block|}
comment|/**     * Get stream encoding or NULL if stream is uninitialized.     * Call init() or read() method to initialize it.     */
specifier|public
name|String
name|getEncoding
parameter_list|()
block|{
name|String
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|internalIn2
operator|!=
literal|null
condition|)
block|{
name|ret
operator|=
name|internalIn2
operator|.
name|getEncoding
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/**     * Read-ahead four bytes and check for BOM marks. Extra bytes are     * unread back to the stream, only BOM bytes are skipped.     */
specifier|protected
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|internalIn2
operator|==
literal|null
condition|)
block|{
name|String
name|encoding
decl_stmt|;
name|byte
name|bom
index|[]
init|=
operator|new
name|byte
index|[
name|BOM_SIZE
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|unread
decl_stmt|;
name|n
operator|=
name|internalIn
operator|.
name|read
argument_list|(
name|bom
argument_list|,
literal|0
argument_list|,
name|bom
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bom
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x00
operator|)
operator|&&
operator|(
name|bom
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x00
operator|)
operator|&&
operator|(
name|bom
index|[
literal|2
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFE
operator|)
operator|&&
operator|(
name|bom
index|[
literal|3
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFF
operator|)
condition|)
block|{
name|encoding
operator|=
literal|"UTF-32BE"
expr_stmt|;
name|unread
operator|=
name|n
operator|-
literal|4
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|bom
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFF
operator|)
operator|&&
operator|(
name|bom
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFE
operator|)
operator|&&
operator|(
name|bom
index|[
literal|2
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x00
operator|)
operator|&&
operator|(
name|bom
index|[
literal|3
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x00
operator|)
condition|)
block|{
name|encoding
operator|=
literal|"UTF-32LE"
expr_stmt|;
name|unread
operator|=
name|n
operator|-
literal|4
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|bom
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xEF
operator|)
operator|&&
operator|(
name|bom
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xBB
operator|)
operator|&&
operator|(
name|bom
index|[
literal|2
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xBF
operator|)
condition|)
block|{
name|encoding
operator|=
literal|"UTF-8"
expr_stmt|;
name|unread
operator|=
name|n
operator|-
literal|3
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|bom
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFE
operator|)
operator|&&
operator|(
name|bom
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFF
operator|)
condition|)
block|{
name|encoding
operator|=
literal|"UTF-16BE"
expr_stmt|;
name|unread
operator|=
name|n
operator|-
literal|2
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|bom
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFF
operator|)
operator|&&
operator|(
name|bom
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xFE
operator|)
condition|)
block|{
name|encoding
operator|=
literal|"UTF-16LE"
expr_stmt|;
name|unread
operator|=
name|n
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// Unicode BOM mark not found, unread all bytes
name|encoding
operator|=
name|defaultEnc
expr_stmt|;
name|unread
operator|=
name|n
expr_stmt|;
block|}
comment|//System.out.println("read=" + n + ", unread=" + unread);
if|if
condition|(
name|unread
operator|>
literal|0
condition|)
block|{
name|internalIn
operator|.
name|unread
argument_list|(
name|bom
argument_list|,
operator|(
name|n
operator|-
name|unread
operator|)
argument_list|,
name|unread
argument_list|)
expr_stmt|;
block|}
comment|// Use given encoding
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
block|{
name|internalIn2
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|internalIn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internalIn2
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|internalIn
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|init
argument_list|()
expr_stmt|;
name|internalIn2
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|char
index|[]
name|cbuf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|init
argument_list|()
expr_stmt|;
return|return
operator|(
name|internalIn2
operator|.
name|read
argument_list|(
name|cbuf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
block|}
end_class

end_unit

