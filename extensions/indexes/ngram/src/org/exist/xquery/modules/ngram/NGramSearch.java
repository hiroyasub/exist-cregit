begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2007-09 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  *   *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|EmptyNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|Match
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|ngram
operator|.
name|NGramIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|ngram
operator|.
name|NGramIndexWorker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|ElementValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|XMLChar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|AnalyzeContextInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Atomize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|BasicExpressionVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Cardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Dependency
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|DynamicCardinalityCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|FunctionSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|LocationStep
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|NodeTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Optimizable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQueryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|fn
operator|.
name|FunStringToCodepoints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|AlternativeStrings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|EmptyExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|EndAnchor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|EvaluatableExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|FixedString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|StartAnchor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|Wildcard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|WildcardedExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|query
operator|.
name|WildcardedExpressionSequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|utils
operator|.
name|F
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|utils
operator|.
name|NodeProxies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|ngram
operator|.
name|utils
operator|.
name|NodeSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|util
operator|.
name|Error
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_class
specifier|public
class|class
name|NGramSearch
extends|extends
name|Function
implements|implements
name|Optimizable
block|{
specifier|private
specifier|static
specifier|final
name|String
name|INTERVAL_QUALIFIER_PATTERN
init|=
literal|"\\{([0-9]+),([0-9]+)\\}"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SEARCH_DESCRIPTION
init|=
literal|"Searches the given $queryString in the index "
operator|+
literal|"defined on the input node set $nodes. "
operator|+
literal|"String comparison is case insensitive. Nodes need to have an ngram index to be searched."
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WILDCARD_PATTERN_DESCRIPTION
init|=
literal|"The string to search for."
operator|+
literal|"A full stop, '.', (not between brackets), without any qualifiers: Matches a single arbitrary character."
operator|+
literal|"A full stop, '.', (not between brackets), immediately followed by a single question mark, '?': Matches either no characters or one character."
operator|+
literal|"A full stop, '.', (not between brackets), immediately followed by a single asterisk, '*': Matches zero or more characters."
operator|+
literal|"A full stop, '.', (not between brackets), immediately followed by a single plus sign, '+': Matches one or more characters."
operator|+
literal|"A full stop, '.', immediately followed by a sequence of characters that matches the regular expression {[0-9]+,[0-9]+}: Matches a number of characters, where the number is no less than the number represented by the series of digits before the comma, and no greater than the number represented by the series of digits following the comma."
operator|+
literal|"An  expression  \"[â¦]\"  matches a single character, namely any of the characters"
operator|+
literal|"enclosed by the brackets.  The string enclosed by the brackets cannot be empty; "
operator|+
literal|"therefore ']' can be allowed between  the brackets, provided that it is the first character."
operator|+
literal|"(Thus, \"[][?]\" matches the three characters '[', ']' and '?'.)"
operator|+
literal|"A circumflex accent, '^', at the start of the search string matches the start of the element content."
operator|+
literal|"A dollar sign, '$', at the end of the search string matches the end of the element content."
operator|+
literal|"One can remove the special meaning of any character mentioned above by preceding them by a backslash."
operator|+
literal|"Between brackets these characters stand for themselves.  Thus, \"[[?*\\]\" matches"
operator|+
literal|"the four characters '[', '?', '*' and '\\'."
operator|+
literal|"'?', '*', '+' and character sequences matching the regular expression {[0-9]+,[0-9]+} not immediately preceeded by an unescaped period, '.', stand for themselves."
operator|+
literal|"'^' and '$' not at the very beginning or end of the search string, respectively, stand for themselves."
decl_stmt|;
specifier|protected
specifier|static
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NGramSearch
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|signatures
index|[]
init|=
block|{
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"contains"
argument_list|,
name|NGramModule
operator|.
name|NAMESPACE_URI
argument_list|,
name|NGramModule
operator|.
name|PREFIX
argument_list|)
argument_list|,
literal|"Similar to the standard XQuery fn:contains function, but based on the NGram index. "
operator|+
name|SEARCH_DESCRIPTION
operator|+
literal|"The string may appear at any position within the node content."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"nodes"
argument_list|,
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"The input node set to search"
argument_list|)
block|,
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"queryString"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The exact string to search for"
argument_list|)
block|}
argument_list|,
operator|new
name|FunctionReturnSequenceType
argument_list|(
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"a set of nodes from the input node set $nodes containing the query string "
operator|+
literal|"or the empty sequence"
argument_list|)
argument_list|)
block|,
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"ends-with"
argument_list|,
name|NGramModule
operator|.
name|NAMESPACE_URI
argument_list|,
name|NGramModule
operator|.
name|PREFIX
argument_list|)
argument_list|,
literal|"Similar to the standard XQuery fn:ends-with function, but based on the NGram index. "
operator|+
name|SEARCH_DESCRIPTION
operator|+
literal|"The string has to appear at the end of the node's content."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"nodes"
argument_list|,
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"The input node set to search"
argument_list|)
block|,
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"queryString"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The exact string to search for"
argument_list|)
block|}
argument_list|,
operator|new
name|FunctionReturnSequenceType
argument_list|(
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"a set of nodes from the input node set $nodes ending with the query string "
operator|+
literal|"or the empty sequence"
argument_list|)
argument_list|)
block|,
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"starts-with"
argument_list|,
name|NGramModule
operator|.
name|NAMESPACE_URI
argument_list|,
name|NGramModule
operator|.
name|PREFIX
argument_list|)
argument_list|,
literal|"Similar to the standard XQuery fn:starts-with function, but based on the NGram index. "
operator|+
name|SEARCH_DESCRIPTION
operator|+
literal|"The string has to appear at the start of the node's content."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"nodes"
argument_list|,
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"The input node set to search"
argument_list|)
block|,
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"queryString"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The exact string to search for"
argument_list|)
block|}
argument_list|,
operator|new
name|FunctionReturnSequenceType
argument_list|(
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"a set of nodes from the input node set $nodes starting with the query string "
operator|+
literal|"or the empty sequence"
argument_list|)
argument_list|)
block|,
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"wildcard-contains"
argument_list|,
name|NGramModule
operator|.
name|NAMESPACE_URI
argument_list|,
name|NGramModule
operator|.
name|PREFIX
argument_list|)
argument_list|,
literal|"Similar to the standard XQuery fn:matches function, but based on the NGram index and "
operator|+
literal|"allowing wildcards in the query string. "
operator|+
name|SEARCH_DESCRIPTION
operator|+
literal|"The string has to match the whole node's content."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"nodes"
argument_list|,
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"The input node set to search"
argument_list|)
block|,
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"queryString"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
name|WILDCARD_PATTERN_DESCRIPTION
argument_list|)
block|}
argument_list|,
operator|new
name|FunctionReturnSequenceType
argument_list|(
name|Type
operator|.
name|NODE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_MORE
argument_list|,
literal|"a set of nodes from the input node set $nodes matching the query string "
operator|+
literal|"or the empty sequence"
argument_list|)
argument_list|)
block|}
decl_stmt|;
specifier|private
name|LocationStep
name|contextStep
init|=
literal|null
decl_stmt|;
specifier|protected
name|QName
name|contextQName
init|=
literal|null
decl_stmt|;
specifier|protected
name|int
name|axis
init|=
name|Constants
operator|.
name|UNKNOWN_AXIS
decl_stmt|;
specifier|private
name|NodeSet
name|preselectResult
init|=
literal|null
decl_stmt|;
specifier|protected
name|boolean
name|optimizeSelf
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|optimizeChild
init|=
literal|false
decl_stmt|;
specifier|public
name|NGramSearch
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|FunctionSignature
name|signature
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setArguments
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
throws|throws
name|XPathException
block|{
name|Expression
name|path
init|=
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|steps
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|Expression
name|arg
init|=
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|arg
operator|=
operator|new
name|DynamicCardinalityCheck
argument_list|(
name|context
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
name|arg
argument_list|,
operator|new
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|util
operator|.
name|Error
argument_list|(
name|Error
operator|.
name|FUNC_PARAM_CARDINALITY
argument_list|,
literal|"2"
argument_list|,
name|mySignature
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Type
operator|.
name|subTypeOf
argument_list|(
name|arg
operator|.
name|returnsType
argument_list|()
argument_list|,
name|Type
operator|.
name|ATOMIC
argument_list|)
condition|)
name|arg
operator|=
operator|new
name|Atomize
argument_list|(
name|context
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|steps
operator|.
name|add
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/*      * (non-Javadoc)      *     * @see org.exist.xquery.PathExpr#analyze(org.exist.xquery.Expression)     */
annotation|@
name|Override
specifier|public
name|void
name|analyze
parameter_list|(
name|AnalyzeContextInfo
name|contextInfo
parameter_list|)
throws|throws
name|XPathException
block|{
name|super
operator|.
name|analyze
argument_list|(
name|contextInfo
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LocationStep
argument_list|>
name|steps
init|=
name|BasicExpressionVisitor
operator|.
name|findLocationSteps
argument_list|(
name|getArgument
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|steps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LocationStep
name|firstStep
init|=
name|steps
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|LocationStep
name|lastStep
init|=
name|steps
operator|.
name|get
argument_list|(
name|steps
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|steps
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|firstStep
operator|.
name|getAxis
argument_list|()
operator|==
name|Constants
operator|.
name|SELF_AXIS
condition|)
block|{
name|Expression
name|outerExpr
init|=
name|contextInfo
operator|.
name|getContextStep
argument_list|()
decl_stmt|;
if|if
condition|(
name|outerExpr
operator|!=
literal|null
operator|&&
name|outerExpr
operator|instanceof
name|LocationStep
condition|)
block|{
name|LocationStep
name|outerStep
init|=
operator|(
name|LocationStep
operator|)
name|outerExpr
decl_stmt|;
name|NodeTest
name|test
init|=
name|outerStep
operator|.
name|getTest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|test
operator|.
name|isWildcardTest
argument_list|()
operator|&&
name|test
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|contextQName
operator|=
operator|new
name|QName
argument_list|(
name|test
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|outerStep
operator|.
name|getAxis
argument_list|()
operator|==
name|Constants
operator|.
name|ATTRIBUTE_AXIS
operator|||
name|outerStep
operator|.
name|getAxis
argument_list|()
operator|==
name|Constants
operator|.
name|DESCENDANT_ATTRIBUTE_AXIS
condition|)
name|contextQName
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|contextStep
operator|=
name|firstStep
expr_stmt|;
name|axis
operator|=
name|outerStep
operator|.
name|getAxis
argument_list|()
expr_stmt|;
name|optimizeSelf
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|NodeTest
name|test
init|=
name|lastStep
operator|.
name|getTest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|test
operator|.
name|isWildcardTest
argument_list|()
operator|&&
name|test
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|contextQName
operator|=
operator|new
name|QName
argument_list|(
name|test
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastStep
operator|.
name|getAxis
argument_list|()
operator|==
name|Constants
operator|.
name|ATTRIBUTE_AXIS
operator|||
name|lastStep
operator|.
name|getAxis
argument_list|()
operator|==
name|Constants
operator|.
name|DESCENDANT_ATTRIBUTE_AXIS
condition|)
name|contextQName
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|axis
operator|=
name|firstStep
operator|.
name|getAxis
argument_list|()
expr_stmt|;
name|optimizeChild
operator|=
name|steps
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|(
name|axis
operator|==
name|Constants
operator|.
name|CHILD_AXIS
operator|||
name|axis
operator|==
name|Constants
operator|.
name|ATTRIBUTE_AXIS
operator|)
expr_stmt|;
name|contextStep
operator|=
name|lastStep
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|canOptimize
parameter_list|(
name|Sequence
name|contextSequence
parameter_list|)
block|{
return|return
name|contextQName
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|optimizeOnSelf
parameter_list|()
block|{
return|return
name|optimizeSelf
return|;
block|}
specifier|public
name|boolean
name|optimizeOnChild
parameter_list|()
block|{
return|return
name|optimizeChild
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getOptimizeAxis
parameter_list|()
block|{
return|return
name|axis
return|;
block|}
annotation|@
name|Override
specifier|public
name|NodeSet
name|preSelect
parameter_list|(
name|Sequence
name|contextSequence
parameter_list|,
name|boolean
name|useContext
parameter_list|)
throws|throws
name|XPathException
block|{
comment|// the expression can be called multiple times, so we need to clear the previous preselectResult
name|preselectResult
operator|=
literal|null
expr_stmt|;
name|NGramIndexWorker
name|index
init|=
operator|(
name|NGramIndexWorker
operator|)
name|context
operator|.
name|getBroker
argument_list|()
operator|.
name|getIndexController
argument_list|()
operator|.
name|getWorkerByIndexId
argument_list|(
name|NGramIndex
operator|.
name|ID
argument_list|)
decl_stmt|;
name|DocumentSet
name|docs
init|=
name|contextSequence
operator|.
name|getDocumentSet
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|getArgument
argument_list|(
literal|1
argument_list|)
operator|.
name|eval
argument_list|(
name|contextSequence
argument_list|)
operator|.
name|getStringValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
init|=
operator|new
name|ArrayList
argument_list|<
name|QName
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|qnames
operator|.
name|add
argument_list|(
name|contextQName
argument_list|)
expr_stmt|;
name|preselectResult
operator|=
name|processMatches
argument_list|(
name|index
argument_list|,
name|docs
argument_list|,
name|qnames
argument_list|,
name|key
argument_list|,
name|useContext
condition|?
name|contextSequence
operator|.
name|toNodeSet
argument_list|()
else|:
literal|null
argument_list|,
name|NodeSet
operator|.
name|DESCENDANT
argument_list|)
expr_stmt|;
return|return
name|preselectResult
return|;
block|}
annotation|@
name|Override
specifier|public
name|Sequence
name|eval
parameter_list|(
name|Sequence
name|contextSequence
parameter_list|,
name|Item
name|contextItem
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|contextItem
operator|!=
literal|null
condition|)
name|contextSequence
operator|=
name|contextItem
operator|.
name|toSequence
argument_list|()
expr_stmt|;
name|NodeSet
name|result
decl_stmt|;
if|if
condition|(
name|preselectResult
operator|==
literal|null
condition|)
block|{
name|Sequence
name|input
init|=
name|getArgument
argument_list|(
literal|0
argument_list|)
operator|.
name|eval
argument_list|(
name|contextSequence
argument_list|,
name|contextItem
argument_list|)
decl_stmt|;
if|if
condition|(
name|input
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|=
name|NodeSet
operator|.
name|EMPTY_SET
expr_stmt|;
else|else
block|{
name|NodeSet
name|inNodes
init|=
name|input
operator|.
name|toNodeSet
argument_list|()
decl_stmt|;
name|DocumentSet
name|docs
init|=
name|inNodes
operator|.
name|getDocumentSet
argument_list|()
decl_stmt|;
name|NGramIndexWorker
name|index
init|=
operator|(
name|NGramIndexWorker
operator|)
name|context
operator|.
name|getBroker
argument_list|()
operator|.
name|getIndexController
argument_list|()
operator|.
name|getWorkerByIndexId
argument_list|(
name|NGramIndex
operator|.
name|ID
argument_list|)
decl_stmt|;
comment|//Alternate design
comment|// NGramIndexWorker index =
comment|// (NGramIndexWorker)context.getBroker().getBrokerPool().getIndexManager().getIndexById(NGramIndex.ID).getWorker();
name|String
name|key
init|=
name|getArgument
argument_list|(
literal|1
argument_list|)
operator|.
name|eval
argument_list|(
name|contextSequence
argument_list|,
name|contextItem
argument_list|)
operator|.
name|getStringValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|contextQName
operator|!=
literal|null
condition|)
block|{
name|qnames
operator|=
operator|new
name|ArrayList
argument_list|<
name|QName
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|qnames
operator|.
name|add
argument_list|(
name|contextQName
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|processMatches
argument_list|(
name|index
argument_list|,
name|docs
argument_list|,
name|qnames
argument_list|,
name|key
argument_list|,
name|inNodes
argument_list|,
name|NodeSet
operator|.
name|ANCESTOR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|contextStep
operator|.
name|setPreloadedData
argument_list|(
name|contextSequence
operator|.
name|getDocumentSet
argument_list|()
argument_list|,
name|preselectResult
argument_list|)
expr_stmt|;
name|result
operator|=
name|getArgument
argument_list|(
literal|0
argument_list|)
operator|.
name|eval
argument_list|(
name|contextSequence
argument_list|)
operator|.
name|toNodeSet
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|String
name|getLocalName
parameter_list|()
block|{
return|return
name|getSignature
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalName
argument_list|()
return|;
block|}
specifier|private
name|NodeSet
name|processMatches
parameter_list|(
name|NGramIndexWorker
name|index
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
parameter_list|,
name|String
name|query
parameter_list|,
name|NodeSet
name|nodeSet
parameter_list|,
name|int
name|axis
parameter_list|)
throws|throws
name|XPathException
block|{
name|EvaluatableExpression
name|parsedQuery
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"wildcard-contains"
argument_list|)
condition|)
name|parsedQuery
operator|=
name|parseQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
else|else
name|parsedQuery
operator|=
operator|new
name|FixedString
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Parsed Query: "
operator|+
name|parsedQuery
argument_list|)
expr_stmt|;
name|NodeSet
name|result
init|=
name|parsedQuery
operator|.
name|eval
argument_list|(
name|index
argument_list|,
name|docs
argument_list|,
name|qnames
argument_list|,
name|nodeSet
argument_list|,
name|axis
argument_list|,
name|this
operator|.
name|getExpressionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|getLocalName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"starts-with"
argument_list|)
condition|)
name|result
operator|=
name|NodeSets
operator|.
name|getNodesMatchingAtStart
argument_list|(
name|result
argument_list|,
name|getExpressionId
argument_list|()
argument_list|)
expr_stmt|;
if|else if
condition|(
name|getLocalName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"ends-with"
argument_list|)
condition|)
name|result
operator|=
name|NodeSets
operator|.
name|getNodesMatchingAtEnd
argument_list|(
name|result
argument_list|,
name|getExpressionId
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|NodeSets
operator|.
name|fmapNodes
argument_list|(
name|result
argument_list|,
operator|new
name|F
argument_list|<
name|NodeProxy
argument_list|,
name|NodeProxy
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeProxy
name|f
parameter_list|(
name|NodeProxy
name|a
parameter_list|)
block|{
return|return
name|NodeProxies
operator|.
name|fmapOwnMatches
argument_list|(
name|a
argument_list|,
operator|new
name|F
argument_list|<
name|Match
argument_list|,
name|Match
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Match
name|f
parameter_list|(
name|Match
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|filterOutOverlappingOffsets
argument_list|()
return|;
block|}
block|}
argument_list|,
name|getExpressionId
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|EvaluatableExpression
name|parseQuery
parameter_list|(
specifier|final
name|String
name|query
parameter_list|)
throws|throws
name|XPathException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|queryTokens
init|=
name|tokenizeQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Tokenized query: "
operator|+
name|queryTokens
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryTokens
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|new
name|EmptyExpression
argument_list|()
return|;
name|List
argument_list|<
name|WildcardedExpression
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|WildcardedExpression
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryTokens
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
literal|"^"
argument_list|)
condition|)
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|StartAnchor
argument_list|()
argument_list|)
expr_stmt|;
name|queryTokens
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryTokens
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|new
name|EmptyExpression
argument_list|()
return|;
name|boolean
name|endAnchorPresent
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|queryTokens
operator|.
name|get
argument_list|(
name|queryTokens
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
name|endAnchorPresent
operator|=
literal|true
expr_stmt|;
name|queryTokens
operator|.
name|remove
argument_list|(
name|queryTokens
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryTokens
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|new
name|EmptyExpression
argument_list|()
return|;
for|for
control|(
name|String
name|token
range|:
name|queryTokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|Wildcard
name|wildcard
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
name|wildcard
operator|=
operator|new
name|Wildcard
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|qualifier
init|=
name|token
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifier
operator|.
name|equals
argument_list|(
literal|"?"
argument_list|)
condition|)
name|wildcard
operator|=
operator|new
name|Wildcard
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|else if
condition|(
name|qualifier
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
name|wildcard
operator|=
operator|new
name|Wildcard
argument_list|(
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|else if
condition|(
name|qualifier
operator|.
name|equals
argument_list|(
literal|"+"
argument_list|)
condition|)
name|wildcard
operator|=
operator|new
name|Wildcard
argument_list|(
literal|1
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
else|else
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|INTERVAL_QUALIFIER_PATTERN
argument_list|)
decl_stmt|;
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|matches
argument_list|()
condition|)
comment|// Should not happen
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"err:FTDY0020: query string violates wildcard qualifier syntax"
argument_list|)
throw|;
try|try
block|{
name|wildcard
operator|=
operator|new
name|Wildcard
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"err:FTDY0020: query string violates wildcard qualifier syntax"
argument_list|,
name|nfe
argument_list|)
throw|;
block|}
block|}
block|}
name|expressions
operator|.
name|add
argument_list|(
name|wildcard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|token
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|token
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|token
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|strings
operator|.
name|add
argument_list|(
name|Character
operator|.
name|toString
argument_list|(
name|token
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|AlternativeStrings
argument_list|(
name|this
argument_list|,
name|strings
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|FixedString
argument_list|(
name|this
argument_list|,
name|unescape
argument_list|(
name|token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|endAnchorPresent
condition|)
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|EndAnchor
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|WildcardedExpressionSequence
argument_list|(
name|expressions
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|unescape
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\\\\(.)"
argument_list|,
literal|"$1"
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|tokenizeQuery
parameter_list|(
specifier|final
name|String
name|query
parameter_list|)
throws|throws
name|XPathException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|token
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|query
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|currentChar
init|=
name|query
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
condition|)
block|{
comment|// Escape sequence
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|query
operator|.
name|length
argument_list|()
condition|)
block|{
name|token
operator|.
name|append
argument_list|(
name|query
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"err:FTDY0020: query string is terminated by an unescaped backslash"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|currentChar
operator|==
literal|'.'
condition|)
block|{
name|int
name|wildcardEnd
init|=
name|i
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|query
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|peek
init|=
name|query
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'?'
operator|||
name|peek
operator|==
literal|'*'
operator|||
name|peek
operator|==
literal|'+'
condition|)
name|wildcardEnd
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'{'
condition|)
block|{
name|wildcardEnd
operator|=
name|query
operator|.
name|indexOf
argument_list|(
literal|'}'
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildcardEnd
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"err:FTDY0020: query string violates wildcard syntax: Unmatched qualifier start { in query string; marked by<-- HERE in \""
operator|+
name|query
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|+
literal|"<-- HERE "
operator|+
name|query
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|+
literal|"\""
argument_list|)
throw|;
if|if
condition|(
operator|!
name|query
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|wildcardEnd
operator|+
literal|1
argument_list|)
operator|.
name|matches
argument_list|(
name|INTERVAL_QUALIFIER_PATTERN
argument_list|)
condition|)
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"err:FTDY0020: query string violates wildcard qualifier syntax;  marked by<-- HERE in \""
operator|+
name|query
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|wildcardEnd
operator|+
literal|1
argument_list|)
operator|+
literal|"<-- HERE "
operator|+
name|query
operator|.
name|substring
argument_list|(
name|wildcardEnd
operator|+
literal|1
argument_list|)
operator|+
literal|"\""
argument_list|)
throw|;
block|}
block|}
name|result
operator|.
name|add
argument_list|(
name|query
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|wildcardEnd
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|wildcardEnd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentChar
operator|==
literal|'['
condition|)
block|{
name|int
name|characterClassEnd
init|=
name|query
operator|.
name|indexOf
argument_list|(
literal|']'
argument_list|,
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// Character classses can not be empty, thus
comment|// start search for end at i+2
if|if
condition|(
name|characterClassEnd
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"err:FTDY0020: query string violates wildcard syntax: Unmatched [ in query string; marked by<-- HERE in \""
operator|+
name|query
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|+
literal|"<-- HERE "
operator|+
name|query
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|+
literal|"\""
argument_list|)
throw|;
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|query
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|characterClassEnd
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|characterClassEnd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentChar
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
literal|"^"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|currentChar
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
block|}
else|else
comment|// default case
name|token
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|NodeSet
name|fixedStringSearch
parameter_list|(
specifier|final
name|NGramIndexWorker
name|index
parameter_list|,
specifier|final
name|DocumentSet
name|docs
parameter_list|,
specifier|final
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
parameter_list|,
specifier|final
name|String
name|query
parameter_list|,
specifier|final
name|NodeSet
name|nodeSet
parameter_list|,
specifier|final
name|int
name|axis
parameter_list|)
throws|throws
name|XPathException
block|{
name|String
index|[]
name|ngrams
init|=
name|NGramSearch
operator|.
name|getDistinctNGrams
argument_list|(
name|query
argument_list|,
name|index
operator|.
name|getN
argument_list|()
argument_list|)
decl_stmt|;
comment|// Nothing to search for? The find nothing.
if|if
condition|(
name|ngrams
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|new
name|EmptyNodeSet
argument_list|()
return|;
name|String
name|firstNgramm
init|=
name|ngrams
index|[
literal|0
index|]
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"First NGRAM: "
operator|+
name|firstNgramm
argument_list|)
expr_stmt|;
name|NodeSet
name|result
init|=
name|index
operator|.
name|search
argument_list|(
name|getExpressionId
argument_list|()
argument_list|,
name|docs
argument_list|,
name|qnames
argument_list|,
name|firstNgramm
argument_list|,
name|firstNgramm
argument_list|,
name|context
argument_list|,
name|nodeSet
argument_list|,
name|axis
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ngrams
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|ngram
init|=
name|ngrams
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
name|ngram
operator|.
name|codePointCount
argument_list|(
literal|0
argument_list|,
name|ngram
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|fillSize
init|=
name|index
operator|.
name|getN
argument_list|()
operator|-
name|len
decl_stmt|;
name|String
name|filledNgram
init|=
name|ngram
decl_stmt|;
comment|// if this ngram is shorter than n,
comment|// fill it up with characters from the previous ngram. too short
comment|// ngrams lead to a considerable performance loss.
if|if
condition|(
name|fillSize
operator|>
literal|0
condition|)
block|{
name|String
name|filler
init|=
name|ngrams
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|filler
operator|.
name|offsetByCodePoints
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fillSize
condition|;
name|j
operator|++
control|)
block|{
name|int
name|codepoint
init|=
name|filler
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|codepoint
argument_list|)
expr_stmt|;
name|buf
operator|.
name|appendCodePoint
argument_list|(
name|codepoint
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|ngram
argument_list|)
expr_stmt|;
name|filledNgram
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Filled: "
operator|+
name|filledNgram
argument_list|)
expr_stmt|;
block|}
name|NodeSet
name|nodes
init|=
name|index
operator|.
name|search
argument_list|(
name|getExpressionId
argument_list|()
argument_list|,
name|docs
argument_list|,
name|qnames
argument_list|,
name|filledNgram
argument_list|,
name|ngram
argument_list|,
name|context
argument_list|,
name|nodeSet
argument_list|,
name|axis
argument_list|)
decl_stmt|;
specifier|final
name|NodeSet
name|nodesContainingFirstINgrams
init|=
name|result
decl_stmt|;
name|result
operator|=
name|NodeSets
operator|.
name|fmapNodes
argument_list|(
name|nodes
argument_list|,
operator|new
name|F
argument_list|<
name|NodeProxy
argument_list|,
name|NodeProxy
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeProxy
name|f
parameter_list|(
name|NodeProxy
name|a
parameter_list|)
block|{
name|NodeProxy
name|before
init|=
name|nodesContainingFirstINgrams
operator|.
name|get
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|before
operator|!=
literal|null
condition|)
block|{
return|return
name|getContinuousMatches
argument_list|(
name|before
argument_list|,
name|a
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Finds all matches in head which are followed by matches in tail in the specified distance.      *      * @param head      *            a nodeset with matches      * @param tail      *            another nodeset with matches      * @return a nodeset containing all matches from the head which are directly followed by matches in the tail      */
specifier|private
name|NodeProxy
name|getContinuousMatches
parameter_list|(
specifier|final
name|NodeProxy
name|head
parameter_list|,
specifier|final
name|NodeProxy
name|tail
parameter_list|)
block|{
comment|// NodeSet result = new ExtArrayNodeSet();
name|Match
name|continuousMatch
init|=
literal|null
decl_stmt|;
name|Match
name|headMatch
init|=
name|head
operator|.
name|getMatches
argument_list|()
decl_stmt|;
while|while
condition|(
name|headMatch
operator|!=
literal|null
operator|&&
name|continuousMatch
operator|==
literal|null
condition|)
block|{
name|Match
name|tailMatch
init|=
name|tail
operator|.
name|getMatches
argument_list|()
decl_stmt|;
while|while
condition|(
name|tailMatch
operator|!=
literal|null
operator|&&
name|continuousMatch
operator|==
literal|null
condition|)
block|{
name|continuousMatch
operator|=
name|headMatch
operator|.
name|continuedBy
argument_list|(
name|tailMatch
argument_list|)
expr_stmt|;
name|tailMatch
operator|=
name|tailMatch
operator|.
name|getNextMatch
argument_list|()
expr_stmt|;
block|}
name|headMatch
operator|=
name|headMatch
operator|.
name|getNextMatch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|continuousMatch
operator|!=
literal|null
condition|)
block|{
name|NodeProxies
operator|.
name|filterMatches
argument_list|(
name|tail
argument_list|,
operator|new
name|F
argument_list|<
name|Match
argument_list|,
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|f
parameter_list|(
name|Match
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
operator|.
name|getContextId
argument_list|()
operator|!=
name|getExpressionId
argument_list|()
operator|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|tail
operator|.
name|addMatch
argument_list|(
name|continuousMatch
argument_list|)
expr_stmt|;
return|return
name|tail
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getDependencies
parameter_list|()
block|{
specifier|final
name|Expression
name|stringArg
init|=
name|getArgument
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Type
operator|.
name|subTypeOf
argument_list|(
name|stringArg
operator|.
name|returnsType
argument_list|()
argument_list|,
name|Type
operator|.
name|NODE
argument_list|)
operator|&&
operator|!
name|Dependency
operator|.
name|dependsOn
argument_list|(
name|stringArg
argument_list|,
name|Dependency
operator|.
name|CONTEXT_ITEM
argument_list|)
condition|)
block|{
return|return
name|Dependency
operator|.
name|CONTEXT_SET
return|;
block|}
else|else
block|{
return|return
name|Dependency
operator|.
name|CONTEXT_SET
operator|+
name|Dependency
operator|.
name|CONTEXT_ITEM
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|returnsType
parameter_list|()
block|{
return|return
name|Type
operator|.
name|NODE
return|;
block|}
comment|/**      * Split the specified string into a sequence of ngrams to be used for querying the index. For example, if we have a      * 3-gram index, the string 'distinct' will be split into the ngrams 'dis', 'tin' and 'ct'.      *      * @param text      *            the character sequence to split      * @return a sequence of ngrams. the last item might be shorter than n.      */
specifier|private
specifier|static
name|String
index|[]
name|getDistinctNGrams
parameter_list|(
specifier|final
name|String
name|text
parameter_list|,
specifier|final
name|int
name|ngramSize
parameter_list|)
block|{
name|int
name|len
init|=
name|text
operator|.
name|codePointCount
argument_list|(
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|len
operator|/
name|ngramSize
decl_stmt|;
name|int
name|remainder
init|=
name|len
operator|%
name|ngramSize
decl_stmt|;
name|String
index|[]
name|n
init|=
operator|new
name|String
index|[
operator|(
name|remainder
operator|>
literal|0
condition|?
name|count
operator|+
literal|1
else|:
name|count
operator|)
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|StringBuilder
name|bld
init|=
operator|new
name|StringBuilder
argument_list|(
name|ngramSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ngramSize
condition|;
name|j
operator|++
control|)
block|{
name|int
name|next
init|=
name|Character
operator|.
name|toLowerCase
argument_list|(
name|text
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|bld
operator|.
name|appendCodePoint
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|n
index|[
name|i
index|]
operator|=
name|bld
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
name|StringBuilder
name|bld
init|=
operator|new
name|StringBuilder
argument_list|(
name|remainder
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|remainder
condition|;
name|j
operator|++
control|)
block|{
name|int
name|next
init|=
name|Character
operator|.
name|toLowerCase
argument_list|(
name|text
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|bld
operator|.
name|appendCodePoint
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|n
index|[
name|count
index|]
operator|=
name|bld
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
block|}
end_class

end_unit

