begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2008-2015 The eXist-db Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|lucene
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|standard
operator|.
name|StandardAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|DrillDownQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|Facets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|FacetsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|FacetsConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|FastTaxonomyFacetCounts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|SearcherTaxonomyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|directory
operator|.
name|DirectoryTaxonomyReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryparser
operator|.
name|classic
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|MemTreeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
operator|.
name|ReindexMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|lucene
operator|.
name|PlainTextHighlighter
operator|.
name|Offset
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|lucene
operator|.
name|PlainTextIndexConfig
operator|.
name|PlainTextField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|DatabaseConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Occurrences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|pool
operator|.
name|NodePool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|modules
operator|.
name|lucene
operator|.
name|QueryOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|helpers
operator|.
name|AttributesImpl
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|XMLConstants
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Class for handling all Lucene operations.  *  * @author<a href="mailto:wolfgang@exist-db.org">Wolfgang Meier</a>  * @author<a href="mailto:dannes@exist-db.org">Dannes Wessels</a>  * @author<a href="mailto:ljo@exist-db.org">Leif-JÃ¶ran Olsson</a>  */
end_comment

begin_class
specifier|public
class|class
name|LuceneIndexWorker
implements|implements
name|OrderedValuesIndex
implements|,
name|QNamedKeysIndex
block|{
specifier|public
specifier|static
specifier|final
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
name|TYPE_NODE_ID
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
argument_list|()
decl_stmt|;
static|static
block|{
name|TYPE_NODE_ID
operator|.
name|setIndexed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TYPE_NODE_ID
operator|.
name|setStored
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TYPE_NODE_ID
operator|.
name|setOmitNorms
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TYPE_NODE_ID
operator|.
name|setStoreTermVectors
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TYPE_NODE_ID
operator|.
name|setTokenized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|LuceneIndexWorker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|LuceneIndex
name|index
decl_stmt|;
specifier|private
name|LuceneMatchListener
name|matchListener
init|=
literal|null
decl_stmt|;
specifier|private
name|XMLToQuery
name|queryTranslator
decl_stmt|;
specifier|private
name|DBBroker
name|broker
decl_stmt|;
specifier|private
name|DocumentImpl
name|currentDoc
init|=
literal|null
decl_stmt|;
specifier|private
name|ReindexMode
name|mode
init|=
name|ReindexMode
operator|.
name|STORE
decl_stmt|;
specifier|private
name|LuceneConfig
name|config
decl_stmt|;
specifier|private
name|Deque
argument_list|<
name|TextExtractor
argument_list|>
name|contentStack
init|=
literal|null
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|NodeId
argument_list|>
name|nodesToRemove
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|PendingDoc
argument_list|>
name|nodesToWrite
init|=
literal|null
decl_stmt|;
specifier|private
name|Document
name|pendingDoc
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|canFlush
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|cachedNodesSize
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|maxCachedNodesSize
init|=
literal|4096
operator|*
literal|1024
decl_stmt|;
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_DOC_ID
init|=
literal|"docId"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_DOC_URI
init|=
literal|"docUri"
decl_stmt|;
specifier|private
specifier|final
name|StreamListener
name|listener
init|=
operator|new
name|LuceneStreamListener
argument_list|()
decl_stmt|;
specifier|public
name|LuceneIndexWorker
parameter_list|(
name|LuceneIndex
name|parent
parameter_list|,
name|DBBroker
name|broker
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|broker
operator|=
name|broker
expr_stmt|;
name|this
operator|.
name|queryTranslator
operator|=
operator|new
name|XMLToQuery
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|getIndexId
parameter_list|()
block|{
return|return
name|LuceneIndex
operator|.
name|ID
return|;
block|}
specifier|public
name|String
name|getIndexName
parameter_list|()
block|{
return|return
name|index
operator|.
name|getIndexName
argument_list|()
return|;
block|}
specifier|public
name|QueryRewriter
name|getQueryRewriter
parameter_list|(
name|XQueryContext
name|context
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|Object
name|configure
parameter_list|(
name|IndexController
name|controller
parameter_list|,
name|NodeList
name|configNodes
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaces
parameter_list|)
throws|throws
name|DatabaseConfigurationException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Configuring lucene index..."
argument_list|)
expr_stmt|;
name|config
operator|=
operator|new
name|LuceneConfig
argument_list|(
name|configNodes
argument_list|,
name|namespaces
argument_list|)
expr_stmt|;
return|return
name|config
return|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|STORE
case|:
name|write
argument_list|()
expr_stmt|;
break|break;
case|case
name|REMOVE_ALL_NODES
case|:
name|removeDocument
argument_list|(
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|REMOVE_SOME_NODES
case|:
name|removeNodes
argument_list|()
expr_stmt|;
break|break;
case|case
name|REMOVE_BINARY
case|:
name|removePlainTextIndexes
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDocument
parameter_list|(
name|DocumentImpl
name|document
parameter_list|)
block|{
name|setDocument
argument_list|(
name|document
argument_list|,
name|ReindexMode
operator|.
name|UNKNOWN
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDocument
parameter_list|(
name|DocumentImpl
name|document
parameter_list|,
name|ReindexMode
name|newMode
parameter_list|)
block|{
name|currentDoc
operator|=
name|document
expr_stmt|;
comment|//config = null;
name|contentStack
operator|=
literal|null
expr_stmt|;
name|IndexSpec
name|indexConf
init|=
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexConf
operator|!=
literal|null
condition|)
block|{
name|config
operator|=
operator|(
name|LuceneConfig
operator|)
name|indexConf
operator|.
name|getCustomIndexSpec
argument_list|(
name|LuceneIndex
operator|.
name|ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
comment|// Create a copy of the original LuceneConfig (there's only one per db instance),
comment|// so we can safely work with it.
name|config
operator|=
operator|new
name|LuceneConfig
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|LuceneConfig
operator|.
name|DEFAULT_CONFIG
expr_stmt|;
block|}
name|mode
operator|=
name|newMode
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setMode
parameter_list|(
name|ReindexMode
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|STORE
case|:
if|if
condition|(
name|nodesToWrite
operator|==
literal|null
condition|)
name|nodesToWrite
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
else|else
name|nodesToWrite
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cachedNodesSize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REMOVE_SOME_NODES
case|:
name|nodesToRemove
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getDocument
parameter_list|()
block|{
return|return
name|currentDoc
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReindexMode
name|getMode
parameter_list|()
block|{
return|return
name|this
operator|.
name|mode
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|IStoredNode
name|getReindexRoot
parameter_list|(
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|NodePath
name|path
parameter_list|,
name|boolean
name|insert
parameter_list|,
name|boolean
name|includeSelf
parameter_list|)
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
condition|)
block|{
comment|// check if sibling attributes or parent element need reindexing
name|IStoredNode
name|parentStoredNode
init|=
name|node
operator|.
name|getParentStoredNode
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|LuceneIndexConfig
argument_list|>
name|configIt
init|=
name|config
operator|.
name|getConfig
argument_list|(
name|parentStoredNode
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|configIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LuceneIndexConfig
name|idxConfig
init|=
name|configIt
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|idxConfig
operator|.
name|shouldReindexOnAttributeChange
argument_list|()
operator|&&
name|idxConfig
operator|.
name|match
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// reindex from attribute parent
return|return
name|parentStoredNode
return|;
block|}
block|}
name|NamedNodeMap
name|attributes
init|=
name|parentStoredNode
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|IStoredNode
argument_list|<
name|?
argument_list|>
name|attr
init|=
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
name|attributes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
operator|.
name|getPrefix
argument_list|()
operator|!=
literal|null
operator|&&
name|XMLConstants
operator|.
name|XMLNS_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attr
operator|.
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|configIt
operator|=
name|config
operator|.
name|getConfig
argument_list|(
name|attr
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|configIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LuceneIndexConfig
name|idxConfig
init|=
name|configIt
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|idxConfig
operator|.
name|shouldReindexOnAttributeChange
argument_list|()
operator|&&
name|idxConfig
operator|.
name|match
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// reindex from attribute parent
return|return
name|parentStoredNode
return|;
block|}
block|}
block|}
comment|// found no reason to reindex
return|return
literal|null
return|;
block|}
name|NodePath2
name|p
init|=
operator|new
name|NodePath2
argument_list|(
operator|(
name|NodePath2
operator|)
name|path
argument_list|)
decl_stmt|;
name|boolean
name|reindexRequired
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
operator|!
name|includeSelf
condition|)
name|p
operator|.
name|removeLastNode
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|config
operator|.
name|matches
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|reindexRequired
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|p
operator|.
name|removeLastNode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reindexRequired
condition|)
block|{
name|p
operator|=
operator|new
name|NodePath2
argument_list|(
operator|(
name|NodePath2
operator|)
name|path
argument_list|)
expr_stmt|;
name|IStoredNode
name|topMost
init|=
literal|null
decl_stmt|;
name|IStoredNode
name|currentNode
init|=
name|node
decl_stmt|;
if|if
condition|(
name|currentNode
operator|.
name|getNodeType
argument_list|()
operator|!=
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentNode
operator|=
name|currentNode
operator|.
name|getParentStoredNode
argument_list|()
expr_stmt|;
while|while
condition|(
name|currentNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|config
operator|.
name|matches
argument_list|(
name|p
argument_list|)
condition|)
name|topMost
operator|=
name|currentNode
expr_stmt|;
name|currentNode
operator|=
name|currentNode
operator|.
name|getParentStoredNode
argument_list|()
expr_stmt|;
name|p
operator|.
name|removeLastNode
argument_list|()
expr_stmt|;
block|}
return|return
name|topMost
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|StreamListener
name|getListener
parameter_list|()
block|{
return|return
name|listener
return|;
block|}
annotation|@
name|Override
specifier|public
name|MatchListener
name|getMatchListener
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|NodeProxy
name|proxy
parameter_list|)
block|{
name|boolean
name|needToFilter
init|=
literal|false
decl_stmt|;
name|Match
name|nextMatch
init|=
name|proxy
operator|.
name|getMatches
argument_list|()
decl_stmt|;
while|while
condition|(
name|nextMatch
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nextMatch
operator|.
name|getIndexId
argument_list|()
operator|.
name|equals
argument_list|(
name|LuceneIndex
operator|.
name|ID
argument_list|)
condition|)
block|{
name|needToFilter
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|nextMatch
operator|=
name|nextMatch
operator|.
name|getNextMatch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|needToFilter
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|matchListener
operator|==
literal|null
condition|)
name|matchListener
operator|=
operator|new
name|LuceneMatchListener
argument_list|(
name|index
argument_list|,
name|broker
argument_list|,
name|proxy
argument_list|)
expr_stmt|;
else|else
name|matchListener
operator|.
name|reset
argument_list|(
name|broker
argument_list|,
name|proxy
argument_list|)
expr_stmt|;
return|return
name|matchListener
return|;
block|}
specifier|protected
name|void
name|removeDocument
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|()
expr_stmt|;
specifier|final
name|BytesRefBuilder
name|bytes
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|NumericUtils
operator|.
name|intToPrefixCoded
argument_list|(
name|docId
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|Term
name|dt
init|=
operator|new
name|Term
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|bytes
operator|.
name|toBytesRef
argument_list|()
argument_list|)
decl_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while removing lucene index: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ReindexMode
operator|.
name|STORE
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|removePlainTextIndexes
parameter_list|()
block|{
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|()
expr_stmt|;
name|String
name|uri
init|=
name|currentDoc
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Term
name|dt
init|=
operator|new
name|Term
argument_list|(
name|FIELD_DOC_URI
argument_list|,
name|uri
argument_list|)
decl_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while removing lucene index: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ReindexMode
operator|.
name|STORE
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|boolean
name|reindex
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|broker
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|doc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|BytesRefBuilder
name|bytes
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|NumericUtils
operator|.
name|intToPrefixCoded
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|Term
name|dt
init|=
operator|new
name|Term
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|bytes
operator|.
name|toBytesRef
argument_list|()
argument_list|)
decl_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while removing lucene index: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reindex
condition|)
block|{
try|try
block|{
name|index
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception during reindex: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|mode
operator|=
name|ReindexMode
operator|.
name|STORE
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Collection removed."
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove specific nodes from the index. This method is used for node updates      * and called from flush() if the worker is in {@link ReindexMode#REMOVE_SOME_NODES}      * mode.      */
specifier|protected
name|void
name|removeNodes
parameter_list|()
block|{
if|if
condition|(
name|nodesToRemove
operator|==
literal|null
condition|)
return|return;
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|()
expr_stmt|;
specifier|final
name|BytesRefBuilder
name|bytes
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|NumericUtils
operator|.
name|intToPrefixCoded
argument_list|(
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|Term
name|dt
init|=
operator|new
name|Term
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|bytes
operator|.
name|toBytesRef
argument_list|()
argument_list|)
decl_stmt|;
name|TermQuery
name|tq
init|=
operator|new
name|TermQuery
argument_list|(
name|dt
argument_list|)
decl_stmt|;
for|for
control|(
name|NodeId
name|nodeId
range|:
name|nodesToRemove
control|)
block|{
comment|// store the node id
name|int
name|nodeIdLen
init|=
name|nodeId
operator|.
name|size
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|nodeIdLen
operator|+
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
name|nodeId
operator|.
name|units
argument_list|()
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nodeId
operator|.
name|serialize
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Term
name|it
init|=
operator|new
name|Term
argument_list|(
name|LuceneUtil
operator|.
name|FIELD_NODE_ID
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|TermQuery
name|iq
init|=
operator|new
name|TermQuery
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|BooleanQuery
name|q
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|q
operator|.
name|add
argument_list|(
name|tq
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|q
operator|.
name|add
argument_list|(
name|iq
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|writer
operator|.
name|deleteDocuments
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while deleting lucene index entries: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|nodesToRemove
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Query the index. Returns a node set containing all matching nodes. Each node      * in the node set has a {@link LuceneMatch}      * element attached, which stores the score and a link to the query which generated it.      *      * @param contextId current context id, identify to track the position inside nested XPath predicates      * @param docs query will be restricted to documents in this set      * @param contextSet if specified, returned nodes will be descendants of the nodes in this set      * @param qnames query will be restricted to nodes with the qualified names given here      * @param queryStr a lucene query string      * @param axis which node is returned: the node in which a match was found or the corresponding ancestor      *  from the contextSet      * @param options the query options      *      * @return node set containing all matching nodes      *       * @throws IOException if an I/O error occurs      * @throws ParseException if the query cannot be parsed      * @throws XPathException if an error occurs executing the query      */
specifier|public
name|NodeSet
name|query
parameter_list|(
name|int
name|contextId
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
parameter_list|,
name|String
name|queryStr
parameter_list|,
name|int
name|axis
parameter_list|,
name|QueryOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
throws|,
name|XPathException
block|{
return|return
name|index
operator|.
name|withSearcher
argument_list|(
name|searcher
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|QName
argument_list|>
name|definedIndexes
init|=
name|getDefinedIndexes
argument_list|(
name|qnames
argument_list|)
decl_stmt|;
specifier|final
name|NodeSet
name|resultSet
init|=
operator|new
name|NewArrayNodeSet
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|returnAncestor
init|=
name|axis
operator|==
name|NodeSet
operator|.
name|ANCESTOR
decl_stmt|;
for|for
control|(
name|QName
name|qname
range|:
name|definedIndexes
control|)
block|{
name|String
name|field
init|=
name|LuceneUtil
operator|.
name|encodeQName
argument_list|(
name|qname
argument_list|,
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSymbols
argument_list|()
argument_list|)
decl_stmt|;
name|LuceneConfig
name|config
init|=
name|getLuceneConfig
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|)
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|getQueryAnalyzer
argument_list|(
name|config
argument_list|,
literal|null
argument_list|,
name|qname
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|Query
name|query
decl_stmt|;
if|if
condition|(
name|queryStr
operator|==
literal|null
condition|)
block|{
name|query
operator|=
operator|new
name|ConstantScoreQuery
argument_list|(
operator|new
name|FieldValueFilter
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QueryParserWrapper
name|parser
init|=
name|getQueryParser
argument_list|(
name|field
argument_list|,
name|analyzer
argument_list|,
name|docs
argument_list|)
decl_stmt|;
name|options
operator|.
name|configureParser
argument_list|(
name|parser
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|query
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|queryStr
argument_list|)
expr_stmt|;
block|}
name|Optional
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|QueryOptions
operator|.
name|FacetQuery
argument_list|>
argument_list|>
name|facets
init|=
name|options
operator|.
name|getFacets
argument_list|()
decl_stmt|;
if|if
condition|(
name|facets
operator|.
name|isPresent
argument_list|()
operator|&&
name|config
operator|!=
literal|null
condition|)
block|{
name|query
operator|=
name|drilldown
argument_list|(
name|facets
operator|.
name|get
argument_list|()
argument_list|,
name|query
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
name|searchAndProcess
argument_list|(
name|contextId
argument_list|,
name|qname
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|resultSet
argument_list|,
name|returnAncestor
argument_list|,
name|searcher
argument_list|,
name|query
argument_list|,
name|options
operator|.
name|getFields
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
return|return
name|resultSet
return|;
block|}
argument_list|)
return|;
block|}
comment|/**      * Query the index. Returns a node set containing all matching nodes. Each node      * in the node set has a {@link LuceneMatch}      * element attached, which stores the score and a link to the query which generated it.      *      * @param contextId current context id, identify to track the position inside nested XPath predicates      * @param docs query will be restricted to documents in this set      * @param contextSet if specified, returned nodes will be descendants of the nodes in this set      * @param qnames query will be restricted to nodes with the qualified names given here      * @param queryRoot an XML representation of the query, see {@link XMLToQuery}.      * @param axis which node is returned: the node in which a match was found or the corresponding ancestor      *  from the contextSet      * @param options the query options      *      * @return node set containing all matching nodes      *      * @throws IOException if an I/O error occurs      * @throws ParseException if the query cannot be parsed      * @throws XPathException if an error occurs executing the query      */
specifier|public
name|NodeSet
name|query
parameter_list|(
name|int
name|contextId
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
parameter_list|,
name|Element
name|queryRoot
parameter_list|,
name|int
name|axis
parameter_list|,
name|QueryOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
throws|,
name|XPathException
block|{
return|return
name|index
operator|.
name|withSearcher
argument_list|(
name|searcher
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|QName
argument_list|>
name|definedIndexes
init|=
name|getDefinedIndexes
argument_list|(
name|qnames
argument_list|)
decl_stmt|;
specifier|final
name|NodeSet
name|resultSet
init|=
operator|new
name|NewArrayNodeSet
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|returnAncestor
init|=
name|axis
operator|==
name|NodeSet
operator|.
name|ANCESTOR
decl_stmt|;
for|for
control|(
name|QName
name|qname
range|:
name|definedIndexes
control|)
block|{
name|String
name|field
init|=
name|LuceneUtil
operator|.
name|encodeQName
argument_list|(
name|qname
argument_list|,
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSymbols
argument_list|()
argument_list|)
decl_stmt|;
name|LuceneConfig
name|config
init|=
name|getLuceneConfig
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|)
decl_stmt|;
name|analyzer
operator|=
name|getQueryAnalyzer
argument_list|(
name|config
argument_list|,
literal|null
argument_list|,
name|qname
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|Query
name|query
init|=
name|queryRoot
operator|==
literal|null
condition|?
operator|new
name|ConstantScoreQuery
argument_list|(
operator|new
name|FieldValueFilter
argument_list|(
name|field
argument_list|)
argument_list|)
else|:
name|queryTranslator
operator|.
name|parse
argument_list|(
name|field
argument_list|,
name|queryRoot
argument_list|,
name|analyzer
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|QueryOptions
operator|.
name|FacetQuery
argument_list|>
argument_list|>
name|facets
init|=
name|options
operator|.
name|getFacets
argument_list|()
decl_stmt|;
if|if
condition|(
name|facets
operator|.
name|isPresent
argument_list|()
operator|&&
name|config
operator|!=
literal|null
condition|)
block|{
name|query
operator|=
name|drilldown
argument_list|(
name|facets
operator|.
name|get
argument_list|()
argument_list|,
name|query
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|searchAndProcess
argument_list|(
name|contextId
argument_list|,
name|qname
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|resultSet
argument_list|,
name|returnAncestor
argument_list|,
name|searcher
argument_list|,
name|query
argument_list|,
name|options
operator|.
name|getFields
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|resultSet
return|;
block|}
argument_list|)
return|;
block|}
specifier|public
name|NodeSet
name|queryField
parameter_list|(
name|int
name|contextId
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|String
name|field
parameter_list|,
name|Element
name|queryRoot
parameter_list|,
name|int
name|axis
parameter_list|,
name|QueryOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|XPathException
block|{
return|return
name|index
operator|.
name|withSearcher
argument_list|(
name|searcher
lambda|->
block|{
specifier|final
name|NodeSet
name|resultSet
init|=
operator|new
name|NewArrayNodeSet
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|returnAncestor
init|=
name|axis
operator|==
name|NodeSet
operator|.
name|ANCESTOR
decl_stmt|;
specifier|final
name|LuceneConfig
name|config
init|=
name|getLuceneConfig
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|)
decl_stmt|;
name|analyzer
operator|=
name|getQueryAnalyzer
argument_list|(
name|config
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
name|options
argument_list|)
expr_stmt|;
specifier|final
name|Query
name|query
init|=
name|queryTranslator
operator|.
name|parse
argument_list|(
name|field
argument_list|,
name|queryRoot
argument_list|,
name|analyzer
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|searchAndProcess
argument_list|(
name|contextId
argument_list|,
literal|null
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|resultSet
argument_list|,
name|returnAncestor
argument_list|,
name|searcher
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
return|return
name|resultSet
return|;
block|}
argument_list|)
return|;
block|}
specifier|private
name|Query
name|drilldown
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|QueryOptions
operator|.
name|FacetQuery
argument_list|>
name|facets
parameter_list|,
name|Query
name|baseQuery
parameter_list|,
name|LuceneConfig
name|config
parameter_list|)
block|{
specifier|final
name|DrillDownQuery
name|drillDownQuery
init|=
operator|new
name|DrillDownQuery
argument_list|(
name|config
operator|.
name|facetsConfig
argument_list|,
name|baseQuery
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|QueryOptions
operator|.
name|FacetQuery
argument_list|>
name|facet
range|:
name|facets
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|FacetsConfig
operator|.
name|DimConfig
name|dimConfig
init|=
name|config
operator|.
name|facetsConfig
operator|.
name|getDimConfig
argument_list|(
name|facet
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|facet
operator|.
name|getValue
argument_list|()
operator|.
name|toQuery
argument_list|(
name|facet
operator|.
name|getKey
argument_list|()
argument_list|,
name|drillDownQuery
argument_list|,
name|dimConfig
operator|.
name|hierarchical
argument_list|)
expr_stmt|;
block|}
return|return
name|drillDownQuery
return|;
block|}
specifier|private
name|void
name|searchAndProcess
parameter_list|(
name|int
name|contextId
parameter_list|,
name|QName
name|qname
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|NodeSet
name|resultSet
parameter_list|,
name|boolean
name|returnAncestor
parameter_list|,
name|SearcherTaxonomyManager
operator|.
name|SearcherAndTaxonomy
name|searcher
parameter_list|,
name|Query
name|query
parameter_list|,
annotation|@
name|Nullable
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|LuceneConfig
name|config
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LuceneFacets
name|facets
init|=
operator|new
name|LuceneFacets
argument_list|()
decl_stmt|;
specifier|final
name|FacetsCollector
name|facetsCollector
init|=
operator|new
name|FacetsCollector
argument_list|()
decl_stmt|;
specifier|final
name|LuceneHitCollector
name|collector
init|=
operator|new
name|LuceneHitCollector
argument_list|(
name|qname
argument_list|,
name|query
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|resultSet
argument_list|,
name|returnAncestor
argument_list|,
name|contextId
argument_list|,
name|facets
argument_list|,
name|facetsCollector
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|searcher
operator|.
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|collector
argument_list|)
expr_stmt|;
comment|// compute facets
name|facets
operator|.
name|compute
argument_list|(
name|searcher
operator|.
name|taxonomyReader
argument_list|,
name|config
operator|.
name|facetsConfig
argument_list|,
name|facetsCollector
argument_list|)
expr_stmt|;
block|}
comment|/**      * Wrapper around Lucene {@link Facets}, which are computed after the search has finished.      */
specifier|protected
specifier|static
class|class
name|LuceneFacets
block|{
specifier|private
name|Facets
name|facets
decl_stmt|;
specifier|public
name|Facets
name|getFacets
parameter_list|()
block|{
return|return
name|facets
return|;
block|}
comment|/**          * Compute facets based on the given {@link FacetsCollector}.          *          * @param reader the taxonomy reader          * @param config the facets configuration          * @param collector the facets collector          *          * @throws IOException if an I/O error occurs          */
specifier|public
name|void
name|compute
parameter_list|(
name|DirectoryTaxonomyReader
name|reader
parameter_list|,
name|FacetsConfig
name|config
parameter_list|,
name|FacetsCollector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|facets
operator|=
operator|new
name|FastTaxonomyFacetCounts
argument_list|(
name|reader
argument_list|,
name|config
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Calls {@link LuceneUtil#extractTerms(Query, Map, IndexReader, boolean)}  to extract      * the terms which would be matched by the given query.      *      * @param query to extract terms for      * @return the map returned by {@link LuceneUtil#extractTerms(Query, Map, IndexReader, boolean)}      * @throws IOException in case of Lucene IO error      */
specifier|public
name|Map
argument_list|<
name|Object
argument_list|,
name|Query
argument_list|>
name|getTerms
parameter_list|(
specifier|final
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Map
argument_list|<
name|Object
argument_list|,
name|Query
argument_list|>
name|termMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|index
operator|.
name|withReader
argument_list|(
name|reader
lambda|->
block|{
name|LuceneUtil
operator|.
name|extractTerms
argument_list|(
name|query
argument_list|,
name|termMap
argument_list|,
name|reader
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|termMap
return|;
block|}
argument_list|)
expr_stmt|;
return|return
name|termMap
return|;
block|}
specifier|public
name|NodeSet
name|queryField
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|int
name|contextId
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|queryString
parameter_list|,
name|int
name|axis
parameter_list|,
name|QueryOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|XPathException
block|{
return|return
name|index
operator|.
name|withSearcher
argument_list|(
name|searcher
lambda|->
block|{
name|NodeSet
name|resultSet
init|=
operator|new
name|NewArrayNodeSet
argument_list|()
decl_stmt|;
name|boolean
name|returnAncestor
init|=
name|axis
operator|==
name|NodeSet
operator|.
name|ANCESTOR
decl_stmt|;
name|LuceneConfig
name|config
init|=
name|getLuceneConfig
argument_list|(
name|context
operator|.
name|getBroker
argument_list|()
argument_list|,
name|docs
argument_list|)
decl_stmt|;
name|Analyzer
name|analyzer
init|=
name|getQueryAnalyzer
argument_list|(
name|config
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using analyzer "
operator|+
name|analyzer
operator|+
literal|" for "
operator|+
name|queryString
argument_list|)
expr_stmt|;
name|QueryParserWrapper
name|parser
init|=
name|getQueryParser
argument_list|(
name|field
argument_list|,
name|analyzer
argument_list|,
name|docs
argument_list|)
decl_stmt|;
name|options
operator|.
name|configureParser
argument_list|(
name|parser
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|Query
name|query
init|=
name|parser
operator|.
name|parse
argument_list|(
name|queryString
argument_list|)
decl_stmt|;
name|searchAndProcess
argument_list|(
name|contextId
argument_list|,
literal|null
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|resultSet
argument_list|,
name|returnAncestor
argument_list|,
name|searcher
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
name|resultSet
return|;
block|}
argument_list|)
return|;
block|}
comment|/**      * Add SOLR formatted data to lucene index.      *       *<pre>      * {@code      *<doc>      *<field name="name1" boost="value1">data1</field>      *<field name="name2">data2</field>      *</doc>      * }      *</pre>      *       * @param descriptor SOLR styled data       */
specifier|public
name|void
name|indexNonXML
parameter_list|(
name|NodeValue
name|descriptor
parameter_list|)
block|{
comment|// Verify input
if|if
condition|(
operator|!
name|descriptor
operator|.
name|getNode
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|contentEquals
argument_list|(
literal|"doc"
argument_list|)
condition|)
block|{
comment|// throw exception
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected<doc> got<"
operator|+
name|descriptor
operator|.
name|getNode
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Setup parser for SOLR syntax and parse
name|PlainTextIndexConfig
name|solrconfParser
init|=
operator|new
name|PlainTextIndexConfig
argument_list|()
decl_stmt|;
name|solrconfParser
operator|.
name|parse
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingDoc
operator|==
literal|null
condition|)
block|{
comment|// create Lucene document
name|pendingDoc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
comment|// Set DocId
name|NumericDocValuesField
name|fDocId
init|=
operator|new
name|NumericDocValuesField
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|pendingDoc
operator|.
name|add
argument_list|(
name|fDocId
argument_list|)
expr_stmt|;
name|IntField
name|fDocIdIdx
init|=
operator|new
name|IntField
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
decl_stmt|;
name|pendingDoc
operator|.
name|add
argument_list|(
name|fDocIdIdx
argument_list|)
expr_stmt|;
comment|// For binary documents the doc path needs to be stored
name|String
name|uri
init|=
name|currentDoc
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Field
name|fDocUri
init|=
operator|new
name|Field
argument_list|(
name|FIELD_DOC_URI
argument_list|,
name|uri
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|,
name|Field
operator|.
name|Index
operator|.
name|NOT_ANALYZED
argument_list|)
decl_stmt|;
name|pendingDoc
operator|.
name|add
argument_list|(
name|fDocUri
argument_list|)
expr_stmt|;
block|}
comment|// Iterate over all found fields and write the data.
for|for
control|(
name|PlainTextField
name|field
range|:
name|solrconfParser
operator|.
name|getFields
argument_list|()
control|)
block|{
comment|// Get field type configuration
name|FieldType
name|fieldType
init|=
name|config
operator|==
literal|null
condition|?
literal|null
else|:
name|config
operator|.
name|getFieldType
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Field
operator|.
name|Store
name|store
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fieldType
operator|!=
literal|null
condition|)
name|store
operator|=
name|fieldType
operator|.
name|getStore
argument_list|()
expr_stmt|;
if|if
condition|(
name|store
operator|==
literal|null
condition|)
name|store
operator|=
name|field
operator|.
name|getStore
argument_list|()
expr_stmt|;
comment|// Get name from SOLR field
name|String
name|contentFieldName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Actual field content ; Store flag can be set in solrField
name|Field
name|contentField
init|=
operator|new
name|Field
argument_list|(
name|contentFieldName
argument_list|,
name|field
operator|.
name|getData
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|store
argument_list|,
name|Field
operator|.
name|Index
operator|.
name|ANALYZED
argument_list|,
name|Field
operator|.
name|TermVector
operator|.
name|YES
argument_list|)
decl_stmt|;
comment|// Extract (document) Boost factor
if|if
condition|(
name|field
operator|.
name|getBoost
argument_list|()
operator|>
literal|0
condition|)
block|{
name|contentField
operator|.
name|setBoost
argument_list|(
name|field
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pendingDoc
operator|.
name|add
argument_list|(
name|contentField
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|writeNonXML
parameter_list|()
block|{
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|()
expr_stmt|;
name|writer
operator|.
name|addDocument
argument_list|(
name|pendingDoc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An exception was caught while indexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|pendingDoc
operator|=
literal|null
expr_stmt|;
name|cachedNodesSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**      * SOLR      *      * @param toBeMatchedURIs the URIs to match      * @param queryText the query      * @param fieldsToGet the fields to get      * @param options the search options      *      * @return search report      *      * @throws XPathException if an error occurs executing the query      * @throws IOException if an I/O error occurs      */
specifier|public
name|NodeImpl
name|search
parameter_list|(
specifier|final
name|XQueryContext
name|context
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|toBeMatchedURIs
parameter_list|,
name|String
name|queryText
parameter_list|,
name|String
index|[]
name|fieldsToGet
parameter_list|,
name|QueryOptions
name|options
parameter_list|)
throws|throws
name|XPathException
throws|,
name|IOException
block|{
return|return
name|index
operator|.
name|withSearcher
argument_list|(
name|searcher
lambda|->
block|{
comment|// Get analyzer : to be retrieved from configuration
specifier|final
name|Analyzer
name|searchAnalyzer
init|=
operator|new
name|StandardAnalyzer
argument_list|(
name|LuceneIndex
operator|.
name|LUCENE_VERSION_IN_USE
argument_list|)
decl_stmt|;
comment|// Setup query Version, default field, analyzer
specifier|final
name|QueryParserWrapper
name|parser
init|=
name|getQueryParser
argument_list|(
literal|""
argument_list|,
name|searchAnalyzer
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|options
operator|.
name|configureParser
argument_list|(
name|parser
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Query
name|query
init|=
name|parser
operator|.
name|parse
argument_list|(
name|queryText
argument_list|)
decl_stmt|;
comment|// extract all used fields from query
specifier|final
name|String
index|[]
name|fields
decl_stmt|;
if|if
condition|(
name|fieldsToGet
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
name|LuceneUtil
operator|.
name|extractFields
argument_list|(
name|query
argument_list|,
name|searcher
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|=
name|fieldsToGet
expr_stmt|;
block|}
specifier|final
name|PlainTextHighlighter
name|highlighter
init|=
operator|new
name|PlainTextHighlighter
argument_list|(
name|query
argument_list|,
name|searcher
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|)
decl_stmt|;
name|context
operator|.
name|pushDocumentContext
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|MemTreeBuilder
name|builder
init|=
name|context
operator|.
name|getDocumentBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|startDocument
argument_list|()
expr_stmt|;
comment|// start root element
specifier|final
name|int
name|nodeNr
init|=
name|builder
operator|.
name|startElement
argument_list|(
literal|""
argument_list|,
literal|"results"
argument_list|,
literal|"results"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Perform actual search
specifier|final
name|BinarySearchCollector
name|collector
init|=
operator|new
name|BinarySearchCollector
argument_list|(
name|toBeMatchedURIs
argument_list|,
name|builder
argument_list|,
name|fields
argument_list|,
name|searchAnalyzer
argument_list|,
name|highlighter
argument_list|)
decl_stmt|;
name|searcher
operator|.
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|collector
argument_list|)
expr_stmt|;
comment|// finish root element
name|builder
operator|.
name|endElement
argument_list|()
expr_stmt|;
comment|//System.out.println(builder.getDocument().toString());
comment|// TODO check
return|return
name|builder
operator|.
name|getDocument
argument_list|()
operator|.
name|getNode
argument_list|(
name|nodeNr
argument_list|)
return|;
block|}
finally|finally
block|{
name|context
operator|.
name|popDocumentContext
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
class|class
name|BinarySearchCollector
extends|extends
name|Collector
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|toBeMatchedURIs
decl_stmt|;
specifier|private
specifier|final
name|MemTreeBuilder
name|builder
decl_stmt|;
specifier|private
specifier|final
name|String
index|[]
name|fields
decl_stmt|;
specifier|private
specifier|final
name|Analyzer
name|searchAnalyzer
decl_stmt|;
specifier|private
specifier|final
name|PlainTextHighlighter
name|highlighter
decl_stmt|;
specifier|private
name|Scorer
name|scorer
decl_stmt|;
specifier|private
name|AtomicReader
name|reader
decl_stmt|;
specifier|public
name|BinarySearchCollector
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|toBeMatchedURIs
parameter_list|,
name|MemTreeBuilder
name|builder
parameter_list|,
name|String
index|[]
name|fields
parameter_list|,
name|Analyzer
name|searchAnalyzer
parameter_list|,
name|PlainTextHighlighter
name|highlighter
parameter_list|)
block|{
name|this
operator|.
name|toBeMatchedURIs
operator|=
name|toBeMatchedURIs
expr_stmt|;
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
name|this
operator|.
name|searchAnalyzer
operator|=
name|searchAnalyzer
expr_stmt|;
name|this
operator|.
name|highlighter
operator|=
name|highlighter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|doc
init|=
name|reader
operator|.
name|document
argument_list|(
name|docNum
argument_list|)
decl_stmt|;
comment|// Get URI field of document
name|String
name|fDocUri
init|=
name|doc
operator|.
name|get
argument_list|(
name|FIELD_DOC_URI
argument_list|)
decl_stmt|;
comment|// Get score
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// Check if document URI has a full match or if a
comment|// document is in a collection
if|if
condition|(
name|isDocumentMatch
argument_list|(
name|fDocUri
argument_list|,
name|toBeMatchedURIs
argument_list|)
condition|)
block|{
try|try
init|(
specifier|final
name|LockedDocument
name|lockedStoredDoc
init|=
name|broker
operator|.
name|getXMLResource
argument_list|(
name|XmldbURI
operator|.
name|createInternal
argument_list|(
name|fDocUri
argument_list|)
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
comment|// try to read document to check if user is allowed to access it
if|if
condition|(
name|lockedStoredDoc
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// setup attributes
name|AttributesImpl
name|attribs
init|=
operator|new
name|AttributesImpl
argument_list|()
decl_stmt|;
name|attribs
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"uri"
argument_list|,
literal|"uri"
argument_list|,
literal|"CDATA"
argument_list|,
name|fDocUri
argument_list|)
expr_stmt|;
name|attribs
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"score"
argument_list|,
literal|"score"
argument_list|,
literal|"CDATA"
argument_list|,
literal|""
operator|+
name|score
argument_list|)
expr_stmt|;
comment|// write element and attributes
name|builder
operator|.
name|startElement
argument_list|(
literal|""
argument_list|,
literal|"search"
argument_list|,
literal|"search"
argument_list|,
name|attribs
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|String
index|[]
name|fieldContent
init|=
name|doc
operator|.
name|getValues
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|attribs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|attribs
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"name"
argument_list|,
literal|"name"
argument_list|,
literal|"CDATA"
argument_list|,
name|field
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|content
range|:
name|fieldContent
control|)
block|{
name|List
argument_list|<
name|Offset
argument_list|>
name|offsets
init|=
name|highlighter
operator|.
name|getOffsets
argument_list|(
name|content
argument_list|,
name|searchAnalyzer
argument_list|)
decl_stmt|;
name|builder
operator|.
name|startElement
argument_list|(
literal|""
argument_list|,
literal|"field"
argument_list|,
literal|"field"
argument_list|,
name|attribs
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
operator|!=
literal|null
condition|)
block|{
name|highlighter
operator|.
name|highlight
argument_list|(
name|content
argument_list|,
name|offsets
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|characters
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|endElement
argument_list|()
expr_stmt|;
comment|// clean attributes
name|attribs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
comment|// not allowed to read the document: ignore the match.
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|atomicReaderContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reader
operator|=
name|atomicReaderContext
operator|.
name|reader
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
specifier|public
name|String
name|getFieldContent
parameter_list|(
name|int
name|docId
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesRefBuilder
name|bytes
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|NumericUtils
operator|.
name|intToPrefixCoded
argument_list|(
name|docId
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|Term
name|dt
init|=
operator|new
name|Term
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|bytes
operator|.
name|toBytesRef
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|index
operator|.
name|withReader
argument_list|(
name|reader
lambda|->
block|{
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
init|=
name|reader
operator|.
name|leaves
argument_list|()
decl_stmt|;
for|for
control|(
name|AtomicReaderContext
name|context
range|:
name|leaves
control|)
block|{
name|AtomicReader
name|atomicReader
init|=
name|context
operator|.
name|reader
argument_list|()
decl_stmt|;
name|DocsEnum
name|docs
init|=
name|atomicReader
operator|.
name|termDocsEnum
argument_list|(
name|dt
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|!=
literal|null
operator|&&
name|docs
operator|.
name|nextDoc
argument_list|()
operator|!=
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|Document
name|doc
init|=
name|atomicReader
operator|.
name|document
argument_list|(
name|docs
operator|.
name|docID
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|doc
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|hasIndex
parameter_list|(
name|int
name|docId
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesRefBuilder
name|bytes
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|NumericUtils
operator|.
name|intToPrefixCoded
argument_list|(
name|docId
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|Term
name|dt
init|=
operator|new
name|Term
argument_list|(
name|FIELD_DOC_ID
argument_list|,
name|bytes
operator|.
name|toBytesRef
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|index
operator|.
name|withReader
argument_list|(
name|reader
lambda|->
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
init|=
name|reader
operator|.
name|leaves
argument_list|()
decl_stmt|;
for|for
control|(
name|AtomicReaderContext
name|context
range|:
name|leaves
control|)
block|{
name|DocsEnum
name|docs
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|termDocsEnum
argument_list|(
name|dt
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|!=
literal|null
operator|&&
name|docs
operator|.
name|nextDoc
argument_list|()
operator|!=
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|found
return|;
block|}
argument_list|)
return|;
block|}
comment|/**      * Check if Lucene found document matches specified documents or collections.      * Collections should end with "/".      *       * @param docUri The uri of the document found by lucene      * @param toBeMatchedUris List of document and collection URIs      *      * @return true if {@code docUri} is matched or is in collection, false otherwise      */
specifier|private
name|boolean
name|isDocumentMatch
parameter_list|(
name|String
name|docUri
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|toBeMatchedUris
parameter_list|)
block|{
if|if
condition|(
name|docUri
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"docUri is null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|toBeMatchedUris
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"match is null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|String
name|doc
range|:
name|toBeMatchedUris
control|)
block|{
if|if
condition|(
name|docUri
operator|.
name|startsWith
argument_list|(
name|doc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
class|class
name|LuceneHitCollector
extends|extends
name|Collector
block|{
specifier|private
name|Scorer
name|scorer
decl_stmt|;
specifier|private
name|AtomicReader
name|reader
decl_stmt|;
specifier|private
name|NumericDocValues
name|docIdValues
decl_stmt|;
specifier|private
name|BinaryDocValues
name|nodeIdValues
decl_stmt|;
specifier|private
specifier|final
name|QName
name|qname
decl_stmt|;
specifier|private
specifier|final
name|DocumentSet
name|docs
decl_stmt|;
specifier|private
specifier|final
name|NodeSet
name|contextSet
decl_stmt|;
specifier|private
specifier|final
name|NodeSet
name|resultSet
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|returnAncestor
decl_stmt|;
specifier|private
specifier|final
name|int
name|contextId
decl_stmt|;
specifier|private
specifier|final
name|Query
name|query
decl_stmt|;
specifier|private
specifier|final
name|LuceneFacets
name|facets
decl_stmt|;
specifier|private
specifier|final
name|FacetsCollector
name|chainedCollector
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|fields
decl_stmt|;
specifier|private
name|LuceneHitCollector
parameter_list|(
name|QName
name|qname
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|NodeSet
name|resultSet
parameter_list|,
name|boolean
name|returnAncestor
parameter_list|,
name|int
name|contextId
parameter_list|,
name|LuceneFacets
name|facets
parameter_list|,
name|FacetsCollector
name|nextCollector
parameter_list|,
annotation|@
name|Nullable
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|this
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|this
operator|.
name|docs
operator|=
name|docs
expr_stmt|;
name|this
operator|.
name|contextSet
operator|=
name|contextSet
expr_stmt|;
name|this
operator|.
name|resultSet
operator|=
name|resultSet
expr_stmt|;
name|this
operator|.
name|returnAncestor
operator|=
name|returnAncestor
expr_stmt|;
name|this
operator|.
name|contextId
operator|=
name|contextId
expr_stmt|;
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|facets
operator|=
name|facets
expr_stmt|;
name|this
operator|.
name|chainedCollector
operator|=
name|nextCollector
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|chainedCollector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|atomicReaderContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reader
operator|=
name|atomicReaderContext
operator|.
name|reader
argument_list|()
expr_stmt|;
name|this
operator|.
name|docIdValues
operator|=
name|this
operator|.
name|reader
operator|.
name|getNumericDocValues
argument_list|(
name|FIELD_DOC_ID
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeIdValues
operator|=
name|this
operator|.
name|reader
operator|.
name|getBinaryDocValues
argument_list|(
name|LuceneUtil
operator|.
name|FIELD_NODE_ID
argument_list|)
expr_stmt|;
name|chainedCollector
operator|.
name|setNextReader
argument_list|(
name|atomicReaderContext
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
try|try
block|{
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|int
name|docId
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|docIdValues
operator|.
name|get
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|DocumentImpl
name|storedDocument
init|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedDocument
operator|==
literal|null
condition|)
return|return;
specifier|final
name|BytesRef
name|ref
init|=
name|this
operator|.
name|nodeIdValues
operator|.
name|get
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|int
name|units
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|ref
operator|.
name|bytes
argument_list|,
name|ref
operator|.
name|offset
argument_list|)
decl_stmt|;
name|NodeId
name|nodeId
init|=
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|createFromData
argument_list|(
name|units
argument_list|,
name|ref
operator|.
name|bytes
argument_list|,
name|ref
operator|.
name|offset
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|//LOG.info("doc: " + docId + "; node: " + nodeId.toString() + "; units: " + units);
name|NodeProxy
name|storedNode
init|=
operator|new
name|NodeProxy
argument_list|(
name|storedDocument
argument_list|,
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|qname
operator|!=
literal|null
condition|)
name|storedNode
operator|.
name|setNodeType
argument_list|(
name|qname
operator|.
name|getNameType
argument_list|()
operator|==
name|ElementValue
operator|.
name|ATTRIBUTE
condition|?
name|Node
operator|.
name|ATTRIBUTE_NODE
else|:
name|Node
operator|.
name|ELEMENT_NODE
argument_list|)
expr_stmt|;
comment|// if a context set is specified, we can directly check if the
comment|// matching node is a descendant of one of the nodes
comment|// in the context set.
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
block|{
name|int
name|sizeHint
init|=
name|contextSet
operator|.
name|getSizeHint
argument_list|(
name|storedDocument
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnAncestor
condition|)
block|{
name|NodeProxy
name|parentNode
init|=
name|contextSet
operator|.
name|get
argument_list|(
name|storedNode
argument_list|)
decl_stmt|;
comment|// NodeProxy parentNode = contextSet.parentWithChild(storedNode, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);
if|if
condition|(
name|parentNode
operator|!=
literal|null
condition|)
block|{
name|LuceneMatch
name|match
init|=
name|createMatch
argument_list|(
name|doc
argument_list|,
name|score
argument_list|,
name|nodeId
argument_list|)
decl_stmt|;
name|parentNode
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|add
argument_list|(
name|parentNode
argument_list|,
name|sizeHint
argument_list|)
expr_stmt|;
if|if
condition|(
name|Expression
operator|.
name|NO_CONTEXT_ID
operator|!=
name|contextId
condition|)
block|{
name|parentNode
operator|.
name|deepCopyContext
argument_list|(
name|storedNode
argument_list|,
name|contextId
argument_list|)
expr_stmt|;
block|}
else|else
name|parentNode
operator|.
name|copyContext
argument_list|(
name|storedNode
argument_list|)
expr_stmt|;
name|chainedCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LuceneMatch
name|match
init|=
name|createMatch
argument_list|(
name|doc
argument_list|,
name|score
argument_list|,
name|nodeId
argument_list|)
decl_stmt|;
name|storedNode
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|add
argument_list|(
name|storedNode
argument_list|,
name|sizeHint
argument_list|)
expr_stmt|;
name|chainedCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LuceneMatch
name|match
init|=
name|createMatch
argument_list|(
name|doc
argument_list|,
name|score
argument_list|,
name|nodeId
argument_list|)
decl_stmt|;
name|storedNode
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|add
argument_list|(
name|storedNode
argument_list|)
expr_stmt|;
name|chainedCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|LuceneMatch
name|createMatch
parameter_list|(
name|int
name|docId
parameter_list|,
name|float
name|score
parameter_list|,
name|NodeId
name|nodeId
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LuceneMatch
name|match
init|=
operator|new
name|LuceneMatch
argument_list|(
name|contextId
argument_list|,
name|nodeId
argument_list|,
name|query
argument_list|,
name|facets
argument_list|)
decl_stmt|;
name|match
operator|.
name|setScore
argument_list|(
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
operator|&&
operator|!
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Document
name|luceneDoc
init|=
name|reader
operator|.
name|document
argument_list|(
name|docId
argument_list|,
name|fields
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|match
operator|.
name|addField
argument_list|(
name|field
argument_list|,
name|luceneDoc
operator|.
name|getFields
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|match
return|;
block|}
block|}
comment|/**      * Check index configurations for all collection in the given DocumentSet and return      * a list of QNames, which have indexes defined on them.      *      * @param qnames the qnames to find the findexes for      *      * @return List of QName objects on which indexes are defined      *      * @throws IOException if an I/O error occurs      */
specifier|public
name|List
argument_list|<
name|QName
argument_list|>
name|getDefinedIndexes
parameter_list|(
specifier|final
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|QName
argument_list|>
name|indexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnames
operator|!=
literal|null
operator|&&
operator|!
name|qnames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
specifier|final
name|QName
name|qname
range|:
name|qnames
control|)
block|{
if|if
condition|(
name|qname
operator|.
name|getLocalPart
argument_list|()
operator|==
literal|null
operator|||
name|qname
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|QName
operator|.
name|WILDCARD
argument_list|)
operator|||
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|==
literal|null
operator|||
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|equals
argument_list|(
name|QName
operator|.
name|WILDCARD
argument_list|)
condition|)
block|{
name|getDefinedIndexesFor
argument_list|(
name|qname
argument_list|,
name|indexes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexes
operator|.
name|add
argument_list|(
name|qname
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|indexes
return|;
block|}
return|return
name|getDefinedIndexesFor
argument_list|(
literal|null
argument_list|,
name|indexes
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|QName
argument_list|>
name|getDefinedIndexesFor
parameter_list|(
name|QName
name|qname
parameter_list|,
specifier|final
name|List
argument_list|<
name|QName
argument_list|>
name|indexes
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|index
operator|.
name|withReader
argument_list|(
name|reader
lambda|->
block|{
for|for
control|(
name|FieldInfo
name|info
range|:
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|reader
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|FIELD_DOC_ID
operator|.
name|equals
argument_list|(
name|info
operator|.
name|name
argument_list|)
condition|)
block|{
name|QName
name|name
init|=
name|LuceneUtil
operator|.
name|decodeQName
argument_list|(
name|info
operator|.
name|name
argument_list|,
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSymbols
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
operator|&&
operator|(
name|qname
operator|==
literal|null
operator|||
name|matchQName
argument_list|(
name|qname
argument_list|,
name|name
argument_list|)
operator|)
condition|)
name|indexes
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|indexes
return|;
block|}
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|matchQName
parameter_list|(
name|QName
name|qname
parameter_list|,
name|QName
name|candidate
parameter_list|)
block|{
name|boolean
name|match
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|qname
operator|.
name|getLocalPart
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|qname
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|QName
operator|.
name|WILDCARD
argument_list|)
operator|)
condition|)
block|{
name|match
operator|=
name|qname
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|candidate
operator|.
name|getLocalPart
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|&&
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|equals
argument_list|(
name|QName
operator|.
name|WILDCARD
argument_list|)
operator|)
operator|&&
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|match
operator|=
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|equals
argument_list|(
name|candidate
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|match
return|;
block|}
comment|/**      * Return the analyzer to be used for the given field or qname. Either field      * or qname should be specified.      *      * @param config the lucene config      * @param field the analyzer field      * @param qname the analyzer qname      *      * @return the analyzer or null      */
annotation|@
name|Nullable
specifier|protected
name|Analyzer
name|getQueryAnalyzer
parameter_list|(
name|LuceneConfig
name|config
parameter_list|,
name|String
name|field
parameter_list|,
name|QName
name|qname
parameter_list|,
name|QueryOptions
name|opts
parameter_list|)
block|{
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
name|Analyzer
name|analyzer
decl_stmt|;
if|if
condition|(
name|opts
operator|.
name|getQueryAnalyzerId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|analyzer
operator|=
name|config
operator|.
name|getAnalyzerById
argument_list|(
name|opts
operator|.
name|getQueryAnalyzerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"getAnalyzerById('%s') returned null!"
argument_list|,
name|opts
operator|.
name|getQueryAnalyzerId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
name|analyzer
operator|=
name|config
operator|.
name|getAnalyzer
argument_list|(
name|qname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|analyzer
operator|=
name|config
operator|.
name|getAnalyzer
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|analyzer
operator|!=
literal|null
condition|)
block|{
return|return
name|analyzer
return|;
block|}
block|}
return|return
name|index
operator|.
name|getDefaultAnalyzer
argument_list|()
return|;
block|}
comment|/**      * Return the first configuration found for documents in the document set.      *      * @param broker the database broker      * @param docs the document set      *      * @return the lucene config or null      */
specifier|public
name|LuceneConfig
name|getLuceneConfig
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentSet
name|docs
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Collection
argument_list|>
name|i
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Collection
name|collection
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|IndexSpec
name|idxConf
init|=
name|collection
operator|.
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|idxConf
operator|!=
literal|null
condition|)
block|{
name|LuceneConfig
name|config
init|=
operator|(
name|LuceneConfig
operator|)
name|idxConf
operator|.
name|getCustomIndexSpec
argument_list|(
name|LuceneIndex
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
return|return
name|config
return|;
block|}
block|}
block|}
return|return
name|LuceneConfig
operator|.
name|DEFAULT_CONFIG
return|;
block|}
specifier|protected
name|QueryParserWrapper
name|getQueryParser
parameter_list|(
name|String
name|field
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
name|DocumentSet
name|docs
parameter_list|)
block|{
if|if
condition|(
name|docs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Collection
argument_list|>
name|i
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Collection
name|collection
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|IndexSpec
name|idxConf
init|=
name|collection
operator|.
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|idxConf
operator|!=
literal|null
condition|)
block|{
name|LuceneConfig
name|config
init|=
operator|(
name|LuceneConfig
operator|)
name|idxConf
operator|.
name|getCustomIndexSpec
argument_list|(
name|LuceneIndex
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
name|QueryParserWrapper
name|parser
init|=
name|config
operator|.
name|getQueryParser
argument_list|(
name|field
argument_list|,
name|analyzer
argument_list|)
decl_stmt|;
if|if
condition|(
name|parser
operator|!=
literal|null
condition|)
block|{
return|return
name|parser
return|;
block|}
block|}
block|}
block|}
block|}
comment|// not found. return default query parser:
return|return
operator|new
name|ClassicQueryParserWrapper
argument_list|(
name|field
argument_list|,
name|analyzer
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|checkIndex
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
return|return
literal|false
return|;
comment|//To change body of implemented methods use File | Settings | File Templates.
block|}
specifier|public
name|Occurrences
index|[]
name|scanIndex
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|nodes
parameter_list|,
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|hints
parameter_list|)
block|{
try|try
block|{
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
init|=
name|hints
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|List
argument_list|<
name|QName
argument_list|>
operator|)
name|hints
operator|.
name|get
argument_list|(
name|QNAMES_KEY
argument_list|)
decl_stmt|;
name|qnames
operator|=
name|getDefinedIndexes
argument_list|(
name|qnames
argument_list|)
expr_stmt|;
comment|//Expects a StringValue
name|String
name|start
init|=
literal|null
decl_stmt|;
name|String
name|end
init|=
literal|null
decl_stmt|;
name|long
name|max
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|hints
operator|!=
literal|null
condition|)
block|{
name|Object
name|vstart
init|=
name|hints
operator|.
name|get
argument_list|(
name|START_VALUE
argument_list|)
decl_stmt|;
name|Object
name|vend
init|=
name|hints
operator|.
name|get
argument_list|(
name|END_VALUE
argument_list|)
decl_stmt|;
name|start
operator|=
name|vstart
operator|==
literal|null
condition|?
literal|null
else|:
name|vstart
operator|.
name|toString
argument_list|()
expr_stmt|;
name|end
operator|=
name|vend
operator|==
literal|null
condition|?
literal|null
else|:
name|vend
operator|.
name|toString
argument_list|()
expr_stmt|;
name|IntegerValue
name|vmax
init|=
operator|(
name|IntegerValue
operator|)
name|hints
operator|.
name|get
argument_list|(
name|VALUE_COUNT
argument_list|)
decl_stmt|;
name|max
operator|=
name|vmax
operator|==
literal|null
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|vmax
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
return|return
name|scanIndexByQName
argument_list|(
name|qnames
argument_list|,
name|docs
argument_list|,
name|nodes
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|max
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to scan index occurrences: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|Occurrences
index|[
literal|0
index|]
return|;
block|}
block|}
specifier|public
name|Occurrences
index|[]
name|scanIndexByField
parameter_list|(
name|String
name|field
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|hints
parameter_list|)
block|{
try|try
block|{
comment|//Expects a StringValue
name|String
name|start
init|=
literal|null
decl_stmt|;
name|String
name|end
init|=
literal|null
decl_stmt|;
name|long
name|max
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|hints
operator|!=
literal|null
condition|)
block|{
name|Object
name|vstart
init|=
name|hints
operator|.
name|get
argument_list|(
name|START_VALUE
argument_list|)
decl_stmt|;
name|Object
name|vend
init|=
name|hints
operator|.
name|get
argument_list|(
name|END_VALUE
argument_list|)
decl_stmt|;
name|start
operator|=
name|vstart
operator|==
literal|null
condition|?
literal|null
else|:
name|vstart
operator|.
name|toString
argument_list|()
expr_stmt|;
name|end
operator|=
name|vend
operator|==
literal|null
condition|?
literal|null
else|:
name|vend
operator|.
name|toString
argument_list|()
expr_stmt|;
name|IntegerValue
name|vmax
init|=
operator|(
name|IntegerValue
operator|)
name|hints
operator|.
name|get
argument_list|(
name|VALUE_COUNT
argument_list|)
decl_stmt|;
name|max
operator|=
name|vmax
operator|==
literal|null
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|vmax
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
return|return
name|scanIndexByField
argument_list|(
name|field
argument_list|,
name|docs
argument_list|,
literal|null
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|max
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to scan index occurrences: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|Occurrences
index|[
literal|0
index|]
return|;
block|}
block|}
specifier|private
name|Occurrences
index|[]
name|scanIndexByQName
parameter_list|(
name|List
argument_list|<
name|QName
argument_list|>
name|qnames
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|nodes
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|end
parameter_list|,
name|long
name|max
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Occurrences
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|index
operator|.
name|withReader
argument_list|(
name|reader
lambda|->
block|{
for|for
control|(
name|QName
name|qname
range|:
name|qnames
control|)
block|{
name|String
name|field
init|=
name|LuceneUtil
operator|.
name|encodeQName
argument_list|(
name|qname
argument_list|,
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSymbols
argument_list|()
argument_list|)
decl_stmt|;
name|doScanIndex
argument_list|(
name|docs
argument_list|,
name|nodes
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|max
argument_list|,
name|map
argument_list|,
name|reader
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
name|Occurrences
index|[]
name|occur
init|=
operator|new
name|Occurrences
index|[
name|map
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
name|map
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
name|occur
argument_list|)
return|;
block|}
specifier|private
name|Occurrences
index|[]
name|scanIndexByField
parameter_list|(
name|String
name|field
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|nodes
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|end
parameter_list|,
name|long
name|max
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Occurrences
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|index
operator|.
name|withReader
argument_list|(
name|reader
lambda|->
block|{
name|doScanIndex
argument_list|(
name|docs
argument_list|,
name|nodes
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|max
argument_list|,
name|map
argument_list|,
name|reader
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
name|Occurrences
index|[]
name|occur
init|=
operator|new
name|Occurrences
index|[
name|map
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
name|map
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
name|occur
argument_list|)
return|;
block|}
specifier|private
name|void
name|doScanIndex
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|nodes
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|end
parameter_list|,
name|long
name|max
parameter_list|,
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Occurrences
argument_list|>
name|map
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
init|=
name|reader
operator|.
name|leaves
argument_list|()
decl_stmt|;
for|for
control|(
name|AtomicReaderContext
name|context
range|:
name|leaves
control|)
block|{
name|NumericDocValues
name|docIdValues
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|getNumericDocValues
argument_list|(
name|FIELD_DOC_ID
argument_list|)
decl_stmt|;
name|BinaryDocValues
name|nodeIdValues
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|getBinaryDocValues
argument_list|(
name|LuceneUtil
operator|.
name|FIELD_NODE_ID
argument_list|)
decl_stmt|;
name|Bits
name|liveDocs
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|getLiveDocs
argument_list|()
decl_stmt|;
name|Terms
name|terms
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
name|TermsEnum
name|termsIter
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|termsIter
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
do|do
block|{
if|if
condition|(
name|map
operator|.
name|size
argument_list|()
operator|>=
name|max
condition|)
block|{
break|break;
block|}
name|BytesRef
name|ref
init|=
name|termsIter
operator|.
name|term
argument_list|()
decl_stmt|;
name|String
name|term
init|=
name|ref
operator|.
name|utf8ToString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|end
operator|==
literal|null
operator|||
name|term
operator|.
name|compareTo
argument_list|(
name|end
argument_list|)
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|start
operator|==
literal|null
operator|||
name|term
operator|.
name|startsWith
argument_list|(
name|start
argument_list|)
operator|)
condition|)
block|{
name|DocsEnum
name|docsEnum
init|=
name|termsIter
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|docsEnum
operator|.
name|nextDoc
argument_list|()
operator|!=
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|!=
literal|null
operator|&&
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|docsEnum
operator|.
name|docID
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|docId
init|=
operator|(
name|int
operator|)
name|docIdValues
operator|.
name|get
argument_list|(
name|docsEnum
operator|.
name|docID
argument_list|()
argument_list|)
decl_stmt|;
name|DocumentImpl
name|storedDocument
init|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedDocument
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
specifier|final
name|BytesRef
name|nodeIdRef
init|=
name|nodeIdValues
operator|.
name|get
argument_list|(
name|docsEnum
operator|.
name|docID
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|units
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|nodeIdRef
operator|.
name|bytes
argument_list|,
name|nodeIdRef
operator|.
name|offset
argument_list|)
decl_stmt|;
name|NodeId
name|nodeId
init|=
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|createFromData
argument_list|(
name|units
argument_list|,
name|nodeIdRef
operator|.
name|bytes
argument_list|,
name|nodeIdRef
operator|.
name|offset
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|get
argument_list|(
name|storedDocument
argument_list|,
name|nodeId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addOccurrence
argument_list|(
name|map
argument_list|,
name|term
argument_list|,
name|docsEnum
operator|.
name|freq
argument_list|()
argument_list|,
name|storedDocument
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addOccurrence
argument_list|(
name|map
argument_list|,
name|term
argument_list|,
name|docsEnum
operator|.
name|freq
argument_list|()
argument_list|,
name|storedDocument
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|termsIter
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
do|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|addOccurrence
parameter_list|(
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Occurrences
argument_list|>
name|map
parameter_list|,
name|String
name|term
parameter_list|,
name|int
name|frequency
parameter_list|,
name|DocumentImpl
name|storedDocument
parameter_list|)
throws|throws
name|IOException
block|{
name|Occurrences
name|oc
init|=
name|map
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|oc
operator|==
literal|null
condition|)
block|{
name|oc
operator|=
operator|new
name|Occurrences
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|oc
operator|.
name|addDocument
argument_list|(
name|storedDocument
argument_list|)
expr_stmt|;
name|oc
operator|.
name|addOccurrences
argument_list|(
name|frequency
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds the passed character sequence to the lucene index. We      * create one lucene document per XML node, using 2 fields to identify      * the node:      *      *<ul>      *<li>docId: eXist-internal document id of the node, stored as string.</li>      *<li>nodeId: the id of the node, stored in binary compressed form.</li>      *</ul>      *      * The text is indexed into a field whose name encodes the qualified name of      * the node. The qualified name is stored as a hex sequence pointing into the      * global symbol table.      *      * @param nodeId the node if      * @param qname the qname of the node      * @param path the node path      * @param config the lucene index config      * @param content the content of the node      */
specifier|protected
name|void
name|indexText
parameter_list|(
specifier|final
name|NodeId
name|nodeId
parameter_list|,
specifier|final
name|QName
name|qname
parameter_list|,
specifier|final
name|NodePath
name|path
parameter_list|,
specifier|final
name|LuceneIndexConfig
name|config
parameter_list|,
specifier|final
name|CharSequence
name|content
parameter_list|)
block|{
specifier|final
name|PendingDoc
name|pending
init|=
operator|new
name|PendingDoc
argument_list|(
name|nodeId
argument_list|,
name|qname
argument_list|,
name|path
argument_list|,
name|content
argument_list|,
name|config
operator|.
name|getBoost
argument_list|()
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|addPending
argument_list|(
name|pending
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds the passed character sequence to the lucene index.      * This version uses the AttrImpl for node specific attribute match boosting.      *      * @param attribs the attributes      * @param nodeId the node id      * @param qname the qname of the node      * @param path the path of the node      * @param config the lucene index config      * @param content the content of the node      */
specifier|protected
name|void
name|indexText
parameter_list|(
specifier|final
name|java
operator|.
name|util
operator|.
name|Collection
argument_list|<
name|AttrImpl
argument_list|>
name|attribs
parameter_list|,
specifier|final
name|NodeId
name|nodeId
parameter_list|,
specifier|final
name|QName
name|qname
parameter_list|,
specifier|final
name|NodePath
name|path
parameter_list|,
specifier|final
name|LuceneIndexConfig
name|config
parameter_list|,
specifier|final
name|CharSequence
name|content
parameter_list|)
block|{
specifier|final
name|PendingDoc
name|pending
init|=
operator|new
name|PendingDoc
argument_list|(
name|nodeId
argument_list|,
name|qname
argument_list|,
name|path
argument_list|,
name|content
argument_list|,
name|config
operator|.
name|getAttrBoost
argument_list|(
name|attribs
argument_list|)
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|addPending
argument_list|(
name|pending
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addPending
parameter_list|(
specifier|final
name|PendingDoc
name|pending
parameter_list|)
block|{
name|nodesToWrite
operator|.
name|add
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|cachedNodesSize
operator|+=
name|pending
operator|.
name|text
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|cachedNodesSize
operator|>
name|maxCachedNodesSize
condition|)
block|{
name|write
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|PendingDoc
block|{
specifier|private
specifier|final
name|NodeId
name|nodeId
decl_stmt|;
specifier|private
specifier|final
name|QName
name|qname
decl_stmt|;
specifier|private
specifier|final
name|NodePath
name|path
decl_stmt|;
specifier|private
specifier|final
name|CharSequence
name|text
decl_stmt|;
specifier|private
specifier|final
name|float
name|boost
decl_stmt|;
specifier|private
specifier|final
name|LuceneIndexConfig
name|idxConf
decl_stmt|;
specifier|private
name|PendingDoc
parameter_list|(
specifier|final
name|NodeId
name|nodeId
parameter_list|,
specifier|final
name|QName
name|qname
parameter_list|,
specifier|final
name|NodePath
name|path
parameter_list|,
specifier|final
name|CharSequence
name|text
parameter_list|,
specifier|final
name|float
name|boost
parameter_list|,
specifier|final
name|LuceneIndexConfig
name|idxConf
parameter_list|)
block|{
name|this
operator|.
name|nodeId
operator|=
name|nodeId
expr_stmt|;
name|this
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|this
operator|.
name|idxConf
operator|=
name|idxConf
expr_stmt|;
name|this
operator|.
name|boost
operator|=
name|boost
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|PendingAttr
block|{
specifier|private
specifier|final
name|AttrImpl
name|attr
decl_stmt|;
specifier|private
specifier|final
name|LuceneIndexConfig
name|conf
decl_stmt|;
specifier|private
specifier|final
name|NodePath
name|path
decl_stmt|;
specifier|public
name|PendingAttr
parameter_list|(
specifier|final
name|AttrImpl
name|attr
parameter_list|,
specifier|final
name|NodePath
name|path
parameter_list|,
specifier|final
name|LuceneIndexConfig
name|conf
parameter_list|)
block|{
name|this
operator|.
name|attr
operator|=
name|attr
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|write
parameter_list|()
block|{
if|if
condition|(
name|nodesToWrite
operator|==
literal|null
operator|||
name|nodesToWrite
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|canFlush
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|broker
operator|.
name|getIndexController
argument_list|()
operator|.
name|isReindexing
argument_list|()
condition|)
block|{
comment|// remove old indexed nodes
name|nodesToRemove
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|PendingDoc
name|p
range|:
name|nodesToWrite
control|)
block|{
name|nodesToRemove
operator|.
name|add
argument_list|(
name|p
operator|.
name|nodeId
argument_list|)
expr_stmt|;
block|}
name|removeNodes
argument_list|()
expr_stmt|;
block|}
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|()
expr_stmt|;
comment|// docId and nodeId are stored as doc value
name|NumericDocValuesField
name|fDocId
init|=
operator|new
name|NumericDocValuesField
argument_list|(
name|FIELD_DOC_ID
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|BinaryDocValuesField
name|fNodeId
init|=
operator|new
name|BinaryDocValuesField
argument_list|(
name|LuceneUtil
operator|.
name|FIELD_NODE_ID
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|8
argument_list|)
argument_list|)
decl_stmt|;
comment|// docId also needs to be indexed
name|IntField
name|fDocIdIdx
init|=
operator|new
name|IntField
argument_list|(
name|FIELD_DOC_ID
argument_list|,
literal|0
argument_list|,
name|IntField
operator|.
name|TYPE_NOT_STORED
argument_list|)
decl_stmt|;
for|for
control|(
name|PendingDoc
name|pending
range|:
name|nodesToWrite
control|)
block|{
specifier|final
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AbstractFieldConfig
argument_list|>
name|facetConfigs
init|=
name|pending
operator|.
name|idxConf
operator|.
name|getFacetsAndFields
argument_list|()
decl_stmt|;
name|facetConfigs
operator|.
name|forEach
argument_list|(
name|config
lambda|->
name|config
operator|.
name|build
argument_list|(
name|broker
argument_list|,
name|currentDoc
argument_list|,
name|pending
operator|.
name|nodeId
argument_list|,
name|doc
argument_list|,
name|pending
operator|.
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|fDocId
operator|.
name|setLongValue
argument_list|(
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|fDocId
argument_list|)
expr_stmt|;
comment|// store the node id
name|int
name|nodeIdLen
init|=
name|pending
operator|.
name|nodeId
operator|.
name|size
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|nodeIdLen
operator|+
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
name|pending
operator|.
name|nodeId
operator|.
name|units
argument_list|()
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending
operator|.
name|nodeId
operator|.
name|serialize
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fNodeId
operator|.
name|setBytesValue
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|fNodeId
argument_list|)
expr_stmt|;
comment|// add separate index for node id
name|BinaryTokenStream
name|bts
init|=
operator|new
name|BinaryTokenStream
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|Field
name|fNodeIdIdx
init|=
operator|new
name|Field
argument_list|(
name|LuceneUtil
operator|.
name|FIELD_NODE_ID
argument_list|,
name|bts
argument_list|,
name|TYPE_NODE_ID
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|fNodeIdIdx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|idxConf
operator|.
name|doIndex
argument_list|()
condition|)
block|{
name|String
name|contentField
decl_stmt|;
comment|// the text content is indexed in a field using either
comment|// the qname of the element or attribute or the field
comment|// name defined in the configuration
if|if
condition|(
name|pending
operator|.
name|idxConf
operator|.
name|isNamed
argument_list|()
condition|)
name|contentField
operator|=
name|pending
operator|.
name|idxConf
operator|.
name|getName
argument_list|()
expr_stmt|;
else|else
name|contentField
operator|=
name|LuceneUtil
operator|.
name|encodeQName
argument_list|(
name|pending
operator|.
name|qname
argument_list|,
name|index
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSymbols
argument_list|()
argument_list|)
expr_stmt|;
name|Field
name|fld
init|=
operator|new
name|Field
argument_list|(
name|contentField
argument_list|,
name|pending
operator|.
name|text
operator|.
name|toString
argument_list|()
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|,
name|Field
operator|.
name|Index
operator|.
name|ANALYZED
argument_list|,
name|Field
operator|.
name|TermVector
operator|.
name|YES
argument_list|)
decl_stmt|;
if|if
condition|(
name|pending
operator|.
name|boost
operator|>
literal|0
condition|)
block|{
name|fld
operator|.
name|setBoost
argument_list|(
name|pending
operator|.
name|boost
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|config
operator|.
name|getBoost
argument_list|()
operator|>
literal|0
condition|)
block|{
name|fld
operator|.
name|setBoost
argument_list|(
name|config
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|add
argument_list|(
name|fld
argument_list|)
expr_stmt|;
block|}
name|fDocIdIdx
operator|.
name|setIntValue
argument_list|(
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|fDocIdIdx
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|docNodeId
init|=
name|LuceneUtil
operator|.
name|createId
argument_list|(
name|currentDoc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|pending
operator|.
name|nodeId
argument_list|)
decl_stmt|;
specifier|final
name|Field
name|fDocNodeId
init|=
operator|new
name|StoredField
argument_list|(
literal|"docNodeId"
argument_list|,
name|docNodeId
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|fDocNodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|idxConf
operator|.
name|getAnalyzer
argument_list|()
operator|==
literal|null
condition|)
block|{
name|writer
operator|.
name|addDocument
argument_list|(
name|config
operator|.
name|facetsConfig
operator|.
name|build
argument_list|(
name|index
operator|.
name|getTaxonomyWriter
argument_list|()
argument_list|,
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|addDocument
argument_list|(
name|config
operator|.
name|facetsConfig
operator|.
name|build
argument_list|(
name|index
operator|.
name|getTaxonomyWriter
argument_list|()
argument_list|,
name|doc
argument_list|)
argument_list|,
name|pending
operator|.
name|idxConf
operator|.
name|getAnalyzer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An exception was caught while indexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|nodesToWrite
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|cachedNodesSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**      * Optimize the Lucene index by merging all segments into a single one. This      * may take a while and write operations will be blocked during the optimize.      */
specifier|public
name|void
name|optimize
parameter_list|()
block|{
name|IndexWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|index
operator|.
name|getWriter
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An exception was caught while optimizing the lucene index: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|index
operator|.
name|releaseWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|LuceneStreamListener
extends|extends
name|AbstractStreamListener
block|{
specifier|private
name|ArrayList
argument_list|<
name|PendingAttr
argument_list|>
name|pendingAttrs
init|=
operator|new
name|ArrayList
argument_list|<
name|PendingAttr
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|AttrImpl
argument_list|>
name|attributes
init|=
operator|new
name|ArrayList
argument_list|<
name|AttrImpl
argument_list|>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
specifier|private
name|ElementImpl
name|currentElement
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|startReplaceDocument
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
comment|// if config has fields or facets, we cannot flush until the document is completely stored
name|canFlush
operator|=
name|config
operator|==
literal|null
operator|||
operator|!
name|config
operator|.
name|hasFieldsOrFacets
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|endReplaceDocument
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
name|canFlush
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|startIndexDocument
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
comment|// if config has fields or facets, we cannot flush until the document is completely stored
name|canFlush
operator|=
name|config
operator|==
literal|null
operator|||
operator|!
name|config
operator|.
name|hasFieldsOrFacets
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|endIndexDocument
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
name|canFlush
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|startElement
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|ElementImpl
name|element
parameter_list|,
name|NodePath
name|path
parameter_list|)
block|{
if|if
condition|(
name|currentElement
operator|!=
literal|null
condition|)
block|{
name|indexPendingAttrs
argument_list|()
expr_stmt|;
block|}
name|currentElement
operator|=
name|element
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|ReindexMode
operator|.
name|STORE
operator|&&
name|config
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|contentStack
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|TextExtractor
name|extractor
range|:
name|contentStack
control|)
block|{
name|extractor
operator|.
name|startElement
argument_list|(
name|element
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|LuceneIndexConfig
argument_list|>
name|configIter
init|=
name|config
operator|.
name|getConfig
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|configIter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|contentStack
operator|==
literal|null
condition|)
block|{
name|contentStack
operator|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|configIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LuceneIndexConfig
name|configuration
init|=
name|configIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuration
operator|.
name|match
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|TextExtractor
name|extractor
init|=
operator|new
name|DefaultTextExtractor
argument_list|()
decl_stmt|;
name|extractor
operator|.
name|configure
argument_list|(
name|config
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
name|contentStack
operator|.
name|push
argument_list|(
name|extractor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|super
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
name|element
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|endElement
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|ElementImpl
name|element
parameter_list|,
name|NodePath
name|path
parameter_list|)
block|{
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|ReindexMode
operator|.
name|STORE
operator|&&
name|contentStack
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|TextExtractor
name|extractor
range|:
name|contentStack
control|)
block|{
name|extractor
operator|.
name|endElement
argument_list|(
name|element
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|LuceneIndexConfig
argument_list|>
name|configIter
init|=
name|config
operator|.
name|getConfig
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|ReindexMode
operator|.
name|REMOVE_ALL_NODES
operator|&&
name|configIter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|ReindexMode
operator|.
name|REMOVE_SOME_NODES
condition|)
block|{
name|nodesToRemove
operator|.
name|add
argument_list|(
name|element
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|configIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LuceneIndexConfig
name|configuration
init|=
name|configIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuration
operator|.
name|match
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|TextExtractor
name|extractor
init|=
name|contentStack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuration
operator|.
name|shouldReindexOnAttributeChange
argument_list|()
condition|)
block|{
comment|// if we still have the attributes cached
comment|// i e this element had no child elements,
comment|// use them to save some time
comment|// otherwise we fetch the attributes again
name|boolean
name|wasEmpty
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|attributes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|wasEmpty
operator|=
literal|true
expr_stmt|;
name|NamedNodeMap
name|attributes1
init|=
name|element
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes1
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|attributes
operator|.
name|add
argument_list|(
operator|(
name|AttrImpl
operator|)
name|attributes1
operator|.
name|item
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|indexText
argument_list|(
name|attributes
argument_list|,
name|element
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|element
operator|.
name|getQName
argument_list|()
argument_list|,
name|path
argument_list|,
name|extractor
operator|.
name|getIndexConfig
argument_list|()
argument_list|,
name|extractor
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|attributes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no attribute matching, index normally
name|indexText
argument_list|(
name|element
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|element
operator|.
name|getQName
argument_list|()
argument_list|,
name|path
argument_list|,
name|extractor
operator|.
name|getIndexConfig
argument_list|()
argument_list|,
name|extractor
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|indexPendingAttrs
argument_list|()
expr_stmt|;
name|currentElement
operator|=
literal|null
expr_stmt|;
name|super
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
name|element
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|attribute
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|AttrImpl
name|attrib
parameter_list|,
name|NodePath
name|path
parameter_list|)
block|{
name|path
operator|.
name|addComponent
argument_list|(
name|attrib
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
name|AttrImpl
name|attribCopy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ReindexMode
operator|.
name|STORE
operator|&&
name|currentElement
operator|!=
literal|null
condition|)
block|{
name|attribCopy
operator|=
operator|(
name|AttrImpl
operator|)
name|NodePool
operator|.
name|getInstance
argument_list|()
operator|.
name|borrowNode
argument_list|(
name|Node
operator|.
name|ATTRIBUTE_NODE
argument_list|)
expr_stmt|;
name|attribCopy
operator|.
name|setValue
argument_list|(
name|attrib
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|attribCopy
operator|.
name|setNodeId
argument_list|(
name|attrib
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
name|attribCopy
operator|.
name|setQName
argument_list|(
name|attrib
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|add
argument_list|(
name|attribCopy
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|LuceneIndexConfig
argument_list|>
name|configIter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
name|configIter
operator|=
name|config
operator|.
name|getConfig
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|ReindexMode
operator|.
name|REMOVE_ALL_NODES
operator|&&
name|configIter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|ReindexMode
operator|.
name|REMOVE_SOME_NODES
condition|)
block|{
name|nodesToRemove
operator|.
name|add
argument_list|(
name|attrib
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|configIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LuceneIndexConfig
name|configuration
init|=
name|configIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuration
operator|.
name|match
argument_list|(
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|configuration
operator|.
name|shouldReindexOnAttributeChange
argument_list|()
condition|)
block|{
name|appendAttrToBeIndexedLater
argument_list|(
name|attribCopy
argument_list|,
operator|new
name|NodePath
argument_list|(
name|path
argument_list|)
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexText
argument_list|(
name|attrib
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|attrib
operator|.
name|getQName
argument_list|()
argument_list|,
name|path
argument_list|,
name|configuration
argument_list|,
name|attrib
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|path
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
name|super
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
name|attrib
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|characters
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|AbstractCharacterData
name|text
parameter_list|,
name|NodePath
name|path
parameter_list|)
block|{
if|if
condition|(
name|contentStack
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|TextExtractor
name|extractor
range|:
name|contentStack
control|)
block|{
name|extractor
operator|.
name|beforeCharacters
argument_list|()
expr_stmt|;
name|extractor
operator|.
name|characters
argument_list|(
name|text
operator|.
name|getXMLString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
name|text
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexWorker
name|getWorker
parameter_list|()
block|{
return|return
name|LuceneIndexWorker
operator|.
name|this
return|;
block|}
comment|/**          * Delay indexing of attributes until we have them all to calculate boost          *          * @param attr the attribute to be indexed          * @param path the node path          * @param conf the index config          */
specifier|private
name|void
name|appendAttrToBeIndexedLater
parameter_list|(
name|AttrImpl
name|attr
parameter_list|,
name|NodePath
name|path
parameter_list|,
name|LuceneIndexConfig
name|conf
parameter_list|)
block|{
if|if
condition|(
name|currentElement
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"currentElement == null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pendingAttrs
operator|.
name|add
argument_list|(
operator|new
name|PendingAttr
argument_list|(
name|attr
argument_list|,
name|path
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Put pending attribute nodes in indexing cache          * and then clear pending attributes          */
specifier|private
name|void
name|indexPendingAttrs
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|mode
operator|==
name|ReindexMode
operator|.
name|STORE
operator|&&
name|config
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PendingAttr
name|pending
range|:
name|pendingAttrs
control|)
block|{
name|AttrImpl
name|attr
init|=
name|pending
operator|.
name|attr
decl_stmt|;
name|indexText
argument_list|(
name|attributes
argument_list|,
name|attr
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|attr
operator|.
name|getQName
argument_list|()
argument_list|,
name|pending
operator|.
name|path
argument_list|,
name|pending
operator|.
name|conf
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|pendingAttrs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|releaseAttributes
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|releaseAttributes
parameter_list|()
block|{
try|try
block|{
for|for
control|(
name|Attr
name|attr
range|:
name|attributes
control|)
block|{
name|NodePool
operator|.
name|getInstance
argument_list|()
operator|.
name|returnNode
argument_list|(
operator|(
name|AttrImpl
operator|)
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|attributes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

