begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*=============================================================================      Copyright 2009 Nikolay Ognyanov      Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at          http://www.apache.org/licenses/LICENSE-2.0      Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.  =============================================================================*/
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xpath
operator|.
name|parser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|CharStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|CommonToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|IntStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|RecognitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|RecognizerSharedState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|TokenSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|TokenStream
import|;
end_import

begin_comment
comment|/**  * Base class for generated XQuery parser. Has the following roles:  *<ol>  *<li> Produce tokens of custom type.</li>  *<li> Provide control over behavior upon errors.</li>  *<li> Switch between XQuery and direct XML lexers.</li>  *<li> Provide utilities for "add-on" parsing of details which   *      can not or should better not be handled in the generated parser.  *</li>  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|Parser
extends|extends
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|Parser
block|{
specifier|private
name|CharStream
name|source
decl_stmt|;
specifier|private
name|Stack
argument_list|<
name|TokenSource
argument_list|>
name|lexerStack
init|=
operator|new
name|Stack
argument_list|<
name|TokenSource
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Stack
argument_list|<
name|Integer
argument_list|>
name|elemStack
init|=
operator|new
name|Stack
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|breakOnError
init|=
literal|true
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"all"
argument_list|)
specifier|private
name|int
name|NCName
decl_stmt|;
specifier|private
name|int
name|Colon
decl_stmt|;
specifier|public
name|Parser
parameter_list|(
name|XQTokenStream
name|input
parameter_list|)
block|{
name|this
argument_list|(
name|input
argument_list|,
operator|new
name|RecognizerSharedState
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Parser
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|RecognizerSharedState
name|state
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|source
operator|=
operator|(
operator|(
name|Lexer
operator|)
name|input
operator|.
name|getTokenSource
argument_list|()
operator|)
operator|.
name|getCharStream
argument_list|()
expr_stmt|;
block|}
comment|/**      * Set a flag which determines error handling behavior. If the flag is      * true then a runtime exception is thrown upon error. Default value      * is "true"      *       * @param breakOnError the value to be set      */
specifier|public
name|void
name|setBreakOnError
parameter_list|(
name|boolean
name|breakOnError
parameter_list|)
block|{
name|this
operator|.
name|breakOnError
operator|=
name|breakOnError
expr_stmt|;
block|}
comment|/**      * Retrieves the value of the error handling flag.      *       * @return value of the flag      */
specifier|public
name|boolean
name|getBreakOnError
parameter_list|()
block|{
return|return
name|breakOnError
return|;
block|}
comment|/**      * A placeholder for implementation of custom error message handling.      */
annotation|@
name|Override
specifier|public
name|void
name|emitErrorMessage
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
operator|.
name|emitErrorMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * Overriden in order to provide control of error handling through      * {@link setBreakOnError}.      */
annotation|@
name|Override
specifier|public
name|void
name|reportError
parameter_list|(
name|RecognitionException
name|e
parameter_list|)
block|{
name|super
operator|.
name|reportError
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakOnError
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|getErrorHeader
argument_list|(
name|e
argument_list|)
operator|+
literal|" "
operator|+
name|getErrorMessage
argument_list|(
name|e
argument_list|,
name|getTokenNames
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Overriden in order to produce XQToken instead of CommonToken.      */
annotation|@
name|Override
specifier|protected
name|Object
name|getMissingSymbol
parameter_list|(
name|IntStream
name|input
parameter_list|,
name|RecognitionException
name|e
parameter_list|,
name|int
name|expectedTokenType
parameter_list|,
name|BitSet
name|follow
parameter_list|)
block|{
name|String
name|tokenText
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|expectedTokenType
operator|==
name|Token
operator|.
name|EOF
condition|)
name|tokenText
operator|=
literal|"<missing EOF>"
expr_stmt|;
else|else
name|tokenText
operator|=
literal|"<missing "
operator|+
name|getTokenNames
argument_list|()
index|[
name|expectedTokenType
index|]
operator|+
literal|">"
expr_stmt|;
name|CommonToken
name|t
init|=
operator|new
name|XQToken
argument_list|(
name|expectedTokenType
argument_list|,
name|tokenText
argument_list|)
decl_stmt|;
name|Token
name|current
init|=
operator|(
operator|(
name|TokenStream
operator|)
name|input
operator|)
operator|.
name|LT
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|getType
argument_list|()
operator|==
name|Token
operator|.
name|EOF
condition|)
block|{
name|current
operator|=
operator|(
operator|(
name|TokenStream
operator|)
name|input
operator|)
operator|.
name|LT
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|setLine
argument_list|(
name|current
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setCharPositionInLine
argument_list|(
name|current
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setChannel
argument_list|(
name|DEFAULT_TOKEN_CHANNEL
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/**      * Convinience method for throwing XQRecognitionException.      */
specifier|protected
name|void
name|raiseError
parameter_list|(
name|String
name|message
parameter_list|)
throws|throws
name|RecognitionException
block|{
throw|throw
operator|new
name|XQRecognitionException
argument_list|(
name|input
argument_list|,
name|message
argument_list|)
throw|;
block|}
specifier|private
name|void
name|popLexer
parameter_list|()
block|{
name|TokenSource
name|tokenSource
init|=
name|lexerStack
operator|.
name|pop
argument_list|()
decl_stmt|;
operator|(
operator|(
name|XQTokenStream
operator|)
name|input
operator|)
operator|.
name|setTokenSource
argument_list|(
name|tokenSource
argument_list|)
expr_stmt|;
block|}
comment|/**      * An empty hook. Called when generated parser encounters encoding      * declaration. According to W3C recommendation handling of such      * declaration is implementation dependent, so here it is left to      * language prpcessor designers...      */
specifier|protected
name|void
name|checkEncoding
parameter_list|()
block|{
comment|// String encoding = input.get(input.index()).getText();
comment|// System.out.println("Encoding: " + encoding);
block|}
comment|/**      * Check that current token is not preceded by blank space and throw      * error if it is.      *       * @throws RecognitionException      */
specifier|protected
name|void
name|noSpaceBefore
parameter_list|()
throws|throws
name|RecognitionException
block|{
if|if
condition|(
operator|(
operator|(
name|XQToken
operator|)
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|)
operator|.
name|spaceBefore
condition|)
block|{
name|raiseError
argument_list|(
literal|"Space not allowed before '"
operator|+
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check that current token, if preceded by specified other token, is       * separated from it by blank space and throw error if it is not.      *       * @param previous the kind of preceding token for which the check is      *                 to be made      */
specifier|protected
name|void
name|needSpaceBetween
parameter_list|(
name|int
name|previous
parameter_list|)
throws|throws
name|RecognitionException
block|{
if|if
condition|(
operator|(
name|input
operator|.
name|LA
argument_list|(
operator|-
literal|1
argument_list|)
operator|==
name|previous
operator|)
operator|&&
operator|!
operator|(
operator|(
name|XQToken
operator|)
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|)
operator|.
name|spaceBefore
condition|)
block|{
name|raiseError
argument_list|(
literal|"Space required before "
operator|+
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Push direct xml element on stack, so that later its name can be compared      * to name of the closing tag (if any).       */
specifier|protected
name|void
name|pushElemName
parameter_list|()
block|{
name|elemStack
operator|.
name|push
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Pop direct xml element from stack. Called if element is terminated      * immediately by '/>'      */
specifier|protected
name|void
name|popElemName
parameter_list|()
block|{
name|elemStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
comment|/**      * Check whether name of closing direct xml element tag matches name       * of opening tag. Throw error if names do not match.      *       * @throws RecognitionException      */
specifier|protected
name|void
name|matchElemName
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|String
name|opening
init|=
name|getQName
argument_list|(
name|elemStack
operator|.
name|pop
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|closing
init|=
name|getQName
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|opening
operator|.
name|equals
argument_list|(
name|closing
argument_list|)
condition|)
block|{
name|raiseError
argument_list|(
literal|"Closing tag name '"
operator|+
name|closing
operator|+
literal|" must match opening tag name '"
operator|+
name|opening
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|getQName
parameter_list|(
name|int
name|index
parameter_list|)
throws|throws
name|RecognitionException
block|{
if|if
condition|(
operator|(
name|index
operator|<
literal|2
operator|)
operator|||
name|input
operator|.
name|get
argument_list|(
name|index
operator|-
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|Colon
condition|)
block|{
return|return
name|input
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getText
argument_list|()
return|;
block|}
else|else
block|{
comment|//if(input.get(index - 2).getType() != NCName) {
comment|//    raiseError("Parser internal error.");
comment|//}
return|return
name|input
operator|.
name|get
argument_list|(
name|index
operator|-
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
name|input
operator|.
name|get
argument_list|(
name|index
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
name|input
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getText
argument_list|()
return|;
block|}
block|}
comment|/**      * Set values of some token codes needed by "add-on" parsing methods.      *       * @param NCName code of the NCName token      * @param Colon  code of the Colon token      * @return      */
specifier|protected
name|boolean
name|setTokenCodes
parameter_list|(
name|int
name|NCName
parameter_list|,
name|int
name|Colon
parameter_list|)
block|{
name|this
operator|.
name|NCName
operator|=
name|NCName
expr_stmt|;
name|this
operator|.
name|Colon
operator|=
name|Colon
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**      * Extract content of direct xml comment constructor parsed by generated      * parser. Throws error if contenct contains the forbidden sequence '--'.      *       * @return comment content      * @throws RecognitionException      */
specifier|protected
name|String
name|parseDirComment
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|String
name|content
init|=
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|content
operator|=
name|content
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|content
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|content
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
operator|(
name|content
operator|.
name|contains
argument_list|(
literal|"--"
argument_list|)
operator|||
name|content
operator|.
name|charAt
argument_list|(
name|length
operator|-
literal|1
argument_list|)
operator|==
literal|'-'
operator|)
condition|)
block|{
name|raiseError
argument_list|(
literal|"String '--' not allowed in xml comment."
argument_list|)
expr_stmt|;
block|}
return|return
name|content
return|;
block|}
comment|/**      * Extract content of direct xml CDATA section constructor parsed by the      * generated parser.      *       * @return CDATA section content.      *       * @throws RecognitionException      */
specifier|protected
name|String
name|parseCData
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|String
name|content
init|=
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
decl_stmt|;
name|content
operator|=
name|content
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|content
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
expr_stmt|;
return|return
name|content
return|;
block|}
comment|/**      * Extract target and content of direct xml processing instruction parsed      * by the generated parser. Throws excetion if procesing instruction       * target is invalid (equal to 'xml' ignoring case).      *       * @return pair of strings containing processing instruction target and      *         content.      *               * @throws RecognitionException      */
specifier|protected
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parseDirPI
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|String
name|text
init|=
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|charAt
argument_list|(
literal|2
argument_list|)
operator|<=
literal|'\u0020'
condition|)
block|{
name|raiseError
argument_list|(
literal|"Procesing instruction may not start with wihte space."
argument_list|)
expr_stmt|;
block|}
name|int
name|limit
init|=
name|text
operator|.
name|length
argument_list|()
operator|-
literal|2
decl_stmt|;
name|int
name|i
init|=
literal|2
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|limit
operator|)
operator|&&
operator|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|>
literal|'\u0020'
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|String
name|target
init|=
name|text
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"xml"
argument_list|)
condition|)
block|{
name|raiseError
argument_list|(
name|target
operator|+
literal|" is not a valid processing instruction name."
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|<=
literal|'\u0020'
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|String
name|content
init|=
name|text
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|limit
argument_list|)
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|target
argument_list|,
name|content
argument_list|)
return|;
block|}
comment|/**      * Extract name and content of direct xml pragma constructor parsed by      * the generated parser.      *       * @return a pair where the first element is pair of prefix and name       *         constituting a QName and second element is pragma text content.      *      * @throws RecognitionException      */
specifier|protected
name|Pair
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|parsePragma
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|String
name|text
init|=
name|input
operator|.
name|get
argument_list|(
name|input
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|int
name|start
init|=
literal|2
decl_stmt|;
while|while
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
operator|<=
literal|'\u0020'
condition|)
block|{
operator|++
name|start
expr_stmt|;
block|}
name|int
name|limit
init|=
name|text
operator|.
name|length
argument_list|()
operator|-
literal|2
decl_stmt|;
name|int
name|i
init|=
name|start
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|limit
operator|)
operator|&&
operator|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|>
literal|'\u0020'
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|String
name|prefix
init|=
literal|""
decl_stmt|;
name|String
name|target
init|=
name|text
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|':'
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|<
name|limit
operator|)
operator|&&
operator|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|>
literal|'\u0020'
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|prefix
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|text
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|<=
literal|'\u0020'
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|String
name|content
init|=
name|text
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|limit
argument_list|)
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|(
operator|new
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|prefix
argument_list|,
name|target
argument_list|)
argument_list|,
name|content
argument_list|)
return|;
block|}
block|}
end_class

end_unit

