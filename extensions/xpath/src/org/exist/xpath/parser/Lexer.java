begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*=============================================================================      Copyright 2009 Nikolay Ognyanov      Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at          http://www.apache.org/licenses/LICENSE-2.0      Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.  =============================================================================*/
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xpath
operator|.
name|parser
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|CharStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|RecognitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|RecognizerSharedState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|Token
import|;
end_import

begin_comment
comment|/**  * Base class for generated lexers. Has 3 roles:  *<ol>  *<li> Produce tokens of custom type.</li>  *<li> Provide control over behavior upon errors.</li>  *<li> Check validity of character references</li>  *</ol>  * Note the small naming trick of this class having same simple name as  * antlr.runtime.Lexer. The problem solved this way is lack of support  * in ANTLR for declaration of base class for generated lexer. For the  * sake of consistency same naming trick is used for {@link Parser} too.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Lexer
extends|extends
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|Lexer
block|{
specifier|private
name|boolean
name|breakOnError
init|=
literal|true
decl_stmt|;
specifier|public
name|Lexer
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Lexer
parameter_list|(
name|CharStream
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Lexer
parameter_list|(
name|CharStream
name|input
parameter_list|,
name|RecognizerSharedState
name|state
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a flag which determines error handling behavior. If the flag is      * true then a runtime exception is thrown upon error. Default value      * is "true".      *       * @param breakOnError the value to be set      */
specifier|public
name|void
name|setBreakOnError
parameter_list|(
name|boolean
name|breakOnError
parameter_list|)
block|{
name|this
operator|.
name|breakOnError
operator|=
name|breakOnError
expr_stmt|;
block|}
comment|/**      * Retrieves the value of the error handling flag.      *       * @return value of the flag      */
specifier|public
name|boolean
name|getBreakOnError
parameter_list|()
block|{
return|return
name|breakOnError
return|;
block|}
comment|/**      * Overrides the method in the base class and produces {@link XQToken}      * instead of CommonTokem.      */
annotation|@
name|Override
specifier|public
name|Token
name|emit
parameter_list|()
block|{
name|Token
name|t
init|=
operator|new
name|XQToken
argument_list|(
name|input
argument_list|,
name|state
operator|.
name|type
argument_list|,
name|state
operator|.
name|channel
argument_list|,
name|state
operator|.
name|tokenStartCharIndex
argument_list|,
name|getCharIndex
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|t
operator|.
name|setLine
argument_list|(
name|state
operator|.
name|tokenStartLine
argument_list|)
expr_stmt|;
name|t
operator|.
name|setText
argument_list|(
name|state
operator|.
name|text
argument_list|)
expr_stmt|;
name|t
operator|.
name|setCharPositionInLine
argument_list|(
name|state
operator|.
name|tokenStartCharPositionInLine
argument_list|)
expr_stmt|;
name|emit
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/**      * A placeholder for implementation of custom error message handling.      */
annotation|@
name|Override
specifier|public
name|void
name|emitErrorMessage
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
operator|.
name|emitErrorMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * Overriden in order to provide control of error handling through      * {@link setBreakOnError}.      */
annotation|@
name|Override
specifier|public
name|void
name|reportError
parameter_list|(
name|RecognitionException
name|e
parameter_list|)
block|{
name|super
operator|.
name|reportError
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakOnError
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|getErrorHeader
argument_list|(
name|e
argument_list|)
operator|+
literal|" "
operator|+
name|getErrorMessage
argument_list|(
name|e
argument_list|,
name|getTokenNames
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Convinience method for throwing {@link XQRecognitionException}.      *       * @param message the error message to be carried      * @throws RecognitionException      */
specifier|protected
name|void
name|raiseError
parameter_list|(
name|String
name|message
parameter_list|)
throws|throws
name|RecognitionException
block|{
throw|throw
operator|new
name|XQRecognitionException
argument_list|(
name|input
argument_list|,
name|message
argument_list|)
throw|;
block|}
comment|/**      * Check whether a recognizer character reference references a valid Char.      * Throws an error if this is not the case.      *       * @throws RecognitionException      */
specifier|protected
name|void
name|checkCharRef
parameter_list|()
throws|throws
name|RecognitionException
block|{
name|String
name|ref
init|=
name|getText
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|ref
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ref
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'&'
condition|)
block|{
name|start
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|isHex
init|=
name|ref
operator|.
name|charAt
argument_list|(
name|start
operator|+
literal|2
argument_list|)
operator|==
literal|'x'
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isHex
condition|)
block|{
name|value
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ref
operator|.
name|substring
argument_list|(
name|start
operator|+
literal|3
argument_list|,
name|length
operator|-
literal|1
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ref
operator|.
name|substring
argument_list|(
name|start
operator|+
literal|2
argument_list|,
name|length
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|raiseError
argument_list|(
literal|"Invalid character constant '"
operator|+
name|ref
operator|.
name|substring
argument_list|(
name|start
operator|-
literal|2
argument_list|)
operator|+
literal|".'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|value
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|value
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|value
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|value
operator|>=
literal|'\u0020'
operator|)
operator|&&
operator|(
name|value
operator|<=
literal|'\uD7FF'
operator|)
operator|||
operator|(
name|value
operator|>=
literal|'\uE000'
operator|)
operator|&&
operator|(
name|value
operator|<=
literal|'\uFFFD'
operator|)
operator|||
operator|(
name|value
operator|>=
literal|65536
operator|)
operator|&&
operator|(
name|value
operator|<=
literal|1114111
operator|)
condition|)
comment|//                  #x10000              #x10FFFF
block|{
comment|// OK
block|}
else|else
block|{
name|raiseError
argument_list|(
literal|"Invalid character constant '"
operator|+
name|ref
operator|.
name|substring
argument_list|(
name|start
argument_list|)
operator|+
literal|".'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

