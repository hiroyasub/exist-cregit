<?xml version="1.0" encoding="UTF-8"?>
<book xmlns:ci="http://apache.org/cocoon/include/1.0">
    <bookinfo>
        <graphic fileref="logo.jpg"/>

        <title>Open Source XML Database</title>
        <author>
            <firstname>Wolfgang M.</firstname>
            <surname>Meier</surname>
            <affiliation>
                <address format="linespecific">
                    <email>wolfgang@exist-db.org</email>
                </address>
            </affiliation>
        </author>
    </bookinfo>
    <ci:include src="sidebar.xml"/>
    <chapter>
        <title>XQuery</title>
        <section>
            <title>Current Status</title>
            <para>eXist implements the current XQuery working draft
            as of November, 2003 with some exceptions. In particular, the XML
            Schema related features are missing, computed node constructors, some 
            functions, and operator combinations still have to be implemented. Please
            have a look at the list of missing features below.</para>

            <para>The XQuery engine
            is a complete rewrite and replaces the old XPath engine. Older code based on 
            XPath should be compatible with the XQuery engine,
            though some aspects (e.g. the rules for automatic type conversions) have
            changed. The query engine doesn't make a difference between XPath
            and XQuery syntax internally. All interfaces should work as before, i.e. you can pass 
            an XQuery expression wherever you used to pass an XPath query.</para>

            <para>Currently, the following features are missing:</para>

            <itemizedlist>
                <listitem>Unrecognized keywords: 
                <command>typeswitch</command>, <command>treat as</command>,
                <command>instance of</command>, <command>castable as</command>.
                </listitem>

                <listitem>Schema related features: <command>validate</command>,
                <command>import schema</command>, <command>declare validation</command>.
                </listitem>

                <listitem>Computed node constructors are not supported. Normal
                node constructors are fully supported.</listitem>

                <listitem>Modules: <command>module</command> and <command>import module</command>
                are not recognized.</listitem>
                
                <listitem>The XQuery spec requires that node sequences are
                always returned in document order. Contrary to that, eXist does
                not maintain the document order for nested nodes.</listitem>
            </itemizedlist>

            <para>Another limitation applies to <emphasis>constructed document
            fragments</emphasis>: it is currently not possible to query document
            fragments that have been constructed within the XQuery, i.e. a query
            like the following will fail:</para>
            
            <synopsis>let $x := &lt;test>Test&lt;/test> return $x/test</synopsis>

            <para>The primary purpose of eXist is to query documents in the
            database. At this stage of development, the constructed in-memory DOM tree 
            can not be queried in the same way as the persistent database DOM.
            You have to store the fragment into the database first. You can use
            the provided <ulink url="#xmldb">xmldb extension functions</ulink> 
            for that.</para>
            
            <para>A list of all the functions currently known to the system can be
            viewed <a href="xquery/functions.xq">here</a>. This list is dynamically
            generated by an XQuery script, so the database needs to be running. The 
            function description is directly extracted from the signature
            provided by each class implementing the <classname>Function</classname> 
            interface.
            </para>
        </section>
        <section>
            <title>Extensions</title>
            <para>eXist offers a number of additional functions and two additional
            operators. These extensions can be grouped into three main categories:</para>

            <orderedlist>
                <listitem>
                    Functions to specify the input document set for an expression.
                </listitem>
                <listitem>
                    Extensions for full-text searching.
                </listitem>
                <listitem>
                    Functions for manipulating the database contents.
                </listitem>
                <listitem>
                    Utility functions.
                </listitem>
                <listitem>
                    HTTP related functions.
                </listitem>
            </orderedlist>

            <para>We start with the additional functions for specifying
            the input document set.</para>

            <section>
                <title>Specifying the Input Document Set</title>
                <para>A database may contain an unlimited set of collections and documents.
                If you use the XML:DB API to query the db, only the documents in the current 
                XML:DB collection are processed by default. However, there are three additional 
                functions to change this behavior: <command>doc()</command>, 
                <command moreinfo="none">document()</command>, 
                <command moreinfo="none">collection()</command> and <command>xcollection()</command>.</para>

            <para>The <command>collection()</command> and <command>doc()</command> 
            functions are standard XQuery/XPath functions.
            <command>xcollection()</command> and <command>document()</command> 
            represent eXist-specific extensions.</para>
            
            <para>eXist interprets the arguments to <command>collection</command> and <command>doc</command>
            as absolute or relative paths, leading to some collection or
            document within the database. Relative paths are resolved relative to the base
            URI property of the static XQuery context, which usually points to a database
            collection.</para>
            
            <note>
                <para>Currently, the document related functions are in the XQuery/XPath
                core library functions namespace (i.e. http://www.w3.org/2003/05/xpath-functions).
                This is definitely wrong, but previous versions of eXist did not use namespaces for
                functions, so older eXist-based applications would complain. However, in the future, the eXist-specific 
                functions will move to their own namespace.</para>
            </note>
            
            <para>While <command>doc()</command> is restricted to a single document-URI argument, 
            <command>document</command> accepts multiple
            document paths to be included into the input node set. Second, calling 
            <command>document</command> without an argument includes <emphasis>every</emphasis>
            document node in the current database instance. Some examples:</para>

                <synopsis format="linespecific">document()//SPEAKER</synopsis>
                <synopsis format="linespecific">document('/db/test/abc.xml', '/db/test/def.xml')//title</synopsis>

                <para>The <command moreinfo="none">collection()</command> function specifies the 
            collection whose documents are to be included into query evaluation. By default, 
            documents found in sub-collections of the specified collection are included. This 
            means that for three collections, <filename moreinfo="none">/db/test</filename>, 
            <filename moreinfo="none">/db/test/abc</filename> and 
            <filename moreinfo="none">/db/test/def</filename>, 
            <command moreinfo="none">collection('/db/test')</command> will include all resources 
            found in <filename moreinfo="none">/db/test</filename>, 
            <filename moreinfo="none">/db/test/abc</filename> and 
            <filename moreinfo="none">/db/test/def</filename>. You may use the 
            <command moreinfo="none">xcollection()</command> function to change this behavior, 
            e.g.</para>
                <synopsis format="linespecific">xcollection('/db/test')//title</synopsis>
                <para>will only include resources found in <filename moreinfo="none">/db/test</filename>, but not in <filename moreinfo="none">/db/test/abc</filename> or <filename moreinfo="none">/db/test/def</filename>.</para>
                <note>
                    <para>Beginning with version 0.9.3, the collection and document functions are implemented
                as ordinary functions. They may occur at any position where a function call is allowed.</para>
                </note>
            </section>
            <section>
                <title>Querying Text</title>
                <para>The standard XPath/XQuery function library contains most
                of the well-known string manipulation functions provided by
                every programming languages. However, these functions are rather
                insufficient when searching for a set of keywords or a phrase inside a
                larger portion of text or mixed content.</para>
                
                <para>This is a weak point if you have to work with document-centric 
                (as opposed to data-centric) documents. For many types of documents, the 
                provided standard
                functions will not yield satisfactory results. For example, you might remember 
                to have read something about "XML" and "databases" in some chapter of a book, 
                but you may not be sure where exactly it was. Using standard XQuery, you 
                could try a query like:</para>
                
                <synopsis format="linespecific">//chapter[contains(., 'XML') and contains(., 'databases')]</synopsis>
                
                <para>Query execution will probably be quite slow, because the XPath engine has to scan 
                the entire character content of all chapter nodes and their descendants. Still you can't be sure 
                to find all matches - for example, "databases" might have been written with a capital letter 
                at the start of the sentence.</para>
                <para>eXist offers additional operators and extension functions for efficient, index-based 
                access to the full-text content of nodes. With eXist, you could formulate 
                your query as follows:</para>
                <synopsis format="linespecific">//chapter[near(., 'XML database?', 50)]</synopsis>
                <para>This query will return all chapters containing both keywords in the correct 
                order and with less than 50 words between them. Additionally, the wildcard in "database?" 
                will match the singular as well as the plural form and the search is done case-insensitive.</para>
                <para>Since the query is index-based, it will usually be a magnitude faster than the standard 
                XPath query above. Let's walk through each of eXist's extensions:</para>
                <section>
                    <title>Operators</title>
                    <para>In cases where the order and distance of search terms is not important, eXist offers 
                    two additional operators for simple keyword queries: 
                    <command moreinfo="none">&amp;=</command> and <command moreinfo="none">|=</command>. 
                    </para>
                    
                    <variablelist>
                        <varlistentry>
                            <term>node-set &amp;= 'string of keywords'</term>
                            <listitem>
                                <para>selects context nodes containing all of the keywords in the right-hand 
                                argument in any order. The default tokenizer is used to split the right-hand 
                                argument into single tokens, i.e. any punctuation or white space is skipped. 
                                Wildcards are allowed. Keywords are compared case-insensitive.</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>node-set |= 'string of keywords'</term>
                            <listitem>
                                <para>as above, but selects context nodes containing <emphasis>any</emphasis> 
                                of the keywords in the right-hand argument.</para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    
                    <note>
                        <para>The strings are split into tokens using the
                        default tokenizer function. The current implementation
                        will work well for all european languages. For
                        non-european languages, things are a bit more
                        complicated. In these cases, eXist uses the predefined
                        unicode codepoints to decide where the string will be
                        split.</para>
                    </note>
                    
                    <para>Both operators accept simple wildcards in the keyword string. A 
                    <command moreinfo="none">?</command> matches zero or one character, 
                    <command moreinfo="none">*</command> matches zero or more characters. 
                    A character range <command moreinfo="none">[abc]</command> matches any 
                    of the characters in the range. You may use a backslash to escape wildcard 
                    characters.</para>
                    
                    <para>To match more complex patterns, full regular expression syntax is 
                    supported through additional functions, which will be described below.</para>
                    
                    <para>Please note that there is an important semantic difference between the two expressions:</para>
                    <synopsis format="linespecific">document()//SPEECH[LINE &amp;= "cursed spite"]</synopsis>
                    <para>and</para>
                    <synopsis format="linespecific">document()//SPEECH[LINE &amp;= "cursed" and LINE &amp;="spite"]</synopsis>
                    
                    <para>The first expression selects all distinct LINE nodes that contain both terms. The second 
                    one selects all context nodes (SPEECH) that have line children containing either or 
                    both of the terms. The second expression is supposed to yield more results than the 
                    first one. To make both expressions select nearly the same nodes, you would have to 
                    change the first one into</para>
                    <synopsis format="linespecific">document()//SPEECH[. &amp;= "cursed spite"]</synopsis>
                    <para>(but this will also include, say SPEAKER or STAGEDIR children of the SPEECH parent)</para>
                </section>
                <section>
                    <title>near()</title>
                    <para>As shown above, the <command moreinfo="none">near()</command> function behaves quite 
                    similar to the <command moreinfo="none">&amp;=</command> operator, but it additionally pays 
                    attention to the order of search terms and their distance in the source document. The syntax is:</para>
                    <synopsis format="linespecific">near(node-list, 'string of keywords' [, max-distance])</synopsis>
                    <para>The functions measures the distance between two search terms by counting the words in 
                    between them. A maximum distance of 1 is assumed by default, which means that the search terms 
                    should occur next to each other. Other values may be specified in the optional third argument, 
                    e.g.:</para>
                    <synopsis format="linespecific">document()//SPEECH[near(., 'love marriage', 25)</synopsis>
                    <para>will return any SPEECH elements containing the words "love" and "marriage" and less 
                    than 25 words between them.</para>
                    <para>Like <command moreinfo="none">&amp;=</command>, <command moreinfo="none">near()</command> 
                    accepts wildcards in the keyword string. As well, punctuation and whitespace will be skipped 
                    according to the default tokenization rules.</para>
                </section>
                <section>
                    <title>match-all()/match-any()</title>
                    <para>These functions are variations of the <command moreinfo="none">&amp;=</command> and 
                    <command moreinfo="none">|=</command> operators which interpret their arguments as 
                    regular expressions. <emphasis>But</emphasis>: contrary to the <command>matches</command>
                    function in the XQuery core library,
                    <command>match-all</command> and
                    <command>match-any</command> try to match the regular
                    expression argument against the keywords contained in the
                    full-text index, not against the entire text. Assume a document containing the
                    following paragraph:</para>
                    
                    <synopsis>&lt;para&gt;Peter lives in Frankfurt&lt;/para&gt;</synopsis>
                    
                    <para>Then the following expression:</para>
                    
                    <synopsis>match-all(para, "li[vf]e.?", "frank.*")</synopsis>
                    
                    <para>will match because the paragraph contains two keywords
                    matching the specified regular expression patterns.</para>
                    
                    <para>
                    <command moreinfo="none">match-all()</command> corresponds to 
                    <command moreinfo="none">&amp;=</command> in that it
                    will select context nodes with keywords
                    matching all of the specified regular expressions. <command moreinfo="none">match-any()</command> 
                    will select nodes with keywords matching <emphasis>any</emphasis> of the specified regexp.</para>
                        
                    <para>Since tokenization doesn't work correctly with regular expression patterns, each 
                    keyword has to be specified as a separate argument, so the syntax looks like:</para>
                    
                    <synopsis format="linespecific">match-all(node-set, 'regexp' [, 'regexp' ...])</synopsis>
                    
                    <para>Please note that the functions will try to match the regexp against the entire 
                    keyword. For example, the expression</para>
                    <synopsis format="linespecific">//SPEECH[match-all(LINE, 'li[vf]e')]</synopsis>
                    <para>will match 'live', 'life', but not 'lives'.</para>
                    <para>eXist uses <ulink url="http://jakarta.apache.org/oro/">Apache's ORO library </ulink> for regular expressions. A complete description of the supported regexp syntax can be found in the documentation of the library.</para>
                </section>
            </section>
            <section id="xmldb">
                <title>Manipulating Database Contents</title>
                
                <para>The xmldb extension functions can be used to create
                new database collections, or to store query output back
                into the database. For example, assume that someone has sent us
                a large file containing a number of RDF metadata records.
                Unfortunately, we don't want to store the metadata records
                as one, single file. Instead, our application expects each
                record to be in its own document. We thus have to transform
                the document and split it into smaller units.</para>
                
                <para>Using an XSLT stylesheet would be one alternative.
                However, it is rather memory-intensive. So why not use XQuery
                to do the job? The XQuery script below shows how to split the
                large RDF file into a number of smaller documents:</para>
                
                <example>
                    <title>Splitting a Document</title>
                    <programlisting>
<![CDATA[
xquery version "1.0";

declare namespace xmldb="http://exist-db.org/xquery/xmldb";
declare namespace util="http://exist-db.org/xquery/util";

xmldb:register-database("org.exist.xmldb.DatabaseImpl", true()),
let $root := xmldb:collection("xmldb:exist:///db", "admin", ""),
    $out := xmldb:create-collection($root, "output")
for $rec in /rdf:RDF/* return
    xmldb:store($out, concat(util:md5($rec/@rdf:about), ".xml"),
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
            {$rec}
        </rdf:RDF>
    )
]]>
                    </programlisting>
                </example>
                <para>The extension functions are based on the XML:DB API, so we
                first have to register a database driver with
                <command>xmldb:register-database</command>. Then we retrieve the
                root collection with <command>xmldb:collection</command>. The
                variable returned by <command>xmldb:collection</command> holds
                the collection as a Java object. We can pass this variable to
                <command>xmldb:create-collection</command> to create a new
                sub-collection, called "output".</para>
                
                <para>The <command>for</command> expression iterates through all
                child elements of the top RDF element. In each iteration, we use
                <command>xmldb:store</command> to write out the current child
                node into a new document.</para>
                
                <para>Obviously, a unique document name is required for each
                document. In this example, the URI contained in the rdf:about attribute is
                unique, so we simply compute an MD5 key from it, append ".xml" and use it as
                document name.</para>
            </section>
            
            <section>
                <title>Utility Functions</title>
                
                <para>The function namespace http://exist-db.org/xquery/util
                contains a number of common utility functions. For example,
                the <command>util:md5</command> function used above is defined 
                here.</para>
                
                <para>We will not discuss all available functions. All functions are 
                documented in the <a href="xquery/functions.xq">functions table</a>.
                However, there's one function which needs some further
                explanation:</para>
                
                <para><command>util:eval</command> is used to dynamically
                execute a constructed XQuery expression inside a running XQuery
                script. This is very handy sometimes, for example, in a
                web-based application, where queries are dynamically built from
                the request parameters the user has passed to the application.</para>
                
                <para>In this case, there would be one XQuery script, which is responsible
                for evaluating the user supplied parameters.
                This script uses the parameters from the HTTP request to create another
                XQuery expression. It then passes the constructed query string
                to <command>util:eval</command> to evaluate the expression,
                post-processes the returned results and displays them to the
                user. Below is a simple example to add or subtract two numbers:
                </para>
                
                <example>
                    <title>Adding/Subtracting Two Numbers</title>
                    
                    <programlisting>
<![CDATA[xquery version "1.0";

declare namespace request="http://exist-db.org/xquery/request";
declare namespace util="http://exist-db.org/xquery/util";

declare function local:do-query() as element()
{
	let $n1 := request:request-parameter("n1", ""),
		$n2 := request:request-parameter("n2", ""),
		$op := request:request-parameter("op", "")
	return
		if($n1 = "" or $n2 = "") then
			<p>Please enter two operands.</p>
		else
			let $query := concat($n1, " ", $op, " ", $n2)
			return
				<p>{$query} = {util:eval($query)}</p>
};

<html>
	<body>
		<h1>Enter two numbers</h1>

		<form action="add.xq" method="get">
			<table border="0" cellpadding="5">
				<tr>
					<td>First number:</td>
					<td><input name="n1" size="4"/></td>
				</tr>
				<tr>
					<td>Operator:</td>
					<td>
						<select name="op">
							<option name="+">+</option>
							<option name="-">-</option>
						</select>
					</td>
				</tr>
				<tr>
					<td>Second number:</td>
					<td><input name="n2" size="4"/></td>
				</tr>
				<tr>
					<td colspan="2"><input type="submit"/></td>
				</tr>
			</table>
		</form>

		{ local:do-query() }
	</body>
</html>]]>
                    </programlisting>
                </example>
            </section>
            <section>
                <title>HTTP Related Functions</title>
                
                <para>The example above reads HTTP request parameters using the
                function <command>request:request-parameter</command>. Obviously, 
                functions in the http://exist-db.org/xquery/request namespace 
                are only usable if the query is executed through the
                XQueryGenerator.</para>
                
                <para><command>request:request-parameter</command> expects two
                arguments: the first argument denotes the name of the parameter,
                the second specifies a default value, which is returned if the
                parameter is not set. The function returns a sequence containing
                the values for the parameter.</para>
                
                <para>There are also two functions to read and set session
                attributes. Any XQuery value can be stored into a session attribute, 
                for example, to cache query results.</para>
            </section>
        </section>
    </chapter>
</book>
