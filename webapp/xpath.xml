<?xml version="1.0" encoding="UTF-8"?>
<!--<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "docbookx.dtd">-->
<book xmlns:ci="http://apache.org/cocoon/include/1.0">
    <bookinfo>
        <graphic fileref="logo.jpg"/>
        <title>Open Source XML Database</title>
        <author>
            <firstname>Wolfgang M.</firstname>
            <surname>Meier</surname>
            <affiliation>
                <address format="linespecific">
                    <email>meier@ifs.tu-darmstadt.de</email>
                </address>
            </affiliation>
        </author>
    </bookinfo>
    <ci:include src="sidebar.xml"/>
    <chapter>
        <title>XPath HowTo</title>
        <section>
            <title>Current Status</title>
            <para>eXist's XPath query engine currently implements major parts of
                the standard, though it is not yet complete. Only abbreviated
                XPath syntax is supported so, for example, node-axis specifiers
                like previous-sibling/next-sibling still wait to be implemented.
                Since eXist's query processing differs a lot from standard
                implementations, we simply can't just plug in some other open
                source XPath engine. Instead, we put much work into the
                extensions eXist defines to standard XPath. However, the
                existing functionality covers most commonly needed XPath expressions.</para>
            <para>eXist currently supports the following functions from the
                XPath spec: contains, starts-with, ends-with, not, position,
                last, true, false, count, boolean, string, number,
                string-length, sum, floor, ceiling, round</para>
            <para>The following sections have a quick look at the extensions
                eXist adds to XPath to enable you to efficiently use the database.</para>
        </section>
        <section>
            <title>Specifying the Input Document Set</title>
            <para>A database may contain an unlimited set of collections and
                documents. If you use the XML:DB API to query the db, only the
                documents in the current XML:DB collection are processed.
                However, there are two additional XPath functions to change this
                behaviour: <command>document()</command> and <command>collection()</command>.</para>
            <para>
                <command>document()</command> accepts a single document path, a
                list of document paths, or a wildcard as parameters. The
                wildcard (*) selects all documents currently stored in the
                database. Some examples:</para>
            <synopsis>document(*)//SPEAKER</synopsis>
            <synopsis>document('/db/test/abc.xml', '/db/test/def.xml')//title</synopsis>
            <para>The <command>collection()</command> function specifies the
                collection whose documents are to be included into query
                evaluation. By default, documents found in sub-collections of
                the specified collection are included. This means that for three
                collections, <filename>/db/test</filename>,
                <filename>/db/test/abc</filename> and
                <filename>/db/test/def</filename>,
                <command>collection('/db/test')</command> will include all
                resources found in <filename>/db/test</filename>,
                <filename>/db/test/abc</filename> and
                <filename>/db/test/def</filename>. You may specify a second,
                boolean argument to change this behaviour, e.g.</para>
            <synopsis>collection('/db/test', false)//title</synopsis>
            <para>will only include resources found in
                <filename>/db/test</filename>, but not in
                <filename>/db/test/abc</filename> or <filename>/db/test/def</filename>.</para>
        </section>
        <section>
            <title>Querying Text</title>
            <para>Standard XPath defines only a few limited functions to search
                for a given string inside the character content of a node. This
                is a weak point if you have to search through documents
                containing larger sections of text. For many types of documents,
                the provided standard functions will not yield satisfying
                results. For example, you might remember to have read something
                about &quot;XML&quot; and &quot;databases&quot; in some chapter
                of a book, but you may not be sure where exactly it was. Using
                standard XPath, you could try a query like:</para>
            <synopsis>//chapter[contains(., 'XML') and contains(., 'databases')]</synopsis>
            <para>Query execution will probably be quite slow, because the XPath
                engine has to scan the entire character content of all chapters
                and their descendants. Still you can't be sure to find all
                matches - for example, &quot;databases&quot; might have been
                written with a capital letter at the start of sentence.</para>
            <para>eXist offers additional operators and extension functions for
                efficient, index-based access to the full-text content of nodes.
                With eXist, you could formulate your query as follows:</para>
            <synopsis>//chapter[near(., 'XML database?', 50)]</synopsis>
            <para>This query will return all chapters containing both keywords
                in the correct order and with less than 50 words between them.
                Additionally, the wildcard in &quot;database?&quot; will match
                singular as well as the plural form and the search is done case-insensitive.</para>
            <para>Since the query is index-based, it will usually be a magnitude
                faster than the standard XPath query above. Let's walk through
                each of eXist's extensions:</para>
            <section>
                <title>Operators</title>
                <para>In cases where the order and distance of search terms is
                    not important, eXist offers two additional operators for
                    simple keyword queries: <command>&amp;=</command> and
                    <command>|=</command>. </para>
                <variablelist>
                    <varlistentry>
                        <term>node-set &amp;= 'string of keywords'</term>
                        <listitem>
                            <para>selects context nodes containing all of the
                                keywords in the right-hand argument in any
                                order. The default tokenizer is used to split
                                the right-hand argument into single tokens, i.e.
                                any punctuation or whitespace is skipped.
                                Wildcards are allowed. Keywords are compared case-insensitive.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>node-set |= 'string of keywords'</term>
                        <listitem>
                            <para>as above, but selects context nodes containing
                                <emphasis>any</emphasis> of the keywords in the
                                right-hand argument.</para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>Both operators accept simple wildcards in the keyword
                    string. A <command>?</command> matches zero or one
                    character, <command>*</command> matches zero or more
                    characters. A character range <command>[abc]</command>
                    matches any of the characters in the range. You may use a
                    backslash to escape wildcard characters.</para>
                <para>To match more complex patterns, full regular expression
                    syntax is supported through additional functions, which will
                    be described below.</para>
                <para>Please note that there is an important semantic difference
                    between the two expressions:</para>
                <synopsis>document(*)//SPEECH[LINE &amp;= &quot;cursed spite&quot;]</synopsis>
                <para>and</para>
                <synopsis>document(*)//SPEECH[LINE &amp;= &quot;cursed&quot; and
                    LINE &amp;=&quot;spite&quot;]</synopsis>
                <para>The first expression selects all distinct LINE nodes that
                    contain both terms. The second one selects all context nodes
                    (SPEECH) that have line children containing either or both
                    of the terms. The second expression is supposed to yield
                    more results than the first one. To make both expressions
                    select nearly the same nodes, you would have to change the
                    first one into</para>
                <synopsis>document(*)//SPEECH[. &amp;= &quot;cursed spite&quot;]</synopsis>
                <para>(but this will also include, say SPEAKER or STAGEDIR
                    children of the SPEECH parent)</para>
            </section>
            <section>
                <title>near()</title>
                <para>As shown above, the <command>near()</command> function
                    behaves quite similar to the <command>&amp;=</command>
                    operator, but it additonally pays attention to the order of
                    search terms and their distance in the source document. The
                    syntax is:</para>
                <synopsis>near(node-list, 'string of keywords' [, max-distance])</synopsis>
                <para>The functions measures the distance between two search
                    terms by counting the words in between them. A maximum
                    distance of 1 is assumed by default, which means that the
                    search terms should occurr next to each other. Other values
                    may be specified in the optional third argument, e.g.:</para>
                <synopsis>document(*)//SPEECH[near(., 'love marriage', 25)</synopsis>
                <para>will return any SPEECH elements containing the words
                    &quot;love&quot; and &quot;marriage&quot; and less than 25
                    words between them.</para>
                <para>Like <command>&amp;=</command>, <command>near()</command>
                    accepts wildcards in the keyword string. As well,
                    punctuation and whitespace will be skipped according to the
                    default tokenization rules.</para>
            </section>
            <section>
                <title>match-all()/match-any()</title>
                <para>These functions are variations of the
                    <command>&amp;=</command> and <command>|=</command>
                    operators which interpret their arguments as regular
                    expressions. Both functions are also completely based on
                    index lookups.</para>
                <para>Since tokenization doesn't work correctly with regular
                    expression patterns, each keyword has to be specified as a
                    seperate argument, so the syntax looks like:</para>
                <synopsis>match-all(node-set, 'regexp' [, 'regexp' ...])</synopsis>
                <para>
                    <command>match-all()</command> corresponds to
                    <command>&amp;=</command> in that it will select context
                    nodes matching all of the specified regular expressions.
                    <command>match-any()</command> will select nodes matching
                    <emphasis>any</emphasis> of the specified regexp.</para>
                <para>Please note that the functions will try to match the
                    regexp against the entire keyword. For example, the expression</para>
                <synopsis>//SPEECH[match-all(LINE, 'li[vf]e')]</synopsis>
                <para>will match 'live', 'life', but not 'lives'.</para>
                <para>eXist uses <ulink
                        href="http://jakarta.apache.org/oro/">Apache's ORO
                        library </ulink> for regular expressions. A complete
                    description of the supported regexp syntax can be found in
                    the documentation of the library.</para>
            </section>
            <section>
                <title>match()</title>
                <para>The <command>match()</command> function differs from all
                    other functions presented here in that it does not use the
                    fulltext index. Instead, <command>match()</command> tries to
                    match the regexp against the character content of a node and
                    its child nodes. The syntax is:</para>
                <synopsis>match(node-set, 'regexp')</synopsis>
                <para>
                    <command>match()</command> thus works similar to
                    <command>contains()</command> and will usually be much
                    slower than the index-based fulltext functions
                    <command>match-all()</command> or <command>match-any()</command>.</para>
            </section>
        </section>
    </chapter>
</book>
