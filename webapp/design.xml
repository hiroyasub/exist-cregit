<book xmlns:ci="http://apache.org/cocoon/include/1.0">
	<ci:include src="sidebar.xml"/>
    <chapter id="ch01">
        <title>Design of eXist</title>
        <para>This is a documentation about the internals and implementation of eXist.</para>
        <section id="sectIndexing">
            <title>Nodes indexing</title>
            <section>
            <title>Algorithm</title>
            <para>

A reference article is the following :
            <p>
                <i>Wolfgang Meier</i>. 
                <ulink url="http://exist-db.org/webdb.pdf">eXist: An Open Source Native XML Database</ulink>
            </p>

There is a basic problem since a long time and I basically know how 
to solve it. I just lack the time to figure out the one missing algorithm. 
Version 1.0b1 is at least able to warn users when it fails to index a document.
            </para>

            <para>
Let me explain the basic problem: eXist uses a numbering scheme to address 
nodes in the document tree. This has many benefits compared to other 
approaches. Most important, eXist can resolve node relationships by just 
looking at the numerical identifiers. This makes query processing fast. 
Assume you have a document like this:
            </para>

<pre>
<![CDATA[
<section>
	<title>Title</title>
	<para><b>bold text</bold></para>
</section>

Internally, eXist assigns the following ids to every node:

1 <section>
| 		|
2 <title> 	3 <para>
|		|
4 "Title"	5 <b>
|		|
6		7 "bold text"
]]>
</pre>

            <para>
The assigned ids have some special properties: you can easily determine the id of 
the parent node, the first child node or any siblings by just looking at the 
id. This is what eXist's query engine does to resolve path steps. Obviously, 
looking at numeric identifiers is much faster than actually loading the DOM 
nodes.
            </para>

            <para>
As you can see, node 6 is a "virtual" node. It simply has to be inserted to 
balance the tree (eXist just balances the nodes in every level of the tree, 
not the tree as a whole).
            </para>

            <para>
As is obvious, there will always be some point where the balancing fails. The 
problem does not arise as long as the data is more or less regularily 
structured. However, if too many "virtual" nodes have to be inserted at 
adjacent levels of the tree, the assigned numbers will explode. For example, 
this happens if you have a large number of simple elements below the root 
node, but also some deeply nested nodes between them (in this case, the 
solution is simple: split the document below the root node into several 
pieces).
            </para>

            <para>
What possibilities do we have to solve this?

<ol>
<li>
Choose a different numbering scheme

Replacing the numbering scheme wouldn't be too difficult. Several schemes have 
been proposed in the literature. However, they all have drawbacks in one way 
or another. In particular, most schemes can only be applied to some types of 
XPath operations, but not to all, so we would have to store much more 
information with the DOM to support the missing operations.
</li>

<li>
Throw the numbering scheme overboard

There are other possible approaches to XML indexing. For example, some systems 
use a limited index: they just track if a node does occur in a document or 
not (and possibly its location within storage). This way, they can limit the 
number of documents to be searched. Then a traditional top-down tree 
traversal is used to search the documents in question. These systems are fast 
on a large number of rather small documents, but performance may get bad for 
larger docs or ancestor-descendant queries, which involve traversing a large 
portion of the node tree.
</li>

<li>
Automatically split documents in a way transparent to the user

This alternative is my favourite one. Whenever the indexer recognizes that the 
numbering scheme may get at its limits, the document is automatically split 
into several smaller parts. This works transparent to the user. He just sees 
one document.
</li>
</ol>
            </para>

            <para>
Searching through a split document is cheap: whenever the query engine reaches 
the root node of a split document, it replaces the node id of the root node 
with the original id of the node in the main document, and continues to 
process the query from there.
            </para>

            <para>
So, the only question remaining is to find an algorithm to correctly determine 
the split positions in the original document to get an optimal distribution 
of nodes.
            </para>
<hr/>
            <para>
I now have a 
possible solution on paper. It doesn't require too many modifications to the 
storage system (it extends node ids to be two-dimensional to support 
sub-document partitions), so a solution is in sight at least.
            </para>
            </section>
            <section>
            <title>Nodes indexing implementation</title>
Here is an UML-like diagram (made with BlueJ) of org/exist/storage package.
NativeBroker is the main class here, a facade to the rest of the implementation. 

The actual indexing occurs in class NativeElementIndex.
<br />
<img alt="storage diagram" border="0" src="resources/storage-diagram.jpg" />

            <para>
The storage package depends on the store package for the actual storage files.
<br />
<img alt="storage diagram" border="0" src="resources/storage.store-diagram.jpg" />
            </para>
            </section>
        </section>

        <section>
            <title>DOM processing</title>
        <section>
            <title>Algorithm</title>
            <para>
Again, the reference article is the following :
            <p>
                <i>Wolfgang Meier</i>. 
                <ulink url="http://exist-db.org/webdb.pdf">eXist: An Open Source Native XML Database</ulink>
            </p>
            </para>
        </section>
            <section>
            <title>DOM implementation</title>
Here is an UML-like diagram (made with BlueJ) of org/exist/dom package.
ElementImpl and AbstractNodeSet are the main classes.
<img alt="DOM diagram" border="0" src="resources/dom-diagram.jpg" />
        </section>
        </section>

        <section>
            <title>XPath processing</title>
        <section>
            <title>Algorithm</title>
            <para>
Again, the reference article is the following :
            <p>
                <i>Wolfgang Meier</i>. 
                <ulink url="http://exist-db.org/webdb.pdf">eXist: An Open Source Native XML Database</ulink>
            </p>
            </para>
        </section>
            <section>
            <title>XPath implementation</title>
Here is an UML-like diagram (made with BlueJ) of org/exist/xquery package.
It is made for the largest part of the hierarchy of AbstractExpression .

The Ancestor-Descendant Join algorithm is described in W. Meier's article. It is implemented in ???.
<img alt="DOM diagram" border="0" src="resources/xquery-diagram.jpg" />
<br />
Value is a sub-package of xquery.
It is made for the largest part of the hierarchies of AbstractSequence, ComputableValue, and Atomic Value .
        </section>
        </section>
    </chapter>
</book>
