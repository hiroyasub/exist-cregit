<?xml version="1.0" encoding="UTF-8"?>
<book xmlns:ci="http://apache.org/cocoon/include/1.0">
    <bookinfo>
        <graphic fileref="logo.jpg"/>
        <title>Open Source Native XML Database</title>
        <author>
            <firstname>Wolfgang M.</firstname>
            <surname>Meier</surname>
            <affiliation>
                <address format="linespecific">
                    <email>wolfgang@exist-db.org</email>
                </address>
            </affiliation>
        </author>
    </bookinfo>
    <ci:include src="sidebar.xml"/>
    <chapter>
        <title>Configuring Indexes</title>
        <section>
            <title>Overview</title>
            <para>eXist basically knows three different types of indexes:</para>
            <orderedlist>
                <listitem>
                    <para>
                        <emphasis>Structural index</emphasis>: keeps track of
                        all element and attribute occurrences within a collection.</para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Fulltext index</emphasis>: maps text tokens to
                        the text and attribute nodes in which they occur.</para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Range index</emphasis>: a type-specific index
                        on defined node values. Range indexes have to be
                        explicitely created.</para>
                </listitem>
            </orderedlist>
            <section>
                <title>Structural index</title>
                <para>This index is maintained automatically and does not need
                    to be configured. Almost all basic XPath/XQuery expressions
                    rely on the structural index (except wildcard expressions
                    like //*). The index is stored in the database file
                    <filename>elements.dbx</filename>. </para>
            </section>
            <section>
                <title>Fulltext index</title>
                <para>The <emphasis>fulltext index</emphasis> is required by
                    eXist's fulltext extensions, including the
                    <command>&amp;=</command> and <command>|=</command>
                    operators, and functions like <command>near()</command>,
                    <command>match-all()</command> etc. These extensions are
                    described in the <ulink url="xquery.xml">XQuery</ulink> docs.</para>
                <para>By default, all text nodes are fulltext indexed, but it is
                    possible to exclude or include specific sections of a
                    document in the configuration as described below.</para>
                <para>The fulltext index is stored in file
                    <filename>words.dbx</filename>. </para>
            </section>
            <section>
                <title>Range index</title>
                <para>
                    <emphasis>Range indexes</emphasis> provide a shortcut for
                    the database to directly select nodes by their typed values.
                    Range indexes are constructed when loading the document, and
                    are automatically maintained during subsequent updates of
                    the document or a part of it.</para>
                <para>For example, if your document contains an element
                    &lt;price&gt; and the content of this element is a
                    floating point number, you can define a range index on price
                    with type <option>xs:double</option>. During indexing, eXist
                    will try to convert all &lt;price&gt; values to an
                    xs:double instance and put these values into the range
                    index. Values that cannot be cast to xs:double are ignored.</para>
                <para>The range index will then be used by any expression that
                    compares &lt;price&gt; to a numeric value. For example:</para>
                <synopsis>//item[price &gt; 100.0]</synopsis>
                <para>For non-string types, a range index saves the query engine
                    a lot of conversion work. Instead of retrieving the value of
                    each price element and casting it to xs:double, the engine
                    can evaluate the expression with a single index lookup.</para>
                <para>However, the benefits also apply to string values: without
                    a range index, eXist will try to use the fulltext index to
                    restrict the number of nodes to look at, but it still has to
                    scan the resulting node set to filter out wrong matches.
                    Using a range index, this scan is not required, and the
                    index can be used not only for equality comparisons, but
                    also for &lt;, &gt;, and even regular expression
                    searches with fn:match().</para>
                <para>The query plan optimizer selects a range index lookup if
                    the following conditions are met: 1) a range index is
                    defined on <emphasis>all</emphasis> items in the input
                    sequence, 2) the index type matches the type of the second
                    argument, and 3) the second argument has no dependencies on
                    the current context item.</para>
            </section>
        </section>
        <section>
            <title>Index Configuration</title>
            <para>The default index creation policy can be configured in the
                central configuration file, conf.xml, which is read at database
                startup. Settings in conf.xml apply if no collection-specific
                configuration is found. Index creation for a specific collection and its
                sub-collections is configured in the collection configuration
                file, located in a special section of the database. Collection
                configurations are stored as normal XML documents below the
                system-collection: <filename>/db/system/config</filename>.</para>
            <para>To configure indexes for a collection, you have to create a
                <filename>collection.xconf</filename> file as described below,
                then store this file into the collection hierarchy below
                <filename>/db/system/config</filename>. The collection hierarchy
                in /db/system/config mirrors the main collection hierarchy. The name of the
                collection configuration file should <emphasis>always</emphasis>
                end with <filename>.xconf</filename>. For example, to configure
                collection <filename>/db/test</filename>, you should store your
                configuration to <filename>/db/system/config/db/test/text.xconf</filename>.</para>
            <para>The elements in the index configuration file should be in
                namespace
                <option>http://exist-db.org/collection-config/1.0</option>. For
                an example, assume you have a collection of documents similar to
                the following:</para>
            <example>
                <title>XML Document</title>
                <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<items xmlns:x="http://www.foo.com">
    <item>
        <itemno>1</itemno>
        <name>Red Bicycle</name>
        <price specialprice="false">645.5</price>
        <stock>15</stock>
		<x:rating>8.7</x:rating>
    </item>]]></programlisting>
            </example>
            <para>The collection configuration for this collection may then look
                as follows:</para>
            <example>
                <title>collection.xconf</title>
                <programlisting><![CDATA[<collection xmlns="http://exist-db.org/collection-config/1.0">
	<index xmlns:x="http://www.foo.com">
		<fulltext default="none" attributes="false" alphanum="false">
			<include path="//item/name"/>
		</fulltext>
		<create path="//item/itemno" type="xs:integer"/>
		<create path="//item/name" type="xs:string"/>
		<create path="//item/stock" type="xs:integer"/>
		<create path="//item/price" type="xs:double"/>
		<create path="//item/prices/@specialprice" type="xs:boolean"/>
		<create path="//item/x:rating" type="xs:double"/>
	</index>
</collection>]]></programlisting>
            </example>
            <para>The <option>index</option> element starts the index
                configuration section. Only one index element is allowed. It
                contains a single <option>fulltext</option> section, followed by
                zero or more <option>create</option> instructions.</para>
            <para>In the example above, we disable fulltext indexing for all elements, except
                the <sgmltag>name</sgmltag> element. We also define a bunch of range indexes
                through the <sgmltag>create</sgmltag> tags.</para>
            <section>
                <title>fulltext</title>
                <para>The <sgmltag>fulltext</sgmltag> section allows to exclude
                    or include specified parts of your document into the
                    fulltext index. Please note that even if you exclude some
                    parts you will still be able to search for them using
                    standard exact-match XPath expressions like =, &gt;,
                    &lt;, contains() ...</para>
                <para>You have to define a default-behaviour for the fulltext
                    indexer through the <option>default</option> attribute
                    setting. Available values are: <option>all</option> or
                    <option>none</option>. If the default behaviour is
                    <option>all</option>, all content will be indexed by
                    default. You may exclude some sections by defining a list of
                    <sgmltag>exclude</sgmltag> elements.</para>
                <para>If you set the default behaviour to <option>none</option>,
                    the indexer will ignore everything by default. Use
                    <sgmltag>include</sgmltag> elements to define those parts
                    you want to be included.</para>
                <para>The <sgmltag>include</sgmltag> and
                    <sgmltag>exclude</sgmltag> elements both expect an
                    index-path expression in the <option>path</option>
                    attribute. The syntax for an index-path is as follows:
                    elements are specified by their qname, attributes as
                    @attribute; / selects child nodes, // selects an item at
                    every position in the tree. For example,</para>
                <synopsis format="linespecific">&lt;exclude path="//url"/&gt;</synopsis>
                <para>exludes the content of all <sgmltag>url</sgmltag> tags and
                    their descendants.</para>
                <synopsis format="linespecific">&lt;exclude path="//article/@id"/&gt;</synopsis>
                <para>excludes the id-attribute of all
                    <sgmltag>article</sgmltag> elements.</para>
                <para>A path component may use a namespace prefix, for which a
                    mapping has to be defined in the enclosing
                    <option>index</option> tag. For example, element
                    <sgmltag>x:rating</sgmltag> above uses a namespace.</para>
                <note>
                    <para>Please note that index-paths are not XPath
                        expressions, though the syntax is similar. Index-paths
                        have to be evaluated during the indexing phase. At this
                        time, eXist has only a limited knowledge of the
                        document, so using full XPath expressions is not possible.</para>
                </note>
                <para>The following list explains all options available for the 
					<sgmltag>fulltext</sgmltag> section:</para>
				<variablelist>
					<varlistentry>
						<term>default</term>
						<listitem>
							<para>Defines the default behaviour for the 
								indexer. Valid settings are 
								<option>all</option> or 
								<option>none</option>.</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>attributes</term>
						<listitem>
							<para>Should attributes be indexed by default? 
								Possible values are <option>true</option> or 
								<option>false</option>.</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>alphanum</term>
						<listitem>
							<para>Should alpha-numeric sequences be indexed? 
								Setting this to <option>false</option> will 
								exclude numbers, dates, serial numbers and any 
								other kind of alpha-numeric sequence not being 
								a simple word.</para>
						</listitem>
					</varlistentry>
				</variablelist>
            </section>
            <section>
                <title>create</title>
                <para>The <sgmltag>create</sgmltag> tag defines a range index on
                    selected elements or attributes. It always has two attributes:
                    <option>path</option> and <option>type</option>.</para>
                <para>The path option specifies an index-path as described in the previous section. The range index
                    will be created for all elements or attributes matching this
                    path. Contrary to the fulltext section, the range index is only created
                for the element specified, not for its descendant nodes.</para>
                <para><option>type</option> defines the type to use for the index in terms
                    of an XML schema builtin type. Currently, the following types are
                supported:</para>
                <unorderedlist>
                    <listitem>xs:string</listitem>
                    <listitem>xs:integer</listitem>
                    <listitem>xs:double</listitem>
                    <listitem>xs:boolean</listitem>
                </unorderedlist>
                <para>Other types will probably be added in the future. Please note, that
                    the xs:integer type is limited to the range of values that can be represented
                    by a Java signed long.</para>
                <para>If a node value cannot be cast to the specified type, it will be ignored silently.
                    For example, if one of the price tags contains the string "unknown" instead of
                    a double value, the indexer will just skip this value. However, the value will still be
                    found in a string comparison.</para>
            </section>
            <section>
                <title>Configuration Loading</title>
                <para>Configurations are "inherited" within the hierarchy, i.e. settings in the child's 
                    configuration file are added to or overwrite those found in the parent collection. 
                    You thus don't need to specify a configuration for every collection: for example,
                    settings that apply to all collections can be specified in 
                    <filename>/db/system/config/db/collection.xconf</filename>.</para>
                
                <para>If a configuration is modified, the new settings will only apply to documents added
                    after the modification. To apply the settings to already existing documents, you need
                    to reindex the collection.</para>
            </section>
        </section>
    </chapter>
</book>
