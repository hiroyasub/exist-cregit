begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|CachingFilterInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *  * @author Adam Retter<adam@existsolutions.com>  */
end_comment

begin_class
specifier|public
class|class
name|BinaryValueFromInputStreamTest
block|{
annotation|@
name|Test
specifier|public
name|void
name|getInputStream
parameter_list|()
throws|throws
name|XPathException
throws|,
name|IOException
block|{
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|InputStream
name|bais
init|=
operator|new
name|FilterInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
name|BinaryValue
name|binaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
name|InputStream
name|is
init|=
name|binaryValue
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|int
name|read
init|=
operator|-
literal|1
decl_stmt|;
name|byte
name|buf
index|[]
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|read
operator|=
name|is
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|baos
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|read
argument_list|)
expr_stmt|;
block|}
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IOException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|filter_withoutIncrementReferenceCountFails
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis
init|=
name|binaryValue
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// create a filter over the first BinaryValue, with no reference count increment
specifier|final
name|InputStream
name|fis
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|bvis
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis
argument_list|)
decl_stmt|;
comment|// we now destroy the filtered binary value, just as it would be if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should close the original binary value, as we have not incremented the reference count!
name|filteredBinaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should not be able to read from the origin binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
comment|// this should throw an IOException
name|binaryValue
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|filter_withIncrementReferenceCount
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis
init|=
name|binaryValue
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// create a filter over the first BinaryValue, and reference count increment
specifier|final
name|InputStream
name|fis
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|bvis
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis
argument_list|)
decl_stmt|;
comment|// we now destroy the filtered binary value, just as it would if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should not close the original binary value, as BinaryValueFilteringInputStream increased the reference count.
name|filteredBinaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the origin binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|binaryValue
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// finally close the original binary value
name|binaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IOException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|multiFilter_withoutIncrementReferenceCountFails
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue1
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis1
init|=
name|binaryValue1
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
specifier|final
name|BinaryValue
name|binaryValue2
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis2
init|=
name|binaryValue2
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// create a filter over both BinaryValues, with no reference count increment
specifier|final
name|InputStream
name|fis
init|=
operator|new
name|MultiBinaryValueFilteringInputStream
argument_list|(
operator|new
name|InputStream
index|[]
block|{
name|bvis1
block|,
name|bvis2
block|}
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis
argument_list|)
decl_stmt|;
comment|// we now destroy the filtered binary value, just as it would be if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should close the original binary values, as we have not incremented the reference counts!
name|filteredBinaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should not be able to read from the origin binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
comment|// this should throw an IOException
name|binaryValue1
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|multiFilter_withIncrementReferenceCount
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData1
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData2
init|=
literal|"second test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais1
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData1
argument_list|)
init|;
specifier|final
name|InputStream
name|bais2
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData2
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue1
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais1
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis1
init|=
name|binaryValue1
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
specifier|final
name|BinaryValue
name|binaryValue2
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais2
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis2
init|=
name|binaryValue2
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// create a filter over both BinaryValues, and reference count increment
specifier|final
name|InputStream
name|fis
init|=
operator|new
name|MultiBinaryValueFilteringInputStream
argument_list|(
operator|new
name|InputStream
index|[]
block|{
name|bvis1
block|,
name|bvis2
block|}
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis
argument_list|)
decl_stmt|;
comment|// we now destroy the filtered binary value, just as it would be if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should not close the original binary values, as MultiBinaryValueFilteringInputStream increased the reference count.
name|filteredBinaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|binaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|binaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the origin binary value2!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos2
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|binaryValue2
operator|.
name|streamBinaryTo
argument_list|(
name|baos2
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData2
argument_list|,
name|baos2
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// we should still be able to read from the original binary value1!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos1
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|binaryValue1
operator|.
name|streamBinaryTo
argument_list|(
name|baos1
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData1
argument_list|,
name|baos1
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// finally close the original binary values
name|binaryValue2
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|binaryValue1
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IOException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|filterFilter_withoutIncrementReferenceCountFails
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis
init|=
name|binaryValue
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// create a filter over the first BinaryValue, with no reference count increment
specifier|final
name|InputStream
name|fis1
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|bvis
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue1
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis1
argument_list|)
decl_stmt|;
comment|// create a second filter over the first filter, with no reference count increment
specifier|final
name|InputStream
name|fbvis
init|=
name|filteredBinaryValue1
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
specifier|final
name|InputStream
name|fis2
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|fbvis
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue2
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis2
argument_list|)
decl_stmt|;
comment|// we now destroy the second filtered binary value, just as it would if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should close the first filtered binary value and original binary value, as we have not incremented the reference counts!
name|filteredBinaryValue2
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should not be able to read from the first filtered binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
comment|// this should throw an IOException
name|filteredBinaryValue1
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|filterFilter_withIncrementReferenceCount
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|bvis
init|=
name|binaryValue
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// create a filter over the first BinaryValue, and reference count increment
specifier|final
name|InputStream
name|fis1
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|bvis
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue1
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis1
argument_list|)
decl_stmt|;
comment|// create a second filter over the first filter, and reference count increment
specifier|final
name|InputStream
name|fbvis
init|=
name|filteredBinaryValue1
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
specifier|final
name|InputStream
name|fis2
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|fbvis
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue2
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis2
argument_list|)
decl_stmt|;
comment|// we now destroy the second filtered binary value, just as it would if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should not close the filtered binary value or original binary value, as BinaryValueFilteringInputStream increased the reference count.
name|filteredBinaryValue2
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|filteredBinaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the filtered binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|filteredBinaryValue1
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// we now destroy the first filtered binary value, just as it would if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should not close the original binary value, as BinaryValueFilteringInputStream increased the reference count.
name|filteredBinaryValue1
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the origin binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|binaryValue
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// finally close the original binary value
name|binaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|multiFilterFilter_withIncrementReferenceCount
parameter_list|()
throws|throws
name|IOException
throws|,
name|XPathException
block|{
specifier|final
name|BinaryValueManager
name|binaryValueManager
init|=
operator|new
name|MockBinaryValueManager
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|testData
init|=
literal|"test data"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|testData
argument_list|)
init|)
block|{
specifier|final
name|BinaryValue
name|binaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|bais
argument_list|)
decl_stmt|;
comment|// create a first filter over the first BinaryValue, and reference count increment
specifier|final
name|InputStream
name|fis1
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|binaryValue
operator|.
name|getInputStream
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue1
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis1
argument_list|)
decl_stmt|;
comment|// create a second filter over the first BinaryValue, and reference count increment
specifier|final
name|InputStream
name|fis2
init|=
operator|new
name|BinaryValueFilteringInputStream
argument_list|(
name|binaryValue
operator|.
name|getInputStream
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|filteredBinaryValue2
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|fis2
argument_list|)
decl_stmt|;
comment|// create a multi filter over both filters
specifier|final
name|InputStream
name|mfis
init|=
operator|new
name|MultiBinaryValueFilteringInputStream
argument_list|(
operator|new
name|InputStream
index|[]
block|{
name|filteredBinaryValue1
operator|.
name|getInputStream
argument_list|()
block|,
name|filteredBinaryValue2
operator|.
name|getInputStream
argument_list|()
block|}
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BinaryValue
name|multiFilteredBinaryValue
init|=
name|BinaryValueFromInputStream
operator|.
name|getInstance
argument_list|(
name|binaryValueManager
argument_list|,
operator|new
name|Base64BinaryValueType
argument_list|()
argument_list|,
name|mfis
argument_list|)
decl_stmt|;
comment|// we now destroy the multi filtered binary value, just as it would be if it went out of scope from popLocalVariables#popLocalVariables.
comment|// It should not close the filtered or original binary values, as MultiBinaryValueFilteringInputStream increased the reference count.
name|multiFilteredBinaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|multiFilteredBinaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|filteredBinaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|filteredBinaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the filtered binary value2!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos2
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|filteredBinaryValue2
operator|.
name|streamBinaryTo
argument_list|(
name|baos2
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos2
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|filteredBinaryValue2
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue2
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the filtered binary value1!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos1
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|filteredBinaryValue1
operator|.
name|streamBinaryTo
argument_list|(
name|baos1
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos1
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|filteredBinaryValue1
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|filteredBinaryValue1
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// we should still be able to read from the original binary value!
try|try
init|(
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|binaryValue
operator|.
name|streamBinaryTo
argument_list|(
name|baos
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|testData
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// finally close the original binary value
name|binaryValue
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|binaryValue
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|binaryValueManager
operator|.
name|runCleanupTasks
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|BinaryValueFilteringInputStream
extends|extends
name|FilterInputStream
block|{
specifier|public
name|BinaryValueFilteringInputStream
parameter_list|(
specifier|final
name|InputStream
name|inputStream
parameter_list|,
specifier|final
name|boolean
name|incrementReferenceCount
parameter_list|)
block|{
name|super
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|incrementReferenceCount
operator|&&
name|inputStream
operator|instanceof
name|CachingFilterInputStream
condition|)
block|{
specifier|final
name|CachingFilterInputStream
name|cfis
init|=
operator|(
operator|(
name|CachingFilterInputStream
operator|)
name|inputStream
operator|)
decl_stmt|;
comment|// increment shared references by one, as this filter is sharing the underlying input stream of the cache
name|cfis
operator|.
name|incrementSharedReferences
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|MultiBinaryValueFilteringInputStream
extends|extends
name|FilterInputStream
block|{
specifier|final
name|InputStream
index|[]
name|inputStreams
decl_stmt|;
specifier|public
name|MultiBinaryValueFilteringInputStream
parameter_list|(
specifier|final
name|InputStream
index|[]
name|inputStreams
parameter_list|,
specifier|final
name|boolean
name|incrementReferenceCount
parameter_list|)
block|{
name|super
argument_list|(
name|inputStreams
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputStreams
operator|=
name|inputStreams
expr_stmt|;
if|if
condition|(
name|incrementReferenceCount
condition|)
block|{
for|for
control|(
specifier|final
name|InputStream
name|inputStream
range|:
name|inputStreams
control|)
block|{
if|if
condition|(
name|inputStream
operator|instanceof
name|CachingFilterInputStream
condition|)
block|{
specifier|final
name|CachingFilterInputStream
name|cfis
init|=
operator|(
operator|(
name|CachingFilterInputStream
operator|)
name|inputStream
operator|)
decl_stmt|;
comment|// increment shared references by one, as this filter is sharing the underlying input stream of the cache
name|cfis
operator|.
name|incrementSharedReferences
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOException
name|firstException
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|inputStreams
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
try|try
block|{
name|inputStreams
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|firstException
operator|==
literal|null
condition|)
block|{
name|firstException
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|firstException
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"first exception on close"
argument_list|,
name|firstException
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

