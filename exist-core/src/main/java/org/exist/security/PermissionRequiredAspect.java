begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2011 The eXist-db Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|security
package|;
end_package

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|JoinPoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Aspect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Pointcut
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|reflect
operator|.
name|MethodSignature
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionRequired
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * @author Adam Retter<adam@exist-db.org>  */
end_comment

begin_class
annotation|@
name|Aspect
specifier|public
class|class
name|PermissionRequiredAspect
block|{
annotation|@
name|Pointcut
argument_list|(
literal|"execution(* *(@org.exist.security.PermissionRequired (*),..))&& args(o,..)&& this(permission)"
argument_list|)
specifier|public
name|void
name|methodParameterWithPermissionRequired
parameter_list|(
name|Permission
name|permission
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
block|}
annotation|@
name|Before
argument_list|(
literal|"methodParameterWithPermissionRequired(permission, o)"
argument_list|)
specifier|public
name|void
name|enforcePermissionsOnParameter
parameter_list|(
name|JoinPoint
name|joinPoint
parameter_list|,
name|Permission
name|permission
parameter_list|,
name|Object
name|o
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//TODO(AR) the next two lines can be replaced when this aspectj bug is closed - https://bugs.eclipse.org/bugs/show_bug.cgi?id=259416
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|PermissionRequired
name|parameterPermissionRequired
init|=
operator|(
name|PermissionRequired
operator|)
name|ms
operator|.
name|getMethod
argument_list|()
operator|.
name|getParameterAnnotations
argument_list|()
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
comment|// 1) check if we should allow DBA access
if|if
condition|(
operator|(
operator|(
name|parameterPermissionRequired
operator|.
name|user
argument_list|()
operator|&
name|IS_DBA
operator|)
operator|==
name|IS_DBA
operator|)
operator|&&
name|permission
operator|.
name|isCurrentSubjectDBA
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// 2) check if the user is in the target group
if|if
condition|(
operator|(
name|parameterPermissionRequired
operator|.
name|user
argument_list|()
operator|&
name|IS_MEMBER
operator|)
operator|==
name|IS_MEMBER
condition|)
block|{
specifier|final
name|Integer
name|groupId
init|=
operator|(
name|Integer
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|permission
operator|.
name|isCurrentSubjectInGroup
argument_list|(
name|groupId
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|//  3) check if we should allow access when POSIX_CHOWN_RESTRICTED is not set
if|if
condition|(
operator|(
name|parameterPermissionRequired
operator|.
name|user
argument_list|()
operator|&
name|NOT_POSIX_CHOWN_RESTRICTED
operator|)
operator|==
name|NOT_POSIX_CHOWN_RESTRICTED
operator|&&
operator|!
name|permission
operator|.
name|isPosixChownRestricted
argument_list|()
condition|)
block|{
specifier|final
name|PermissionRequired
name|methodPermissionRequired
init|=
name|ms
operator|.
name|getMethod
argument_list|()
operator|.
name|getAnnotation
argument_list|(
name|PermissionRequired
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|methodPermissionRequired
operator|.
name|user
argument_list|()
operator|&
name|IS_OWNER
operator|)
operator|==
name|IS_OWNER
operator|&&
name|permission
operator|.
name|isCurrentSubjectOwner
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
comment|// 4) check if we are looking for setGID
if|if
condition|(
operator|(
name|parameterPermissionRequired
operator|.
name|mode
argument_list|()
operator|&
name|IS_SET_GID
operator|)
operator|==
name|IS_SET_GID
condition|)
block|{
specifier|final
name|Permission
name|other
init|=
operator|(
name|Permission
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|isSetGid
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"You must be a member of the group you are changing the item to"
argument_list|)
throw|;
block|}
annotation|@
name|Pointcut
argument_list|(
literal|"execution(@org.exist.security.PermissionRequired * *(..))&& this(permission)&& @annotation(permissionRequired)"
argument_list|)
specifier|public
name|void
name|methodWithPermissionRequired
parameter_list|(
name|Permission
name|permission
parameter_list|,
name|PermissionRequired
name|permissionRequired
parameter_list|)
block|{
block|}
annotation|@
name|Before
argument_list|(
literal|"methodWithPermissionRequired(permission, permissionRequired)"
argument_list|)
specifier|public
name|void
name|enforcePermissions
parameter_list|(
name|JoinPoint
name|joinPoint
parameter_list|,
name|Permission
name|permission
parameter_list|,
name|PermissionRequired
name|permissionRequired
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//1) check if we should allow DBA access
if|if
condition|(
operator|(
operator|(
name|permissionRequired
operator|.
name|user
argument_list|()
operator|&
name|IS_DBA
operator|)
operator|==
name|IS_DBA
operator|)
operator|&&
name|permission
operator|.
name|isCurrentSubjectDBA
argument_list|()
condition|)
block|{
return|return;
block|}
comment|//2) check for owner access
if|if
condition|(
operator|(
name|permissionRequired
operator|.
name|user
argument_list|()
operator|&
name|IS_OWNER
operator|)
operator|==
name|IS_OWNER
operator|&&
name|permission
operator|.
name|isCurrentSubjectOwner
argument_list|()
condition|)
block|{
if|if
condition|(
name|permissionRequired
operator|.
name|group
argument_list|()
operator|==
name|UNDEFINED
condition|)
block|{
return|return;
block|}
else|else
block|{
comment|//check for group memebership
if|if
condition|(
name|permissionRequired
operator|.
name|group
argument_list|()
operator|==
name|IS_MEMBER
operator|&&
name|permission
operator|.
name|isCurrentSubjectInGroup
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|//3) check for group access
if|if
condition|(
name|permissionRequired
operator|.
name|user
argument_list|()
operator|==
name|UNDEFINED
operator|&&
name|permissionRequired
operator|.
name|group
argument_list|()
operator|!=
name|UNDEFINED
condition|)
block|{
if|if
condition|(
name|permissionRequired
operator|.
name|group
argument_list|()
operator|==
name|IS_MEMBER
operator|&&
name|permission
operator|.
name|isCurrentSubjectInGroup
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
comment|//4) check for acl mode access
if|if
condition|(
name|permission
operator|instanceof
name|ACLPermission
operator|&&
name|permissionRequired
operator|.
name|mode
argument_list|()
operator|!=
name|UNDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|permissionRequired
operator|.
name|mode
argument_list|()
operator|&
name|ACL_WRITE
operator|)
operator|==
name|ACL_WRITE
operator|&&
operator|(
operator|(
name|ACLPermission
operator|)
name|permission
operator|)
operator|.
name|isCurrentSubjectCanWriteACL
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"You do not have appropriate access rights to modify permissions on this object"
argument_list|)
throw|;
block|}
comment|//TODO(AR) change Pointcut so that @annotation values are directly bound. see - https://bugs.eclipse.org/bugs/show_bug.cgi?id=347684
comment|/*     @Pointcut("execution(@org.exist.security.PermissionRequired * *(..))&& this(permission)&& @annotation(org.exist.security.PermissionRequired(mode,user,group))")     public void methodWithPermissionRequired(Permission permission, int mode, int user, int group) {     }      @Before("methodWithPermissionRequired(permission, mode, user, group)")     public void enforcePermissions(JoinPoint joinPoint, Permission permission, int mode, int user, int group) {         System.out.println("POINTCUT");     }*/
block|}
end_class

end_unit

