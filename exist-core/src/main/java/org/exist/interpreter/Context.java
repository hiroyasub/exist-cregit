begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2018 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|interpreter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|XMLGregorianCalendar
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|ibm
operator|.
name|icu
operator|.
name|text
operator|.
name|Collator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|debuggee
operator|.
name|DebuggeeJoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|MemTreeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|source
operator|.
name|Source
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|ExtendedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|UpdateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|LockedDocumentMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|hashtable
operator|.
name|NamePool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|FunctionCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|FunctionSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|LocalVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Module
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Pragma
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Profiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|UserDefinedFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Variable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQueryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQueryWatchDog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|AnyURIValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|BinaryValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|NodeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|Sequence
import|;
end_import

begin_interface
specifier|public
interface|interface
name|Context
block|{
comment|/**      * Returns true if this context has a parent context (means it is a module context).      *      * @return true if there is a parent context.      */
name|boolean
name|hasParent
parameter_list|()
function_decl|;
name|XQueryContext
name|getRootContext
parameter_list|()
function_decl|;
name|XQueryContext
name|copyContext
parameter_list|()
function_decl|;
comment|/**      * Update the current dynamic context using the properties of another context.      *      * This is needed by {@link org.exist.xquery.functions.util.Eval}.      *      * @param from the context to update from      */
name|void
name|updateContext
parameter_list|(
name|XQueryContext
name|from
parameter_list|)
function_decl|;
comment|/**      * Prepares the current context before xquery execution.      */
name|void
name|prepareForExecution
parameter_list|()
function_decl|;
comment|/**      * Is profiling enabled?      *      * @return true if profiling is enabled for this context.      */
name|boolean
name|isProfilingEnabled
parameter_list|()
function_decl|;
name|boolean
name|isProfilingEnabled
parameter_list|(
name|int
name|verbosity
parameter_list|)
function_decl|;
comment|/**      * Returns the {@link Profiler} instance of this context if profiling is enabled.      *      * @return the profiler instance.      */
name|Profiler
name|getProfiler
parameter_list|()
function_decl|;
comment|/**      * Called from the XQuery compiler to set the root expression for this context.      *      * @param expr the root expression.      */
name|void
name|setRootExpression
parameter_list|(
name|Expression
name|expr
parameter_list|)
function_decl|;
comment|/**      * Returns the root expression of the XQuery associated with this context.      *      * @return root expression      */
name|Expression
name|getRootExpression
parameter_list|()
function_decl|;
comment|/**      * Returns the number of expression objects in the internal representation of the query. Used to estimate the size of the query.      *      * @return number of expression objects      */
name|int
name|getExpressionCount
parameter_list|()
function_decl|;
name|void
name|setSource
parameter_list|(
name|Source
name|source
parameter_list|)
function_decl|;
name|Source
name|getSource
parameter_list|()
function_decl|;
comment|/**      * Declare a user-defined static prefix/namespace mapping.      *      * eXist internally keeps a table containing all prefix/namespace mappings it found in documents, which have been previously stored into the      * database. These default mappings need not to be declared explicitely.      *      * @param prefix the namespace prefix.      * @param uri the namespace URI.      *      * @throws XPathException if an error occurs when declaring the namespace.      */
name|void
name|declareNamespace
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|uri
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|void
name|declareNamespaces
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaceMap
parameter_list|)
function_decl|;
comment|/**      * Removes the namespace URI from the prefix/namespace mappings table.      *      * @param uri the namespace URI.      */
name|void
name|removeNamespace
parameter_list|(
name|String
name|uri
parameter_list|)
function_decl|;
comment|/**      * Declare an in-scope namespace. This is called during query execution.      *      * @param prefix the namespace prefix.      * @param uri the namespace uri.      */
name|void
name|declareInScopeNamespace
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|uri
parameter_list|)
function_decl|;
name|String
name|getInScopeNamespace
parameter_list|(
name|String
name|prefix
parameter_list|)
function_decl|;
name|String
name|getInScopePrefix
parameter_list|(
name|String
name|uri
parameter_list|)
function_decl|;
name|String
name|getInheritedNamespace
parameter_list|(
name|String
name|prefix
parameter_list|)
function_decl|;
name|String
name|getInheritedPrefix
parameter_list|(
name|String
name|uri
parameter_list|)
function_decl|;
comment|/**      * Return the namespace URI mapped to the registered prefix or null if the prefix is not registered.      *      * @param prefix the namespace prefix.      *      * @return the namespace URI.      */
name|String
name|getURIForPrefix
parameter_list|(
name|String
name|prefix
parameter_list|)
function_decl|;
comment|/**      * Get URI Prefix.      *      * @param uri the namespace URI.      *      * @return the prefix mapped to the registered URI or null if the URI is not registered.      */
name|String
name|getPrefixForURI
parameter_list|(
name|String
name|uri
parameter_list|)
function_decl|;
comment|/**      * Returns the current default function namespace.      *      * @return current default function namespace      */
name|String
name|getDefaultFunctionNamespace
parameter_list|()
function_decl|;
comment|/**      * Set the default function namespace. By default, this points to the namespace for XPath built-in functions.      *      * @param uri the namespace URI.      *      * @throws XPathException if an error occurs when setting the default function namespace.      */
name|void
name|setDefaultFunctionNamespace
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Returns the current default element namespace.      *      * @return current default element namespace schema      *      * @throws XPathException if an error occurs when getting the default element namespace.      */
name|String
name|getDefaultElementNamespaceSchema
parameter_list|()
throws|throws
name|XPathException
function_decl|;
comment|/**      * Set the default element namespace. By default, this points to the empty uri.      *      * @param uri the default element namespace schema uri      *      * @throws XPathException if an error occurs when setting the default element namespace schema.      */
name|void
name|setDefaultElementNamespaceSchema
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Returns the current default element namespace.      *      * @return current default element namespace      *      * @throws XPathException if an error occurs when getting the default element namespace.      */
name|String
name|getDefaultElementNamespace
parameter_list|()
throws|throws
name|XPathException
function_decl|;
comment|/**      * Set the default element namespace. By default, this points to the empty uri.      *      * @param uri the namespace uri      * @param schema detail of the namespace schema, or null      *      * @throws XPathException if an error occurs when setting the default element namespace.      */
name|void
name|setDefaultElementNamespace
parameter_list|(
name|String
name|uri
parameter_list|,
annotation|@
name|Nullable
name|String
name|schema
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Set the default collation to be used by all operators and functions on strings.      * Throws an exception if the collation is unknown or cannot be instantiated.      *      * @param uri the collation URI      *      * @throws XPathException if an error occurs when setting the default collation.      */
name|void
name|setDefaultCollation
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|String
name|getDefaultCollation
parameter_list|()
function_decl|;
name|Collator
name|getCollator
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|Collator
name|getDefaultCollator
parameter_list|()
function_decl|;
comment|/**      * Set the set of statically known documents for the current execution context.      * These documents will be processed if no explicit document set has been set for the current expression      * with fn:doc() or fn:collection().      *      * @param docs the statically known documents      */
name|void
name|setStaticallyKnownDocuments
parameter_list|(
name|XmldbURI
index|[]
name|docs
parameter_list|)
function_decl|;
name|void
name|setStaticallyKnownDocuments
parameter_list|(
name|DocumentSet
name|set
parameter_list|)
function_decl|;
comment|//TODO : not sure how these 2 options might/have to be related
name|void
name|setCalendar
parameter_list|(
name|XMLGregorianCalendar
name|newCalendar
parameter_list|)
function_decl|;
name|void
name|setTimeZone
parameter_list|(
name|TimeZone
name|newTimeZone
parameter_list|)
function_decl|;
name|XMLGregorianCalendar
name|getCalendar
parameter_list|()
function_decl|;
name|TimeZone
name|getImplicitTimeZone
parameter_list|()
function_decl|;
comment|/**      * Get statically known documents      *      * @return set of statically known documents.      *      * @throws XPathException if an error occurs when getting the statically known documents.      */
name|DocumentSet
name|getStaticallyKnownDocuments
parameter_list|()
throws|throws
name|XPathException
function_decl|;
name|ExtendedXMLStreamReader
name|getXMLStreamReader
parameter_list|(
name|NodeValue
name|nv
parameter_list|)
throws|throws
name|XMLStreamException
throws|,
name|IOException
function_decl|;
name|void
name|setProtectedDocs
parameter_list|(
name|LockedDocumentMap
name|map
parameter_list|)
function_decl|;
name|LockedDocumentMap
name|getProtectedDocs
parameter_list|()
function_decl|;
name|boolean
name|inProtectedMode
parameter_list|()
function_decl|;
comment|/**      * Should loaded documents be locked?      *      * @return true if documents should be locked on load.      */
name|boolean
name|lockDocumentsOnLoad
parameter_list|()
function_decl|;
name|void
name|addLockedDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
function_decl|;
name|void
name|setShared
parameter_list|(
name|boolean
name|shared
parameter_list|)
function_decl|;
name|boolean
name|isShared
parameter_list|()
function_decl|;
name|void
name|addModifiedDoc
parameter_list|(
name|DocumentImpl
name|document
parameter_list|)
function_decl|;
name|void
name|reset
parameter_list|()
function_decl|;
comment|/**      * Prepare this XQueryContext to be reused. This should be called when adding an XQuery to the cache.      *      * @param keepGlobals true if global variables should be preserved.      */
name|void
name|reset
parameter_list|(
name|boolean
name|keepGlobals
parameter_list|)
function_decl|;
comment|/**      * Returns true if whitespace between constructed element nodes should be stripped by default.      *      * @return true if whitespace should be stripped, false otherwise.      */
name|boolean
name|stripWhitespace
parameter_list|()
function_decl|;
name|void
name|setStripWhitespace
parameter_list|(
name|boolean
name|strip
parameter_list|)
function_decl|;
comment|/**      * Returns true if namespaces for constructed element and document nodes should be preserved on copy by default.      *      * @return true if namespaces should be preserved, false otherwise.      */
name|boolean
name|preserveNamespaces
parameter_list|()
function_decl|;
comment|/**      * Set whether namespaces should be preserved.      *      * @param preserve true if namespaces should be preserved, false otherwise.      */
name|void
name|setPreserveNamespaces
parameter_list|(
specifier|final
name|boolean
name|preserve
parameter_list|)
function_decl|;
comment|/**      * Returns true if namespaces for constructed element and document nodes should be inherited on copy by default.      *      * @return true if namespaces are inheirted, false otherwise.      */
name|boolean
name|inheritNamespaces
parameter_list|()
function_decl|;
comment|/**      * Set whether namespaces should be inherited.      *      * @param inherit true if namespaces should be inherited, false otherwise.      */
name|void
name|setInheritNamespaces
parameter_list|(
specifier|final
name|boolean
name|inherit
parameter_list|)
function_decl|;
comment|/**      * Returns true if order empty is set to greatest, otherwise false for order empty is least.      *      * @return true if the order is empty-greatest, false otherwise.      */
name|boolean
name|orderEmptyGreatest
parameter_list|()
function_decl|;
comment|/**      * The method<code>setOrderEmptyGreatest.</code>      *      * @param order a<code>boolean</code> value      */
name|void
name|setOrderEmptyGreatest
parameter_list|(
specifier|final
name|boolean
name|order
parameter_list|)
function_decl|;
comment|/**      * Get modules.      *      * @return iterator over all modules imported into this context      */
name|Iterator
argument_list|<
name|Module
argument_list|>
name|getModules
parameter_list|()
function_decl|;
comment|/**      * Get root modules.      *      * @return iterator over all modules registered in the entire context tree      */
name|Iterator
argument_list|<
name|Module
argument_list|>
name|getRootModules
parameter_list|()
function_decl|;
name|Iterator
argument_list|<
name|Module
argument_list|>
name|getAllModules
parameter_list|()
function_decl|;
comment|/**      * Get the built-in module registered for the given namespace URI.      *      * @param namespaceURI the namespace of the module.      *      * @return the module, or null      */
annotation|@
name|Nullable
name|Module
name|getModule
parameter_list|(
name|String
name|namespaceURI
parameter_list|)
function_decl|;
name|Module
name|getRootModule
parameter_list|(
name|String
name|namespaceURI
parameter_list|)
function_decl|;
name|void
name|setModule
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|Module
name|module
parameter_list|)
function_decl|;
comment|/**      * For compiled expressions: check if the source of any module imported by the current      * query has changed since compilation.      *      * @return true if the modules are valid, false otherwise.      */
name|boolean
name|checkModulesValid
parameter_list|()
function_decl|;
name|void
name|analyzeAndOptimizeIfModulesChanged
parameter_list|(
name|Expression
name|expr
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Load a built-in module from the given class name and assign it to the namespace URI.      *      * The specified {@code moduleClass} should be a subclass of {@link Module}. The method will try to instantiate      * the class.      *      * If the class is not found or an exception is thrown, the method will silently fail. The      * namespace URI has to be equal to the namespace URI declared by the module class. Otherwise,      * the module is not loaded.      *      * @param namespaceURI the namespace URI of the module to load      * @param moduleClass  the Java class of the module to load      *      * @return the loaded module, or null      */
annotation|@
name|Nullable
name|Module
name|loadBuiltInModule
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|String
name|moduleClass
parameter_list|)
function_decl|;
comment|/**      * Declare a user-defined function. All user-defined functions are kept in a single hash map.      *      * @param function the function.      *      * @throws XPathException if an error orccurs whilst declaring the function.      */
name|void
name|declareFunction
parameter_list|(
name|UserDefinedFunction
name|function
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Resolve a user-defined function.      *      * @param name the function name      * @param argCount the function arity      *      * @return the resolved function, or null      *      * @throws XPathException if an error occurs whilst resolving the function      */
annotation|@
name|Nullable
name|UserDefinedFunction
name|resolveFunction
parameter_list|(
name|QName
name|name
parameter_list|,
name|int
name|argCount
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|Iterator
argument_list|<
name|FunctionSignature
argument_list|>
name|getSignaturesForFunction
parameter_list|(
name|QName
name|name
parameter_list|)
function_decl|;
name|Iterator
argument_list|<
name|UserDefinedFunction
argument_list|>
name|localFunctions
parameter_list|()
function_decl|;
comment|/**      * Declare a local variable. This is called by variable binding expressions like "let" and "for".      *      * @param var the variable      *      * @return the declare variable      *      * @throws XPathException if an error occurs whilst declaring the variable binding      */
name|LocalVariable
name|declareVariableBinding
parameter_list|(
name|LocalVariable
name|var
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Declare a global variable as by "declare variable".      *      * @param var the variable      *      * @return variable the declared variable      *      * @throws XPathException if an error occurs whilst declaring the global variable      */
name|Variable
name|declareGlobalVariable
parameter_list|(
name|Variable
name|var
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|void
name|undeclareGlobalVariable
parameter_list|(
name|QName
name|name
parameter_list|)
function_decl|;
comment|/**      * Declare a user-defined variable.      *      * The value argument is converted into an XPath value (@see XPathUtil#javaObjectToXPath(Object)).      *      * @param qname the qualified name of the new variable. Any namespaces should have been declared before.      * @param value a Java object, representing the fixed value of the variable      *      * @return the created Variable object      *      * @throws XPathException if the value cannot be converted into a known XPath value or the variable QName      *     references an unknown namespace-prefix.      */
name|Variable
name|declareVariable
parameter_list|(
name|String
name|qname
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|Variable
name|declareVariable
parameter_list|(
name|QName
name|qn
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Try to resolve a variable.      *      * @param name the qualified name of the variable as string      * @return the declared Variable object      * @throws XPathException if the variable is unknown      */
name|Variable
name|resolveVariable
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Try to resolve a variable.      *      * @param qname the qualified name of the variable      * @return the declared Variable object      * @throws XPathException if the variable is unknown      */
name|Variable
name|resolveVariable
parameter_list|(
name|QName
name|qname
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|boolean
name|isVarDeclared
parameter_list|(
name|QName
name|qname
parameter_list|)
function_decl|;
name|Map
argument_list|<
name|QName
argument_list|,
name|Variable
argument_list|>
name|getVariables
parameter_list|()
function_decl|;
name|Map
argument_list|<
name|QName
argument_list|,
name|Variable
argument_list|>
name|getLocalVariables
parameter_list|()
function_decl|;
name|Map
argument_list|<
name|QName
argument_list|,
name|Variable
argument_list|>
name|getGlobalVariables
parameter_list|()
function_decl|;
comment|/**      * Turn on/off XPath 1.0 backwards compatibility.      *      * If turned on, comparison expressions will behave like in XPath 1.0, i.e. if any one of the operands is a number,      * the other operand will be cast to a double.      *      * @param backwardsCompatible true to enable XPath 1.0 backwards compatible mode.      */
name|void
name|setBackwardsCompatibility
parameter_list|(
name|boolean
name|backwardsCompatible
parameter_list|)
function_decl|;
comment|/**      * XPath 1.0 backwards compatibility turned on?      *      * In XPath 1.0 compatible mode, additional conversions will be applied to values if a numeric value is expected.      *      * @return true if XPath 1.0 compatible mode is enabled.      */
name|boolean
name|isBackwardsCompatible
parameter_list|()
function_decl|;
name|boolean
name|isRaiseErrorOnFailedRetrieval
parameter_list|()
function_decl|;
comment|/**      * Get the DBBroker instance used for the current query.      *      * The DBBroker is the main database access object, providing access to all internal database functions.      *      * @return DBBroker instance      */
name|DBBroker
name|getBroker
parameter_list|()
function_decl|;
comment|/**      * Get the subject which executes the current query.      *      * @return subject      */
name|Subject
name|getSubject
parameter_list|()
function_decl|;
comment|/**      * Get the document builder currently used for creating temporary document fragments.      * A new document builder will be created on demand.      *      * @return document builder      */
name|MemTreeBuilder
name|getDocumentBuilder
parameter_list|()
function_decl|;
name|MemTreeBuilder
name|getDocumentBuilder
parameter_list|(
name|boolean
name|explicitCreation
parameter_list|)
function_decl|;
comment|/**      * Returns the shared name pool used by all in-memory documents which are created within this query context.      * Create a name pool for every document would be a waste of memory, especially since it is likely that the      * documents contain elements or attributes with similar names.      *      * @return the shared name pool      */
name|NamePool
name|getSharedNamePool
parameter_list|()
function_decl|;
name|XQueryContext
name|getContext
parameter_list|()
function_decl|;
name|void
name|prologEnter
parameter_list|(
name|Expression
name|expr
parameter_list|)
function_decl|;
name|void
name|expressionStart
parameter_list|(
name|Expression
name|expr
parameter_list|)
throws|throws
name|TerminatedException
function_decl|;
name|void
name|expressionEnd
parameter_list|(
name|Expression
name|expr
parameter_list|)
function_decl|;
name|void
name|stackEnter
parameter_list|(
name|Expression
name|expr
parameter_list|)
throws|throws
name|TerminatedException
function_decl|;
name|void
name|stackLeave
parameter_list|(
name|Expression
name|expr
parameter_list|)
function_decl|;
name|void
name|proceed
parameter_list|()
throws|throws
name|TerminatedException
function_decl|;
name|void
name|proceed
parameter_list|(
name|Expression
name|expr
parameter_list|)
throws|throws
name|TerminatedException
function_decl|;
name|void
name|proceed
parameter_list|(
name|Expression
name|expr
parameter_list|,
name|MemTreeBuilder
name|builder
parameter_list|)
throws|throws
name|TerminatedException
function_decl|;
name|void
name|setWatchDog
parameter_list|(
name|XQueryWatchDog
name|watchdog
parameter_list|)
function_decl|;
name|XQueryWatchDog
name|getWatchDog
parameter_list|()
function_decl|;
comment|/**      * Push any document fragment created within the current execution context on the stack.      */
name|void
name|pushDocumentContext
parameter_list|()
function_decl|;
comment|/**      * Pop the last document fragment created within the current execution context off the stack.      */
name|void
name|popDocumentContext
parameter_list|()
function_decl|;
comment|/**      * Set the base URI for the evaluation context.      *      * This is the URI returned by the {@code fn:base-uri()} function.      *      * @param uri the base URI      */
name|void
name|setBaseURI
parameter_list|(
name|AnyURIValue
name|uri
parameter_list|)
function_decl|;
comment|/**      * Set the base URI for the evaluation context.      *      * A base URI specified via the base-uri directive in the XQuery prolog overwrites any other setting.      *      * @param uri the base URI      * @param setInProlog true if it was set by a declare option in the XQuery prolog      */
name|void
name|setBaseURI
parameter_list|(
name|AnyURIValue
name|uri
parameter_list|,
name|boolean
name|setInProlog
parameter_list|)
function_decl|;
comment|/**      * Set the path to a base directory where modules should be loaded from. Relative module paths will be resolved      * against this directory. The property is usually set by the XQueryServlet or XQueryGenerator, but can also      * be specified manually.      *      * @param path the module load path.      */
name|void
name|setModuleLoadPath
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
name|String
name|getModuleLoadPath
parameter_list|()
function_decl|;
comment|/**      * Returns true if the baseURI is declared.      *      * @return true if the baseURI is declared, false otherwise.      */
name|boolean
name|isBaseURIDeclared
parameter_list|()
function_decl|;
comment|/**      * Get the base URI of the evaluation context.      *      * This is the URI returned by the fn:base-uri() function.      *      * @return base URI of the evaluation context      *      * @throws XPathException if an error occurs      */
name|AnyURIValue
name|getBaseURI
parameter_list|()
throws|throws
name|XPathException
function_decl|;
comment|/**      * Set the current context position, i.e. the position of the currently processed item in the context sequence.      * This value is required by some expressions, e.g. fn:position().      *      * @param pos the position      * @param sequence the sequence      */
name|void
name|setContextSequencePosition
parameter_list|(
name|int
name|pos
parameter_list|,
name|Sequence
name|sequence
parameter_list|)
function_decl|;
comment|/**      * Get the current context position, i.e. the position of the currently processed item in the context sequence.      *      * @return current context position      */
name|int
name|getContextPosition
parameter_list|()
function_decl|;
name|Sequence
name|getContextSequence
parameter_list|()
function_decl|;
name|void
name|pushInScopeNamespaces
parameter_list|()
function_decl|;
comment|/**      * Push all in-scope namespace declarations onto the stack.      *      * @param inherit true if the current namespaces become inherited      *                just like the previous inherited ones      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|void
name|pushInScopeNamespaces
parameter_list|(
name|boolean
name|inherit
parameter_list|)
function_decl|;
name|void
name|popInScopeNamespaces
parameter_list|()
function_decl|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|void
name|pushNamespaceContext
parameter_list|()
function_decl|;
name|void
name|popNamespaceContext
parameter_list|()
function_decl|;
comment|/**      * Returns the last variable on the local variable stack. The current variable context can be restored by      * passing the return value to {@link #popLocalVariables(LocalVariable)}.      *      * @param newContext true if there is a new context      *      * @return last variable on the local variable stack      */
name|LocalVariable
name|markLocalVariables
parameter_list|(
name|boolean
name|newContext
parameter_list|)
function_decl|;
comment|/**      * Restore the local variable stack to the position marked by variable {@code var}.      *      * @param var only clear variables after this variable, or null      */
name|void
name|popLocalVariables
parameter_list|(
annotation|@
name|Nullable
name|LocalVariable
name|var
parameter_list|)
function_decl|;
comment|/**      * Returns the current size of the stack. This is used to determine where a variable has been declared.      *      * @return current size of the stack      */
name|int
name|getCurrentStackSize
parameter_list|()
function_decl|;
comment|/**      * Report the start of a function execution. Adds the reported function signature to the function call stack.      *      * @param signature the function signature      */
name|void
name|functionStart
parameter_list|(
name|FunctionSignature
name|signature
parameter_list|)
function_decl|;
comment|/**      * Report the end of the currently executed function. Pops the last function signature from the function call stack.      */
name|void
name|functionEnd
parameter_list|()
function_decl|;
comment|/**      * Check if the specified function signature is found in the current function called stack.      * If yes, the function might be tail recursive and needs      * to be optimized.      *      * @param signature the function signature      *      * @return true if the function call is tail recursive      */
name|boolean
name|tailRecursiveCall
parameter_list|(
name|FunctionSignature
name|signature
parameter_list|)
function_decl|;
name|void
name|mapModule
parameter_list|(
name|String
name|namespace
parameter_list|,
name|XmldbURI
name|uri
parameter_list|)
function_decl|;
comment|/**      * Import a module and make it available in this context. The prefix and location parameters are optional. If prefix is null, the default prefix      * specified by the module is used. If location is null, the module will be read from the namespace URI.      *      * @param namespaceURI the namespace URI of the module      * @param prefix the namespace prefix of the module      * @param location the location of the module      *      * @return the imported module      *      * @throws XPathException if an error occurs whilst importing the module      */
name|Module
name|importModule
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|location
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Returns the static location mapped to an XQuery source module, if known.      *      * @param namespaceURI the URI of the module      *      * @return the location string      */
name|String
name|getModuleLocation
parameter_list|(
name|String
name|namespaceURI
parameter_list|)
function_decl|;
comment|/**      * Returns an iterator over all module namespace URIs which are statically mapped to a known location.      *      * @return an iterator      */
name|Iterator
argument_list|<
name|String
argument_list|>
name|getMappedModuleURIs
parameter_list|()
function_decl|;
comment|/**      * Add a forward reference to an undeclared function. Forward references will be resolved later.      *      * @param call the undeclared function      */
name|void
name|addForwardReference
parameter_list|(
name|FunctionCall
name|call
parameter_list|)
function_decl|;
comment|/**      * Resolve all forward references to previously undeclared functions.      *      * @throws XPathException of an exception occurs whilst resolving the forward references      */
name|void
name|resolveForwardReferences
parameter_list|()
throws|throws
name|XPathException
function_decl|;
name|boolean
name|optimizationsEnabled
parameter_list|()
function_decl|;
comment|/**      * Add a static compile-time option i.e. declare option      *      * @param name  the name of the option      * @param value the value of the option      *      * @throws XPathException of an exception occurs whilst adding the option      */
name|void
name|addOption
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Add a dynamic run-time option i.e. util:declare-option      *      * @param name  the name of the dynamic option      * @param value the value of the dynamic option      *      * @throws XPathException if an exception occurs whilst adding the dynamic option      */
name|void
name|addDynamicOption
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Get dynamic options that were declared at run-time      * first as these have precedence, and then if not found      * get static options that were declare at compile time      *      * @param qname option name      * @return the option      */
name|Option
name|getOption
parameter_list|(
name|QName
name|qname
parameter_list|)
function_decl|;
name|Pragma
name|getPragma
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|contents
parameter_list|)
throws|throws
name|XPathException
function_decl|;
comment|/**      * Store the supplied in-memory document to a temporary document fragment.      *      * @param doc the in-memory document      * @return The temporary document      *      * @throws XPathException if an exception occurs whilst storing the temporary document      */
name|DocumentImpl
name|storeTemporaryDoc
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|void
name|setAttribute
parameter_list|(
name|String
name|attribute
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
name|Object
name|getAttribute
parameter_list|(
name|String
name|attribute
parameter_list|)
function_decl|;
name|void
name|registerUpdateListener
parameter_list|(
name|UpdateListener
name|listener
parameter_list|)
function_decl|;
comment|/**      * Check if the XQuery contains options that define serialization settings. If yes,      * copy the corresponding settings to the current set of output properties.      *      * @param properties the properties object to which serialization parameters will be added.      *      * @throws XPathException if an error occurs while parsing the option      */
name|void
name|checkOptions
parameter_list|(
name|Properties
name|properties
parameter_list|)
throws|throws
name|XPathException
function_decl|;
name|void
name|setDebuggeeJoint
parameter_list|(
name|DebuggeeJoint
name|joint
parameter_list|)
function_decl|;
name|DebuggeeJoint
name|getDebuggeeJoint
parameter_list|()
function_decl|;
name|boolean
name|isDebugMode
parameter_list|()
function_decl|;
name|boolean
name|requireDebugMode
parameter_list|()
function_decl|;
name|void
name|registerBinaryValueInstance
parameter_list|(
name|BinaryValue
name|binaryValue
parameter_list|)
function_decl|;
name|void
name|runCleanupTasks
parameter_list|(
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|predicate
parameter_list|)
function_decl|;
block|}
end_interface

end_unit

