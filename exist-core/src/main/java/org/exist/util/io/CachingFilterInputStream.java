begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 2012, Adam Retter  All rights reserved.   Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions are met:  * Redistributions of source code must retain the above copyright  notice, this list of conditions and the following disclaimer.  * Redistributions in binary form must reproduce the above copyright  notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.  * Neither the name of Adam Retter Consulting nor the  names of its contributors may be used to endorse or promote products  derived from this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL Adam Retter BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
package|;
end_package

begin_import
import|import
name|net
operator|.
name|jcip
operator|.
name|annotations
operator|.
name|NotThreadSafe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_comment
comment|/**  * Implementation of an Input Stream Filter that extends any InputStream with  * mark() and reset() capabilities by caching the read data for later  * re-reading.  *  * NOTE - Only supports reading data up to 2GB as the cache index uses an 'int'  * index  *  * @version 1.1  *  * @author<a href="mailto:adam.retter@googlemail.com">Adam Retter</a>  * @author<a href="tobi.krebsATgmail.com">Tobi Krebs</a>  */
end_comment

begin_class
annotation|@
name|NotThreadSafe
specifier|public
class|class
name|CachingFilterInputStream
extends|extends
name|FilterInputStream
block|{
comment|//TODO what about if the underlying stream supports marking
comment|//then we could just use its capabilities?
specifier|private
specifier|final
name|FilterInputStreamCache
name|cache
decl_stmt|;
specifier|private
name|int
name|srcOffset
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|mark
init|=
literal|0
decl_stmt|;
comment|/**      * Constructor which uses an existing Cache from a CachingFilterInputStream,      * if inputStream is a CachingFilterInputStream.      *      * @param inputStream the input stream      *      * @throws InstantiationException if the construction fails      */
specifier|public
name|CachingFilterInputStream
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|InstantiationException
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputStream
operator|instanceof
name|CachingFilterInputStream
condition|)
block|{
name|this
operator|.
name|cache
operator|=
operator|(
operator|(
name|CachingFilterInputStream
operator|)
name|inputStream
operator|)
operator|.
name|shareCache
argument_list|()
expr_stmt|;
comment|// must be #shareCache not #getCache() to increment references
block|}
else|else
block|{
throw|throw
operator|new
name|InstantiationException
argument_list|(
literal|"Only CachingFilterInputStream are supported as InputStream"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|CachingFilterInputStream
parameter_list|(
specifier|final
name|FilterInputStreamCache
name|cache
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
block|}
comment|/**      * Gets the cache implementation directly.      */
name|FilterInputStreamCache
name|getCache
parameter_list|()
block|{
return|return
name|cache
return|;
block|}
comment|/**      * Gets the cache implementation for      * sharing with another source. This is done      * by incrementing its shared reference count.      *      * @return the cache implementation      */
name|FilterInputStreamCache
name|shareCache
parameter_list|()
block|{
name|cache
operator|.
name|incrementSharedReferences
argument_list|()
expr_stmt|;
return|return
name|cache
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getCache
argument_list|()
operator|.
name|available
argument_list|()
operator|-
name|srcOffset
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|mark
parameter_list|(
specifier|final
name|int
name|readLimit
parameter_list|)
block|{
name|mark
operator|=
name|srcOffset
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|srcOffset
operator|=
name|mark
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FilterInputStreamCache
operator|.
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
comment|//Read from cache
if|if
condition|(
name|useCache
argument_list|()
condition|)
block|{
specifier|final
name|int
name|data
init|=
name|getCache
argument_list|()
operator|.
name|get
argument_list|(
name|srcOffset
operator|++
argument_list|)
decl_stmt|;
return|return
name|data
return|;
block|}
else|else
block|{
specifier|final
name|int
name|data
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|FileFilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
return|return
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
return|;
block|}
name|srcOffset
operator|++
expr_stmt|;
return|return
name|data
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|read
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FilterInputStreamCache
operator|.
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|if
condition|(
name|useCache
argument_list|()
condition|)
block|{
comment|//copy data from the cache
name|int
name|actualLen
init|=
operator|(
name|len
operator|>
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
condition|?
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
else|:
name|len
operator|)
decl_stmt|;
name|getCache
argument_list|()
operator|.
name|copyTo
argument_list|(
name|this
operator|.
name|srcOffset
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|actualLen
argument_list|)
expr_stmt|;
name|this
operator|.
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
comment|//if the requested bytes were more than what is present in the cache, then also read from the src
if|if
condition|(
name|actualLen
operator|<
name|len
condition|)
block|{
name|int
name|srcLen
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|actualLen
argument_list|,
name|len
operator|-
name|actualLen
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|srcLen
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to the read opertaion above
name|srcOffset
operator|+=
name|srcLen
expr_stmt|;
name|actualLen
operator|+=
name|srcLen
expr_stmt|;
block|}
return|return
name|actualLen
return|;
block|}
else|else
block|{
name|int
name|actualLen
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|actualLen
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to read operation above
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
return|return
name|actualLen
return|;
block|}
block|}
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
return|;
block|}
comment|/**      * Closes the src InputStream and empties the cache      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
name|getCache
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Determine the current offset      *      * @return The current offset of this stream      */
specifier|public
name|int
name|offset
parameter_list|()
block|{
return|return
name|srcOffset
return|;
block|}
comment|/**      * Similar to {@link #skip(long)} but travels backwards      *      * @param len The number of bytes to skip backwards      *      * @return The actual number of bytes skipped backwards      */
specifier|public
name|long
name|skipBackwards
parameter_list|(
specifier|final
name|long
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// can only skip back to zero
specifier|final
name|long
name|actualLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|srcOffset
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|srcOffset
operator|=
name|srcOffset
operator|-
operator|(
name|int
operator|)
name|actualLen
expr_stmt|;
return|return
name|actualLen
return|;
block|}
comment|/**      * We cant actually skip as we need to read so that we can cache the data,      * however apart from the potentially increased I/O and Memory, the end      * result is the same      */
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
specifier|final
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FilterInputStreamCache
operator|.
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|else if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|useCache
argument_list|()
condition|)
block|{
comment|//skip data from the cache
name|long
name|actualLen
init|=
operator|(
name|len
operator|>
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
condition|?
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
else|:
name|len
operator|)
decl_stmt|;
comment|//if the requested bytes were more than what is present in the cache, then also read from the src
if|if
condition|(
name|actualLen
operator|<
name|len
condition|)
block|{
comment|// we can't skip directly on the src otherwise it will never be read into the cache, so we read over the amount of bytes we want to skip instead
specifier|final
name|int
name|toReadFromSrc
init|=
operator|(
name|int
operator|)
operator|(
name|len
operator|-
name|actualLen
operator|)
decl_stmt|;
specifier|final
name|byte
name|skipped
index|[]
init|=
operator|new
name|byte
index|[
name|toReadFromSrc
index|]
decl_stmt|;
comment|//read some data from the source (and into the cache)
name|int
name|toRead
init|=
name|toReadFromSrc
decl_stmt|;
while|while
condition|(
name|toRead
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|read
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|skipped
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|read
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
break|break;
block|}
name|toRead
operator|-=
name|read
expr_stmt|;
name|actualLen
operator|+=
name|read
expr_stmt|;
block|}
block|}
comment|//increase srcOffset due to the read operation above
name|srcOffset
operator|+=
operator|(
name|int
operator|)
name|actualLen
expr_stmt|;
return|return
name|actualLen
return|;
block|}
else|else
block|{
specifier|final
name|byte
name|skipped
index|[]
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|len
index|]
decl_stmt|;
comment|//TODO could overflow
name|int
name|toRead
init|=
operator|(
name|int
operator|)
name|len
decl_stmt|;
name|int
name|totalRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|toRead
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|read
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|skipped
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|read
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
break|break;
block|}
name|toRead
operator|-=
name|read
expr_stmt|;
name|totalRead
operator|+=
name|read
expr_stmt|;
block|}
comment|//increase srcOffset due to read operation above
name|srcOffset
operator|+=
name|totalRead
expr_stmt|;
return|return
name|totalRead
return|;
block|}
block|}
specifier|private
name|boolean
name|useCache
parameter_list|()
block|{
comment|//If cache hasRead and srcOffset is still in cache useCache
return|return
name|getCache
argument_list|()
operator|.
name|getSrcOffset
argument_list|()
operator|>
literal|0
operator|&&
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|>
name|srcOffset
return|;
block|}
comment|/**      * Increments the number of shared references to the cache.      */
specifier|public
name|void
name|incrementSharedReferences
parameter_list|()
block|{
name|getCache
argument_list|()
operator|.
name|incrementSharedReferences
argument_list|()
expr_stmt|;
block|}
comment|/**      * Decrements the number of shared references to the cache.      */
specifier|public
name|void
name|decrementSharedReferences
parameter_list|()
block|{
name|getCache
argument_list|()
operator|.
name|decrementSharedReferences
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

