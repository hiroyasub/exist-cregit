begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
package|;
end_package

begin_comment
comment|// Copied without change from Xerces module org.apache.xerces.util.XMLChar, version 2.5.0
end_comment

begin_comment
comment|/*  * The Apache Software License, Version 1.1  *  *  * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by the  *        Apache Software Foundation (http://www.apache.org/)."  *    Alternately, this acknowledgment may appear in the software itself,  *    if and wherever such third-party acknowledgments normally appear.  *  * 4. The names "Xerces" and "Apache Software Foundation" must  *    not be used to endorse or promote products derived from this  *    software without prior written permission. For written  *    permission, please contact apache@apache.org.  *  * 5. Products derived from this software may not be called "Apache",  *    nor may "Apache" appear in their name, without prior written  *    permission of the Apache Software Foundation.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ====================================================================  *  * This software consists of voluntary contributions made by many  * individuals on behalf of the Apache Software Foundation and was  * originally based on software copyright (c) 1999, International  * Business Machines, Inc., http://www.apache.org.  For more  * information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment

begin_comment
comment|/**  * This class defines the basic XML character properties. The data  * in this class can be used to verify that a character is a valid  * XML character or if the character is a space, name start, or name  * character.  *  * A series of convenience methods are supplied to ease the burden  * of the developer. Because inlining the checks can improve per  * character performance, the tables of character properties are  * public. Using the character as an index into the<code>CHARS</code>  * array and applying the appropriate mask flag (e.g.  *<code>MASK_VALID</code>), yields the same results as calling the  * convenience methods. There is one exception: check the comments  * for the<code>isValid</code> method for details.  *  * @author Glenn Marcy, IBM  * @author Andy Clark, IBM  * @author Eric Ye, IBM  * @author Arnaud  Le Hors, IBM  * @author Rahul Srivastava, Sun Microsystems Inc.  *  * @version $Id$  */
end_comment

begin_class
specifier|public
class|class
name|XMLChar
block|{
comment|//
comment|// Constants
comment|//
comment|/** Character flags. */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|CHARS
init|=
operator|new
name|byte
index|[
literal|1
operator|<<
literal|16
index|]
decl_stmt|;
comment|/** Valid character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_VALID
init|=
literal|0x01
decl_stmt|;
comment|/** Space character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_SPACE
init|=
literal|0x02
decl_stmt|;
comment|/** Name start character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_NAME_START
init|=
literal|0x04
decl_stmt|;
comment|/** Name character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_NAME
init|=
literal|0x08
decl_stmt|;
comment|/** Pubid character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_PUBID
init|=
literal|0x10
decl_stmt|;
comment|/**      * Content character mask. Special characters are those that can      * be considered the start of markup, such as '&lt;' and '&amp;'.      * The various newline characters are considered special as well.      * All other valid XML characters can be considered content.      *      * This is an optimization for the inner loop of character scanning.      */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_CONTENT
init|=
literal|0x20
decl_stmt|;
comment|/** NCName start character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_NCNAME_START
init|=
literal|0x40
decl_stmt|;
comment|/** NCName character mask. */
specifier|public
specifier|static
specifier|final
name|int
name|MASK_NCNAME
init|=
literal|0x80
decl_stmt|;
comment|//
comment|// Static initialization
comment|//
static|static
block|{
comment|//
comment|// [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] |
comment|//              [#xE000-#xFFFD] | [#x10000-#x10FFFF]
comment|//
specifier|final
name|int
name|charRange
index|[]
init|=
block|{
literal|0x0009
block|,
literal|0x000A
block|,
literal|0x000D
block|,
literal|0x000D
block|,
literal|0x0020
block|,
literal|0xD7FF
block|,
literal|0xE000
block|,
literal|0xFFFD
block|,         }
decl_stmt|;
comment|//
comment|// [3] S ::= (#x20 | #x9 | #xD | #xA)+
comment|//
specifier|final
name|int
name|spaceChar
index|[]
init|=
block|{
literal|0x0020
block|,
literal|0x0009
block|,
literal|0x000D
block|,
literal|0x000A
block|,         }
decl_stmt|;
comment|//
comment|// [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |
comment|//                  CombiningChar | Extender
comment|//
specifier|final
name|int
name|nameChar
index|[]
init|=
block|{
literal|0x002D
block|,
literal|0x002E
block|,
comment|// '-' and '.'
block|}
decl_stmt|;
comment|//
comment|// [5] Name ::= (Letter | '_' | ':') (NameChar)*
comment|//
specifier|final
name|int
name|nameStartChar
index|[]
init|=
block|{
literal|0x003A
block|,
literal|0x005F
block|,
comment|// ':' and '_'
block|}
decl_stmt|;
comment|//
comment|// [13] PubidChar ::= #x20 | 0xD | 0xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
comment|//
specifier|final
name|int
name|pubidChar
index|[]
init|=
block|{
literal|0x000A
block|,
literal|0x000D
block|,
literal|0x0020
block|,
literal|0x0021
block|,
literal|0x0023
block|,
literal|0x0024
block|,
literal|0x0025
block|,
literal|0x003D
block|,
literal|0x005F
block|}
decl_stmt|;
specifier|final
name|int
name|pubidRange
index|[]
init|=
block|{
literal|0x0027
block|,
literal|0x003B
block|,
literal|0x003F
block|,
literal|0x005A
block|,
literal|0x0061
block|,
literal|0x007A
block|}
decl_stmt|;
comment|//
comment|// [84] Letter ::= BaseChar | Ideographic
comment|//
specifier|final
name|int
name|letterRange
index|[]
init|=
block|{
comment|// BaseChar
literal|0x0041
block|,
literal|0x005A
block|,
literal|0x0061
block|,
literal|0x007A
block|,
literal|0x00C0
block|,
literal|0x00D6
block|,
literal|0x00D8
block|,
literal|0x00F6
block|,
literal|0x00F8
block|,
literal|0x0131
block|,
literal|0x0134
block|,
literal|0x013E
block|,
literal|0x0141
block|,
literal|0x0148
block|,
literal|0x014A
block|,
literal|0x017E
block|,
literal|0x0180
block|,
literal|0x01C3
block|,
literal|0x01CD
block|,
literal|0x01F0
block|,
literal|0x01F4
block|,
literal|0x01F5
block|,
literal|0x01FA
block|,
literal|0x0217
block|,
literal|0x0250
block|,
literal|0x02A8
block|,
literal|0x02BB
block|,
literal|0x02C1
block|,
literal|0x0388
block|,
literal|0x038A
block|,
literal|0x038E
block|,
literal|0x03A1
block|,
literal|0x03A3
block|,
literal|0x03CE
block|,
literal|0x03D0
block|,
literal|0x03D6
block|,
literal|0x03E2
block|,
literal|0x03F3
block|,
literal|0x0401
block|,
literal|0x040C
block|,
literal|0x040E
block|,
literal|0x044F
block|,
literal|0x0451
block|,
literal|0x045C
block|,
literal|0x045E
block|,
literal|0x0481
block|,
literal|0x0490
block|,
literal|0x04C4
block|,
literal|0x04C7
block|,
literal|0x04C8
block|,
literal|0x04CB
block|,
literal|0x04CC
block|,
literal|0x04D0
block|,
literal|0x04EB
block|,
literal|0x04EE
block|,
literal|0x04F5
block|,
literal|0x04F8
block|,
literal|0x04F9
block|,
literal|0x0531
block|,
literal|0x0556
block|,
literal|0x0561
block|,
literal|0x0586
block|,
literal|0x05D0
block|,
literal|0x05EA
block|,
literal|0x05F0
block|,
literal|0x05F2
block|,
literal|0x0621
block|,
literal|0x063A
block|,
literal|0x0641
block|,
literal|0x064A
block|,
literal|0x0671
block|,
literal|0x06B7
block|,
literal|0x06BA
block|,
literal|0x06BE
block|,
literal|0x06C0
block|,
literal|0x06CE
block|,
literal|0x06D0
block|,
literal|0x06D3
block|,
literal|0x06E5
block|,
literal|0x06E6
block|,
literal|0x0905
block|,
literal|0x0939
block|,
literal|0x0958
block|,
literal|0x0961
block|,
literal|0x0985
block|,
literal|0x098C
block|,
literal|0x098F
block|,
literal|0x0990
block|,
literal|0x0993
block|,
literal|0x09A8
block|,
literal|0x09AA
block|,
literal|0x09B0
block|,
literal|0x09B6
block|,
literal|0x09B9
block|,
literal|0x09DC
block|,
literal|0x09DD
block|,
literal|0x09DF
block|,
literal|0x09E1
block|,
literal|0x09F0
block|,
literal|0x09F1
block|,
literal|0x0A05
block|,
literal|0x0A0A
block|,
literal|0x0A0F
block|,
literal|0x0A10
block|,
literal|0x0A13
block|,
literal|0x0A28
block|,
literal|0x0A2A
block|,
literal|0x0A30
block|,
literal|0x0A32
block|,
literal|0x0A33
block|,
literal|0x0A35
block|,
literal|0x0A36
block|,
literal|0x0A38
block|,
literal|0x0A39
block|,
literal|0x0A59
block|,
literal|0x0A5C
block|,
literal|0x0A72
block|,
literal|0x0A74
block|,
literal|0x0A85
block|,
literal|0x0A8B
block|,
literal|0x0A8F
block|,
literal|0x0A91
block|,
literal|0x0A93
block|,
literal|0x0AA8
block|,
literal|0x0AAA
block|,
literal|0x0AB0
block|,
literal|0x0AB2
block|,
literal|0x0AB3
block|,
literal|0x0AB5
block|,
literal|0x0AB9
block|,
literal|0x0B05
block|,
literal|0x0B0C
block|,
literal|0x0B0F
block|,
literal|0x0B10
block|,
literal|0x0B13
block|,
literal|0x0B28
block|,
literal|0x0B2A
block|,
literal|0x0B30
block|,
literal|0x0B32
block|,
literal|0x0B33
block|,
literal|0x0B36
block|,
literal|0x0B39
block|,
literal|0x0B5C
block|,
literal|0x0B5D
block|,
literal|0x0B5F
block|,
literal|0x0B61
block|,
literal|0x0B85
block|,
literal|0x0B8A
block|,
literal|0x0B8E
block|,
literal|0x0B90
block|,
literal|0x0B92
block|,
literal|0x0B95
block|,
literal|0x0B99
block|,
literal|0x0B9A
block|,
literal|0x0B9E
block|,
literal|0x0B9F
block|,
literal|0x0BA3
block|,
literal|0x0BA4
block|,
literal|0x0BA8
block|,
literal|0x0BAA
block|,
literal|0x0BAE
block|,
literal|0x0BB5
block|,
literal|0x0BB7
block|,
literal|0x0BB9
block|,
literal|0x0C05
block|,
literal|0x0C0C
block|,
literal|0x0C0E
block|,
literal|0x0C10
block|,
literal|0x0C12
block|,
literal|0x0C28
block|,
literal|0x0C2A
block|,
literal|0x0C33
block|,
literal|0x0C35
block|,
literal|0x0C39
block|,
literal|0x0C60
block|,
literal|0x0C61
block|,
literal|0x0C85
block|,
literal|0x0C8C
block|,
literal|0x0C8E
block|,
literal|0x0C90
block|,
literal|0x0C92
block|,
literal|0x0CA8
block|,
literal|0x0CAA
block|,
literal|0x0CB3
block|,
literal|0x0CB5
block|,
literal|0x0CB9
block|,
literal|0x0CE0
block|,
literal|0x0CE1
block|,
literal|0x0D05
block|,
literal|0x0D0C
block|,
literal|0x0D0E
block|,
literal|0x0D10
block|,
literal|0x0D12
block|,
literal|0x0D28
block|,
literal|0x0D2A
block|,
literal|0x0D39
block|,
literal|0x0D60
block|,
literal|0x0D61
block|,
literal|0x0E01
block|,
literal|0x0E2E
block|,
literal|0x0E32
block|,
literal|0x0E33
block|,
literal|0x0E40
block|,
literal|0x0E45
block|,
literal|0x0E81
block|,
literal|0x0E82
block|,
literal|0x0E87
block|,
literal|0x0E88
block|,
literal|0x0E94
block|,
literal|0x0E97
block|,
literal|0x0E99
block|,
literal|0x0E9F
block|,
literal|0x0EA1
block|,
literal|0x0EA3
block|,
literal|0x0EAA
block|,
literal|0x0EAB
block|,
literal|0x0EAD
block|,
literal|0x0EAE
block|,
literal|0x0EB2
block|,
literal|0x0EB3
block|,
literal|0x0EC0
block|,
literal|0x0EC4
block|,
literal|0x0F40
block|,
literal|0x0F47
block|,
literal|0x0F49
block|,
literal|0x0F69
block|,
literal|0x10A0
block|,
literal|0x10C5
block|,
literal|0x10D0
block|,
literal|0x10F6
block|,
literal|0x1102
block|,
literal|0x1103
block|,
literal|0x1105
block|,
literal|0x1107
block|,
literal|0x110B
block|,
literal|0x110C
block|,
literal|0x110E
block|,
literal|0x1112
block|,
literal|0x1154
block|,
literal|0x1155
block|,
literal|0x115F
block|,
literal|0x1161
block|,
literal|0x116D
block|,
literal|0x116E
block|,
literal|0x1172
block|,
literal|0x1173
block|,
literal|0x11AE
block|,
literal|0x11AF
block|,
literal|0x11B7
block|,
literal|0x11B8
block|,
literal|0x11BC
block|,
literal|0x11C2
block|,
literal|0x1E00
block|,
literal|0x1E9B
block|,
literal|0x1EA0
block|,
literal|0x1EF9
block|,
literal|0x1F00
block|,
literal|0x1F15
block|,
literal|0x1F18
block|,
literal|0x1F1D
block|,
literal|0x1F20
block|,
literal|0x1F45
block|,
literal|0x1F48
block|,
literal|0x1F4D
block|,
literal|0x1F50
block|,
literal|0x1F57
block|,
literal|0x1F5F
block|,
literal|0x1F7D
block|,
literal|0x1F80
block|,
literal|0x1FB4
block|,
literal|0x1FB6
block|,
literal|0x1FBC
block|,
literal|0x1FC2
block|,
literal|0x1FC4
block|,
literal|0x1FC6
block|,
literal|0x1FCC
block|,
literal|0x1FD0
block|,
literal|0x1FD3
block|,
literal|0x1FD6
block|,
literal|0x1FDB
block|,
literal|0x1FE0
block|,
literal|0x1FEC
block|,
literal|0x1FF2
block|,
literal|0x1FF4
block|,
literal|0x1FF6
block|,
literal|0x1FFC
block|,
literal|0x212A
block|,
literal|0x212B
block|,
literal|0x2180
block|,
literal|0x2182
block|,
literal|0x3041
block|,
literal|0x3094
block|,
literal|0x30A1
block|,
literal|0x30FA
block|,
literal|0x3105
block|,
literal|0x312C
block|,
literal|0xAC00
block|,
literal|0xD7A3
block|,
comment|// Ideographic
literal|0x3021
block|,
literal|0x3029
block|,
literal|0x4E00
block|,
literal|0x9FA5
block|,         }
decl_stmt|;
specifier|final
name|int
name|letterChar
index|[]
init|=
block|{
comment|// BaseChar
literal|0x0386
block|,
literal|0x038C
block|,
literal|0x03DA
block|,
literal|0x03DC
block|,
literal|0x03DE
block|,
literal|0x03E0
block|,
literal|0x0559
block|,
literal|0x06D5
block|,
literal|0x093D
block|,
literal|0x09B2
block|,
literal|0x0A5E
block|,
literal|0x0A8D
block|,
literal|0x0ABD
block|,
literal|0x0AE0
block|,
literal|0x0B3D
block|,
literal|0x0B9C
block|,
literal|0x0CDE
block|,
literal|0x0E30
block|,
literal|0x0E84
block|,
literal|0x0E8A
block|,
literal|0x0E8D
block|,
literal|0x0EA5
block|,
literal|0x0EA7
block|,
literal|0x0EB0
block|,
literal|0x0EBD
block|,
literal|0x1100
block|,
literal|0x1109
block|,
literal|0x113C
block|,
literal|0x113E
block|,
literal|0x1140
block|,
literal|0x114C
block|,
literal|0x114E
block|,
literal|0x1150
block|,
literal|0x1159
block|,
literal|0x1163
block|,
literal|0x1165
block|,
literal|0x1167
block|,
literal|0x1169
block|,
literal|0x1175
block|,
literal|0x119E
block|,
literal|0x11A8
block|,
literal|0x11AB
block|,
literal|0x11BA
block|,
literal|0x11EB
block|,
literal|0x11F0
block|,
literal|0x11F9
block|,
literal|0x1F59
block|,
literal|0x1F5B
block|,
literal|0x1F5D
block|,
literal|0x1FBE
block|,
literal|0x2126
block|,
literal|0x212E
block|,
comment|// Ideographic
literal|0x3007
block|,         }
decl_stmt|;
comment|//
comment|// [87] CombiningChar ::= ...
comment|//
specifier|final
name|int
name|combiningCharRange
index|[]
init|=
block|{
literal|0x0300
block|,
literal|0x0345
block|,
literal|0x0360
block|,
literal|0x0361
block|,
literal|0x0483
block|,
literal|0x0486
block|,
literal|0x0591
block|,
literal|0x05A1
block|,
literal|0x05A3
block|,
literal|0x05B9
block|,
literal|0x05BB
block|,
literal|0x05BD
block|,
literal|0x05C1
block|,
literal|0x05C2
block|,
literal|0x064B
block|,
literal|0x0652
block|,
literal|0x06D6
block|,
literal|0x06DC
block|,
literal|0x06DD
block|,
literal|0x06DF
block|,
literal|0x06E0
block|,
literal|0x06E4
block|,
literal|0x06E7
block|,
literal|0x06E8
block|,
literal|0x06EA
block|,
literal|0x06ED
block|,
literal|0x0901
block|,
literal|0x0903
block|,
literal|0x093E
block|,
literal|0x094C
block|,
literal|0x0951
block|,
literal|0x0954
block|,
literal|0x0962
block|,
literal|0x0963
block|,
literal|0x0981
block|,
literal|0x0983
block|,
literal|0x09C0
block|,
literal|0x09C4
block|,
literal|0x09C7
block|,
literal|0x09C8
block|,
literal|0x09CB
block|,
literal|0x09CD
block|,
literal|0x09E2
block|,
literal|0x09E3
block|,
literal|0x0A40
block|,
literal|0x0A42
block|,
literal|0x0A47
block|,
literal|0x0A48
block|,
literal|0x0A4B
block|,
literal|0x0A4D
block|,
literal|0x0A70
block|,
literal|0x0A71
block|,
literal|0x0A81
block|,
literal|0x0A83
block|,
literal|0x0ABE
block|,
literal|0x0AC5
block|,
literal|0x0AC7
block|,
literal|0x0AC9
block|,
literal|0x0ACB
block|,
literal|0x0ACD
block|,
literal|0x0B01
block|,
literal|0x0B03
block|,
literal|0x0B3E
block|,
literal|0x0B43
block|,
literal|0x0B47
block|,
literal|0x0B48
block|,
literal|0x0B4B
block|,
literal|0x0B4D
block|,
literal|0x0B56
block|,
literal|0x0B57
block|,
literal|0x0B82
block|,
literal|0x0B83
block|,
literal|0x0BBE
block|,
literal|0x0BC2
block|,
literal|0x0BC6
block|,
literal|0x0BC8
block|,
literal|0x0BCA
block|,
literal|0x0BCD
block|,
literal|0x0C01
block|,
literal|0x0C03
block|,
literal|0x0C3E
block|,
literal|0x0C44
block|,
literal|0x0C46
block|,
literal|0x0C48
block|,
literal|0x0C4A
block|,
literal|0x0C4D
block|,
literal|0x0C55
block|,
literal|0x0C56
block|,
literal|0x0C82
block|,
literal|0x0C83
block|,
literal|0x0CBE
block|,
literal|0x0CC4
block|,
literal|0x0CC6
block|,
literal|0x0CC8
block|,
literal|0x0CCA
block|,
literal|0x0CCD
block|,
literal|0x0CD5
block|,
literal|0x0CD6
block|,
literal|0x0D02
block|,
literal|0x0D03
block|,
literal|0x0D3E
block|,
literal|0x0D43
block|,
literal|0x0D46
block|,
literal|0x0D48
block|,
literal|0x0D4A
block|,
literal|0x0D4D
block|,
literal|0x0E34
block|,
literal|0x0E3A
block|,
literal|0x0E47
block|,
literal|0x0E4E
block|,
literal|0x0EB4
block|,
literal|0x0EB9
block|,
literal|0x0EBB
block|,
literal|0x0EBC
block|,
literal|0x0EC8
block|,
literal|0x0ECD
block|,
literal|0x0F18
block|,
literal|0x0F19
block|,
literal|0x0F71
block|,
literal|0x0F84
block|,
literal|0x0F86
block|,
literal|0x0F8B
block|,
literal|0x0F90
block|,
literal|0x0F95
block|,
literal|0x0F99
block|,
literal|0x0FAD
block|,
literal|0x0FB1
block|,
literal|0x0FB7
block|,
literal|0x20D0
block|,
literal|0x20DC
block|,
literal|0x302A
block|,
literal|0x302F
block|,         }
decl_stmt|;
specifier|final
name|int
name|combiningCharChar
index|[]
init|=
block|{
literal|0x05BF
block|,
literal|0x05C4
block|,
literal|0x0670
block|,
literal|0x093C
block|,
literal|0x094D
block|,
literal|0x09BC
block|,
literal|0x09BE
block|,
literal|0x09BF
block|,
literal|0x09D7
block|,
literal|0x0A02
block|,
literal|0x0A3C
block|,
literal|0x0A3E
block|,
literal|0x0A3F
block|,
literal|0x0ABC
block|,
literal|0x0B3C
block|,
literal|0x0BD7
block|,
literal|0x0D57
block|,
literal|0x0E31
block|,
literal|0x0EB1
block|,
literal|0x0F35
block|,
literal|0x0F37
block|,
literal|0x0F39
block|,
literal|0x0F3E
block|,
literal|0x0F3F
block|,
literal|0x0F97
block|,
literal|0x0FB9
block|,
literal|0x20E1
block|,
literal|0x3099
block|,
literal|0x309A
block|,         }
decl_stmt|;
comment|//
comment|// [88] Digit ::= ...
comment|//
specifier|final
name|int
name|digitRange
index|[]
init|=
block|{
literal|0x0030
block|,
literal|0x0039
block|,
literal|0x0660
block|,
literal|0x0669
block|,
literal|0x06F0
block|,
literal|0x06F9
block|,
literal|0x0966
block|,
literal|0x096F
block|,
literal|0x09E6
block|,
literal|0x09EF
block|,
literal|0x0A66
block|,
literal|0x0A6F
block|,
literal|0x0AE6
block|,
literal|0x0AEF
block|,
literal|0x0B66
block|,
literal|0x0B6F
block|,
literal|0x0BE7
block|,
literal|0x0BEF
block|,
literal|0x0C66
block|,
literal|0x0C6F
block|,
literal|0x0CE6
block|,
literal|0x0CEF
block|,
literal|0x0D66
block|,
literal|0x0D6F
block|,
literal|0x0E50
block|,
literal|0x0E59
block|,
literal|0x0ED0
block|,
literal|0x0ED9
block|,
literal|0x0F20
block|,
literal|0x0F29
block|,         }
decl_stmt|;
comment|//
comment|// [89] Extender ::= ...
comment|//
specifier|final
name|int
name|extenderRange
index|[]
init|=
block|{
literal|0x3031
block|,
literal|0x3035
block|,
literal|0x309D
block|,
literal|0x309E
block|,
literal|0x30FC
block|,
literal|0x30FE
block|,         }
decl_stmt|;
specifier|final
name|int
name|extenderChar
index|[]
init|=
block|{
literal|0x00B7
block|,
literal|0x02D0
block|,
literal|0x02D1
block|,
literal|0x0387
block|,
literal|0x0640
block|,
literal|0x0E46
block|,
literal|0x0EC6
block|,
literal|0x3005
block|,         }
decl_stmt|;
comment|//
comment|// SpecialChar ::= '<', '&', '\n', '\r', ']'
comment|//
specifier|final
name|int
name|specialChar
index|[]
init|=
block|{
literal|'<'
block|,
literal|'&'
block|,
literal|'\n'
block|,
literal|'\r'
block|,
literal|']'
block|,         }
decl_stmt|;
comment|//
comment|// Initialize
comment|//
comment|// set valid characters
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charRange
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|charRange
index|[
name|i
index|]
init|;
name|j
operator|<=
name|charRange
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|j
operator|++
control|)
block|{
name|CHARS
index|[
name|j
index|]
operator||=
name|MASK_VALID
operator||
name|MASK_CONTENT
expr_stmt|;
block|}
block|}
comment|// remove special characters
for|for
control|(
name|int
name|i5
range|:
name|specialChar
control|)
block|{
name|CHARS
index|[
name|i5
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|CHARS
index|[
name|i5
index|]
operator|&
operator|~
name|MASK_CONTENT
operator|)
expr_stmt|;
block|}
comment|// set space characters
for|for
control|(
name|int
name|i4
range|:
name|spaceChar
control|)
block|{
name|CHARS
index|[
name|i4
index|]
operator||=
name|MASK_SPACE
expr_stmt|;
block|}
comment|// set name start characters
for|for
control|(
name|int
name|i3
range|:
name|nameStartChar
control|)
block|{
name|CHARS
index|[
name|i3
index|]
operator||=
name|MASK_NAME_START
operator||
name|MASK_NAME
operator||
name|MASK_NCNAME_START
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|letterRange
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|letterRange
index|[
name|i
index|]
init|;
name|j
operator|<=
name|letterRange
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|j
operator|++
control|)
block|{
name|CHARS
index|[
name|j
index|]
operator||=
name|MASK_NAME_START
operator||
name|MASK_NAME
operator||
name|MASK_NCNAME_START
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i2
range|:
name|letterChar
control|)
block|{
name|CHARS
index|[
name|i2
index|]
operator||=
name|MASK_NAME_START
operator||
name|MASK_NAME
operator||
name|MASK_NCNAME_START
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
comment|// set name characters
for|for
control|(
name|int
name|i1
range|:
name|nameChar
control|)
block|{
name|CHARS
index|[
name|i1
index|]
operator||=
name|MASK_NAME
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|digitRange
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|digitRange
index|[
name|i
index|]
init|;
name|j
operator|<=
name|digitRange
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|j
operator|++
control|)
block|{
name|CHARS
index|[
name|j
index|]
operator||=
name|MASK_NAME
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|combiningCharRange
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|combiningCharRange
index|[
name|i
index|]
init|;
name|j
operator|<=
name|combiningCharRange
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|j
operator|++
control|)
block|{
name|CHARS
index|[
name|j
index|]
operator||=
name|MASK_NAME
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|element
range|:
name|combiningCharChar
control|)
block|{
name|CHARS
index|[
name|element
index|]
operator||=
name|MASK_NAME
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extenderRange
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|extenderRange
index|[
name|i
index|]
init|;
name|j
operator|<=
name|extenderRange
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|j
operator|++
control|)
block|{
name|CHARS
index|[
name|j
index|]
operator||=
name|MASK_NAME
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|item
range|:
name|extenderChar
control|)
block|{
name|CHARS
index|[
name|item
index|]
operator||=
name|MASK_NAME
operator||
name|MASK_NCNAME
expr_stmt|;
block|}
comment|// remove ':' from allowable MASK_NCNAME_START and MASK_NCNAME chars
name|CHARS
index|[
literal|':'
index|]
operator|&=
operator|~
operator|(
name|MASK_NCNAME_START
operator||
name|MASK_NCNAME
operator|)
expr_stmt|;
comment|// set Pubid characters
for|for
control|(
name|int
name|value
range|:
name|pubidChar
control|)
block|{
name|CHARS
index|[
name|value
index|]
operator||=
name|MASK_PUBID
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pubidRange
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|pubidRange
index|[
name|i
index|]
init|;
name|j
operator|<=
name|pubidRange
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|j
operator|++
control|)
block|{
name|CHARS
index|[
name|j
index|]
operator||=
name|MASK_PUBID
expr_stmt|;
block|}
block|}
block|}
comment|//<clinit>()
comment|//
comment|// Public static methods
comment|//
comment|/**      * Returns true if the specified character is a supplemental character.      *      * @param c The character to check.      *      * @return true if the specified character is a supplemental character.      */
specifier|public
specifier|static
name|boolean
name|isSupplemental
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|0x10000
operator|&&
name|c
operator|<=
literal|0x10FFFF
operator|)
return|;
block|}
comment|/**      * Returns the supplemental character corresponding to the given      * surrogates.      *      * @param h The high surrogate.      * @param l The low surrogate.      *      * @return the supplemental character      */
specifier|public
specifier|static
name|int
name|supplemental
parameter_list|(
name|char
name|h
parameter_list|,
name|char
name|l
parameter_list|)
block|{
return|return
operator|(
name|h
operator|-
literal|0xD800
operator|)
operator|*
literal|0x400
operator|+
operator|(
name|l
operator|-
literal|0xDC00
operator|)
operator|+
literal|0x10000
return|;
block|}
comment|/**      * Returns the high surrogate of a supplemental character      *      * @param c The supplemental character to "split".      *      * @return the high surrogate of the supplemental character      */
specifier|public
specifier|static
name|char
name|highSurrogate
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
operator|(
operator|(
operator|(
name|c
operator|-
literal|0x00010000
operator|)
operator|>>
literal|10
operator|)
operator|+
literal|0xD800
operator|)
return|;
block|}
comment|/**      * Returns the low surrogate of a supplemental character      *      * @param c The supplemental character to "split".      *      * @return the low surrogate of the supplemental character      */
specifier|public
specifier|static
name|char
name|lowSurrogate
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
operator|(
operator|(
operator|(
name|c
operator|-
literal|0x00010000
operator|)
operator|&
literal|0x3FF
operator|)
operator|+
literal|0xDC00
operator|)
return|;
block|}
comment|/**      * Returns whether the given character is a high surrogate      *      * @param c The character to check.      *      * @return true if the character is a high surrogate      */
specifier|public
specifier|static
name|boolean
name|isHighSurrogate
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
literal|0xD800
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0xDBFF
operator|)
return|;
block|}
comment|/**      * Returns whether the given character is a low surrogate      *      * @param c The character to check.      *      * @return true if the character is a low surrogate      */
specifier|public
specifier|static
name|boolean
name|isLowSurrogate
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
literal|0xDC00
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0xDFFF
operator|)
return|;
block|}
comment|/**      * Return whether a given char (codepoint) is a surrogate (high or low)      *      * @param c the character to check.      *      * @return true if the character is a surrogate      */
specifier|static
specifier|public
name|boolean
name|isSurrogate
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|&
literal|0xF800
operator|)
operator|==
literal|0xD800
return|;
block|}
comment|/**      * Returns true if the specified character is valid. This method      * also checks the surrogate character range from 0x10000 to 0x10FFFF.      *      * If the program chooses to apply the mask directly to the      *<code>CHARS</code> array, then they are responsible for checking      * the surrogate character range.      *      * @param c The character to check.      *      * @return true if the character is valid.      */
specifier|public
specifier|static
name|boolean
name|isValid
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_VALID
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
literal|0x10000
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0x10FFFF
operator|)
return|;
block|}
comment|// isValid(int):boolean
comment|/**      * Returns true if the specified character is invalid.      *      * @param c The character to check.      *      * @return true if the character is a invalid.      */
specifier|public
specifier|static
name|boolean
name|isInvalid
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|!
name|isValid
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|// isInvalid(int):boolean
comment|/**      * Returns true if the specified character can be considered content.      *      * @param c The character to check.      *      * @return true if the character can be considered as content.      */
specifier|public
specifier|static
name|boolean
name|isContent
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_CONTENT
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
literal|0x10000
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0x10FFFF
operator|)
return|;
block|}
comment|// isContent(int):boolean
comment|/**      * Returns true if the specified character can be considered markup.      * Markup characters include '&lt;', '&amp;', and '%'.      *      * @param c The character to check.      *      * @return true if the specified character can be considered as markup      */
specifier|public
specifier|static
name|boolean
name|isMarkup
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'&'
operator|||
name|c
operator|==
literal|'%'
return|;
block|}
comment|// isMarkup(int):boolean
comment|/**      * Returns true if the specified character is a space character      * as defined by production [3] in the XML 1.0 specification.      *      * @param c The character to check.      *      * @return true if the specified character is a space character      */
specifier|public
specifier|static
name|boolean
name|isSpace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_SPACE
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isSpace(int):boolean
comment|/**      * Returns true if the specified character is a valid name start      * character as defined by production [5] in the XML 1.0      * specification.      *      * @param c The character to check.      *      * @return true if the specified character is a valid name start character      */
specifier|public
specifier|static
name|boolean
name|isNameStart
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_NAME_START
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isNameStart(int):boolean
comment|/**      * Returns true if the specified character is a valid name      * character as defined by production [4] in the XML 1.0      * specification.      *      * @param c The character to check.      *      * @return true if the specified character is a valid name character      */
specifier|public
specifier|static
name|boolean
name|isName
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_NAME
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isName(int):boolean
comment|/**      * Returns true if the specified character is a valid NCName start      * character as defined by production [4] in Namespaces in XML      * recommendation.      *      * @param c The character to check.      *      * @return true if the specified character is a valid NCName start character      */
specifier|public
specifier|static
name|boolean
name|isNCNameStart
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_NCNAME_START
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isNCNameStart(int):boolean
comment|/**      * Returns true if the specified character is a valid NCName      * character as defined by production [5] in Namespaces in XML      * recommendation.      *      * @param c The character to check.      *      * @return true if the specified character is a valid NCName character      */
specifier|public
specifier|static
name|boolean
name|isNCName
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_NCNAME
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isNCName(int):boolean
comment|/**      * Returns true if the specified character is a valid Pubid      * character as defined by production [13] in the XML 1.0      * specification.      *      * @param c The character to check.      *      * @return true if the specified character is a valid Pubid character      */
specifier|public
specifier|static
name|boolean
name|isPubid
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|0x10000
operator|&&
operator|(
name|CHARS
index|[
name|c
index|]
operator|&
name|MASK_PUBID
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isPubid(int):boolean
comment|/*      * [5] Name ::= (Letter | '_' | ':') (NameChar)*      */
comment|/**      * Check to see if a string is a valid Name according to [5]      * in the XML 1.0 Recommendation      *      * @param name string to check      * @return true if name is a valid Name      */
specifier|public
specifier|static
name|boolean
name|isValidName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|char
name|ch
init|=
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isNameStart
argument_list|(
name|ch
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// isValidName(String):boolean
comment|/*      * from the namespace rec      * [4] NCName ::= (Letter | '_') (NCNameChar)*      */
comment|/**      * Check to see if a string is a valid NCName according to [4]      * from the XML Namespaces 1.0 Recommendation      *      * @param ncName string to check      * @return true if name is a valid NCName      */
specifier|public
specifier|static
name|boolean
name|isValidNCName
parameter_list|(
specifier|final
name|String
name|ncName
parameter_list|)
block|{
if|if
condition|(
name|ncName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|char
name|ch
init|=
name|ncName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isNCNameStart
argument_list|(
name|ch
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ncName
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|ncName
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isNCName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// isValidNCName(String):boolean
comment|/*      * [7] Nmtoken ::= (NameChar)+      */
comment|/**      * Check to see if a string is a valid Nmtoken according to [7]      * in the XML 1.0 Recommendation      *      * @param nmtoken string to check      * @return true if nmtoken is a valid Nmtoken      */
specifier|public
specifier|static
name|boolean
name|isValidNmtoken
parameter_list|(
name|String
name|nmtoken
parameter_list|)
block|{
if|if
condition|(
name|nmtoken
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nmtoken
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
name|ch
init|=
name|nmtoken
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// isValidName(String):boolean
comment|// encodings
comment|/**      * Returns true if the encoding name is a valid IANA encoding.      * This method does not verify that there is a decoder available      * for this encoding, only that the characters are valid for an      * IANA encoding name.      *      * @param ianaEncoding The IANA encoding name.      *      * @return true if the encoding name is a valid IANA encoding      */
specifier|public
specifier|static
name|boolean
name|isValidIANAEncoding
parameter_list|(
name|String
name|ianaEncoding
parameter_list|)
block|{
if|if
condition|(
name|ianaEncoding
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|length
init|=
name|ianaEncoding
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|char
name|c
init|=
name|ianaEncoding
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ianaEncoding
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|'A'
operator|||
name|c
operator|>
literal|'Z'
operator|)
operator|&&
operator|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
operator|)
operator|&&
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// isValidIANAEncoding(String):boolean
comment|/**      * Returns true if the encoding name is a valid Java encoding.      * This method does not verify that there is a decoder available      * for this encoding, only that the characters are valid for an      * Java encoding name.      *      * @param javaEncoding The Java encoding name.      *      * @return true if the encoding name is a valid Java encoding      */
specifier|public
specifier|static
name|boolean
name|isValidJavaEncoding
parameter_list|(
name|String
name|javaEncoding
parameter_list|)
block|{
if|if
condition|(
name|javaEncoding
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|length
init|=
name|javaEncoding
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
name|c
init|=
name|javaEncoding
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|'A'
operator|||
name|c
operator|>
literal|'Z'
operator|)
operator|&&
operator|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
operator|)
operator|&&
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// isValidIANAEncoding(String):boolean
block|}
end_class

begin_comment
comment|// class XMLChar
end_comment

end_unit

