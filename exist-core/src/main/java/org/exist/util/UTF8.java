begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  `gnu.iou' I/O buffers and utilities.  *  Copyright (C) 1998, 1999, 2000, 2001, 2002 John Pritchard.  *  *  This program is free software; you can redistribute it or modify  *  it under the terms of the GNU Lesser General Public License as  *  published by the Free Software Foundation; either version 2.1 of  *  the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to the Free  *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  *  02111-1307 USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * This class contains two static tools for doing UTF-8 encoding and  * decoding.  *  *  UTF-8 is ASCII- transparent.  It supports character sets  * requiring more than the seven bit ASCII base range of UTF-8,  * including Unicode, ISO-8859, ISO-10646, etc..  *  *  We do not use an ISO UCS code signature, and we do not use a  * Java Data I/O- style strlen prefix.  *  * @author John Pritchard (john@syntelos.org)  */
end_comment

begin_class
specifier|public
class|class
name|UTF8
block|{
comment|/**      * Decode UTF-8 input, terminates decoding at a null character,      * value 0x0.      *      * @param code the encoded UTf-8 string      *      * @return the decoded UTF-8 string      *      * @throws IllegalStateException Bad format.      */
specifier|public
specifier|final
specifier|static
name|XMLString
name|decode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|byte
index|[]
name|code
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|code
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|decode
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|code
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|final
specifier|static
name|XMLString
name|decode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|byte
index|[]
name|code
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|many
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|code
operator|||
literal|0
operator|>=
name|code
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|XMLString
name|xs
init|=
operator|new
name|XMLString
argument_list|(
name|many
argument_list|)
decl_stmt|;
return|return
name|decode
argument_list|(
name|code
argument_list|,
name|off
argument_list|,
name|many
argument_list|,
name|xs
argument_list|)
return|;
block|}
comment|/**      * Decode UTF-8 input, terminates decoding at a null character,      * value 0x0.      *      * @param code the encoded UTf-8 string      * @param off the offset of the string      * @param many many      * @param xs xs      *      * @return the decoded UTF-8 string      *      * @throws IllegalStateException Bad format.      */
specifier|public
specifier|final
specifier|static
name|XMLString
name|decode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|byte
index|[]
name|code
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|many
parameter_list|,
specifier|final
name|XMLString
name|xs
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|code
operator|||
literal|0
operator|>=
name|code
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
name|char
name|ch
decl_stmt|;
specifier|final
name|int
name|end
init|=
operator|(
name|off
operator|+
name|many
operator|)
decl_stmt|;
name|byte
name|cc
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|off
init|;
name|c
operator|<
name|end
condition|;
name|c
operator|++
control|)
block|{
name|cc
operator|=
name|code
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|cc
condition|)
block|{
name|xs
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b11000000
operator|==
operator|(
name|cc
operator|&
name|b11100000
operator|)
condition|)
block|{
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|1
index|]
operator|&
name|b00111111
operator|)
expr_stmt|;
name|ch
operator||=
operator|(
name|cc
operator|&
name|b00011111
operator|)
operator|<<
literal|6
expr_stmt|;
name|c
operator|+=
literal|1
expr_stmt|;
block|}
if|else if
condition|(
name|b11100000
operator|==
operator|(
name|cc
operator|&
name|b11110000
operator|)
condition|)
block|{
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|2
index|]
operator|&
name|b00111111
operator|)
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|1
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|6
expr_stmt|;
name|ch
operator||=
operator|(
name|cc
operator|&
name|b00001111
operator|)
operator|<<
literal|12
expr_stmt|;
name|c
operator|+=
literal|2
expr_stmt|;
block|}
if|else if
condition|(
name|b11110000
operator|==
operator|(
name|cc
operator|&
name|b11111000
operator|)
condition|)
block|{
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|3
index|]
operator|&
name|b00111111
operator|)
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|2
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|6
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|1
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|12
expr_stmt|;
name|c
operator|+=
literal|3
expr_stmt|;
block|}
if|else if
condition|(
name|b11111000
operator|==
operator|(
name|cc
operator|&
name|b11111100
operator|)
condition|)
block|{
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|4
index|]
operator|&
name|b00111111
operator|)
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|3
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|6
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|2
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|12
expr_stmt|;
name|c
operator|+=
literal|4
expr_stmt|;
block|}
if|else if
condition|(
name|b11111100
operator|==
operator|(
name|cc
operator|&
name|b11111110
operator|)
condition|)
block|{
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|5
index|]
operator|&
name|b00111111
operator|)
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|4
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|6
expr_stmt|;
name|ch
operator||=
operator|(
name|code
index|[
name|c
operator|+
literal|3
index|]
operator|&
name|b00111111
operator|)
operator|<<
literal|12
expr_stmt|;
name|c
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|(
name|char
operator|)
operator|(
name|cc
operator|&
name|b01111111
operator|)
expr_stmt|;
comment|// 0x7f
block|}
name|xs
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|// else // if ( 0< cc)
block|}
return|return
name|xs
return|;
block|}
comment|/**      * Encode string in UTF-8.      *      * @param str the string to encode      *      * @return the encoded string      */
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|encode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|char
index|[]
name|str
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|str
operator|||
literal|0
operator|>=
name|str
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|encode
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
name|str
operator|.
name|length
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Encode string in UTF-8.      *      * Warning: the size of bytbuf is not checked. Use encoded() to determine      * the size needed.      *      * @param str the string to encode      * @param start the offset of the string      * @param length the length of the string      * @param bytbuf bytebuf      * @param offset the offset in bytebuf      *      * @return the encoded string      */
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|encode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|char
index|[]
name|str
parameter_list|,
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
annotation|@
name|Nullable
name|byte
index|[]
name|bytbuf
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|str
operator|||
literal|0
operator|>=
name|length
condition|)
block|{
return|return
name|bytbuf
return|;
block|}
if|if
condition|(
name|bytbuf
operator|==
literal|null
condition|)
block|{
name|bytbuf
operator|=
operator|new
name|byte
index|[
name|encoded
argument_list|(
name|str
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
index|]
expr_stmt|;
block|}
name|char
name|ch
decl_stmt|,
name|sch
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|start
init|;
name|c
operator|<
name|end
condition|;
name|c
operator|++
control|)
block|{
name|ch
operator|=
name|str
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
literal|0x7f
operator|>=
name|ch
condition|)
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|ch
expr_stmt|;
block|}
if|else if
condition|(
literal|0x7ff
operator|>=
name|ch
condition|)
block|{
name|sch
operator|=
operator|(
name|char
operator|)
operator|(
name|ch
operator|>>>
literal|6
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sch
condition|)
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11000000
operator||
operator|(
name|sch
operator|&
name|b00011111
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11000000
operator|)
expr_stmt|;
block|}
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b10000000
operator||
operator|(
name|ch
operator|&
name|b00111111
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sch
operator|=
operator|(
name|char
operator|)
operator|(
name|ch
operator|>>>
literal|12
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sch
condition|)
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11100000
operator||
operator|(
name|sch
operator|&
name|b00001111
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11100000
operator|)
expr_stmt|;
block|}
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b10000000
operator||
operator|(
operator|(
name|ch
operator|>>>
literal|6
operator|)
operator|&
name|b00111111
operator|)
operator|)
expr_stmt|;
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b10000000
operator||
operator|(
name|ch
operator|&
name|b00111111
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|bytbuf
return|;
block|}
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|encode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|String
name|str
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|byte
index|[]
name|bytbuf
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
return|return
name|encode
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|bytbuf
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/**      * Encode string in UTF-8.      *      * Warning: the size of bytbuf is not checked. Use encoded() to determine      * the size needed.      *      * @param str the string to encode      * @param start the offset of the string      * @param length the length of the string      * @param bytbuf bytebuf      * @param offset the offset in bytebuf      *      * @return the encoded string      */
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|encode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|String
name|str
parameter_list|,
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|byte
index|[]
name|bytbuf
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|str
operator|||
literal|0
operator|>=
name|length
condition|)
block|{
return|return
name|bytbuf
return|;
block|}
name|char
name|ch
decl_stmt|,
name|sch
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|start
init|;
name|c
operator|<
name|end
condition|;
name|c
operator|++
control|)
block|{
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x7f
operator|>=
name|ch
condition|)
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|ch
expr_stmt|;
block|}
if|else if
condition|(
literal|0x7ff
operator|>=
name|ch
condition|)
block|{
name|sch
operator|=
operator|(
name|char
operator|)
operator|(
name|ch
operator|>>>
literal|6
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sch
condition|)
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11000000
operator||
operator|(
name|sch
operator|&
name|b00011111
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11000000
operator|)
expr_stmt|;
block|}
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b10000000
operator||
operator|(
name|ch
operator|&
name|b00111111
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sch
operator|=
operator|(
name|char
operator|)
operator|(
name|ch
operator|>>>
literal|12
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sch
condition|)
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11100000
operator||
operator|(
name|sch
operator|&
name|b00001111
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b11100000
operator|)
expr_stmt|;
block|}
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b10000000
operator||
operator|(
operator|(
name|ch
operator|>>>
literal|6
operator|)
operator|&
name|b00111111
operator|)
operator|)
expr_stmt|;
name|bytbuf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
name|b10000000
operator||
operator|(
name|ch
operator|&
name|b00111111
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|bytbuf
return|;
block|}
comment|/**      * Encode string in UTF-8.      *      * @param s the string to encode      *      * @return the encoded string      */
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|encode
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|s
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|encode
argument_list|(
name|s
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|char
name|b10000000
init|=
operator|(
name|char
operator|)
literal|0x80
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b11000000
init|=
operator|(
name|char
operator|)
literal|0xC0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b11100000
init|=
operator|(
name|char
operator|)
literal|0xE0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b11110000
init|=
operator|(
name|char
operator|)
literal|0xF0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b11111000
init|=
operator|(
name|char
operator|)
literal|0xF8
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b11111100
init|=
operator|(
name|char
operator|)
literal|0xFC
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b11111110
init|=
operator|(
name|char
operator|)
literal|0xFE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b01111111
init|=
operator|(
name|char
operator|)
literal|0x7F
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b00111111
init|=
operator|(
name|char
operator|)
literal|0x3F
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b00011111
init|=
operator|(
name|char
operator|)
literal|0x1F
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|b00001111
init|=
operator|(
name|char
operator|)
literal|0x0F
decl_stmt|;
comment|//private static final char b00000111 = (char) 0x07;
comment|//private static final char b00000011 = (char) 0x03;
comment|//private static final char b00000001 = (char) 0x01;
comment|/**      * Returns the length of the string encoded in UTF-8.      *      * @param str the string      * @return the length of the encoded string      */
specifier|public
specifier|final
specifier|static
name|int
name|encoded
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|str
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|bytlen
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|//char sch;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
name|ch
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x7f
operator|>=
name|ch
condition|)
block|{
name|bytlen
operator|++
expr_stmt|;
block|}
if|else if
condition|(
literal|0x7ff
operator|>=
name|ch
condition|)
block|{
name|bytlen
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|bytlen
operator|+=
literal|3
expr_stmt|;
block|}
block|}
return|return
name|bytlen
return|;
block|}
comment|/**      * Returns the length of the string encoded in UTF-8.      *      * @param str the string      * @param start the offset of the string      * @param len the length of the string      * @return the length of the encoded string      */
specifier|public
specifier|final
specifier|static
name|int
name|encoded
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|char
index|[]
name|str
parameter_list|,
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|str
operator|||
literal|0
operator|>=
name|len
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|bytlen
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|//char sch;
specifier|final
name|int
name|end
init|=
name|start
operator|+
name|len
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|start
init|;
name|c
operator|<
name|end
condition|;
name|c
operator|++
control|)
block|{
name|ch
operator|=
name|str
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
literal|0x7f
operator|>=
name|ch
condition|)
block|{
name|bytlen
operator|++
expr_stmt|;
block|}
if|else if
condition|(
literal|0x7ff
operator|>=
name|ch
condition|)
block|{
name|bytlen
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|bytlen
operator|+=
literal|3
expr_stmt|;
block|}
block|}
return|return
name|bytlen
return|;
block|}
comment|/**      * Static method to generate the UTF-8 representation of a Unicode character.      * This particular code is taken from saxon (see http://saxon.sf.net).      *      * @param in  the Unicode character, or the high half of a surrogate pair      * @param in2 the low half of a surrogate pair (ignored unless the first argument is in the      *            range for a surrogate pair)      * @param out an array of at least 4 bytes to hold the UTF-8 representation.      * @return the number of bytes in the UTF-8 representation      */
specifier|public
specifier|static
name|int
name|getUTF8Encoding
parameter_list|(
specifier|final
name|char
name|in
parameter_list|,
specifier|final
name|char
name|in2
parameter_list|,
specifier|final
name|byte
index|[]
name|out
parameter_list|)
block|{
comment|// See Tony Graham, "Unicode, a Primer", page 92
specifier|final
name|int
name|i
init|=
operator|(
name|int
operator|)
name|in
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0x7f
condition|)
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
return|return
literal|1
return|;
block|}
if|else if
condition|(
name|i
operator|<=
literal|0x7ff
condition|)
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0xc0
operator||
operator|(
operator|(
name|in
operator|>>
literal|6
operator|)
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
name|in
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|else if
condition|(
name|i
operator|>=
literal|0xd800
operator|&&
name|i
operator|<=
literal|0xdbff
condition|)
block|{
comment|// surrogate pair
specifier|final
name|int
name|j
init|=
operator|(
name|int
operator|)
name|in2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|j
operator|>=
literal|0xdc00
operator|&&
name|j
operator|<=
literal|0xdfff
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed Unicode Surrogate Pair ("
operator|+
name|i
operator|+
literal|","
operator|+
name|j
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|byte
name|xxxxxx
init|=
operator|(
name|byte
operator|)
operator|(
name|j
operator|&
literal|0x3f
operator|)
decl_stmt|;
specifier|final
name|byte
name|yyyyyy
init|=
operator|(
name|byte
operator|)
operator|(
operator|(
operator|(
name|i
operator|&
literal|0x03
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|j
operator|>>
literal|6
operator|)
operator|&
literal|0x0f
operator|)
operator|)
decl_stmt|;
specifier|final
name|byte
name|zzzz
init|=
operator|(
name|byte
operator|)
operator|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|0x0f
operator|)
decl_stmt|;
specifier|final
name|byte
name|uuuuu
init|=
operator|(
name|byte
operator|)
operator|(
operator|(
operator|(
name|i
operator|>>
literal|6
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0xf0
operator||
operator|(
operator|(
name|uuuuu
operator|>>
literal|2
operator|)
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
operator|(
name|uuuuu
operator|&
literal|0x03
operator|)
operator|<<
literal|4
operator|)
operator||
name|zzzz
operator|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
name|yyyyyy
operator|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
name|xxxxxx
operator|)
expr_stmt|;
return|return
literal|4
return|;
block|}
if|else if
condition|(
name|i
operator|>=
literal|0xdc00
operator|&&
name|i
operator|<=
literal|0xdfff
condition|)
block|{
comment|// second half of surrogate pair - ignore it
return|return
literal|0
return|;
block|}
else|else
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0xe0
operator||
operator|(
operator|(
name|in
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
operator|(
name|in
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
name|in
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
block|}
end_class

end_unit

