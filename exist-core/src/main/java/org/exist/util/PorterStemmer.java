begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*    Porter stemmer in Java. The original paper is in         Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,        no. 3, pp 130-137,     See also http://www.muscat.com/~martin/stem.html     Bug 1 (reported by Gonzalo Parra 16/10/99) fixed as marked below.    Tthe words 'aed', 'eed', 'oed' leave k at 'a' for step 3, and b[k-1]    is then out outside the bounds of b.     Similarly,     Bug 2 (reported by Steve Dyrdahl 22/2/00) fixed as marked below.    'ion' by itself leaves j = -1 in the test for 'ion' in step 5, and    b[j] is then outside the bounds of b.     Release 3.     [ This version is derived from Release 3, modified by Brian Goetz to       optimize for fewer object creations.  ]  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
package|;
end_package

begin_comment
comment|/**  *  * Stemmer, implementing the Porter Stemming Algorithm  *  * The Stemmer class transforms a word into its root form.  The input  * word can be provided a character at time (by calling add()), or at once  * by calling one of the various stem(something) methods.    */
end_comment

begin_class
specifier|public
class|class
name|PorterStemmer
block|{
specifier|private
name|char
index|[]
name|b
decl_stmt|;
specifier|private
name|int
name|i
decl_stmt|;
comment|/* offset into b */
specifier|private
name|int
name|j
decl_stmt|;
specifier|private
name|int
name|k
decl_stmt|;
specifier|private
name|int
name|k0
decl_stmt|;
specifier|private
name|boolean
name|dirty
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|INC
init|=
literal|50
decl_stmt|;
comment|/* unit of size whereby b is increased */
specifier|private
specifier|static
specifier|final
name|int
name|EXTRA
init|=
literal|1
decl_stmt|;
specifier|public
name|PorterStemmer
parameter_list|()
block|{
name|b
operator|=
operator|new
name|char
index|[
name|INC
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/**     * reset() resets the stemmer so it can stem another word.  If you invoke    * the stemmer by calling add(char) and then stem(), you must call reset()    * before starting another word.    */
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Add a character to the word being stemmed.  When you are finished     * adding characters, you can call stem(void) to process the word.    *    * @param ch the character    */
specifier|public
name|void
name|add
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|b
operator|.
name|length
operator|<=
name|i
operator|+
name|EXTRA
condition|)
block|{
name|char
index|[]
name|new_b
init|=
operator|new
name|char
index|[
name|b
operator|.
name|length
operator|+
name|INC
index|]
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|b
operator|.
name|length
condition|;
name|c
operator|++
control|)
name|new_b
index|[
name|c
index|]
operator|=
name|b
index|[
name|c
index|]
expr_stmt|;
name|b
operator|=
name|new_b
expr_stmt|;
block|}
name|b
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
comment|/**    * After a word has been stemmed, it can be retrieved by toString(),     * or a reference to the internal buffer can be retrieved by getResultBuffer    * and getResultLength (which is generally more efficient.)    *    * @return the stemmed string    */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|String
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**    * Returns the length of the word resulting from the stemming process.    *    * @return the length    */
specifier|public
name|int
name|getResultLength
parameter_list|()
block|{
return|return
name|i
return|;
block|}
comment|/**    * Returns a reference to a character buffer containing the results of    * the stemming process.  You also need to consult getResultLength()    * to determine the length of the result.    *    * @return the result buffer    */
specifier|public
name|char
index|[]
name|getResultBuffer
parameter_list|()
block|{
return|return
name|b
return|;
block|}
comment|/* cons(i) is true<=> b[i] is a consonant. */
specifier|private
specifier|final
name|boolean
name|cons
parameter_list|(
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|b
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'e'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
return|return
literal|false
return|;
case|case
literal|'y'
case|:
return|return
operator|(
name|i
operator|==
name|k0
operator|)
condition|?
literal|true
else|:
operator|!
name|cons
argument_list|(
name|i
operator|-
literal|1
argument_list|)
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
comment|/* m() measures the number of consonant sequences between k0 and j. if c is      a consonant sequence and v a vowel sequence, and<..> indicates arbitrary      presence,<c><v>       gives 0<c>vc<v>     gives 1<c>vcvc<v>   gives 2<c>vcvcvc<v> gives 3           ....   */
specifier|private
specifier|final
name|int
name|m
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|k0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|j
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
operator|!
name|cons
argument_list|(
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|j
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
name|cons
argument_list|(
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|j
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
operator|!
name|cons
argument_list|(
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* vowelinstem() is true<=> k0,...j contains a vowel */
specifier|private
specifier|final
name|boolean
name|vowelinstem
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|k0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|cons
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* doublec(j) is true<=> j,(j-1) contain a double consonant. */
specifier|private
specifier|final
name|boolean
name|doublec
parameter_list|(
name|int
name|j
parameter_list|)
block|{
if|if
condition|(
name|j
operator|<
name|k0
operator|+
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|b
index|[
name|j
index|]
operator|!=
name|b
index|[
name|j
operator|-
literal|1
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|cons
argument_list|(
name|j
argument_list|)
return|;
block|}
comment|/* cvc(i) is true<=> i-2,i-1,i has the form consonant - vowel - consonant      and also if the second c is not w,x or y. this is used when trying to      restore an e at the end of a short word. e.g.            cav(e), lov(e), hop(e), crim(e), but           snow, box, tray.    */
specifier|private
specifier|final
name|boolean
name|cvc
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|k0
operator|+
literal|2
operator|||
operator|!
name|cons
argument_list|(
name|i
argument_list|)
operator|||
name|cons
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|cons
argument_list|(
name|i
operator|-
literal|2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
specifier|final
name|int
name|ch
init|=
name|b
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'w'
operator|||
name|ch
operator|==
literal|'x'
operator|||
name|ch
operator|==
literal|'y'
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|final
name|boolean
name|ends
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|int
name|l
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|int
name|o
init|=
name|k
operator|-
name|l
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|o
operator|<
name|k0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|b
index|[
name|o
operator|+
name|i
index|]
operator|!=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|j
operator|=
name|k
operator|-
name|l
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/* setto(s) sets (j+1),...k to the characters in the string s, readjusting      k. */
name|void
name|setto
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|int
name|l
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|int
name|o
init|=
name|j
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|b
index|[
name|o
operator|+
name|i
index|]
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
name|l
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/* r(s) is used further down. */
name|void
name|r
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|m
argument_list|()
operator|>
literal|0
condition|)
block|{
name|setto
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* step1() gets rid of plurals and -ed or -ing. e.g.             caresses  ->  caress            ponies    ->  poni            ties      ->  ti            caress    ->  caress            cats      ->  cat             feed      ->  feed            agreed    ->  agree            disabled  ->  disable             matting   ->  mat            mating    ->  mate            meeting   ->  meet            milling   ->  mill            messing   ->  mess             meetings  ->  meet    */
specifier|private
specifier|final
name|void
name|step1
parameter_list|()
block|{
if|if
condition|(
name|b
index|[
name|k
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|ends
argument_list|(
literal|"sses"
argument_list|)
condition|)
block|{
name|k
operator|-=
literal|2
expr_stmt|;
block|}
if|else if
condition|(
name|ends
argument_list|(
literal|"ies"
argument_list|)
condition|)
block|{
name|setto
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|b
index|[
name|k
operator|-
literal|1
index|]
operator|!=
literal|'s'
condition|)
block|{
name|k
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"eed"
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
argument_list|()
operator|>
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
block|}
block|}
if|else if
condition|(
operator|(
name|ends
argument_list|(
literal|"ed"
argument_list|)
operator|||
name|ends
argument_list|(
literal|"ing"
argument_list|)
operator|)
operator|&&
name|vowelinstem
argument_list|()
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|ends
argument_list|(
literal|"at"
argument_list|)
condition|)
block|{
name|setto
argument_list|(
literal|"ate"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|ends
argument_list|(
literal|"bl"
argument_list|)
condition|)
block|{
name|setto
argument_list|(
literal|"ble"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|ends
argument_list|(
literal|"iz"
argument_list|)
condition|)
block|{
name|setto
argument_list|(
literal|"ize"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|doublec
argument_list|(
name|k
argument_list|)
condition|)
block|{
specifier|final
name|int
name|ch
init|=
name|b
index|[
name|k
operator|--
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'l'
operator|||
name|ch
operator|==
literal|'s'
operator|||
name|ch
operator|==
literal|'z'
condition|)
block|{
name|k
operator|++
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|m
argument_list|()
operator|==
literal|1
operator|&&
name|cvc
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|setto
argument_list|(
literal|"e"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* step2() turns terminal y to i when there is another vowel in the stem. */
specifier|private
specifier|final
name|void
name|step2
parameter_list|()
block|{
if|if
condition|(
name|ends
argument_list|(
literal|"y"
argument_list|)
operator|&&
name|vowelinstem
argument_list|()
condition|)
block|{
name|b
index|[
name|k
index|]
operator|=
literal|'i'
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/* step3() maps double suffices to single ones. so -ization ( = -ize plus      -ation) maps to -ize etc. note that the string before the suffix must give      m()> 0. */
specifier|private
specifier|final
name|void
name|step3
parameter_list|()
block|{
if|if
condition|(
name|k
operator|==
name|k0
condition|)
block|{
return|return;
block|}
comment|/* For Bug 1 */
switch|switch
condition|(
name|b
index|[
name|k
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ational"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ate"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"tional"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"tion"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"enci"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ence"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"anci"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ance"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"izer"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ize"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"bli"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ble"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"alli"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"al"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"entli"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ent"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"eli"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"e"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ousli"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ous"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ization"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ize"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ation"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ate"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ator"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ate"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"alism"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"al"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"iveness"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ive"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"fulness"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ful"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ousness"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ous"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"aliti"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"al"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"iviti"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ive"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"biliti"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ble"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"logi"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"log"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* step4() deals with -ic-, -full, -ness etc. similar strategy to step3. */
specifier|private
specifier|final
name|void
name|step4
parameter_list|()
block|{
switch|switch
condition|(
name|b
index|[
name|k
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"icate"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ic"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ative"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"alize"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"al"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"iciti"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ic"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ical"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|"ic"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ful"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ness"
argument_list|)
condition|)
block|{
name|r
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
comment|/* step5() takes off -ant, -ence etc., in context<c>vcvc<v>. */
specifier|private
specifier|final
name|void
name|step5
parameter_list|()
block|{
if|if
condition|(
name|k
operator|==
name|k0
condition|)
block|{
return|return;
block|}
comment|/* for Bug 1 */
switch|switch
condition|(
name|b
index|[
name|k
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"al"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'c'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ance"
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ence"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'e'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"er"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'i'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ic"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'l'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"able"
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ible"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'n'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ant"
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ement"
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"ment"
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* element etc. not stripped before the m */
if|if
condition|(
name|ends
argument_list|(
literal|"ent"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'o'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ion"
argument_list|)
operator|&&
name|j
operator|>=
literal|0
operator|&&
operator|(
name|b
index|[
name|j
index|]
operator|==
literal|'s'
operator|||
name|b
index|[
name|j
index|]
operator|==
literal|'t'
operator|)
condition|)
block|{
break|break;
block|}
comment|/* j>= 0 fixes Bug 2 */
if|if
condition|(
name|ends
argument_list|(
literal|"ou"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
comment|/* takes care of -ous */
case|case
literal|'s'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ism"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'t'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ate"
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ends
argument_list|(
literal|"iti"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'u'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ous"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'v'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ive"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
case|case
literal|'z'
case|:
if|if
condition|(
name|ends
argument_list|(
literal|"ize"
argument_list|)
condition|)
block|{
break|break;
block|}
return|return;
default|default:
return|return;
block|}
if|if
condition|(
name|m
argument_list|()
operator|>
literal|1
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
block|}
block|}
comment|/* step6() removes a final -e if m()> 1. */
specifier|private
specifier|final
name|void
name|step6
parameter_list|()
block|{
name|j
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|b
index|[
name|k
index|]
operator|==
literal|'e'
condition|)
block|{
specifier|final
name|int
name|a
init|=
name|m
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|>
literal|1
operator|||
name|a
operator|==
literal|1
operator|&&
operator|!
name|cvc
argument_list|(
name|k
operator|-
literal|1
argument_list|)
condition|)
block|{
name|k
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
index|[
name|k
index|]
operator|==
literal|'l'
operator|&&
name|doublec
argument_list|(
name|k
argument_list|)
operator|&&
name|m
argument_list|()
operator|>
literal|1
condition|)
block|{
name|k
operator|--
expr_stmt|;
block|}
block|}
comment|/**     * Stem a word provided as a String.  Returns the result as a String.    *    * @param s the word to stem    *    * @return the stemmed string    */
specifier|public
name|String
name|stem
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|word
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|word
control|)
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|stem
argument_list|()
expr_stmt|;
specifier|final
name|String
name|result
init|=
name|toString
argument_list|()
decl_stmt|;
name|reset
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Stem a word contained in a char[].  Returns true if the stemming process    * resulted in a word different from the input.  You can retrieve the    * result with getResultLength()/getResultBuffer() or toString().    *    * @param word the word to stem    *    * @return true if the stemmed word is different    */
specifier|public
name|boolean
name|stem
parameter_list|(
name|char
index|[]
name|word
parameter_list|)
block|{
return|return
name|stem
argument_list|(
name|word
argument_list|,
name|word
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Stem a word contained in a portion of a char[] array.  Returns    * true if the stemming process resulted in a word different from    * the input.  You can retrieve the result with    * getResultLength()/getResultBuffer() or toString().    *    * @param wordBuffer the buffer containing the word to stem    * @param offset the offset of the word in the buffer    * @param wordLen the length of the word in the buffer    *    * @return true if the stemmed word is different    */
specifier|public
name|boolean
name|stem
parameter_list|(
name|char
index|[]
name|wordBuffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|wordLen
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|length
operator|<
name|wordLen
condition|)
block|{
name|char
index|[]
name|new_b
init|=
operator|new
name|char
index|[
name|wordLen
operator|+
name|EXTRA
index|]
decl_stmt|;
name|b
operator|=
name|new_b
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|wordLen
condition|;
name|j
operator|++
control|)
name|b
index|[
name|j
index|]
operator|=
name|wordBuffer
index|[
name|offset
operator|+
name|j
index|]
expr_stmt|;
name|i
operator|=
name|wordLen
expr_stmt|;
return|return
name|stem
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Stem a word contained in a leading portion of a char[] array.    * Returns true if the stemming process resulted in a word different    * from the input.  You can retrieve the result with    * getResultLength()/getResultBuffer() or toString().    *    * @param word the word to stem    * @param wordLen the length of the word to stem    *    * @return true if the stemmed word is different    */
specifier|public
name|boolean
name|stem
parameter_list|(
name|char
index|[]
name|word
parameter_list|,
name|int
name|wordLen
parameter_list|)
block|{
return|return
name|stem
argument_list|(
name|word
argument_list|,
literal|0
argument_list|,
name|wordLen
argument_list|)
return|;
block|}
comment|/**    * Stem the word placed into the Stemmer buffer through calls to add().    * Returns true if the stemming process resulted in a word different    * from the input.  You can retrieve the result with    * getResultLength()/getResultBuffer() or toString().    *    * @return true if the stemmed word is different    */
specifier|public
name|boolean
name|stem
parameter_list|()
block|{
return|return
name|stem
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|stem
parameter_list|(
name|int
name|i0
parameter_list|)
block|{
name|k
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|k0
operator|=
name|i0
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|k0
operator|+
literal|1
condition|)
block|{
name|step1
argument_list|()
expr_stmt|;
name|step2
argument_list|()
expr_stmt|;
name|step3
argument_list|()
expr_stmt|;
name|step4
argument_list|()
expr_stmt|;
name|step5
argument_list|()
expr_stmt|;
name|step6
argument_list|()
expr_stmt|;
block|}
name|i
operator|=
name|k
operator|+
literal|1
expr_stmt|;
return|return
name|dirty
return|;
block|}
comment|/**    * Test program for demonstrating the Stemmer.  It reads a file and    * stems each word, writing the result to standard out.      * Usage: Stemmer file-name    *    * @param args the arguments    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|PorterStemmer
name|s
init|=
operator|new
name|PorterStemmer
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|arg
range|:
name|args
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|arg
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
name|s
operator|.
name|add
argument_list|(
name|arg
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|stem
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|s
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

