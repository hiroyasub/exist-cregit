begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2015 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|collections
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|function
operator|.
name|Consumer2E
import|;
end_import

begin_import
import|import
name|net
operator|.
name|jcip
operator|.
name|annotations
operator|.
name|GuardedBy
import|;
end_import

begin_import
import|import
name|net
operator|.
name|jcip
operator|.
name|annotations
operator|.
name|NotThreadSafe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|input
operator|.
name|CloseShieldInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Indexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|IndexController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Account
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|MimeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|XMLReaderObjectFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|XMLReaderObjectFactory
operator|.
name|VALIDATION_SETTING
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|FastByteArrayInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|serializer
operator|.
name|DOMStreamer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|XMLReader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockMode
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * An implementation of {@link Collection} that allows  * mutations to be made to the Collection object  *  * Locks should be taken appropriately for any mutation  */
end_comment

begin_class
annotation|@
name|NotThreadSafe
specifier|public
class|class
name|MutableCollection
implements|implements
name|Collection
block|{
comment|//TODO(AR) ultimately remove all locking internally from this class and externalise it to the callers, all methods are then internally lock free, and then finally remove `NonLocking` methods
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|Collection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SHALLOW_SIZE
init|=
literal|550
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DOCUMENT_SIZE
init|=
literal|450
decl_stmt|;
specifier|private
specifier|final
name|int
name|collectionId
decl_stmt|;
specifier|private
name|XmldbURI
name|path
decl_stmt|;
specifier|private
specifier|final
name|LockManager
name|lockManager
decl_stmt|;
comment|/*      * LinkedHashSet is used to ensure a consistent iteration order of child Documents.      * The `insertion-order` of a LinkedHashSet means we effectively order by Document creation      * time, i.e. oldest first.      * This ordering ensures that adding new Documents does not affect the existing order of Documents,      * in this manner locks acquired when iterating are always acquired and released in the same order      * which gives us deadlock avoidance for Document iteration.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"LockManager"
argument_list|)
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|DocumentImpl
argument_list|>
name|documents
decl_stmt|;
comment|/*      * LinkedHashSet is used to ensure a consistent iteration order of sub-Collections.      * The `insertion-order` of a LinkedHashSet means we effectively order by sub-Collection creation      * time, i.e. oldest first.      * This ordering ensures that adding new sub-Collections does not affect the existing order of sub-Collections,      * in this manner locks acquired when iterating are always acquired and released in the same order      * which gives us deadlock avoidance for sub-Collection iteration.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"LockManager"
argument_list|)
specifier|private
specifier|final
name|LinkedHashSet
argument_list|<
name|XmldbURI
argument_list|>
name|subCollections
decl_stmt|;
specifier|private
name|long
name|created
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|isTempCollection
decl_stmt|;
specifier|private
specifier|final
name|Permission
name|permissions
decl_stmt|;
specifier|private
specifier|final
name|CollectionMetadata
name|collectionMetadata
decl_stmt|;
comment|/**      * Constructs a Collection Object (not yet persisted)      *      * @param broker The database broker      * @param collectionId a unique numeric id for the collection      * @param path The path of the Collection      */
specifier|public
name|MutableCollection
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|int
name|collectionId
parameter_list|,
specifier|final
name|XmldbURI
name|path
parameter_list|)
block|{
name|this
argument_list|(
name|broker
argument_list|,
name|collectionId
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a Collection Object (not yet persisted)      *      * @param broker The database broker      * @param collectionId a unique numeric id for the collection      * @param path The path of the Collection      * @param permissions The permissions of the collection, or null for the default      * @param created The created time of the collection, or -1 for now      */
specifier|public
name|MutableCollection
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|int
name|collectionId
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|path
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|Permission
name|permissions
parameter_list|,
specifier|final
name|long
name|created
parameter_list|)
block|{
name|this
argument_list|(
name|broker
argument_list|,
name|collectionId
argument_list|,
name|path
argument_list|,
name|permissions
argument_list|,
name|created
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a Collection Object (not yet persisted)      *      * @param broker The database broker      * @param collectionId a unique numeric id for the collection      * @param path The path of the Collection      * @param permissions The permissions of the collection, or null for the default      * @param created The created time of the collection, or -1 for now      * @param subCollections the sub-collections      * @param documents the documents in the collection      */
specifier|private
name|MutableCollection
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|int
name|collectionId
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|path
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|Permission
name|permissions
parameter_list|,
specifier|final
name|long
name|created
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|LinkedHashSet
argument_list|<
name|XmldbURI
argument_list|>
name|subCollections
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|DocumentImpl
argument_list|>
name|documents
parameter_list|)
block|{
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|collectionId
operator|=
name|collectionId
expr_stmt|;
name|this
operator|.
name|permissions
operator|=
name|permissions
operator|!=
literal|null
condition|?
name|permissions
else|:
name|PermissionFactory
operator|.
name|getDefaultCollectionPermission
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|created
operator|=
name|created
operator|>
literal|0
condition|?
name|created
else|:
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|lockManager
operator|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getLockManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|collectionMetadata
operator|=
operator|new
name|CollectionMetadata
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|subCollections
operator|=
name|subCollections
operator|!=
literal|null
condition|?
name|subCollections
else|:
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|documents
operator|=
name|documents
operator|!=
literal|null
condition|?
name|documents
else|:
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Deserializes a Collection object      *      * Counterpart method to {@link #serialize(VariableByteOutputStream)}      *      * @param broker The database broker      * @param path The path of the Collection      * @param inputStream The input stream to deserialize the Collection from      * @throws PermissionDeniedException is user does not have sufficient rights      * @throws IOException if an I/O error happens      * @throws LockException in case dbbroker is locked      *      * @return The Collection Object      */
specifier|public
specifier|static
name|MutableCollection
name|load
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|path
parameter_list|,
specifier|final
name|VariableByteInput
name|inputStream
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
return|return
name|deserialize
argument_list|(
name|broker
argument_list|,
name|path
argument_list|,
name|inputStream
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|setPath
parameter_list|(
name|XmldbURI
name|path
parameter_list|)
block|{
name|setPath
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|setPath
parameter_list|(
name|XmldbURI
name|path
parameter_list|,
specifier|final
name|boolean
name|updateChildren
parameter_list|)
block|{
name|path
operator|=
name|path
operator|.
name|toCollectionPathURI
argument_list|()
expr_stmt|;
comment|//TODO : see if the URI resolves against DBBroker.TEMP_COLLECTION
name|this
operator|.
name|isTempCollection
operator|=
name|path
operator|.
name|getRawCollectionPath
argument_list|()
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|updateChildren
condition|)
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|DocumentImpl
argument_list|>
name|docEntry
range|:
name|documents
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|XmldbURI
name|docUri
init|=
name|path
operator|.
name|append
argument_list|(
name|docEntry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|documentLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|docUri
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|docEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|doc
operator|.
name|setCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// this will invalidate the cached `uri` in DocumentImpl
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addCollection
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|Collection
name|child
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to write to Collection denied for "
operator|+
name|this
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|childName
init|=
name|child
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|subCollections
operator|.
name|contains
argument_list|(
name|childName
argument_list|)
condition|)
block|{
name|subCollections
operator|.
name|add
argument_list|(
name|childName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|stableIterator
parameter_list|(
specifier|final
name|LinkedHashSet
argument_list|<
name|T
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|set
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|stableDocumentIterator
parameter_list|(
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|DocumentImpl
argument_list|>
name|documents
parameter_list|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|documents
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|String
argument_list|>
name|stableDocumentNameIterator
parameter_list|(
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|DocumentImpl
argument_list|>
name|documents
parameter_list|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|documents
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|CollectionEntry
argument_list|>
name|getEntries
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|CollectionEntry
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|subCollectionIterator
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|documentIterator
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|subCollectionIterator
operator|=
name|stableIterator
argument_list|(
name|subCollections
argument_list|)
expr_stmt|;
name|documentIterator
operator|=
name|stableDocumentIterator
argument_list|(
name|documents
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|subCollectionIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|XmldbURI
name|subCollectionURI
init|=
name|subCollectionIterator
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|subCollectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|subCollectionURI
argument_list|)
init|)
block|{
specifier|final
name|CollectionEntry
name|entry
init|=
operator|new
name|SubCollectionEntry
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
argument_list|,
name|subCollectionURI
argument_list|)
decl_stmt|;
name|entry
operator|.
name|readMetadata
argument_list|(
name|broker
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|documentIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|document
init|=
name|documentIterator
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|documentLock
init|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|document
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|DocumentEntry
name|entry
init|=
operator|new
name|DocumentEntry
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|entry
operator|.
name|readMetadata
argument_list|(
name|broker
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
annotation|@
name|Override
specifier|public
name|CollectionEntry
name|getChildCollectionEntry
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|XmldbURI
name|subCollectionURI
init|=
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|final
name|CollectionEntry
name|entry
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|subCollectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|subCollectionURI
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|entry
operator|=
operator|new
name|SubCollectionEntry
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
argument_list|,
name|subCollectionURI
argument_list|)
expr_stmt|;
name|entry
operator|.
name|readMetadata
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
annotation|@
name|Override
specifier|public
name|CollectionEntry
name|getResourceEntry
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
specifier|final
name|CollectionEntry
name|entry
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|documents
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
name|entry
operator|=
operator|new
name|DocumentEntry
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|entry
operator|.
name|readMetadata
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|entry
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTempCollection
parameter_list|()
block|{
return|return
name|isTempCollection
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|update
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|Collection
name|child
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|child
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
name|subCollections
operator|.
name|remove
argument_list|(
name|childName
argument_list|)
expr_stmt|;
name|subCollections
operator|.
name|add
argument_list|(
name|childName
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addDocument
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param oldDoc if not null, then this document is replacing another and so WRITE access on the collection is not required,      * just WRITE access on the old document      */
specifier|private
name|void
name|addDocument
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|/* create */
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to write to Collection denied for "
operator|+
name|this
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|/* update-replace */
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|oldDocLock
init|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|oldDoc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to write to overwrite document: "
operator|+
name|oldDoc
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
name|documents
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|lastSegmentString
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|unlinkDocument
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to remove document from collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|documents
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|collectionIterator
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to list sub-collections denied on "
operator|+
name|this
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|stableIterator
argument_list|(
name|subCollections
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|collectionIteratorNoLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to list sub-collections denied on "
operator|+
name|this
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|stableIterator
argument_list|(
name|subCollections
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Collection
argument_list|>
name|getDescendants
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|Subject
name|user
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|ArrayList
argument_list|<
name|Collection
argument_list|>
name|collectionList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to list sub-collections denied on "
operator|+
name|this
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
name|collectionList
operator|.
name|ensureCapacity
argument_list|(
name|subCollections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|=
name|stableIterator
argument_list|(
name|subCollections
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URI !
specifier|final
name|Collection
name|child
init|=
name|broker
operator|.
name|getCollection
argument_list|(
name|path
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|collectionList
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCollectionCount
argument_list|(
name|broker
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//Recursive call
name|collectionList
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getDescendants
argument_list|(
name|broker
argument_list|,
name|user
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|collectionList
return|;
block|}
annotation|@
name|Override
specifier|public
name|MutableDocumentSet
name|allDocs
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
return|return
name|allDocs
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|recursive
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|MutableDocumentSet
name|allDocs
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|,
specifier|final
name|LockedDocumentMap
name|lockMap
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
name|XmldbURI
index|[]
name|subColls
init|=
literal|null
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
comment|//Add all docs in this collection to the returned set
name|getDocuments
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|)
expr_stmt|;
comment|//Get a list of sub-collection URIs. We will process them
comment|//after unlocking this collection. otherwise we may deadlock ourselves
name|subColls
operator|=
name|subCollections
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|path
operator|::
name|appendInternal
argument_list|)
operator|.
name|toArray
argument_list|(
name|XmldbURI
index|[]
operator|::
operator|new
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recursive
operator|&&
name|subColls
operator|!=
literal|null
condition|)
block|{
comment|// process the child collections
for|for
control|(
specifier|final
name|XmldbURI
name|subCol
range|:
name|subColls
control|)
block|{
try|try
init|(
specifier|final
name|Collection
name|child
init|=
name|broker
operator|.
name|openCollection
argument_list|(
name|subCol
argument_list|,
name|NO_LOCK
argument_list|)
init|)
block|{
comment|// NOTE: the recursive call below to child.addDocs will take a lock
comment|//A collection may have been removed in the meantime, so check first
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
block|{
name|child
operator|.
name|allDocs
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|recursive
argument_list|,
name|lockMap
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
comment|//SKIP to next collection
comment|//TODO create an audit log??!
block|}
block|}
block|}
return|return
name|docs
return|;
block|}
annotation|@
name|Override
specifier|public
name|DocumentSet
name|allDocs
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|,
specifier|final
name|LockedDocumentMap
name|lockMap
parameter_list|,
specifier|final
name|LockMode
name|lockType
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
name|XmldbURI
name|uris
index|[]
init|=
literal|null
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
comment|//Add all documents in this collection to the returned set
name|getDocuments
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|lockMap
argument_list|,
name|lockType
argument_list|)
expr_stmt|;
comment|//Get a list of sub-collection URIs. We will process them
comment|//after unlocking this collection.
comment|//otherwise we may deadlock ourselves
name|uris
operator|=
name|subCollections
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|path
operator|::
name|appendInternal
argument_list|)
operator|.
name|toArray
argument_list|(
name|XmldbURI
index|[]
operator|::
operator|new
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recursive
operator|&&
name|uris
operator|!=
literal|null
condition|)
block|{
comment|//Process the child collections
for|for
control|(
specifier|final
name|XmldbURI
name|uri
range|:
name|uris
control|)
block|{
try|try
init|(
specifier|final
name|Collection
name|child
init|=
name|broker
operator|.
name|openCollection
argument_list|(
name|uri
argument_list|,
name|NO_LOCK
argument_list|)
init|)
block|{
comment|// NOTE: the recursive call below to child.addDocs will take a lock
comment|// a collection may have been removed in the meantime, so check first
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
block|{
name|child
operator|.
name|allDocs
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|recursive
argument_list|,
name|lockMap
argument_list|,
name|lockType
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
name|pde
parameter_list|)
block|{
comment|//SKIP to next collection
comment|//TODO create an audit log??!
block|}
block|}
block|}
return|return
name|docs
return|;
block|}
annotation|@
name|Override
specifier|public
name|DocumentSet
name|getDocuments
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|documentIterator
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|documentIterator
operator|=
name|stableDocumentIterator
argument_list|(
name|documents
argument_list|)
expr_stmt|;
name|docs
operator|.
name|addCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|addDocumentsToSet
argument_list|(
name|broker
argument_list|,
name|documentIterator
argument_list|,
name|docs
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
annotation|@
name|Override
specifier|public
name|DocumentSet
name|getDocumentsNoLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|documentIterator
init|=
name|stableDocumentIterator
argument_list|(
name|documents
argument_list|)
decl_stmt|;
name|docs
operator|.
name|addCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|addDocumentsToSet
argument_list|(
name|broker
argument_list|,
name|documentIterator
argument_list|,
name|docs
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
annotation|@
name|Override
specifier|public
name|DocumentSet
name|getDocuments
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|,
specifier|final
name|LockedDocumentMap
name|lockMap
parameter_list|,
specifier|final
name|LockMode
name|lockType
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|documentIterator
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|documentIterator
operator|=
name|stableDocumentIterator
argument_list|(
name|documents
argument_list|)
expr_stmt|;
name|docs
operator|.
name|addCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|addDocumentsToSet
argument_list|(
name|broker
argument_list|,
name|documentIterator
argument_list|,
name|docs
argument_list|,
name|lockMap
argument_list|,
name|lockType
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
specifier|private
name|void
name|addDocumentsToSet
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|documentIterator
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|,
specifier|final
name|LockedDocumentMap
name|lockMap
parameter_list|,
specifier|final
name|LockMode
name|lockType
parameter_list|)
throws|throws
name|LockException
block|{
specifier|final
name|int
name|requiredPermission
decl_stmt|;
if|if
condition|(
name|lockType
operator|==
name|LockMode
operator|.
name|READ_LOCK
condition|)
block|{
name|requiredPermission
operator|=
name|Permission
operator|.
name|READ
expr_stmt|;
block|}
else|else
block|{
name|requiredPermission
operator|=
name|Permission
operator|.
name|WRITE
expr_stmt|;
block|}
while|while
condition|(
name|documentIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|documentIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|requiredPermission
argument_list|)
condition|)
block|{
specifier|final
name|ManagedDocumentLock
name|documentLock
decl_stmt|;
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|WRITE_LOCK
case|:
name|documentLock
operator|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|READ_LOCK
case|:
name|documentLock
operator|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_LOCK
case|:
default|default:
name|documentLock
operator|=
name|ManagedDocumentLock
operator|.
name|notLocked
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|lockMap
operator|.
name|add
argument_list|(
operator|new
name|LockedDocument
argument_list|(
name|documentLock
argument_list|,
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|addDocumentsToSet
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|documentIterator
parameter_list|,
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|)
block|{
while|while
condition|(
name|documentIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|documentIterator
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|lockedDoc
init|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
annotation|@
name|EnsureContainerLocked
argument_list|(
name|mode
operator|=
name|READ_LOCK
argument_list|)
specifier|public
name|int
name|compareTo
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|other
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectionId
operator|==
name|other
operator|.
name|getId
argument_list|()
condition|)
block|{
return|return
name|Constants
operator|.
name|EQUAL
return|;
block|}
if|else if
condition|(
name|collectionId
operator|<
name|other
operator|.
name|getId
argument_list|()
condition|)
block|{
return|return
name|Constants
operator|.
name|INFERIOR
return|;
block|}
else|else
block|{
return|return
name|Constants
operator|.
name|SUPERIOR
return|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|EnsureContainerLocked
argument_list|(
name|mode
operator|=
name|READ_LOCK
argument_list|)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|READ_LOCK
argument_list|)
specifier|final
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj
operator|instanceof
name|Collection
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
operator|(
name|Collection
operator|)
name|obj
operator|)
operator|.
name|getId
argument_list|()
operator|==
name|collectionId
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getMemorySize
parameter_list|()
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
return|return
name|SHALLOW_SIZE
operator|+
operator|(
name|documents
operator|.
name|size
argument_list|()
operator|*
name|DOCUMENT_SIZE
operator|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getMemorySizeNoLock
parameter_list|()
block|{
return|return
name|SHALLOW_SIZE
operator|+
operator|(
name|documents
operator|.
name|size
argument_list|()
operator|*
name|DOCUMENT_SIZE
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getChildCollectionCount
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|subCollections
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|documents
operator|.
name|isEmpty
argument_list|()
operator|&&
name|subCollections
operator|.
name|isEmpty
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getDocument
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|documents
operator|.
name|get
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
decl_stmt|;
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read document: "
operator|+
name|name
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Document "
operator|+
name|name
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|LockedDocument
name|getDocumentWithLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
return|return
name|getDocumentWithLock
argument_list|(
name|broker
argument_list|,
name|name
argument_list|,
name|READ_LOCK
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|LockedDocument
name|getDocumentWithLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|LockMode
name|lockMode
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
comment|// lock the document
specifier|final
name|ManagedDocumentLock
name|documentLock
decl_stmt|;
specifier|final
name|Runnable
name|unlockFn
decl_stmt|;
comment|// we unlock on error, or if there is no Collection
switch|switch
condition|(
name|lockMode
condition|)
block|{
case|case
name|WRITE_LOCK
case|:
name|documentLock
operator|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unlockFn
operator|=
name|documentLock
operator|::
name|close
expr_stmt|;
break|break;
case|case
name|READ_LOCK
case|:
name|documentLock
operator|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unlockFn
operator|=
name|documentLock
operator|::
name|close
expr_stmt|;
break|break;
case|case
name|NO_LOCK
case|:
default|default:
name|documentLock
operator|=
name|ManagedDocumentLock
operator|.
name|notLocked
argument_list|(
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unlockFn
operator|=
parameter_list|()
lambda|->
block|{
block|}
expr_stmt|;
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
name|documents
operator|.
name|get
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
decl_stmt|;
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|unlockFn
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|unlockFn
operator|.
name|run
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read + document: "
operator|+
name|name
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|LockedDocument
argument_list|(
name|documentLock
argument_list|,
name|doc
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getDocumentNoLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|String
name|rawPath
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|documents
operator|.
name|get
argument_list|(
name|rawPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read document: "
operator|+
name|rawPath
argument_list|)
throw|;
block|}
block|}
return|return
name|doc
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getDocumentCount
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|documents
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getDocumentCountNoLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|documents
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getId
parameter_list|()
block|{
return|return
name|collectionId
return|;
block|}
annotation|@
name|Override
specifier|public
name|XmldbURI
name|getURI
parameter_list|()
block|{
return|return
name|path
return|;
comment|//TODO(AR) we should have a READ_LOCK on here! but we can't as we need the URI to get the READ_LOCK... urgh!
block|}
comment|/**      * Returns the parent-collection.      *      * @return The parent-collection or null if this is the root collection.      */
annotation|@
name|Override
specifier|public
name|XmldbURI
name|getParentURI
parameter_list|()
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//TODO : resolve URI against ".." !
return|return
name|path
operator|.
name|removeLastSegment
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|final
specifier|public
name|Permission
name|getPermissions
parameter_list|()
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
return|return
name|permissions
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|permissions
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Permission
name|getPermissionsNoLock
parameter_list|()
block|{
return|return
name|permissions
return|;
block|}
annotation|@
name|Override
specifier|public
name|CollectionMetadata
name|getMetadata
parameter_list|()
block|{
return|return
name|collectionMetadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasDocument
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|documents
operator|.
name|containsKey
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : ouch ! Should we return at any price ? Without even logging ? -pb
return|return
name|documents
operator|.
name|containsKey
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasChildCollection
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|subCollections
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasChildCollectionNoLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|subCollections
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
return|return
name|getDocuments
argument_list|(
name|broker
argument_list|,
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|)
operator|.
name|getDocumentIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|iteratorNoLock
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|getDocumentsNoLock
argument_list|(
name|broker
argument_list|,
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|)
operator|.
name|getDocumentIterator
argument_list|()
return|;
block|}
comment|/**      * Serializes the Collection to a byte representation      *      * Counterpart method to {@link #deserialize(DBBroker, XmldbURI, VariableByteInput)}      *      * @param outputStream The output stream to write the collection contents to      */
annotation|@
name|Override
specifier|public
name|void
name|serialize
parameter_list|(
specifier|final
name|VariableByteOutputStream
name|outputStream
parameter_list|)
throws|throws
name|IOException
throws|,
name|LockException
block|{
name|outputStream
operator|.
name|writeInt
argument_list|(
name|collectionId
argument_list|)
expr_stmt|;
specifier|final
name|int
name|size
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
decl_stmt|;
comment|//TODO(AR) should we READ_LOCK the Collection to stop it being modified concurrently? see NativeBroker#saveCollection line 1801 - already has WRITE_LOCK ;-)
comment|//        try(final ManagedCollectionLock collectionLock = lockManager.acquireCollectionReadLock(path)) {
name|size
operator|=
name|subCollections
operator|.
name|size
argument_list|()
expr_stmt|;
comment|//            i = subCollections.stableIterator();
name|i
operator|=
name|subCollections
operator|.
name|iterator
argument_list|()
expr_stmt|;
comment|//        }
name|outputStream
operator|.
name|writeInt
argument_list|(
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|XmldbURI
name|childCollectionURI
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|outputStream
operator|.
name|writeUTF
argument_list|(
name|childCollectionURI
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|permissions
operator|.
name|write
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeLong
argument_list|(
name|created
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
comment|//no-op
block|}
comment|/**      * Read collection contents from the stream      *      * Counterpart method to {@link #serialize(VariableByteOutputStream)}      *      * @param broker The database broker      * @param path The path of the Collection      * @param istream The input stream to deserialize the Collection from      */
specifier|private
specifier|static
name|MutableCollection
name|deserialize
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|path
parameter_list|,
specifier|final
name|VariableByteInput
name|istream
parameter_list|)
throws|throws
name|IOException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
specifier|final
name|int
name|collectionId
init|=
name|istream
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|collectionId
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Internal error reading collection: invalid collection id"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|collLen
init|=
name|istream
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|//TODO(AR) should we WRITE_LOCK the Collection to stop it being loaded from disk concurrently? see NativeBroker#openCollection line 1030 - already has READ_LOCK ;-)
comment|//        try(final ManagedCollectionLock collectionLock = lockManager.acquireCollectionWriteLock(path, false)) {
specifier|final
name|LinkedHashSet
argument_list|<
name|XmldbURI
argument_list|>
name|subCollections
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|16
argument_list|,
name|collLen
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collLen
condition|;
name|i
operator|++
control|)
block|{
name|subCollections
operator|.
name|add
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|istream
operator|.
name|readUTF
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Permission
name|permission
init|=
name|PermissionFactory
operator|.
name|getDefaultCollectionPermission
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
argument_list|)
decl_stmt|;
name|permission
operator|.
name|read
argument_list|(
name|istream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|permission
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to open the Collection "
operator|+
name|path
argument_list|)
throw|;
block|}
specifier|final
name|long
name|created
init|=
name|istream
operator|.
name|readLong
argument_list|()
decl_stmt|;
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|DocumentImpl
argument_list|>
name|documents
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|MutableCollection
name|collection
init|=
operator|new
name|MutableCollection
argument_list|(
name|broker
argument_list|,
name|collectionId
argument_list|,
name|path
argument_list|,
name|permission
argument_list|,
name|created
argument_list|,
name|subCollections
argument_list|,
name|documents
argument_list|)
decl_stmt|;
name|broker
operator|.
name|getCollectionResources
argument_list|(
operator|new
name|InternalAccess
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|addDocument
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
block|{
name|doc
operator|.
name|setCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Document must have ID. ["
operator|+
name|doc
operator|+
literal|"]"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Document must have ID."
argument_list|)
throw|;
block|}
name|documents
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|lastSegmentString
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getId
parameter_list|()
block|{
return|return
name|collectionId
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|collection
return|;
comment|//        }
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeCollection
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|subCollections
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Document '"
operator|+
name|doc
operator|.
name|getURI
argument_list|()
operator|+
literal|"' does not belong to Collection '"
operator|+
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|BrokerPool
name|db
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
decl_stmt|;
name|db
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REMOVE_XML
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to write collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docUpdateLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|path
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|documents
operator|.
name|get
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
return|return;
comment|//TODO should throw an exception!!! Otherwise we dont know if the document was removed
block|}
try|try
block|{
name|boolean
name|useTriggers
init|=
name|broker
operator|.
name|isTriggersEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE_URI
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// we remove a collection.xconf configuration file: tell the configuration manager to
comment|// reload the configuration.
name|useTriggers
operator|=
literal|false
expr_stmt|;
specifier|final
name|CollectionConfigurationManager
name|confMgr
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|confMgr
operator|!=
literal|null
condition|)
block|{
name|confMgr
operator|.
name|invalidate
argument_list|(
name|getURI
argument_list|()
argument_list|,
name|broker
operator|.
name|getBrokerPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocumentTriggers
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|useTriggers
condition|?
name|getConfiguration
argument_list|(
name|broker
argument_list|)
else|:
literal|null
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|broker
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|documents
operator|.
name|remove
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyUpdate
argument_list|(
name|doc
argument_list|,
name|UpdateListener
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to write collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|path
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|getDocument
argument_list|(
name|broker
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
return|return;
comment|//TODO should throw an exception!!! Otherwise we dont know if the document was removed
block|}
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REMOVE_BINARY
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to write collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|!=
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" is not a binary object"
argument_list|)
throw|;
block|}
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docUpdateLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
try|try
block|{
specifier|final
name|DocumentTriggers
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|broker
operator|.
name|isTriggersEnabled
argument_list|()
condition|?
name|getConfiguration
argument_list|(
name|broker
argument_list|)
else|:
literal|null
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|IndexController
name|indexController
init|=
name|broker
operator|.
name|getIndexController
argument_list|()
decl_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|(
name|doc
argument_list|,
name|StreamListener
operator|.
name|ReindexMode
operator|.
name|REMOVE_BINARY
argument_list|)
decl_stmt|;
try|try
block|{
name|indexController
operator|.
name|startIndexDocument
argument_list|(
name|transaction
argument_list|,
name|listener
argument_list|)
expr_stmt|;
try|try
block|{
name|broker
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot delete file: "
operator|+
name|doc
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|documents
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|indexController
operator|.
name|endIndexDocument
argument_list|(
name|transaction
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|store
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
specifier|final
name|XMLReader
name|reader
init|=
name|getReader
argument_list|(
name|broker
argument_list|,
literal|false
argument_list|,
name|info
operator|.
name|getCollectionConfig
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|store
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|source
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|releaseReader
argument_list|(
name|broker
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|store
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|,
specifier|final
name|XMLReader
name|reader
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
name|storeXMLInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|storeInfo
lambda|->
block|{
try|try
block|{
specifier|final
name|InputStream
name|is
init|=
name|source
operator|.
name|getByteStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
operator|&&
name|is
operator|.
name|markSupported
argument_list|()
condition|)
block|{
name|is
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Reader
name|cs
init|=
name|source
operator|.
name|getCharacterStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|markSupported
argument_list|()
condition|)
block|{
name|cs
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
comment|// mark is not supported: exception is expected, do nothing
name|LOG
operator|.
name|debug
argument_list|(
literal|"InputStream or CharacterStream underlying the InputSource does not support marking and therefore cannot be re-read."
argument_list|)
expr_stmt|;
block|}
name|storeInfo
operator|.
name|setReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|reader
operator|.
name|parse
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|store
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|String
name|data
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
name|storeXMLInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|storeInfo
lambda|->
block|{
specifier|final
name|CollectionConfiguration
name|colconf
init|=
name|storeInfo
operator|.
name|getDocument
argument_list|()
operator|.
name|getCollection
argument_list|()
operator|.
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
specifier|final
name|XMLReader
name|reader
init|=
name|getReader
argument_list|(
name|broker
argument_list|,
literal|false
argument_list|,
name|colconf
argument_list|)
decl_stmt|;
name|storeInfo
operator|.
name|setReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|reader
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|releaseReader
argument_list|(
name|broker
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|store
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|Node
name|node
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to write collection: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|storeXMLInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|storeInfo
lambda|->
name|storeInfo
operator|.
name|getDOMStreamer
argument_list|()
operator|.
name|serialize
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**       * Stores an XML document in the database. {@link #validateXMLResourceInternal(Txn, DBBroker, XmldbURI,      * CollectionConfiguration, Consumer2E)}should have been called previously in order to acquire a write lock      * for the document. Launches the finish trigger.      *      * @param transaction The database transaction      * @param broker      The database broker      * @param info        Tracks information between validate and store phases      * @param parserFn    A function which parses the XML document      */
specifier|private
name|void
name|storeXMLInternal
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|Consumer2E
argument_list|<
name|IndexInfo
argument_list|,
name|EXistException
argument_list|,
name|SAXException
argument_list|>
name|parserFn
parameter_list|)
throws|throws
name|EXistException
throws|,
name|SAXException
throws|,
name|PermissionDeniedException
block|{
specifier|final
name|DocumentImpl
name|document
init|=
name|info
operator|.
name|getIndexer
argument_list|()
operator|.
name|getDocument
argument_list|()
decl_stmt|;
specifier|final
name|Database
name|db
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
decl_stmt|;
try|try
block|{
comment|/* TODO              *               * These security checks are temporarily disabled because throwing an exception              * here may cause the database to corrupt.              * Why would the database corrupt? Because validateXMLInternal that is typically              * called before this method actually modifies the database and this collection,              * so throwing an exception here leaves the database in an inconsistent state              * with data 1/2 added/updated.              *               * The downside of disabling these checks here is that: this collection is not locked              * between the call to validateXmlInternal and storeXMLInternal, which means that if              * UserA in ThreadA calls validateXmlInternal and is permitted access to store a resource,              * and then UserB in ThreadB modifies the permissions of this collection to prevent UserA              * from storing the document, when UserA reaches here (storeXMLInternal) they will still              * be allowed to store their document. However the next document that UserA attempts to store              * will be forbidden by validateXmlInternal and so the security transgression whilst not ideal              * is short-lived.              *               * To fix the issue we need to refactor validateXMLInternal and move any document/database/collection              * modification code into storeXMLInternal after the commented out permissions checks below.              *               * Noted by Adam Retter 2012-02-01T19:18              */
comment|/*             if(info.isCreating()) {                 // create                 *                  if(!getPermissionsNoLock().validate(broker.getCurrentSubject(), Permission.WRITE)) {                     throw new PermissionDeniedException("Permission denied to write collection: " + path);                 }             } else {                 // update                  final Permission oldDocPermissions = info.getOldDocPermissions();                 if(!((oldDocPermissions.getOwner().getId() != broker.getCurrentSubject().getId()) | (oldDocPermissions.validate(broker.getCurrentSubject(), Permission.WRITE)))) {                     throw new PermissionDeniedException("A resource with the same name already exists in the target collection '" + path + "', and you do not have write access on that resource.");                 }             }             */
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"storing document "
operator|+
name|document
operator|.
name|getDocId
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
block|}
comment|//Sanity check
if|if
condition|(
operator|!
name|lockManager
operator|.
name|isDocumentLockedForWrite
argument_list|(
name|document
operator|.
name|getURI
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"document is not locked for write !"
argument_list|)
expr_stmt|;
block|}
name|db
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_STORE_DOC
argument_list|,
name|document
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|parserFn
operator|.
name|accept
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|broker
operator|.
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
name|broker
operator|.
name|flush
argument_list|()
expr_stmt|;
name|broker
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
comment|//broker.checkTree(document);
name|LOG
operator|.
name|debug
argument_list|(
literal|"document stored."
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//This lock has been acquired in validateXMLResourceInternal()
name|info
operator|.
name|getDocumentLock
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|isCreating
argument_list|()
condition|)
block|{
name|info
operator|.
name|getTriggers
argument_list|()
operator|.
name|afterCreateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|StreamListener
name|listener
init|=
name|broker
operator|.
name|getIndexController
argument_list|()
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
name|listener
operator|.
name|endReplaceDocument
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|info
operator|.
name|getTriggers
argument_list|()
operator|.
name|afterUpdateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|db
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyUpdate
argument_list|(
name|document
argument_list|,
operator|(
name|info
operator|.
name|isCreating
argument_list|()
condition|?
name|UpdateListener
operator|.
name|ADD
else|:
name|UpdateListener
operator|.
name|UPDATE
operator|)
argument_list|)
expr_stmt|;
comment|//Is it a collection configuration file ?
specifier|final
name|XmldbURI
name|docName
init|=
name|document
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
comment|//WARNING : there is no reason to lock the collection since setPath() is normally called in a safe way
comment|//TODO: *resolve* URI against CollectionConfigurationManager.CONFIG_COLLECTION_URI
if|if
condition|(
name|getURI
argument_list|()
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|CONFIG_COLLECTION_URI
argument_list|)
operator|&&
name|docName
operator|.
name|endsWith
argument_list|(
name|CollectionConfiguration
operator|.
name|COLLECTION_CONFIG_SUFFIX_URI
argument_list|)
condition|)
block|{
name|broker
operator|.
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
specifier|final
name|CollectionConfigurationManager
name|manager
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|manager
operator|.
name|invalidate
argument_list|(
name|getURI
argument_list|()
argument_list|,
name|broker
operator|.
name|getBrokerPool
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|loadConfiguration
argument_list|(
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|LockException
name|pde
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|pde
operator|.
name|getMessage
argument_list|()
argument_list|,
name|pde
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
specifier|final
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
comment|// DIZ: should this exception really been thrown? bugid=1807744
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Error while reading new collection configuration: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|String
name|data
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
return|return
name|validateXMLResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|CollectionConfiguration
name|colconf
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
specifier|final
name|XMLReader
name|reader
init|=
name|getReader
argument_list|(
name|broker
argument_list|,
literal|true
argument_list|,
name|colconf
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|validateXMLResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
name|colconf
argument_list|,
name|source
argument_list|,
name|reader
argument_list|)
return|;
block|}
finally|finally
block|{
name|releaseReader
argument_list|(
name|broker
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|,
specifier|final
name|XMLReader
name|reader
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|CollectionConfiguration
name|colconf
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
name|validateXMLResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
name|colconf
argument_list|,
name|source
argument_list|,
name|reader
argument_list|)
return|;
block|}
specifier|private
name|IndexInfo
name|validateXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|CollectionConfiguration
name|colconf
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|,
specifier|final
name|XMLReader
name|reader
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
return|return
name|validateXMLResourceInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
name|colconf
argument_list|,
parameter_list|(
name|info
parameter_list|)
lambda|->
block|{
name|info
operator|.
name|setReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
comment|/*                  * Note - we must close shield the input source,                  * else it can be closed by the Reader, so subsequently                  * when we try and read it in storeXmlInternal we will get                  * an exception.                  */
specifier|final
name|InputSource
name|closeShieldedInputSource
init|=
name|closeShieldInputSource
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|reader
operator|.
name|parse
argument_list|(
name|closeShieldedInputSource
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"The XML parser reported a problem: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
comment|//stops streams on the input source from being closed
specifier|private
name|InputSource
name|closeShieldInputSource
parameter_list|(
specifier|final
name|InputSource
name|source
parameter_list|)
block|{
specifier|final
name|InputSource
name|protectedInputSource
init|=
operator|new
name|InputSource
argument_list|()
decl_stmt|;
name|protectedInputSource
operator|.
name|setEncoding
argument_list|(
name|source
operator|.
name|getEncoding
argument_list|()
argument_list|)
expr_stmt|;
name|protectedInputSource
operator|.
name|setSystemId
argument_list|(
name|source
operator|.
name|getSystemId
argument_list|()
argument_list|)
expr_stmt|;
name|protectedInputSource
operator|.
name|setPublicId
argument_list|(
name|source
operator|.
name|getPublicId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|getByteStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//TODO consider AutoCloseInputStream
specifier|final
name|InputStream
name|closeShieldByteStream
init|=
operator|new
name|CloseShieldInputStream
argument_list|(
name|source
operator|.
name|getByteStream
argument_list|()
argument_list|)
decl_stmt|;
name|protectedInputSource
operator|.
name|setByteStream
argument_list|(
name|closeShieldByteStream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|.
name|getCharacterStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//TODO consider AutoCloseReader
specifier|final
name|Reader
name|closeShieldReader
init|=
operator|new
name|CloseShieldReader
argument_list|(
name|source
operator|.
name|getCharacterStream
argument_list|()
argument_list|)
decl_stmt|;
name|protectedInputSource
operator|.
name|setCharacterStream
argument_list|(
name|closeShieldReader
argument_list|)
expr_stmt|;
block|}
return|return
name|protectedInputSource
return|;
block|}
specifier|private
specifier|static
class|class
name|CloseShieldReader
extends|extends
name|Reader
block|{
specifier|private
specifier|final
name|Reader
name|reader
decl_stmt|;
specifier|public
name|CloseShieldReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|char
index|[]
name|cbuf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|read
argument_list|(
name|cbuf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|//do nothing as we are close shield
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|Node
name|node
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
return|return
name|validateXMLResourceInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
name|getConfiguration
argument_list|(
name|broker
argument_list|)
argument_list|,
parameter_list|(
name|info
parameter_list|)
lambda|->
block|{
name|info
operator|.
name|setDOMStreamer
argument_list|(
operator|new
name|DOMStreamer
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|getDOMStreamer
argument_list|()
operator|.
name|serialize
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
argument_list|)
return|;
block|}
comment|/**       * Validates an XML document et prepares it for further storage. Launches prepare and postValidate triggers.      * Since the process is dependant from the collection configuration, the collection acquires a write lock during      * the process.      *      * @param transaction The database transaction      * @param broker      The database broker      * @param name        the name (without path) of the document      * @param validator   A function which validates the document of throws an Exception      *       * @return An {@link IndexInfo} with a write lock on the document.      */
specifier|private
name|IndexInfo
name|validateXMLResourceInternal
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|CollectionConfiguration
name|config
parameter_list|,
specifier|final
name|Consumer2E
argument_list|<
name|IndexInfo
argument_list|,
name|SAXException
argument_list|,
name|EXistException
argument_list|>
name|validator
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
comment|//Make the necessary operations if we process a collection configuration document
name|checkConfigurationDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|)
expr_stmt|;
specifier|final
name|Database
name|db
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
decl_stmt|;
if|if
condition|(
name|db
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Database is read-only"
argument_list|)
throw|;
block|}
name|ManagedDocumentLock
name|documentWriteLock
init|=
literal|null
decl_stmt|;
name|DocumentImpl
name|oldDoc
init|=
literal|null
decl_stmt|;
name|db
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_VALIDATE_DOC
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
comment|// acquire the WRITE_LOCK on the Document, this lock is released in storeXMLInternal via IndexInfo
name|documentWriteLock
operator|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|oldDoc
operator|=
name|documents
operator|.
name|get
argument_list|(
name|name
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
expr_stmt|;
name|checkPermissionsForAddDocument
argument_list|(
name|broker
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
comment|// NOTE: the new `document` object actually gets discarded in favour of the `oldDoc` below if there is an oldDoc and it is XML (so we can use -1 as the docId because it will never be used)
specifier|final
name|int
name|docId
init|=
operator|(
name|oldDoc
operator|!=
literal|null
operator|&&
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
operator|)
condition|?
operator|-
literal|1
else|:
name|broker
operator|.
name|getNextResourceId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
name|DocumentImpl
name|document
init|=
operator|new
name|DocumentImpl
argument_list|(
operator|(
name|BrokerPool
operator|)
name|db
argument_list|,
name|this
argument_list|,
name|docId
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|checkCollectionConflict
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|manageDocumentInformation
argument_list|(
name|oldDoc
argument_list|,
name|document
argument_list|)
expr_stmt|;
specifier|final
name|Indexer
name|indexer
init|=
operator|new
name|Indexer
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|)
decl_stmt|;
specifier|final
name|IndexInfo
name|info
init|=
operator|new
name|IndexInfo
argument_list|(
name|indexer
argument_list|,
name|config
argument_list|,
name|documentWriteLock
argument_list|)
decl_stmt|;
name|info
operator|.
name|setCreating
argument_list|(
name|oldDoc
operator|==
literal|null
argument_list|)
expr_stmt|;
name|info
operator|.
name|setOldDocPermissions
argument_list|(
name|oldDoc
operator|!=
literal|null
condition|?
name|oldDoc
operator|.
name|getPermissions
argument_list|()
else|:
literal|null
argument_list|)
expr_stmt|;
name|indexer
operator|.
name|setDocument
argument_list|(
name|document
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|indexer
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|DocumentTriggers
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|indexer
argument_list|,
name|this
argument_list|,
name|broker
operator|.
name|isTriggersEnabled
argument_list|()
condition|?
name|config
else|:
literal|null
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|info
operator|.
name|setTriggers
argument_list|(
name|trigger
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
name|trigger
operator|.
name|beforeCreateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trigger
operator|.
name|beforeUpdateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning document "
operator|+
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|validator
operator|.
name|accept
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// new document is valid: remove old document
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|updateModificationTime
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/**                      * Matching {@link StreamListener#endReplaceDocument(Txn)} call is in                      * {@link #storeXMLInternal(Txn, DBBroker, IndexInfo, Consumer2E)}                      */
specifier|final
name|StreamListener
name|listener
init|=
name|broker
operator|.
name|getIndexController
argument_list|()
operator|.
name|getStreamListener
argument_list|(
name|document
argument_list|,
name|StreamListener
operator|.
name|ReindexMode
operator|.
name|REPLACE_DOCUMENT
argument_list|)
decl_stmt|;
name|listener
operator|.
name|startReplaceDocument
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
comment|//TODO : use a more elaborated method ? No triggers...
name|broker
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|oldDoc
argument_list|)
expr_stmt|;
name|documents
operator|.
name|remove
argument_list|(
name|oldDoc
operator|.
name|getFileURI
argument_list|()
operator|.
name|lastSegmentString
argument_list|()
argument_list|)
expr_stmt|;
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//TODO : use a more elaborated method ? No triggers...
name|broker
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|oldDoc
operator|.
name|copyOf
argument_list|(
name|broker
argument_list|,
name|document
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|indexer
operator|.
name|setDocumentObject
argument_list|(
name|oldDoc
argument_list|)
expr_stmt|;
comment|//old has become new at this point
name|document
operator|=
name|oldDoc
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removed old document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|trigger
operator|.
name|setValidating
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
decl||
name|PermissionDeniedException
decl||
name|SAXException
decl||
name|LockException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|// if there is an exception and we hold the document WRITE_LOCK we must release it
if|if
condition|(
name|documentWriteLock
operator|!=
literal|null
condition|)
block|{
name|documentWriteLock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|db
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkConfigurationDocument
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|docUri
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
comment|//Is it a collection configuration file ?
comment|//TODO : use XmldbURI.resolve() !
if|if
condition|(
operator|!
name|getURI
argument_list|()
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|CONFIG_COLLECTION_URI
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|docUri
operator|.
name|endsWith
argument_list|(
name|CollectionConfiguration
operator|.
name|COLLECTION_CONFIG_SUFFIX_URI
argument_list|)
condition|)
block|{
return|return;
block|}
comment|//Allow just one configuration document per collection
comment|//TODO : do not throw the exception if a system property allows several ones -pb
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|iterator
argument_list|(
name|broker
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|confDoc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|currentConfDocName
init|=
name|confDoc
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentConfDocName
operator|!=
literal|null
operator|&&
operator|!
name|currentConfDocName
operator|.
name|equals
argument_list|(
name|docUri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Could not store configuration '"
operator|+
name|docUri
operator|+
literal|"': A configuration document with a different name ("
operator|+
name|currentConfDocName
operator|+
literal|") already exists in this collection ("
operator|+
name|getURI
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|//broker.saveCollection(transaction, this);
comment|//CollectionConfigurationManager confMgr = broker.getBrokerPool().getConfigurationManager();
comment|//if(confMgr != null)
comment|//try {
comment|//confMgr.reload(broker, this);
comment|// catch (CollectionConfigurationException e) {
comment|//throw new EXistException("An error occurred while reloading the updated collection configuration: " + e.getMessage(), e);
comment|//}
block|}
comment|/**      * If an old document exists, keep information about  the document.      *      * @param oldDoc The old document      * @param document The current/new document      */
specifier|private
name|void
name|manageDocumentInformation
parameter_list|(
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
specifier|final
name|DocumentMetadata
name|metadata
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|=
name|oldDoc
operator|.
name|getMetadata
argument_list|()
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|oldDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getCreated
argument_list|()
argument_list|)
expr_stmt|;
name|document
operator|.
name|setPermissions
argument_list|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|=
operator|new
name|DocumentMetadata
argument_list|()
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|document
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/**       * Update the modification time of a document       *       * @param document The document whose modification time should be updated       */
specifier|private
name|void
name|updateModificationTime
parameter_list|(
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
specifier|final
name|DocumentMetadata
name|metadata
init|=
name|document
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setLastModified
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|document
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check Permissions about user and document when a document is added to the database,      * and throw exceptions if necessary.      *      * @param broker The database broker      * @param oldDoc old Document existing in database prior to adding a new one with same name, or null if none exists      */
specifier|private
name|void
name|checkPermissionsForAddDocument
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
comment|// do we have execute permission on the collection?
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Execute permission is not granted on the Collection."
argument_list|)
throw|;
block|}
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
comment|/* update document */
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found old doc "
operator|+
name|oldDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if the document is locked by another user
specifier|final
name|Account
name|lockUser
init|=
name|oldDoc
operator|.
name|getUserLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lockUser
operator|!=
literal|null
operator|&&
operator|!
name|lockUser
operator|.
name|equals
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"The document is locked by user '"
operator|+
name|lockUser
operator|.
name|getName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// do we have write permission on the old document or are we the owner of the old document?
if|if
condition|(
operator|!
operator|(
operator|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|getOwner
argument_list|()
operator|.
name|getId
argument_list|()
operator|==
name|broker
operator|.
name|getCurrentSubject
argument_list|()
operator|.
name|getId
argument_list|()
operator|)
operator|||
operator|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource with the same name already exists in the target collection '"
operator|+
name|path
operator|+
literal|"', and you do not have write access on that resource."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|/* create document */
if|if
condition|(
operator|!
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Write permission is not granted on the Collection."
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|checkCollectionConflict
parameter_list|(
specifier|final
name|XmldbURI
name|docUri
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
block|{
if|if
condition|(
name|subCollections
operator|.
name|contains
argument_list|(
name|docUri
operator|.
name|lastSegment
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"The collection '"
operator|+
name|getURI
argument_list|()
operator|+
literal|"' already has a sub-collection named '"
operator|+
name|docUri
operator|.
name|lastSegment
argument_list|()
operator|+
literal|"', you cannot create a Document with the same name as an existing collection."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|mimeType
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|,
specifier|final
name|Date
name|created
parameter_list|,
specifier|final
name|Date
name|modified
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
operator|new
name|FastByteArrayInputStream
argument_list|(
name|data
argument_list|)
argument_list|,
name|mimeType
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|created
argument_list|,
name|modified
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|,
specifier|final
name|long
name|size
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|name
argument_list|,
name|is
argument_list|,
name|mimeType
argument_list|,
name|size
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|Date
name|created
parameter_list|,
specifier|final
name|Date
name|modified
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
specifier|final
name|Database
name|db
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
decl_stmt|;
if|if
condition|(
name|db
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Database is read-only"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|uri
init|=
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|name
operator|.
name|lastSegment
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|;
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|uri
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|getDocument
argument_list|(
name|broker
argument_list|,
name|name
argument_list|)
decl_stmt|;
specifier|final
name|int
name|docId
init|=
name|broker
operator|.
name|getNextResourceId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
specifier|final
name|BinaryDocument
name|blob
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|blob
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|docId
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blob
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
argument_list|,
name|this
argument_list|,
name|docId
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|addBinaryResource
argument_list|(
name|db
argument_list|,
name|transaction
argument_list|,
name|broker
argument_list|,
name|blob
argument_list|,
name|is
argument_list|,
name|mimeType
argument_list|,
name|size
argument_list|,
name|created
argument_list|,
name|modified
argument_list|,
name|DBBroker
operator|.
name|PreserveType
operator|.
name|DEFAULT
argument_list|,
name|oldDoc
argument_list|,
name|collectionLock
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|validateBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
try|try
block|{
specifier|final
name|int
name|docId
init|=
name|broker
operator|.
name|getNextResourceId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
return|return
operator|new
name|BinaryDocument
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
argument_list|,
name|this
argument_list|,
name|docId
argument_list|,
name|name
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|Date
name|created
parameter_list|,
specifier|final
name|Date
name|modified
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|blob
argument_list|,
name|is
argument_list|,
name|mimeType
argument_list|,
name|size
argument_list|,
name|created
argument_list|,
name|modified
argument_list|,
name|DBBroker
operator|.
name|PreserveType
operator|.
name|DEFAULT
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|Date
name|created
parameter_list|,
specifier|final
name|Date
name|modified
parameter_list|,
specifier|final
name|DBBroker
operator|.
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
specifier|final
name|Database
name|db
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
decl_stmt|;
if|if
condition|(
name|db
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Database is read-only"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|docUri
init|=
name|blob
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|;
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|blob
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|getDocument
argument_list|(
name|broker
argument_list|,
name|docUri
argument_list|)
decl_stmt|;
return|return
name|addBinaryResource
argument_list|(
name|db
argument_list|,
name|transaction
argument_list|,
name|broker
argument_list|,
name|blob
argument_list|,
name|is
argument_list|,
name|mimeType
argument_list|,
name|size
argument_list|,
name|created
argument_list|,
name|modified
argument_list|,
name|preserve
argument_list|,
name|oldDoc
argument_list|,
name|collectionLock
argument_list|)
return|;
block|}
block|}
specifier|private
name|BinaryDocument
name|addBinaryResource
parameter_list|(
specifier|final
name|Database
name|db
parameter_list|,
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|,
specifier|final
name|String
name|mimeType
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|Date
name|created
parameter_list|,
specifier|final
name|Date
name|modified
parameter_list|,
specifier|final
name|DBBroker
operator|.
name|PreserveType
name|preserve
parameter_list|,
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
specifier|final
name|ManagedCollectionLock
name|collectionLock
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
specifier|final
name|DocumentTriggers
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|broker
operator|.
name|isTriggersEnabled
argument_list|()
condition|?
name|getConfiguration
argument_list|(
name|broker
argument_list|)
else|:
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|XmldbURI
name|docUri
init|=
name|blob
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
try|try
block|{
name|db
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_STORE_BINARY
argument_list|,
name|docUri
argument_list|)
expr_stmt|;
name|checkPermissionsForAddDocument
argument_list|(
name|broker
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|checkCollectionConflict
argument_list|(
name|docUri
argument_list|)
expr_stmt|;
comment|//manageDocumentInformation(oldDoc, blob);
if|if
condition|(
operator|!
name|broker
operator|.
name|preserveOnCopy
argument_list|(
name|preserve
argument_list|)
condition|)
block|{
name|blob
operator|.
name|copyOf
argument_list|(
name|broker
argument_list|,
name|blob
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blob
operator|.
name|getMetadata
argument_list|()
operator|==
literal|null
condition|)
block|{
name|blob
operator|.
name|setMetadata
argument_list|(
operator|new
name|DocumentMetadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentMetadata
name|metadata
init|=
name|blob
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setMimeType
argument_list|(
name|mimeType
operator|==
literal|null
condition|?
name|MimeType
operator|.
name|BINARY_TYPE
operator|.
name|getName
argument_list|()
else|:
name|mimeType
argument_list|)
expr_stmt|;
if|if
condition|(
name|created
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|setCreated
argument_list|(
name|created
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modified
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|setLastModified
argument_list|(
name|modified
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blob
operator|.
name|setContentLength
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
name|trigger
operator|.
name|beforeCreateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trigger
operator|.
name|beforeUpdateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old document db entry"
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|broker
operator|.
name|preserveOnCopy
argument_list|(
name|preserve
argument_list|)
condition|)
block|{
name|updateModificationTime
argument_list|(
name|blob
argument_list|)
expr_stmt|;
block|}
comment|// remove the old document
name|broker
operator|.
name|removeResource
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
comment|// store the binary content (create/replace)
name|broker
operator|.
name|storeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|blob
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
specifier|final
name|IndexController
name|indexController
init|=
name|broker
operator|.
name|getIndexController
argument_list|()
decl_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|(
name|blob
argument_list|,
name|StreamListener
operator|.
name|ReindexMode
operator|.
name|STORE
argument_list|)
decl_stmt|;
name|indexController
operator|.
name|startIndexDocument
argument_list|(
name|transaction
argument_list|,
name|listener
argument_list|)
expr_stmt|;
try|try
block|{
name|broker
operator|.
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|indexController
operator|.
name|endIndexDocument
argument_list|(
name|transaction
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
name|trigger
operator|.
name|afterCreateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trigger
operator|.
name|afterUpdateDocument
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collectionLock
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|blob
return|;
block|}
finally|finally
block|{
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPermissions
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|int
name|mode
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|path
argument_list|)
init|)
block|{
name|PermissionFactory
operator|.
name|chmod
argument_list|(
name|broker
argument_list|,
name|this
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|mode
argument_list|)
argument_list|,
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|CollectionConfiguration
name|getConfiguration
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
block|{
specifier|final
name|CollectionConfigurationManager
name|manager
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//Attempt to get configuration
return|return
name|manager
operator|.
name|getConfiguration
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setCreationTime
parameter_list|(
specifier|final
name|long
name|ms
parameter_list|)
block|{
name|created
operator|=
name|ms
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getCreationTime
parameter_list|()
block|{
return|return
name|created
return|;
block|}
comment|/**       * Get XML Reader from ReaderPool and setup validation when needed.      *      * @param broker The database broker      * @param validation true if validation should be enabled      * @param collectionConf The configuration of the Collection      *      * @return An XML Reader      */
specifier|private
name|XMLReader
name|getReader
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|boolean
name|validation
parameter_list|,
specifier|final
name|CollectionConfiguration
name|collectionConf
parameter_list|)
block|{
comment|// Get reader from readerpool.
specifier|final
name|XMLReader
name|reader
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getParserPool
argument_list|()
operator|.
name|borrowXMLReader
argument_list|()
decl_stmt|;
comment|// If Collection configuration exists (try to) get validation mode
comment|// and setup reader with this information.
if|if
condition|(
operator|!
name|validation
condition|)
block|{
name|XMLReaderObjectFactory
operator|.
name|setReaderValidationMode
argument_list|(
name|XMLReaderObjectFactory
operator|.
name|VALIDATION_SETTING
operator|.
name|DISABLED
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|collectionConf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|VALIDATION_SETTING
name|mode
init|=
name|collectionConf
operator|.
name|getValidationMode
argument_list|()
decl_stmt|;
name|XMLReaderObjectFactory
operator|.
name|setReaderValidationMode
argument_list|(
name|mode
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
comment|// Return configured reader.
return|return
name|reader
return|;
block|}
comment|/**      * Reset validation mode of reader and return reader to reader pool.      *      * @param broker The database broker      * @param reader The XML Reader to release      */
specifier|private
name|void
name|releaseReader
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|XMLReader
name|reader
parameter_list|)
block|{
comment|// Get validation mode from static configuration
specifier|final
name|Configuration
name|config
init|=
name|broker
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|String
name|optionValue
init|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|XMLReaderObjectFactory
operator|.
name|PROPERTY_VALIDATION_MODE
argument_list|)
decl_stmt|;
specifier|final
name|VALIDATION_SETTING
name|validationMode
init|=
name|XMLReaderObjectFactory
operator|.
name|convertValidationMode
argument_list|(
name|optionValue
argument_list|)
decl_stmt|;
comment|// Restore default validation mode
name|XMLReaderObjectFactory
operator|.
name|setReaderValidationMode
argument_list|(
name|validationMode
argument_list|,
name|reader
argument_list|)
expr_stmt|;
comment|// Return reader
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getParserPool
argument_list|()
operator|.
name|returnXMLReader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|)
block|{
specifier|final
name|CollectionConfiguration
name|conf
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
comment|//If the collection has its own config...
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
return|return
name|broker
operator|.
name|getIndexConfiguration
argument_list|()
return|;
block|}
comment|//... otherwise return the general config (the broker's one)
return|return
name|conf
operator|.
name|getIndexConfiguration
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|GeneralRangeIndexSpec
name|getIndexByPathConfiguration
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|NodePath
name|nodePath
parameter_list|)
block|{
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
operator|(
name|idxSpec
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|nodePath
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QNameRangeIndexSpec
name|getIndexByQNameConfiguration
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|QName
name|nodeName
parameter_list|)
block|{
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
operator|(
name|idxSpec
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|nodeName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|Iterator
argument_list|<
name|String
argument_list|>
name|documentNameIterator
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|path
argument_list|)
init|)
block|{
name|documentNameIterator
operator|=
name|documents
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|documentNameIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|documentNameIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|documentNameIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

