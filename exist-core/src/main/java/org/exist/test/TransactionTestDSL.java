begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database  * Copyright (C) 2001-2017 The eXist Project  * http://exist-db.org  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|test
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|Either
import|;
end_import

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|function
operator|.
name|QuadFunction7E
import|;
end_import

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|NewArrayNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|test
operator|.
name|TransactionTestDSL
operator|.
name|BiTransactionScheduleBuilder
operator|.
name|BiTransactionScheduleBuilderOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|test
operator|.
name|TransactionTestDSL
operator|.
name|TransactionScheduleBuilder
operator|.
name|NilOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQuery
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|Either
operator|.
name|Left
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|Either
operator|.
name|Right
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
operator|.
name|XML_FILE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ThreadUtils
operator|.
name|nameInstanceThread
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ThreadUtils
operator|.
name|newInstanceSubThreadGroup
import|;
end_import

begin_comment
comment|/**  * A DSL for describing a schedule of  * transaction operations upon the database.  *  * A type-safe builder pattern is provided  * for constructing the schedule. Once  * the schedule is build a scheduler  * can execute it upon the database  * and return the results.  *  * The DSL uses recursive types  * in a similar way to a typed heterogeneous  * list (such as Shapeless's HList) to ensure  * that the each operation in the schedule  * receives the correct input type, i.e.  * the output type of the previous operation.  * At the cost of complexity in implementing  * the DSL, the recursive typing makes use of  * the DSL by the user much simpler and safer.  *  * The recursive type implementation was  * inspired by<a href="https://apocalisp.wordpress.com/2008/10/23/heterogeneous-lists-and-the-limits-of-the-java-type-system/">https://apocalisp.wordpress.com/2008/10/23/heterogeneous-lists-and-the-limits-of-the-java-type-system/</a>.  *  * Example usage for creating a schedule of  * two transactions, where each will execute in  * its own thread but operationally linear  * according to the schedule:  *  *<pre>{@code  *  * import static org.exist.test.TransactionTestDSL.TransactionOperation.*;  * import static org.exist.test.TransactionTestDSL.TransactionScheduleBuilder.biSchedule;  *  * @Test  * public void getDocuments() throws ExecutionException, InterruptedException {  *   final String documentUri = "/db/test/hamlet.xml";  *  *   final Tuple2<DocumentImpl, DocumentImpl> result = biSchedule()  *       .firstT1(getDocument(documentUri))  *                                            .andThenT2(getDocument(documentUri))  *       .andThenT1(commit())  *                                            .andThenT2(commit())  *       .build()  *   .execute(existEmbeddedServer.getBrokerPool());  *  *   assertNotNull(result);  *   assertNotNull(result._1);  *   assertNotNull(result._2);  *  *   assertEquals(documentUri, result._1.getURI().getCollectionPath());  *   assertEquals(documentUri, result._2.getURI().getCollectionPath());  * }  *  * }</pre>  *  * @author<a href="mailto:adam@evolvedbinary.com">Adam Retter</a>  */
end_comment

begin_interface
specifier|public
interface|interface
name|TransactionTestDSL
block|{
comment|/**      * A Transaction Schedule builder.      *      * Enables us to build a schedule of operations to be executed      * within one or more transactions.      *      * @param<A> A recursive type, holds the type of the previously scheduled      *           operation(s).      */
interface|interface
name|TransactionScheduleBuilder
parameter_list|<
name|A
extends|extends
name|TransactionScheduleBuilder
parameter_list|<
name|A
parameter_list|>
parameter_list|>
block|{
name|NilOperation
name|nilOperation
init|=
operator|new
name|NilOperation
argument_list|()
decl_stmt|;
specifier|static
name|NilOperation
name|nil
parameter_list|()
block|{
return|return
name|nilOperation
return|;
block|}
specifier|final
class|class
name|NilOperation
implements|implements
name|TransactionScheduleBuilder
argument_list|<
name|NilOperation
argument_list|>
block|{
specifier|private
name|NilOperation
parameter_list|()
block|{
block|}
block|}
comment|/**          * Creates a Schedule Builder factory for two transactions T1 and T2.          *          * @return a Schedule Builder factory for two transactions          */
specifier|static
name|BiTransactionScheduleBuilderFactory
name|biSchedule
parameter_list|()
block|{
return|return
name|BiTransactionScheduleBuilderFactory
operator|.
name|getInstance
argument_list|()
return|;
block|}
block|}
comment|/**      * A schedule builder factory for two transactions T1 and T2.      *      * Responsible for creating a Schedule Builder which is initialized      * to the first transaction state.      */
class|class
name|BiTransactionScheduleBuilderFactory
block|{
specifier|private
specifier|static
specifier|final
name|BiTransactionScheduleBuilderFactory
name|INSTANCE
init|=
operator|new
name|BiTransactionScheduleBuilderFactory
argument_list|()
decl_stmt|;
specifier|private
name|BiTransactionScheduleBuilderFactory
parameter_list|()
block|{
block|}
specifier|private
specifier|static
name|BiTransactionScheduleBuilderFactory
name|getInstance
parameter_list|()
block|{
return|return
name|INSTANCE
return|;
block|}
comment|/**          * Constructs a Schedule Builder for two transactions T1 and T2,          * whose first schedule is an operation with T1.          *          * @param<U> The state returned by the first operation with T1.          *          * @param stateTransform The initial state for T1.          *          * @return the schedule builder.          */
specifier|public
parameter_list|<
name|U
parameter_list|>
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|Void
argument_list|,
name|U
argument_list|,
name|Void
argument_list|,
name|Void
argument_list|,
name|NilOperation
argument_list|>
name|firstT1
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|Void
argument_list|,
name|U
argument_list|>
name|stateTransform
parameter_list|)
block|{
return|return
name|BiTransactionScheduleBuilderOperation
operator|.
name|first
argument_list|(
name|Left
argument_list|(
name|stateTransform
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Constructs a Schedule Builder for two transactions T1 and T2,          * whose first schedule is an operation with T2.          *          * @param<U> The state returned by the first operation with T2.          *          * @param stateTransform The initial state for T2.          *          * @return the schedule builder.          */
specifier|public
parameter_list|<
name|U
parameter_list|>
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|Void
argument_list|,
name|Void
argument_list|,
name|Void
argument_list|,
name|U
argument_list|,
name|NilOperation
argument_list|>
name|firstT2
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|Void
argument_list|,
name|U
argument_list|>
name|stateTransform
parameter_list|)
block|{
return|return
name|BiTransactionScheduleBuilderOperation
operator|.
name|first
argument_list|(
name|Right
argument_list|(
name|stateTransform
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * A Schedule for two transactions T1 and T2.      *      * @param<A> A recursive type, holds the type of the previously scheduled      *           operation(s).      */
specifier|abstract
class|class
name|BiTransactionScheduleBuilder
parameter_list|<
name|A
extends|extends
name|TransactionScheduleBuilder
parameter_list|<
name|A
parameter_list|>
parameter_list|>
implements|implements
name|TransactionScheduleBuilder
argument_list|<
name|A
argument_list|>
block|{
comment|/**          * Describes a scheduled operation on transaction T1 and/or T2.          *          * @param<T1> The type of the state held for T1 before the          *            operation has executed          * @param<U1> The type of the state held for T1 after the          *            operation has executed          * @param<T2> The type of the state held for T2 before the          *            operation has executed          * @param<U2> The type of the state held for T2 after the          *            operation has executed          *          * @param<B> A recursive type, holds the type of the previously scheduled          *           operation(s).          */
specifier|public
specifier|static
class|class
name|BiTransactionScheduleBuilderOperation
parameter_list|<
name|T1
parameter_list|,
name|U1
parameter_list|,
name|T2
parameter_list|,
name|U2
parameter_list|,
name|B
extends|extends
name|TransactionScheduleBuilder
parameter_list|<
name|B
parameter_list|>
parameter_list|>
extends|extends
name|BiTransactionScheduleBuilder
argument_list|<
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
argument_list|>
block|{
comment|// was this created by a transformation on T1 (if not then T2)
specifier|private
specifier|final
name|boolean
name|operationOnT1
decl_stmt|;
comment|// the previous schedule builder operation
specifier|private
specifier|final
name|B
name|previous
decl_stmt|;
comment|// transformations on the transactions
specifier|private
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
name|t1_state
decl_stmt|;
specifier|private
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
name|t2_state
decl_stmt|;
comment|// latches, used to switch scheduling between t1 and t2
specifier|private
specifier|final
name|NamedCountDownLatch
name|t1WaitLatch
decl_stmt|;
specifier|private
specifier|final
name|NamedCountDownLatch
name|t2WaitLatch
decl_stmt|;
comment|// just a counter to help us name our latches for debugging
specifier|private
specifier|static
name|int
name|countDownLatchNum
init|=
literal|0
decl_stmt|;
comment|/**              * Constructs an initial schedule builder.              *              * @param<T1> The type of the state held for T1 before the              *<pre>operation</pre> has executed              * @param<U1> The type of the state held for T1 after the              *<pre>operation</pre> has executed              * @param<T2> The type of the state held for T2 before the              *<pre>operation</pre> has executed              * @param<U2> The type of the state held for T2 after the              *<pre>operation</pre> has executed              *              * @param operation An operation on either Transaction T1 or T2              *              * @return the builder              */
specifier|public
specifier|static
parameter_list|<
name|T1
parameter_list|,
name|U1
parameter_list|,
name|T2
parameter_list|,
name|U2
parameter_list|>
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|NilOperation
argument_list|>
name|first
parameter_list|(
specifier|final
name|Either
argument_list|<
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
argument_list|,
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
argument_list|>
name|operation
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|.
name|isLeft
argument_list|()
condition|)
block|{
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|T1
argument_list|>
name|initial_t1_state
init|=
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t1
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Initialized T1: Starting schedule execution with T1..."
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
decl_stmt|;
comment|// as we start with t1, we add a function that pauses t2, awaiting countdown latch signalled from t1
specifier|final
name|NamedCountDownLatch
name|t2WaitForT1
init|=
operator|new
name|NamedCountDownLatch
argument_list|(
literal|"t2WaitForT1-"
operator|+
operator|(
operator|++
name|countDownLatchNum
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
name|initial_t2_state
init|=
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t2
parameter_list|)
lambda|->
block|{
comment|// instruct t2 to wait
name|listener
operator|.
name|event
argument_list|(
literal|"Initialized T2: Instructing T2 to wait for T1 ("
operator|+
name|t2WaitForT1
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t2WaitForT1
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
decl_stmt|;
return|return
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|true
argument_list|,
name|TransactionScheduleBuilder
operator|.
name|nil
argument_list|()
argument_list|,
name|initial_t1_state
operator|.
name|andThen
argument_list|(
name|operation
operator|.
name|left
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|initial_t2_state
argument_list|,
literal|null
argument_list|,
name|t2WaitForT1
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|T2
argument_list|>
name|initial_t2_state
init|=
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t2
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Initialized T2: Starting schedule execution with T2..."
argument_list|)
expr_stmt|;
return|return
name|t2
return|;
block|}
decl_stmt|;
comment|// as we start with t2, we add a function that pauses t1, awaiting countdown latch signalled from t2
specifier|final
name|NamedCountDownLatch
name|t1WaitForT2
init|=
operator|new
name|NamedCountDownLatch
argument_list|(
literal|"t1WaitForT2-"
operator|+
operator|(
operator|++
name|countDownLatchNum
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
name|initial_t1_state
init|=
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t1
parameter_list|)
lambda|->
block|{
comment|// instruct t1 to wait
name|listener
operator|.
name|event
argument_list|(
literal|"Initialized T1: Instructing T1 to wait for T2 ("
operator|+
name|t1WaitForT2
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t1WaitForT2
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
decl_stmt|;
return|return
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|TransactionScheduleBuilder
operator|.
name|nil
argument_list|()
argument_list|,
name|initial_t1_state
argument_list|,
name|initial_t2_state
operator|.
name|andThen
argument_list|(
name|operation
operator|.
name|right
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|t1WaitForT2
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
specifier|private
name|BiTransactionScheduleBuilderOperation
parameter_list|(
specifier|final
name|boolean
name|operationOnT1
parameter_list|,
specifier|final
name|B
name|previous
parameter_list|,
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
name|t1_state
parameter_list|,
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
name|t2_state
parameter_list|)
block|{
name|this
argument_list|(
name|operationOnT1
argument_list|,
name|previous
argument_list|,
name|t1_state
argument_list|,
name|t2_state
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|BiTransactionScheduleBuilderOperation
parameter_list|(
specifier|final
name|boolean
name|operationOnT1
parameter_list|,
specifier|final
name|B
name|previous
parameter_list|,
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
name|t1_state
parameter_list|,
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
name|t2_state
parameter_list|,
specifier|final
name|NamedCountDownLatch
name|t1WaitLatch
parameter_list|,
specifier|final
name|NamedCountDownLatch
name|t2WaitLatch
parameter_list|)
block|{
name|this
operator|.
name|operationOnT1
operator|=
name|operationOnT1
expr_stmt|;
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
name|this
operator|.
name|t1_state
operator|=
name|t1_state
expr_stmt|;
name|this
operator|.
name|t2_state
operator|=
name|t2_state
expr_stmt|;
name|this
operator|.
name|t1WaitLatch
operator|=
name|t1WaitLatch
expr_stmt|;
name|this
operator|.
name|t2WaitLatch
operator|=
name|t2WaitLatch
expr_stmt|;
block|}
comment|/**              * Utility getter to access the previous state.              *              * @return The previous schedule builder operation, or null              *  if there was no previous operation.              */
specifier|public
name|B
name|previous
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
comment|/**              * Schedules the next operation on Transaction T1.              *              * @param<V1> The type of the state held for T1 after the              *<pre>t1Transformation</pre> has executed              *              * @param t1Transformation An operation to perform with T1              *     on the current state held for T1, which yields a              *     new state of type<pre>V1</pre>              *              * @return the schedule builder.              */
specifier|public
parameter_list|<
name|V1
parameter_list|>
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|V1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
argument_list|>
name|andThenT1
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|U1
argument_list|,
name|V1
argument_list|>
name|t1Transformation
parameter_list|)
block|{
if|if
condition|(
name|operationOnT1
condition|)
block|{
comment|//continue executing t1
return|return
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|true
argument_list|,
name|this
argument_list|,
name|t1_state
operator|.
name|andThen
argument_list|(
name|t1Transformation
argument_list|)
argument_list|,
name|t2_state
argument_list|,
name|t1WaitLatch
argument_list|,
name|t2WaitLatch
argument_list|)
return|;
block|}
else|else
block|{
comment|// switch execution from t2 to t1
comment|// we add a function that pauses t2 awaiting countdown latch signalled from t1
specifier|final
name|NamedCountDownLatch
name|t2WaitForT1
init|=
operator|new
name|NamedCountDownLatch
argument_list|(
literal|"t2WaitForT1-"
operator|+
operator|(
operator|++
name|countDownLatchNum
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
name|next_t2_state
init|=
name|t2_state
operator|.
name|andThen
argument_list|(
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t2
parameter_list|)
lambda|->
block|{
comment|// resume t1, by counting down the latch
if|if
condition|(
name|t1WaitLatch
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Releasing T1 from wait ("
operator|+
name|t1WaitLatch
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t1WaitLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
return|return
name|t2
return|;
block|}
argument_list|)
operator|.
name|andThen
argument_list|(
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t2
parameter_list|)
lambda|->
block|{
comment|// instruct t2 to wait
name|listener
operator|.
name|event
argument_list|(
literal|"Instructing T2 to wait for T1 ("
operator|+
name|t2WaitForT1
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t2WaitForT1
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|t2
return|;
block|}
argument_list|)
decl_stmt|;
return|return
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|true
argument_list|,
name|this
argument_list|,
name|t1_state
operator|.
name|andThen
argument_list|(
name|t1Transformation
argument_list|)
argument_list|,
name|next_t2_state
argument_list|,
name|t1WaitLatch
argument_list|,
name|t2WaitForT1
argument_list|)
return|;
block|}
block|}
comment|/**              * Schedules the next operation on Transaction T2.              *              * @param<V2> The type of the state held for T2 after the              *<pre>t2Transformation</pre> has executed              *              * @param t2Transformation An operation to perform with T2              *     on the current state held for T2, which yields a              *     new state of type<pre>V2</pre>              *              * @return the schedule builder.              */
specifier|public
parameter_list|<
name|V2
parameter_list|>
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|V2
argument_list|,
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
argument_list|>
name|andThenT2
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|U2
argument_list|,
name|V2
argument_list|>
name|t2Transformation
parameter_list|)
block|{
if|if
condition|(
operator|!
name|operationOnT1
condition|)
block|{
comment|//continue executing t2
return|return
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|this
argument_list|,
name|t1_state
argument_list|,
name|t2_state
operator|.
name|andThen
argument_list|(
name|t2Transformation
argument_list|)
argument_list|,
name|t1WaitLatch
argument_list|,
name|t2WaitLatch
argument_list|)
return|;
block|}
else|else
block|{
comment|// switch execution from t1 to t2
comment|// we add a function that pauses t1 awaiting countdown latch signalled from t2
specifier|final
name|NamedCountDownLatch
name|t1WaitForT2
init|=
operator|new
name|NamedCountDownLatch
argument_list|(
literal|"t1WaitForT2-"
operator|+
operator|(
operator|++
name|countDownLatchNum
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
name|next_t1_state
init|=
name|t1_state
operator|.
name|andThen
argument_list|(
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t1
parameter_list|)
lambda|->
block|{
comment|// resume t2, by counting down the latch
if|if
condition|(
name|t2WaitLatch
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Releasing T2 from wait ("
operator|+
name|t2WaitLatch
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t2WaitLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
return|return
name|t1
return|;
block|}
argument_list|)
operator|.
name|andThen
argument_list|(
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t1
parameter_list|)
lambda|->
block|{
comment|// instruct t1 to wait
name|listener
operator|.
name|event
argument_list|(
literal|"Instructing T1 to wait for T2 ("
operator|+
name|t1WaitForT2
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t1WaitForT2
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|t1
return|;
block|}
argument_list|)
decl_stmt|;
return|return
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|this
argument_list|,
name|next_t1_state
argument_list|,
name|t2_state
operator|.
name|andThen
argument_list|(
name|t2Transformation
argument_list|)
argument_list|,
name|t1WaitForT2
argument_list|,
name|t2WaitLatch
argument_list|)
return|;
block|}
block|}
comment|/**              * Constructs the final Transaction Schedule              * from the builder.              *              * @return the transaction schedule.              */
specifier|public
name|BiTransactionSchedule
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
argument_list|>
name|build
parameter_list|()
block|{
comment|// we must compose a final operation to countdown any last remaining latches between t1->t2, or t2->t1 scheduling transitions
specifier|final
name|TransactionOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|>
name|final_t1_state
init|=
name|t1_state
operator|.
name|andThen
argument_list|(
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t1
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|t2WaitLatch
operator|!=
literal|null
operator|&&
name|t2WaitLatch
operator|.
name|getCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Final release of T2 from wait ("
operator|+
name|t2WaitLatch
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t2WaitLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
return|return
name|t1
return|;
block|}
argument_list|)
decl_stmt|;
specifier|final
name|TransactionOperation
argument_list|<
name|T2
argument_list|,
name|U2
argument_list|>
name|final_t2_state
init|=
name|t2_state
operator|.
name|andThen
argument_list|(
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t2
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|t1WaitLatch
operator|!=
literal|null
operator|&&
name|t1WaitLatch
operator|.
name|getCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Final release of T1 from wait ("
operator|+
name|t1WaitLatch
operator|.
name|getName
argument_list|()
operator|+
literal|")..."
argument_list|)
expr_stmt|;
name|t1WaitLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
return|return
name|t2
return|;
block|}
argument_list|)
decl_stmt|;
specifier|final
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
argument_list|>
name|finalOperation
init|=
operator|new
name|BiTransactionScheduleBuilderOperation
argument_list|<>
argument_list|(
literal|false
comment|/* value of this parameter here is not significant */
argument_list|,
name|this
argument_list|,
name|final_t1_state
argument_list|,
name|final_t2_state
argument_list|,
name|t1WaitLatch
argument_list|,
name|t2WaitLatch
argument_list|)
decl_stmt|;
return|return
operator|new
name|BiTransactionSchedule
argument_list|<>
argument_list|(
name|finalOperation
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * A schedule of one or more transactions that may      * be executed upon the database      *      * @param<U> The type of the result from executing the schedule.      */
interface|interface
name|TransactionSchedule
parameter_list|<
name|U
parameter_list|>
block|{
comment|/**          * Execute the schedule on the database.          *          * @param brokerPool The database          *          * @return The result of executing the schedule.          *          * @throws ExecutionException if the execution fails.          * @throws InterruptedException if the execution is interrupted.          */
specifier|default
name|U
name|execute
parameter_list|(
specifier|final
name|BrokerPool
name|brokerPool
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
block|{
return|return
name|execute
argument_list|(
name|brokerPool
argument_list|,
name|NULL_SCHEDULE_LISTENER
argument_list|)
return|;
block|}
comment|/**          * Execute the schedule on the database.          *          * @param brokerPool The database          * @param executionListener A listener which receives execution events.          *          * @return The result of executing the schedule.          *          * @throws ExecutionException if the execution fails.          * @throws InterruptedException if the execution is interrupted.          */
name|U
name|execute
parameter_list|(
specifier|final
name|BrokerPool
name|brokerPool
parameter_list|,
specifier|final
name|ExecutionListener
name|executionListener
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
function_decl|;
block|}
comment|/**      * A schedule of two transactions T1 and T2.      *      * Which are executed concurrently, each in their      * own thread, but linearly according to the schedule.      *      * @param<T1> The initial type of the state held for T1 before the      *             schedule is executed      * @param<U1> The final type of the state held for T1 after the      *             schedule has executed      * @param<T2> The initial type of the state held for T2 before the      *             schedule is executed      * @param<U2> The final type of the state held for T2 after the      *             schedule has executed      *      * @param<B> A recursive type, which enforces the types of all operations which      *           which make up the schedule.      */
class|class
name|BiTransactionSchedule
parameter_list|<
name|T1
parameter_list|,
name|U1
parameter_list|,
name|T2
parameter_list|,
name|U2
parameter_list|,
name|B
extends|extends
name|TransactionScheduleBuilder
parameter_list|<
name|B
parameter_list|>
parameter_list|>
implements|implements
name|TransactionSchedule
argument_list|<
name|Tuple2
argument_list|<
name|U1
argument_list|,
name|U2
argument_list|>
argument_list|>
block|{
specifier|private
specifier|final
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
name|lastOperation
decl_stmt|;
specifier|private
name|BiTransactionSchedule
parameter_list|(
specifier|final
name|BiTransactionScheduleBuilderOperation
argument_list|<
name|T1
argument_list|,
name|U1
argument_list|,
name|T2
argument_list|,
name|U2
argument_list|,
name|B
argument_list|>
name|lastOperation
parameter_list|)
block|{
name|this
operator|.
name|lastOperation
operator|=
name|lastOperation
expr_stmt|;
block|}
comment|// TODO(AR) enable the creation of transactions to be specified in the DSL just like in Granite, so we can show isolation (or not)!
annotation|@
name|Override
specifier|public
name|Tuple2
argument_list|<
name|U1
argument_list|,
name|U2
argument_list|>
name|execute
parameter_list|(
specifier|final
name|BrokerPool
name|brokerPool
parameter_list|,
specifier|final
name|ExecutionListener
name|executionListener
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|brokerPool
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|executionListener
argument_list|)
expr_stmt|;
specifier|final
name|ThreadGroup
name|transactionsThreadGroup
init|=
name|newInstanceSubThreadGroup
argument_list|(
name|brokerPool
argument_list|,
literal|"transactionTestDSL"
argument_list|)
decl_stmt|;
comment|// submit t1
specifier|final
name|ExecutorService
name|t1ExecutorService
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
name|r
lambda|->
operator|new
name|Thread
argument_list|(
name|transactionsThreadGroup
argument_list|,
name|r
argument_list|,
name|nameInstanceThread
argument_list|(
name|brokerPool
argument_list|,
literal|"transaction-test-dsl.transaction-1-schedule"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Future
argument_list|<
name|U1
argument_list|>
name|t1Result
init|=
name|t1ExecutorService
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
init|(
specifier|final
name|DBBroker
name|broker
init|=
name|brokerPool
operator|.
name|get
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
name|brokerPool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
argument_list|)
init|;
specifier|final
name|Txn
name|txn
init|=
name|brokerPool
operator|.
name|getTransactionManager
argument_list|()
operator|.
name|beginTransaction
argument_list|()
init|)
block|{
specifier|final
name|U1
name|result
init|=
name|lastOperation
operator|.
name|t1_state
operator|.
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|executionListener
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|txn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// submit t2
specifier|final
name|ExecutorService
name|t2ExecutorService
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
name|r
lambda|->
operator|new
name|Thread
argument_list|(
name|transactionsThreadGroup
argument_list|,
name|r
argument_list|,
name|nameInstanceThread
argument_list|(
name|brokerPool
argument_list|,
literal|"transaction-test-dsl.transaction-2-schedule"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Future
argument_list|<
name|U2
argument_list|>
name|t2Result
init|=
name|t2ExecutorService
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
init|(
specifier|final
name|DBBroker
name|broker
init|=
name|brokerPool
operator|.
name|get
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
name|brokerPool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
argument_list|)
init|;
specifier|final
name|Txn
name|txn
init|=
name|brokerPool
operator|.
name|getTransactionManager
argument_list|()
operator|.
name|beginTransaction
argument_list|()
init|)
block|{
specifier|final
name|U2
name|result
init|=
name|lastOperation
operator|.
name|t2_state
operator|.
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|executionListener
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|txn
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|U1
name|u1
init|=
literal|null
decl_stmt|;
name|U2
name|u2
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|t1Result
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|u1
operator|=
name|t1Result
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t2Result
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|u2
operator|=
name|t2Result
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t1Result
operator|.
name|isDone
argument_list|()
operator|&&
name|t2Result
operator|.
name|isDone
argument_list|()
condition|)
block|{
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
return|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ExecutionException
decl||
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// if we get to here then t1Result or t2Result has thrown an exception
comment|// force shutdown of transaction threads
name|t2ExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|t1ExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
comment|//TODO(AR) rather than working with exceptions, it would be better to encapsulate them in a similar way to working on an empty sequence, e.g. could use Either<L,R>???
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**      * A function which describes an operation on the database with a Transaction.      *      * You can think of this as a function<pre>f(T) -&gt; U</pre>      * where the database and transaction are available to the      * function<pre>f</pre>.      *      * @param<T> The initial state before the transaction operation.      * @param<U> The state after the transaction operation.      */
annotation|@
name|FunctionalInterface
interface|interface
name|TransactionOperation
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|QuadFunction7E
argument_list|<
name|DBBroker
argument_list|,
name|Txn
argument_list|,
name|ExecutionListener
argument_list|,
name|T
argument_list|,
name|U
argument_list|,
name|EXistException
argument_list|,
name|XPathException
argument_list|,
name|PermissionDeniedException
argument_list|,
name|LockException
argument_list|,
name|TriggerException
argument_list|,
name|IOException
argument_list|,
name|InterruptedException
argument_list|>
block|{
comment|/**          * Get a document from the database.          *          * @param<T> The type of the state held for the transaction          *     before this operation executes.          *          * @param uri The uri of the document.          *          * @return an operation which will retrieve the document from the database.          */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|DocumentImpl
argument_list|>
name|getDocument
parameter_list|(
specifier|final
name|String
name|uri
parameter_list|)
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Getting document: "
operator|+
name|uri
argument_list|)
expr_stmt|;
return|return
operator|(
name|DocumentImpl
operator|)
name|broker
operator|.
name|getXMLResource
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|uri
argument_list|)
argument_list|)
return|;
block|}
return|;
block|}
comment|/**          * Delete a document from the database.          *          * @param<T> The type of the document held for the transaction          *     before this operation executes.          *          * @return an operation which will delete a document from the database.          */
specifier|static
parameter_list|<
name|T
extends|extends
name|DocumentImpl
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|Void
argument_list|>
name|deleteDocument
parameter_list|()
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|transaction
parameter_list|,
name|listener
parameter_list|,
name|doc
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Deleting document: "
operator|+
name|doc
operator|.
name|getDocumentURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|XmldbURI
name|collectionUri
init|=
name|doc
operator|.
name|getURI
argument_list|()
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|collection
init|=
name|broker
operator|.
name|openCollection
argument_list|(
name|collectionUri
argument_list|,
name|Lock
operator|.
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"No such collection: "
operator|+
name|collectionUri
argument_list|)
throw|;
block|}
if|if
condition|(
name|XML_FILE
operator|==
name|doc
operator|.
name|getResourceType
argument_list|()
condition|)
block|{
name|collection
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collection
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
return|;
block|}
comment|/**          * Update a document in the database.          *          * @param<T> The type of the document held for the transaction          *     before this operation executes.          *          * @param xqueryUpdate The XQuery Update to execute on the document.          *          * @return an operation which will update a document in the database.          */
specifier|static
parameter_list|<
name|T
extends|extends
name|DocumentImpl
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|Void
argument_list|>
name|updateDocument
parameter_list|(
specifier|final
name|String
name|xqueryUpdate
parameter_list|)
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|transaction
parameter_list|,
name|listener
parameter_list|,
name|doc
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Updating document: "
operator|+
name|doc
operator|.
name|getDocumentURI
argument_list|()
operator|+
literal|", with: "
operator|+
name|xqueryUpdate
argument_list|)
expr_stmt|;
specifier|final
name|XQuery
name|xquery
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getXQueryService
argument_list|()
decl_stmt|;
specifier|final
name|NodeSet
name|nodeSet
init|=
operator|new
name|NewArrayNodeSet
argument_list|()
decl_stmt|;
name|nodeSet
operator|.
name|add
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
name|xquery
operator|.
name|execute
argument_list|(
name|broker
argument_list|,
name|xqueryUpdate
argument_list|,
name|nodeSet
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|;
block|}
comment|/**          * Query a document in the database.          *          * @param<T> The type of the document held for the transaction          *     before this operation executes.          *          * @param query The XQuery to execute against the document.          *          * @return an operation which will update a document in the database.          */
specifier|static
parameter_list|<
name|T
extends|extends
name|DocumentImpl
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|Void
argument_list|>
name|queryDocument
parameter_list|(
specifier|final
name|String
name|query
parameter_list|)
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|transaction
parameter_list|,
name|listener
parameter_list|,
name|doc
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Querying document: "
operator|+
name|doc
operator|.
name|getDocumentURI
argument_list|()
operator|+
literal|", with: "
operator|+
name|query
argument_list|)
expr_stmt|;
specifier|final
name|XQuery
name|xquery
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getXQueryService
argument_list|()
decl_stmt|;
specifier|final
name|NodeSet
name|nodeSet
init|=
operator|new
name|NewArrayNodeSet
argument_list|()
decl_stmt|;
name|nodeSet
operator|.
name|add
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
name|xquery
operator|.
name|execute
argument_list|(
name|broker
argument_list|,
name|query
argument_list|,
name|nodeSet
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|;
block|}
comment|/**          * Commit the transaction.          *          * @param<T> The type of the state held for the transaction          *     before this operation executes.          *          * @return an operation which will commit the transaction          *    and return the input unchanged.          */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|T
argument_list|>
name|commit
parameter_list|()
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|transaction
parameter_list|,
name|listener
parameter_list|,
name|t
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Committing Transaction"
argument_list|)
expr_stmt|;
name|transaction
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
return|;
block|}
comment|/**          * Abort the transaction.          *          * @param<T> The type of the state held for the transaction          *     before this operation executes.          *          * @return an operation which will abort the transaction          *    and return the input unchanged.          */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|T
argument_list|>
name|abort
parameter_list|()
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|transaction
parameter_list|,
name|listener
parameter_list|,
name|t
parameter_list|)
lambda|->
block|{
name|listener
operator|.
name|event
argument_list|(
literal|"Aborting Transaction"
argument_list|)
expr_stmt|;
name|transaction
operator|.
name|abort
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
return|;
block|}
comment|/**          * Executes this, and then the other Transaction Operation          * on the input type {@code<T>} and returns          * the results as a tuple.          *          * e.g.<pre>Tuple2(f(T) -&gt; U, other(T) -&gt; U2)</pre>          *          * @param<U2> thr result of the other operation.          *          * @param other another transaction operation which also operates on T          *          * @return The tuple of results.          */
specifier|default
parameter_list|<
name|U2
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|Tuple2
argument_list|<
name|U
argument_list|,
name|U2
argument_list|>
argument_list|>
name|with
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|?
extends|extends
name|U2
argument_list|>
name|other
parameter_list|)
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t
parameter_list|)
lambda|->
operator|new
name|Tuple2
argument_list|<>
argument_list|(
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|listener
argument_list|,
name|t
argument_list|)
argument_list|,
name|other
operator|.
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|listener
argument_list|,
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Returns a composed function that first applies this function to          * its input, and then applies the {@code after} function to the result.          *          * See {@link Function#andThen(Function)}          *          * @param<V> the result of the after operation.          *          * @param after the after function          *          * @return the composed function          */
specifier|default
parameter_list|<
name|V
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|V
argument_list|>
name|andThen
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|after
parameter_list|)
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|t
parameter_list|)
lambda|->
name|after
operator|.
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|listener
argument_list|,
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|listener
argument_list|,
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Returns a composed function that first applies the {@code before}          * function to its input, and then applies this function to the result.          *          * See {@link Function#compose(Function)}          *          * @param<V> the input type of the before operation.          *          * @param before the before function.          *          * @return the composed function          */
specifier|default
parameter_list|<
name|V
parameter_list|>
name|TransactionOperation
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
name|compose
parameter_list|(
specifier|final
name|TransactionOperation
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|before
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|before
argument_list|)
expr_stmt|;
return|return
parameter_list|(
name|broker
parameter_list|,
name|txn
parameter_list|,
name|listener
parameter_list|,
name|v
parameter_list|)
lambda|->
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|listener
argument_list|,
name|before
operator|.
name|apply
argument_list|(
name|broker
argument_list|,
name|txn
argument_list|,
name|listener
argument_list|,
name|v
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Returns a function that always returns its input argument.          *          * See {@link Function#identity()}          *          * @param<T> the result of the identity operation.          *          * @return the identity operation          */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|TransactionOperation
argument_list|<
name|T
argument_list|,
name|T
argument_list|>
name|identity
parameter_list|()
block|{
return|return
parameter_list|(
name|broker
parameter_list|,
name|transaction
parameter_list|,
name|listener
parameter_list|,
name|t
parameter_list|)
lambda|->
name|t
return|;
block|}
block|}
comment|/**      * A simple extension of {@link CountDownLatch}      * which also provides a name for the latch.      *      * Useful for debugging latching ordering in      * transaction schedules.      */
class|class
name|NamedCountDownLatch
extends|extends
name|CountDownLatch
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|public
name|NamedCountDownLatch
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
name|super
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|public
specifier|final
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
comment|/**      * A listener that receives events      * from the scheduler during execution      * of the schedule.      */
annotation|@
name|FunctionalInterface
interface|interface
name|ExecutionListener
block|{
comment|/**          * Called when a execution event occurs.          *          * @param message a message describing the event.          */
name|void
name|event
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
function_decl|;
block|}
comment|/**      * Discards {@link ExecutionListener} Events      */
name|ExecutionListener
name|NULL_SCHEDULE_LISTENER
init|=
name|message
lambda|->
block|{
block|}
decl_stmt|;
comment|/**      * Just writes {@link ExecutionListener} Events to Standard Out      */
name|ExecutionListener
name|STD_OUT_SCHEDULE_LISTENER
init|=
name|message
lambda|->
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"["
operator|+
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
literal|"]: "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|message
argument_list|)
decl_stmt|;
block|}
end_interface

end_unit

