begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2015 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple2
import|;
end_import

begin_import
import|import
name|it
operator|.
name|unimi
operator|.
name|dsi
operator|.
name|fastutil
operator|.
name|objects
operator|.
name|ObjectLinkedOpenHashSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|backup
operator|.
name|RawDataBackup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
operator|.
name|SubCollectionEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|IndexController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StructuralIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|IEmbeddedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|INodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|EnsureLocked
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|EnsureUnlocked
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|DigestType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_comment
comment|/**  * This is the base class for all database backends. All the basic database  * operations like storing, removing or index access are provided by subclasses  * of this class.  *   * @author<a href="mailto:wolfgang@exist-db.org">Wolfgang Meier</a>  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|DBBroker
implements|implements
name|AutoCloseable
block|{
comment|// Matching types
specifier|public
specifier|final
specifier|static
name|int
name|MATCH_EXACT
init|=
literal|0
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|MATCH_REGEXP
init|=
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|MATCH_WILDCARDS
init|=
literal|2
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|MATCH_CONTAINS
init|=
literal|3
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|MATCH_STARTSWITH
init|=
literal|4
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|MATCH_ENDSWITH
init|=
literal|5
decl_stmt|;
comment|//TODO : move elsewhere
specifier|public
specifier|static
specifier|final
name|String
name|CONFIGURATION_ELEMENT_NAME
init|=
literal|"xupdate"
decl_stmt|;
comment|//TODO : move elsewhere
specifier|public
specifier|final
specifier|static
name|String
name|XUPDATE_FRAGMENTATION_FACTOR_ATTRIBUTE
init|=
literal|"allowed-fragmentation"
decl_stmt|;
comment|//TODO : move elsewhere
specifier|public
specifier|final
specifier|static
name|String
name|PROPERTY_XUPDATE_FRAGMENTATION_FACTOR
init|=
literal|"xupdate.fragmentation"
decl_stmt|;
comment|//TODO : move elsewhere
specifier|public
specifier|final
specifier|static
name|String
name|XUPDATE_CONSISTENCY_CHECKS_ATTRIBUTE
init|=
literal|"enable-consistency-checks"
decl_stmt|;
comment|//TODO : move elsewhere
specifier|public
specifier|final
specifier|static
name|String
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
init|=
literal|"xupdate.consistency-checks"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_CHOWN_RESTRICTED_ATTRIBUTE
init|=
literal|"posix-chown-restricted"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_CHOWN_RESTRICTED_PROPERTY
init|=
literal|"db-connection.posix-chown-restricted"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PRESERVE_ON_COPY_ATTRIBUTE
init|=
literal|"preserve-on-copy"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PRESERVE_ON_COPY_PROPERTY
init|=
literal|"db-connection.preserve-on-copy"
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|DBBroker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|boolean
name|caseSensitive
init|=
literal|true
decl_stmt|;
specifier|protected
name|Configuration
name|config
decl_stmt|;
specifier|protected
name|BrokerPool
name|pool
decl_stmt|;
specifier|private
name|Deque
argument_list|<
name|Subject
argument_list|>
name|subject
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Used when TRACE level logging is enabled      * to provide a history of {@link Subject} state      * changes      *      * This can be written to a log file by calling      * {@link DBBroker#traceSubjectChanges()}      */
specifier|private
name|TraceableStateChanges
argument_list|<
name|Subject
argument_list|,
name|TraceableSubjectChange
operator|.
name|Change
argument_list|>
name|subjectChangeTrace
init|=
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|?
operator|new
name|TraceableStateChanges
argument_list|<>
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|private
name|int
name|referenceCount
init|=
literal|0
decl_stmt|;
specifier|protected
name|String
name|id
decl_stmt|;
specifier|private
specifier|final
name|TimestampedReference
argument_list|<
name|IndexController
argument_list|>
name|indexController
init|=
operator|new
name|TimestampedReference
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|PreserveType
name|preserveOnCopy
decl_stmt|;
specifier|private
name|boolean
name|triggersEnabled
init|=
literal|true
decl_stmt|;
specifier|public
name|DBBroker
parameter_list|(
specifier|final
name|BrokerPool
name|pool
parameter_list|,
specifier|final
name|Configuration
name|config
parameter_list|)
block|{
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
specifier|final
name|Boolean
name|temp
init|=
operator|(
name|Boolean
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|NativeValueIndex
operator|.
name|PROPERTY_INDEX_CASE_SENSITIVE
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|null
condition|)
block|{
name|caseSensitive
operator|=
name|temp
expr_stmt|;
block|}
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|preserveOnCopy
operator|=
name|config
operator|.
name|getProperty
argument_list|(
name|PRESERVE_ON_COPY_PROPERTY
argument_list|,
name|PreserveType
operator|.
name|NO_PRESERVE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Prepares the broker for (re-)use,      * when (re-)leased from BrokerPool.      */
specifier|public
name|void
name|prepare
parameter_list|()
block|{
comment|/**          * Index modules should always be re-loaded in case          * {@link org.exist.indexing.IndexManager#registerIndex(Index)} or          * {@link org.exist.indexing.IndexManager#unregisterIndex(Index)}          * has been called since the previous lease of this broker.          */
name|loadIndexModules
argument_list|()
expr_stmt|;
block|}
comment|/**      * Loads the index modules via an IndexController      */
specifier|protected
name|void
name|loadIndexModules
parameter_list|()
block|{
name|indexController
operator|.
name|setIfExpiredOrNull
argument_list|(
name|getBrokerPool
argument_list|()
operator|.
name|getIndexManager
argument_list|()
operator|.
name|getConfigurationTimestamp
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IndexController
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Change the state that the broker performs actions as      *      * @param subject The new state for the broker to perform actions as      */
specifier|public
name|void
name|pushSubject
parameter_list|(
specifier|final
name|Subject
name|subject
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|subjectChangeTrace
operator|.
name|add
argument_list|(
name|TraceableSubjectChange
operator|.
name|push
argument_list|(
name|subject
argument_list|,
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|subject
operator|.
name|addFirst
argument_list|(
name|subject
argument_list|)
expr_stmt|;
block|}
comment|/**      * Restore the previous state for the broker to perform actions as      *      * @return The state which has been popped      */
specifier|public
name|Subject
name|popSubject
parameter_list|()
block|{
specifier|final
name|Subject
name|subject
init|=
name|this
operator|.
name|subject
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|subjectChangeTrace
operator|.
name|add
argument_list|(
name|TraceableSubjectChange
operator|.
name|pop
argument_list|(
name|subject
argument_list|,
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|subject
return|;
block|}
comment|/**      * The state that is currently using this DBBroker object      *       * @return The current state that the broker is executing as      */
specifier|public
name|Subject
name|getCurrentSubject
parameter_list|()
block|{
return|return
name|subject
operator|.
name|peekFirst
argument_list|()
return|;
block|}
comment|/**      * Logs the details of all state changes      *      * Used for tracing privilege escalation/de-escalation      * during the lifetime of an active broker      *      * @throws IllegalStateException if TRACE level logging is not enabled      */
specifier|public
name|void
name|traceSubjectChanges
parameter_list|()
block|{
name|subjectChangeTrace
operator|.
name|logTrace
argument_list|(
name|LOG
argument_list|)
expr_stmt|;
block|}
comment|/**      * Clears the details of all state changes      *      * Used for tracing privilege escalation/de-escalation      * during the lifetime of an active broker      *      * @throws IllegalStateException if TRACE level logging is not enabled      */
specifier|public
name|void
name|clearSubjectChangesTrace
parameter_list|()
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This is only enabled at TRACE level logging"
argument_list|)
throw|;
block|}
name|subjectChangeTrace
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|IndexController
name|getIndexController
parameter_list|()
block|{
return|return
name|indexController
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
specifier|abstract
name|ElementIndex
name|getElementIndex
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|StructuralIndex
name|getStructuralIndex
parameter_list|()
function_decl|;
comment|/** Flush all data that has not been written before. */
specifier|public
name|void
name|flush
parameter_list|()
block|{
comment|// do nothing
block|}
comment|/** Observer Design Pattern: List of ContentLoadingObserver objects */
specifier|protected
name|List
argument_list|<
name|ContentLoadingObserver
argument_list|>
name|contentLoadingObservers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Remove all observers */
specifier|public
name|void
name|clearContentLoadingObservers
parameter_list|()
block|{
name|contentLoadingObservers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Observer Design Pattern: add an observer.      *      * @param observer the observer      */
specifier|public
name|void
name|addContentLoadingObserver
parameter_list|(
name|ContentLoadingObserver
name|observer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|contentLoadingObservers
operator|.
name|contains
argument_list|(
name|observer
argument_list|)
condition|)
block|{
name|contentLoadingObservers
operator|.
name|add
argument_list|(
name|observer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Observer Design Pattern: remove an observer.      *      * @param observer the observer      */
specifier|public
name|void
name|removeContentLoadingObserver
parameter_list|(
name|ContentLoadingObserver
name|observer
parameter_list|)
block|{
if|if
condition|(
name|contentLoadingObservers
operator|.
name|contains
argument_list|(
name|observer
argument_list|)
condition|)
block|{
name|contentLoadingObservers
operator|.
name|remove
argument_list|(
name|observer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds all the documents in the database to the specified DocumentSet.      *      * WARNING: This is an incredibly expensive operation as it requires recursing through the Collection hierarchy and      * accessing every document.      *      * @param docs a (possibly empty) document set to which the found documents are added.      * @return all XML resources as MutableDocumentSet      * @throws PermissionDeniedException when one collection can not be accessed      * @throws LockException when one collection is locked      */
specifier|public
specifier|abstract
name|MutableDocumentSet
name|getAllXMLResources
parameter_list|(
name|MutableDocumentSet
name|docs
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
function_decl|;
specifier|public
specifier|abstract
name|void
name|getResourcesFailsafe
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|,
name|boolean
name|fullScan
parameter_list|)
throws|throws
name|TerminatedException
function_decl|;
specifier|public
specifier|abstract
name|void
name|getCollectionsFailsafe
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
function_decl|;
comment|/**      * Gets a database Collection.      *      * The Collection is identified by its absolute path, e.g. /db/shakespeare.      * The returned Collection will NOT HAVE a lock.      *      * The caller should take care to release any associated resource by      * calling {@link Collection#close()}      *      * In general, accessing Collections without a lock provides no consistency guarantees.      * This function should only be used where estimated reads are needed, no writes should      * be performed on a Collection retrieved by this function.      * If you are uncertain whether this function is safe for you to use, you should always      * use #openCollection(XmldbURI, LockMode) instead.      *      * @param uri The Collection's path      * @return the Collection, or null if no Collection matches the path      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
annotation|@
name|Nullable
annotation|@
name|EnsureUnlocked
specifier|public
specifier|abstract
name|Collection
name|getCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
comment|/**      * Open a Collection for reading or writing.      *      * The Collection is identified by its absolute path, e.g. /db/shakespeare.      * It will be loaded and locked according to the lockMode argument.      *       * The caller should take care to release the Collection lock properly by      * calling {@link Collection#close()}      *       * @param uri The Collection's path      * @param lockMode the mode for locking the Collection, as specified in {@link LockMode}      *      * @return the Collection, or null if no Collection matches the path      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
specifier|public
specifier|abstract
name|Collection
name|openCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|,
name|LockMode
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
specifier|public
specifier|abstract
name|List
argument_list|<
name|String
argument_list|>
name|findCollectionsMatching
parameter_list|(
name|String
name|regexp
parameter_list|)
function_decl|;
comment|/**      * Gets the database Collection identified by the specified path.      * If the Collection does not yet exist, it is created - including all ancestors.      * The Collection is identified by its absolute path, e.g. /db/shakespeare.      * The returned Collection will NOT HAVE a lock.      *      * The caller should take care to release any associated resource by      * calling {@link Collection#close()}      *       * @param transaction The current transaction      * @param uri The Collection's URI      *      * @return The existing or created Collection      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws IOException If an error occurs whilst reading (get) or writing (create) a Collection to disk      * @throws TriggerException If a CollectionTrigger throws an exception      */
specifier|public
specifier|abstract
annotation|@
name|EnsureUnlocked
name|Collection
name|getOrCreateCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|XmldbURI
name|uri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
function_decl|;
comment|/**      * Returns the database collection identified by the specified path. If the      * collection does not yet exist, it is created - including all ancestors.      * The path should be absolute, e.g. /db/shakespeare.      *      * @param transaction The transaction, which registers the acquired write locks. The locks should be released on commit/abort.      * @param uri The collection's URI      * @param creationAttributes the attributes to use if the collection needs to be created.      * @return The collection or<code>null</code> if no collection matches the path      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws IOException If an error occurs whilst reading (get) or writing (create) a Collection to disk      * @throws TriggerException If a CollectionTrigger throws an exception      */
specifier|public
specifier|abstract
name|Collection
name|getOrCreateCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|XmldbURI
name|uri
parameter_list|,
name|Optional
argument_list|<
name|Tuple2
argument_list|<
name|Permission
argument_list|,
name|Long
argument_list|>
argument_list|>
name|creationAttributes
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
function_decl|;
comment|/**      * Returns the configuration object used to initialize the current database      * instance.      *      * @return the configuration      */
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|config
return|;
block|}
comment|/**      * Return a {@link org.exist.storage.dom.NodeIterator} starting at the      * specified node.      *       * @param node the NodeHandle      * @return NodeIterator of node.      * @throws RuntimeException not implemented      */
specifier|public
name|INodeIterator
name|getNodeIterator
parameter_list|(
name|NodeHandle
name|node
parameter_list|)
throws|throws
name|RuntimeException
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"not implemented for this storage backend"
argument_list|)
throw|;
block|}
comment|/**      * Return the document stored at the specified path. The path should be      * absolute, e.g. /db/shakespeare/plays/hamlet.xml.      *      * @param docURI the XmldbURI to the resource      * @return the document or null if no document could be found at the      *         specified location.      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
specifier|public
specifier|abstract
annotation|@
name|EnsureUnlocked
name|Document
name|getXMLResource
parameter_list|(
name|XmldbURI
name|docURI
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
comment|/**      * Get a document by its file name. The document's file name is used to      * identify a document.      *      * @param docURI absolute file name in the database;      *                 name can be given with or without the leading path      * @param accessType The access mode for the resource e.g. {@link org.exist.security.Permission#READ}      * @return The document value or null if no document could be found      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
specifier|public
specifier|abstract
annotation|@
name|EnsureUnlocked
name|DocumentImpl
name|getResource
parameter_list|(
name|XmldbURI
name|docURI
parameter_list|,
name|int
name|accessType
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
specifier|public
specifier|abstract
annotation|@
name|EnsureUnlocked
name|DocumentImpl
name|getResourceById
parameter_list|(
name|int
name|collectionId
parameter_list|,
name|byte
name|resourceType
parameter_list|,
name|int
name|documentId
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
comment|/**      * Return the document stored at the specified path. The path should be      * absolute, e.g. /db/shakespeare/plays/hamlet.xml, with the specified lock.      *      * @param docURI absolute file name in the database;      *                 name can be given with or without the leading path.      * @param lockMode one of the modes in {@link LockMode}      *      * @return the document or null if no document could be found at the      *         specified location.      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
specifier|public
specifier|abstract
name|LockedDocument
name|getXMLResource
parameter_list|(
name|XmldbURI
name|docURI
parameter_list|,
name|LockMode
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
comment|/**      * Get a new document id that does not yet exist within the collection.      *      * @param transaction the transaction      *      * @return next resource ID      *      * @throws EXistException when something went wrong      * @throws LockException when the resource or collection is locked      */
specifier|public
specifier|abstract
name|int
name|getNextResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|EXistException
throws|,
name|LockException
function_decl|;
comment|/**      * Get the string value of the specified node.      *       * If addWhitespace is set to true, an extra space character will be added      * between adjacent elements in mixed content nodes.      * @param node the node      * @param addWhitespace to add whitespace or not      *      * @return the node value as String      *      * @throws RuntimeException not implemented      */
specifier|public
name|String
name|getNodeValue
parameter_list|(
name|IStoredNode
name|node
parameter_list|,
name|boolean
name|addWhitespace
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"not implemented for this storage backend"
argument_list|)
throw|;
block|}
comment|/**      * Get an instance of the Serializer used for converting nodes back to XML.      * Subclasses of DBBroker may have specialized subclasses of Serializer to      * convert a node into an XML-string      * @return the {@link Serializer}      */
specifier|public
specifier|abstract
name|Serializer
name|getSerializer
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|NativeValueIndex
name|getValueIndex
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|Serializer
name|newSerializer
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|Serializer
name|newSerializer
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|chainOfReceivers
parameter_list|)
function_decl|;
comment|/**      * Get a node with given owner document and id from the database.      *       * @param doc the document the node belongs to      * @param nodeId the node's unique identifier      *      * @return the IStoredNode      */
specifier|public
specifier|abstract
name|IStoredNode
name|objectWith
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|Document
name|doc
parameter_list|,
name|NodeId
name|nodeId
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|IStoredNode
name|objectWith
parameter_list|(
name|NodeProxy
name|p
parameter_list|)
function_decl|;
comment|/**      * Remove the Collection and all of its sub-Collections from the database.      *      * @param transaction The current transaction      * @param collection The Collection to remove from the database      *      * @return true if the Collection was removed, false otherwise      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws IOException If an error occurs whilst removing the Collection from disk      * @throws TriggerException If a CollectionTrigger throws an exception      */
specifier|public
specifier|abstract
name|boolean
name|removeCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
function_decl|;
comment|/**      * Removes the resources entry from the Collection store on disk.      *      * @param transaction The database transaction.      * @param document The document to remove.      */
specifier|public
specifier|abstract
name|void
name|removeResourceMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|document
parameter_list|)
function_decl|;
comment|/**      * Remove a document from the database.      *      * @param tx the transaction      * @param doc the document      *      * @throws IOException If an error occurs whilst removing the Collection from disk      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
specifier|public
specifier|abstract
name|void
name|removeResource
parameter_list|(
name|Txn
name|tx
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|PermissionDeniedException
function_decl|;
comment|/**      * Remove a XML document from the database.      *      * NOTE Should never be called directly,      * only for use from {@link Collection#removeXMLResource(Txn, DBBroker, XmldbURI)}      * or {@link DBBroker}.      *      * @param transaction the transaction      * @param document the document      *      * @throws IOException If an error occurs whilst removing the Collection from disk      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
specifier|public
name|void
name|removeXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|document
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove a XML document from the database.      *      * NOTE Should never be called directly,      * only for use from {@link Collection#removeXMLResource(Txn, DBBroker, XmldbURI)}      * or {@link DBBroker}.      *      * @param transaction the transaction      * @param document the document      * @param freeDocId true, if the document ID can be freed      *      * @throws IOException If an error occurs whilst removing the Collection from disk      * @throws PermissionDeniedException If the current user does not have appropriate permissions      */
specifier|public
specifier|abstract
name|void
name|removeXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|document
parameter_list|,
name|boolean
name|freeDocId
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
function_decl|;
specifier|public
enum|enum
name|IndexMode
block|{
name|STORE
block|,
name|REPAIR
block|,
name|REMOVE
block|}
comment|/**      * Reindex a Collection and its descendants      *      * NOTE: Read locks will be taken in a top-down, left-right manner      *     on Collections as they are indexed      *      * @param transaction the transaction      * @param collectionUri The URI of the Collection to reindex      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst reindexing the Collection on disk      */
specifier|public
specifier|abstract
name|void
name|reindexCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
name|XmldbURI
name|collectionUri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
function_decl|;
specifier|public
specifier|abstract
name|void
name|reindexXMLResource
parameter_list|(
specifier|final
name|Txn
name|txn
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|void
name|reindexXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|IndexMode
name|mode
parameter_list|)
function_decl|;
comment|/**      * Repair indexes. Should delete all secondary indexes and rebuild them.      * This method will be called after the recovery run has completed.      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst repairing indexes the database      */
specifier|public
specifier|abstract
name|void
name|repair
parameter_list|()
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
function_decl|;
comment|/**      * Repair core indexes (dom, collections ...). This method is called immediately      * after recovery and before {@link #repair()}.      */
specifier|public
specifier|abstract
name|void
name|repairPrimary
parameter_list|()
function_decl|;
comment|/**      * Saves the specified Collection to disk. Collections are usually cached in      * memory. If a Collection is modified, this method needs to be called to make      * the changes persistent.      *      * Note: adding or removing a document to a Collection does not require a save. However,      * modifying a Collection's metadata or adding or removing a sub-Collection does require      * a save.      *      * NOTE: It is assumed that the caller holds a {@link LockMode#WRITE_LOCK} on the Collection      *      * @param transaction The current transaction      * @param collection The Collection to persist      *      * @throws IOException If an error occurs whilst writing the Collection to disk      */
specifier|public
specifier|abstract
name|void
name|saveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|collection
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|void
name|closeDocument
parameter_list|()
function_decl|;
comment|/**      * Shut down the database instance. All open files, jdbc connections etc.      * should be closed.      */
specifier|public
specifier|abstract
name|void
name|shutdown
parameter_list|()
function_decl|;
comment|/**      * Store a node into the database. This method is called by the parser to      * write a node to the storage backend.      *       * @param transaction the current transaction      * @param node the node to be stored      * @param currentPath      *            path expression which points to this node's element-parent or      *            to itself if it is an element.      * @param indexSpec the IndexSpec      * @param<T> the return type      */
specifier|public
specifier|abstract
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|storeNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|IndexSpec
name|indexSpec
parameter_list|)
function_decl|;
specifier|public
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|endElement
parameter_list|(
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|abstract
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|endElement
parameter_list|(
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|,
name|boolean
name|remove
parameter_list|)
function_decl|;
comment|/**      * Store a document (descriptor) into the database.      *      * @param transaction the current transaction      * @param doc      *            the document's metadata to store.      */
specifier|public
specifier|abstract
name|void
name|storeXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|doc
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|void
name|storeMetadata
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|TriggerException
function_decl|;
comment|/**      * Stores the given data under the given binary resource descriptor      * (BinaryDocument).      *      * @param transaction the current transaction      * @param blob      *            the binary document descriptor      * @param data      *            the document binary data      *      * @throws IOException If an error occurs whilst writing the binary resource to disk      */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|void
name|storeBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|BinaryDocument
name|blob
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Stores the given data under the given binary resource descriptor      * (BinaryDocument).      *      * @param transaction the current transaction      * @param blob      *            the binary document descriptor      * @param is      *            the document binary data as input stream      *      * @throws IOException If an error occurs whilst writing the binary resource to disk      */
specifier|public
specifier|abstract
name|void
name|storeBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|BinaryDocument
name|blob
parameter_list|,
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|void
name|getCollectionResources
parameter_list|(
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
parameter_list|)
function_decl|;
comment|/**      * @deprecated use {@link #readBinaryResource(Txn, BinaryDocument, OutputStream)}      * @param blob      *            the binary document descriptor      * @param os the OutputStream to use      * @throws IOException If an error occurs whilst reading the binary resource from disk      */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|void
name|readBinaryResource
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|void
name|readBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * @deprecated use {@link #withBinaryFile(Txn, BinaryDocument, Function)}      * @param blob      *            the binary document descriptor      * @return the path to the binary document      * @throws IOException If an error occurs whilst reading the binary resource from disk      */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|Path
name|getBinaryFile
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Perform an operation with a {@link Path} reference to the BLOB file      * backing a Binary Document.      *      * NOTE: Use of this method should be avoided where possible. It only      * exists for integration with tools which can only      * work with File Paths and where making a copy of the file is not      * necessary.      *      * WARNING: The provided {@link Path} MUST ONLY be used for      * READ operations, any WRITE/DELETE operation will corrupt the      * integrity of the blob store.      *      * Consider if you really need to use this method. It is likely you could      * instead use {@link #getBinaryResource(Txn, BinaryDocument)} and make a      * copy of the data to a temporary file.      *      * Note that any resources associated with the BLOB file      * may not be released until the {@code fnFile} has finished executing.      *      * USE WITH CAUTION!      *      * @param transaction the current database transaction.      * @param binaryDocument the binary document to retrieve the backing BLOB file for.      * @param<T> the type of the return value      * @param fnFile a function which performs a read-only operation on the BLOB file.      *     The Path will be null if the Blob does not exist in the Blob Store.      *     If you wish to handle exceptions in your function you should consider      *     {@link com.evolvedbinary.j8fu.Try} or similar.      * @return T      *      * @throws IOException if an error occurs whilst retrieving the BLOB file.      */
specifier|public
specifier|abstract
parameter_list|<
name|T
parameter_list|>
name|T
name|withBinaryFile
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|binaryDocument
parameter_list|,
specifier|final
name|Function
argument_list|<
name|Path
argument_list|,
name|T
argument_list|>
name|fnFile
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * @deprecated use {@link #getBinaryResource(Txn, BinaryDocument)}      * @param blob      *            the binary document descriptor      * @return the InputStream      * @throws IOException if an error occurs whilst retrieving the binary resource.      */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|InputStream
name|getBinaryResource
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|InputStream
name|getBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * @deprecated use {@link BinaryDocument#getContentLength()}      * @param blob      *            the binary document descriptor      * @return the size of the binary resource      * @throws IOException if an error occurs whilst retrieving the binary resource.      */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|long
name|getBinaryResourceSize
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Get the Digest of the content of a Binary Document.      *      * @param transaction the database transaction      * @param binaryDocument the binary document      * @param digestType the type of the digest      *      * @return the message digest of the content of the Binary Document      * @throws IOException if an error occurs whilst retrieving the digest.      */
specifier|public
specifier|abstract
name|MessageDigest
name|getBinaryResourceContentDigest
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|binaryDocument
parameter_list|,
specifier|final
name|DigestType
name|digestType
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Completely delete this binary document (descriptor and binary data).      *      * @param transaction The current transaction      * @param blob the binary document descriptor      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws IOException if an error occurs whilst removing the binary resource.      */
specifier|public
specifier|abstract
name|void
name|removeBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
function_decl|;
comment|/** 	 * Move a collection and all its sub-Collections to another Collection and 	 * rename it. Moving a collection just modifies the collection path and all 	 * resource paths. The data itself remains in place.      *      * NOTE: It is assumed that the caller holds a {@link LockMode#WRITE_LOCK} on both the      *     `sourceCollection` and the `targetCollection` 	 *      * @param transaction The current transaction 	 * @param sourceCollection The Collection to move 	 * @param targetCollection The target Collection to move the sourceCollection into 	 * @param newName The new name the sourceCollection should have in the targetCollection 	 *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst moving the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception 	 */
specifier|public
specifier|abstract
name|void
name|moveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|targetCollection
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
function_decl|;
comment|/** 	 * Move a resource to the target Collection and rename it.      *      * NOTE: It is assumed that the caller holds a {@link LockMode#WRITE_LOCK} on the      *     `sourceDocument` and its parent Collection, and the `targetCollection` 	 *      * @param transaction The current transaction      * @param sourceDocument The document to move      * @param targetCollection The target Collection to move the sourceDocument into      * @param newName The new name the sourceDocument should have in the targetCollection      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst moving the Document on disk      * @throws TriggerException If a CollectionTrigger throws an exception 	 */
specifier|public
specifier|abstract
name|void
name|moveResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|sourceDocument
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|targetCollection
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
function_decl|;
comment|/** 	 * Copy a collection to the destination collection and rename it.      *      * NOTE: It is assumed that the caller holds a {@link LockMode#READ_LOCK}      *     `sourceCollection` and a {@link LockMode#WRITE_LOCK} on the `targetCollection` 	 * 	 * @param transaction The transaction, which registers the acquired write locks. The locks should be released on commit/abort. 	 * @param sourceCollection The origin collection 	 * @param destination The destination parent collection 	 * @param newName The new name of the collection 	 *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst copying the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception      * @throws EXistException If an internal error occurs      *      * @deprecated Use {@link #copyCollection(Txn, Collection, Collection, XmldbURI, PreserveType)} 	 */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|void
name|copyCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
function_decl|;
comment|/**      * Copy a collection to the destination collection and rename it.      *      * NOTE: It is assumed that the caller holds a {@link LockMode#READ_LOCK}      *     `sourceCollection` and a {@link LockMode#WRITE_LOCK} on the `targetCollection` 	 *      * @param transaction The transaction, which registers the acquired write locks. The locks should be released on commit/abort.      * @param sourceCollection The origin collection      * @param targetCollection The destination parent collection      * @param newName The new name of the collection      * @param preserve Cause the copy process to preserve the following attributes of each source in the copy:      *     modification time, file mode, user ID, and group ID, as allowed by permissions. Access Control Lists (ACLs)      *     will also be preserved.      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst copying the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception      * @throws EXistException If an internal error occurs      */
specifier|public
specifier|abstract
name|void
name|copyCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|targetCollection
parameter_list|,
name|XmldbURI
name|newName
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
function_decl|;
comment|/** 	 * Copy a resource to the destination collection and rename it. 	 *      * NOTE: It is assumed that the caller holds a {@link LockMode#READ_LOCK} on the      *     `sourceDocument` and its parent Collection,      *     and a {@link LockMode#WRITE_LOCK} on the `targetCollection` 	 *      * @param transaction The current transaction 	 * @param sourceDocument the resource to copy 	 * @param targetCollection the destination collection 	 * @param newName the new name the resource should have in the destination collection      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst copying the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception      * @throws EXistException If an internal error occurs      *      * @deprecated Use {@link #copyResource(Txn, DocumentImpl, Collection, XmldbURI, PreserveType)} 	 */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|void
name|copyResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|DocumentImpl
name|sourceDocument
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|targetCollection
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
function_decl|;
comment|/**      * Copy a resource to the destination collection and rename it.      * 	 *      * NOTE: It is assumed that the caller holds a {@link LockMode#READ_LOCK} on the      *     `sourceDocument` and its parent Collection,      *     and a {@link LockMode#WRITE_LOCK} on the `targetCollection`      *      * @param transaction The current transaction      * @param sourceDocument the resource to copy      * @param targetCollection the destination collection      * @param newName the new name the resource should have in the destination collection      * @param preserve Cause the copy process to preserve the following attributes of each source in the copy:      *     modification time, file mode, user ID, and group ID, as allowed by permissions. Access Control Lists (ACLs)      *     will also be preserved.      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst copying the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception      * @throws EXistException If an internal error occurs      */
specifier|public
specifier|abstract
name|void
name|copyResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|DocumentImpl
name|sourceDocument
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|Collection
name|targetCollection
parameter_list|,
name|XmldbURI
name|newName
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
function_decl|;
comment|/** 	 * Defragment pages of this document. This will minimize the number of split 	 * pages. 	 *      * @param transaction The current transaction 	 * @param doc to defrag 	 */
specifier|public
specifier|abstract
name|void
name|defragXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
name|DocumentImpl
name|doc
parameter_list|)
function_decl|;
comment|/** 	 * Perform a consistency check on the specified document. 	 *  	 * This checks if the DOM tree is consistent. 	 *  	 * @param doc the document to check the XML tree in 	 */
specifier|public
specifier|abstract
name|void
name|checkXMLResourceTree
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|DocumentImpl
name|doc
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|void
name|checkXMLResourceConsistency
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
function_decl|;
comment|/** 	 * Sync dom and collection state data (pages) to disk. In case of 	 * {@link org.exist.storage.sync.Sync#MAJOR}, sync all states (dom, 	 * collection, text and element) to disk. 	 *  	 * @param syncEvent the event 	 */
specifier|public
specifier|abstract
name|void
name|sync
parameter_list|(
name|Sync
name|syncEvent
parameter_list|)
function_decl|;
comment|/** 	 * Update a node's data. To keep nodes in a correct sequential order, it is 	 * sometimes necessary to update a previous written node. Warning: don't use 	 * it for other purposes. 	 *      * @param transaction the current transaction 	 * @param node the node to update      * @param reindex true will trigger a reindex      * @param<T> the type to return 	 */
specifier|public
specifier|abstract
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|updateNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|boolean
name|reindex
parameter_list|)
function_decl|;
comment|/** 	 * Is the database running read-only? Returns false by default. Storage 	 * backends should override this if they support read-only mode. 	 *  	 * @return boolean 	 */
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|BrokerPool
name|getBrokerPool
parameter_list|()
block|{
return|return
name|pool
return|;
block|}
specifier|public
name|Database
name|getDatabase
parameter_list|()
block|{
return|return
name|pool
return|;
block|}
specifier|public
specifier|abstract
name|void
name|insertNodeAfter
parameter_list|(
name|Txn
name|transaction
parameter_list|,
specifier|final
name|NodeHandle
name|previous
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|void
name|indexNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IStoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
function_decl|;
specifier|public
name|void
name|indexNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IStoredNode
name|node
parameter_list|)
block|{
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|abstract
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|removeNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|void
name|removeAllNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IStoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|StreamListener
name|listener
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|void
name|endRemove
parameter_list|(
name|Txn
name|transaction
parameter_list|)
function_decl|;
comment|/** 	 * Create a temporary document in the temp collection and store the supplied 	 * data. 	 *  	 * @param doc the document to store      * @return the temporary document      *      * @throws EXistException If an internal error occurs      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks 	 */
specifier|public
specifier|abstract
annotation|@
name|EnsureUnlocked
name|DocumentImpl
name|storeTempResource
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
function_decl|;
comment|/** 	 * Clean up temporary resources. Called by the sync daemon. 	 *  	 * @param forceRemoval Should temporary resources be forcefully removed      * @throws PermissionDeniedException If the current user does not have appropriate permissions 	 */
specifier|public
specifier|abstract
name|void
name|cleanUpTempResources
parameter_list|(
name|boolean
name|forceRemoval
parameter_list|)
throws|throws
name|PermissionDeniedException
function_decl|;
comment|/** Convenience method that allows to check available memory during broker-related processes. 	 * This method should eventually trigger flush() events. 	 */
specifier|public
specifier|abstract
name|void
name|checkAvailableMemory
parameter_list|()
function_decl|;
comment|/**      * Get all the documents in this database matching the given      * document-type's name.      *      * WARNING: This is an incredibly expensive operation as it requires recursing through the Collection hierarchy and      * accessing every document.      *      * @param doctype The doctype to match documents against      * @param result a (possibly empty) document set to which the found documents are added.      *      * @return The result      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      */
specifier|public
specifier|abstract
name|MutableDocumentSet
name|getXMLResourcesByDoctype
parameter_list|(
name|String
name|doctype
parameter_list|,
name|MutableDocumentSet
name|result
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
function_decl|;
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|referenceCount
return|;
block|}
specifier|public
name|void
name|incReferenceCount
parameter_list|()
block|{
operator|++
name|referenceCount
expr_stmt|;
block|}
specifier|public
name|void
name|decReferenceCount
parameter_list|()
block|{
operator|--
name|referenceCount
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|IndexSpec
name|getIndexConfiguration
parameter_list|()
function_decl|;
specifier|public
name|void
name|setId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|id
return|;
block|}
specifier|public
specifier|abstract
name|IEmbeddedXMLStreamReader
name|getXMLStreamReader
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
function_decl|;
specifier|public
specifier|abstract
name|IEmbeddedXMLStreamReader
name|newXMLStreamReader
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
function_decl|;
specifier|public
specifier|abstract
name|void
name|backupToArchive
parameter_list|(
name|RawDataBackup
name|backup
parameter_list|)
throws|throws
name|IOException
throws|,
name|EXistException
function_decl|;
comment|/**      * Reads and populates the metadata for a sub-Collection      *      * The entry to read is determined by {@link SubCollectionEntry#getUri()}      *      * NOTE: It is assumed that the caller holds a {@link LockMode#READ_LOCK} (or better)      * on the Collection indicated in `entry`.      *      * @param entry The sub-Collection entry to populate      *      * @throws IOException If an error occurs whilst reading (get) or writing (create) a Collection to disk      * @throws LockException if we are unable to obtain a lock on the collections.dbx      */
specifier|public
specifier|abstract
name|void
name|readCollectionEntry
parameter_list|(
name|SubCollectionEntry
name|entry
parameter_list|)
throws|throws
name|IOException
throws|,
name|LockException
function_decl|;
comment|/**      * Determines if Collection or Document attributes be preserved on copy,      * by comparing the argument with the global system settings.      *      * Returns true if either:      *     1.) The {@code preserve} argument is {@link PreserveType#PRESERVE}.      *     2.) The {@code preserve} argument is {@link PreserveType#DEFAULT},      *         and the global system setting is {@link PreserveType#PRESERVE}.      *      * @param preserve The call-specific preserve flag.      *      * @return true if attributes should be preserved.      */
specifier|public
name|boolean
name|preserveOnCopy
parameter_list|(
specifier|final
name|PreserveType
name|preserve
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|preserve
argument_list|)
expr_stmt|;
return|return
name|PreserveType
operator|.
name|PRESERVE
operator|==
name|preserve
operator|||
operator|(
name|PreserveType
operator|.
name|DEFAULT
operator|==
name|preserve
operator|&&
name|PreserveType
operator|.
name|PRESERVE
operator|==
name|this
operator|.
name|preserveOnCopy
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|pool
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|ObjectLinkedOpenHashSet
argument_list|<
name|Txn
argument_list|>
name|currentTransactions
init|=
operator|new
name|ObjectLinkedOpenHashSet
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|// 4 - we don't expect many concurrent transactions per-broker!
specifier|public
name|void
name|addCurrentTransaction
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
block|{
synchronized|synchronized
init|(
name|currentTransactions
init|)
block|{
if|if
condition|(
operator|!
name|currentTransactions
operator|.
name|add
argument_list|(
name|transaction
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Transaction is already current: "
operator|+
name|transaction
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|void
name|removeCurrentTransaction
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
block|{
synchronized|synchronized
init|(
name|currentTransactions
init|)
block|{
if|if
condition|(
operator|!
name|currentTransactions
operator|.
name|remove
argument_list|(
name|transaction
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to remove current transaction: "
operator|+
name|transaction
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
annotation|@
name|Nullable
name|Txn
name|getCurrentTransaction
parameter_list|()
block|{
synchronized|synchronized
init|(
name|currentTransactions
init|)
block|{
if|if
condition|(
name|currentTransactions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|currentTransactions
operator|.
name|last
argument_list|()
return|;
block|}
block|}
comment|/**      * Gets the current transaction, or if there is no current transaction      * for this thread (i.e. broker), then we begin a new transaction.      *      * The callee is *always* responsible for calling .close on the transaction      *      * Note - When there is an existing transaction, calling .close on the object      * returned (e.g. ResusableTxn) from this function will only cause a minor state      * change and not close the original transaction. That is intentional, as it will      * eventually be closed by the creator of the original transaction (i.e. the code      * site that began the first transaction)      *      * @deprecated This is a stepping-stone; Transactions should be explicitly passed      *   around. This will be removed in the near future.      * @return the transaction      */
annotation|@
name|Deprecated
specifier|public
name|Txn
name|continueOrBeginTransaction
parameter_list|()
block|{
synchronized|synchronized
init|(
name|currentTransactions
init|)
block|{
if|if
condition|(
name|currentTransactions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|TransactionManager
name|tm
init|=
name|getBrokerPool
argument_list|()
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
return|return
name|tm
operator|.
name|beginTransaction
argument_list|()
return|;
comment|//TransactionManager will call this#addCurrentTransaction
block|}
else|else
block|{
return|return
operator|new
name|Txn
operator|.
name|ReusableTxn
argument_list|(
name|currentTransactions
operator|.
name|last
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
comment|//TODO the object passed to the function e.g. Txn should not implement .close
comment|//if we are using a function passing approach like this, i.e. one point of
comment|//responsibility and WE HERE should be responsible for closing the transaction.
comment|//we could return a sub-class of Txn which is uncloseable like Txn.reuseable or similar
comment|//also getCurrentTransaction should then be made private
comment|//    private<T> T transact(final Function<Txn, T> transactee) throws EXistException {
comment|//        final Txn existing = getCurrentTransaction();
comment|//        if(existing == null) {
comment|//            try(final Txn txn = pool.getTransactionManager().beginTransaction()) {
comment|//                return transactee.apply(txn);
comment|//            }
comment|//        } else {
comment|//            return transactee.apply(existing);
comment|//        }
comment|//    }
specifier|public
name|boolean
name|isTriggersEnabled
parameter_list|()
block|{
return|return
name|triggersEnabled
return|;
block|}
specifier|public
name|void
name|setTriggersEnabled
parameter_list|(
specifier|final
name|boolean
name|triggersEnabled
parameter_list|)
block|{
name|this
operator|.
name|triggersEnabled
operator|=
name|triggersEnabled
expr_stmt|;
block|}
comment|/**      * Represents a {@link Subject} change      * made to a broker      *      * Used for tracing subject changes      */
specifier|private
specifier|static
class|class
name|TraceableSubjectChange
extends|extends
name|TraceableStateChange
argument_list|<
name|Subject
argument_list|,
name|TraceableSubjectChange
operator|.
name|Change
argument_list|>
block|{
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
specifier|public
enum|enum
name|Change
block|{
name|PUSH
block|,
name|POP
block|}
specifier|private
name|TraceableSubjectChange
parameter_list|(
specifier|final
name|Change
name|change
parameter_list|,
specifier|final
name|Subject
name|subject
parameter_list|,
specifier|final
name|String
name|id
parameter_list|)
block|{
name|super
argument_list|(
name|change
argument_list|,
name|subject
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|describeState
parameter_list|()
block|{
return|return
name|getState
argument_list|()
operator|.
name|getName
argument_list|()
return|;
block|}
specifier|final
specifier|static
name|TraceableSubjectChange
name|push
parameter_list|(
specifier|final
name|Subject
name|subject
parameter_list|,
specifier|final
name|String
name|id
parameter_list|)
block|{
return|return
operator|new
name|TraceableSubjectChange
argument_list|(
name|Change
operator|.
name|PUSH
argument_list|,
name|subject
argument_list|,
name|id
argument_list|)
return|;
block|}
specifier|final
specifier|static
name|TraceableSubjectChange
name|pop
parameter_list|(
specifier|final
name|Subject
name|subject
parameter_list|,
specifier|final
name|String
name|id
parameter_list|)
block|{
return|return
operator|new
name|TraceableSubjectChange
argument_list|(
name|Change
operator|.
name|POP
argument_list|,
name|subject
argument_list|,
name|id
argument_list|)
return|;
block|}
block|}
comment|/**      * Indicates the behaviour for not preserving or      * preserving Collection of Document attributes      * when making a copy.      */
specifier|public
enum|enum
name|PreserveType
block|{
comment|/**          * Implies whatever the default is,          * as configured in conf.xml: /exist/db-connection/@preserve-on-copy          */
name|DEFAULT
block|,
comment|/**          * Collection or Document attributes are not preserved          * when making a copy.          */
name|NO_PRESERVE
block|,
comment|/**          * Collection or Document attributes are preserved          * when making a copy.          */
name|PRESERVE
block|}
block|}
end_class

end_unit

