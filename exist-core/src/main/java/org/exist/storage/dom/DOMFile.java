begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database  * Copyright (C) 2001-2007 The eXist team  * http://exist-db.org  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *    * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU Lesser General Public License for more details.  *   * You should have received a copy of the GNU Lesser General Public License  * along with this program; if not, write to the Free Software Foundation  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  *    *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Paged
operator|.
name|Page
operator|.
name|NO_PAGE
import|;
end_import

begin_import
import|import
name|it
operator|.
name|unimi
operator|.
name|dsi
operator|.
name|fastutil
operator|.
name|objects
operator|.
name|Reference2LongMap
import|;
end_import

begin_import
import|import
name|it
operator|.
name|unimi
operator|.
name|dsi
operator|.
name|fastutil
operator|.
name|objects
operator|.
name|Reference2LongOpenHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|ElementImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|IStoredNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|StoredNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|DLNBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|ExtendedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|EmbeddedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BufferStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|NativeBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|NativeBroker
operator|.
name|NodeRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|Signatures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|StorageAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cacheable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|LRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|JournalException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|LogEntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Loggable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Lsn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|LockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|FastByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|sanity
operator|.
name|SanityCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_comment
comment|/**  * This is the main storage for XML nodes. Nodes are stored in document order.  * Every document gets its own sequence of pages, which is bound to the writing  * thread to avoid conflicting writes. The page structure is as follows:  *  | page header | (tid1 node-data, tid2 node-data, ..., tidn node-data) |  *   * node-data contains the raw binary data of the node. Within a page, a node is  * identified by a unique id, called tuple id (tuple id). Every node can thus be  * located by a virtual address pointer, which consists of the page id and the  * tid. Both components are encoded in a long value (with additional bits used  * for optional flags). The address pointer is used to reference nodes from the  * indexes. It should thus remain unchanged during the life-time of a document.  *   * However, XUpdate requests may insert new nodes in the middle of a page. In  * these cases, the page will be split and the upper portion of the page is  * copied to a split page. The record in the original page will be replaced by a  * forward link, pointing to the new location of the node data in the split  * page.  *   * As a consequence, the class has to distinguish three different types of data  * records:  *   * 1) Ordinary record:  *  | tuple id | length | data |  *   * 3) Relocated record:  *  | tuple id | length | address pointer to original location | data |  *   * 2) Forward link:  *  | tuple id | address pointer |  *   * tuple id and length each use two bytes (short), address pointers 8 bytes (long).  * The upper two bits of the tuple id are used to indicate the type of the record  * (see {@link org.exist.storage.dom.ItemId}).  *   * @author<a href="mailto:wolfgang@exist-db.org">Wolfgang Meier</a>  */
end_comment

begin_class
specifier|public
class|class
name|DOMFile
extends|extends
name|BTree
implements|implements
name|Lockable
block|{
specifier|protected
specifier|final
specifier|static
name|Logger
name|LOGSTATS
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|NativeBroker
operator|.
name|EXIST_STATISTICS_LOGGER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FILE_NAME
init|=
literal|"dom.dbx"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CONFIG_KEY_FOR_FILE
init|=
literal|"db-connection.dom"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_TID
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_DATA_LENGTH
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_LINK
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_ORIGINAL_LOCATION
init|=
name|LENGTH_LINK
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_FORWARD_LOCATION
init|=
name|LENGTH_LINK
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_OVERFLOW_LOCATION
init|=
name|LENGTH_LINK
decl_stmt|;
comment|/*      * Byte ids for the records written to the log file.      */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_CREATE_PAGE
init|=
literal|0x10
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_ADD_VALUE
init|=
literal|0x11
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_VALUE
init|=
literal|0x12
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_EMPTY_PAGE
init|=
literal|0x13
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_VALUE
init|=
literal|0x14
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_PAGE
init|=
literal|0x15
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_WRITE_OVERFLOW
init|=
literal|0x16
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_OVERFLOW
init|=
literal|0x17
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_INSERT_RECORD
init|=
literal|0x18
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_SPLIT_PAGE
init|=
literal|0x19
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_ADD_LINK
init|=
literal|0x1A
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_ADD_MOVED_REC
init|=
literal|0x1B
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_HEADER
init|=
literal|0x1C
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_LINK
init|=
literal|0x1D
decl_stmt|;
static|static
block|{
comment|// register log entry types for this db file
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_CREATE_PAGE
argument_list|,
name|CreatePageLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_ADD_VALUE
argument_list|,
name|AddValueLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_VALUE
argument_list|,
name|RemoveValueLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_EMPTY_PAGE
argument_list|,
name|RemoveEmptyPageLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_VALUE
argument_list|,
name|UpdateValueLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_PAGE
argument_list|,
name|RemovePageLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_WRITE_OVERFLOW
argument_list|,
name|WriteOverflowPageLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_OVERFLOW
argument_list|,
name|RemoveOverflowLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_INSERT_RECORD
argument_list|,
name|InsertValueLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_SPLIT_PAGE
argument_list|,
name|SplitPageLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_ADD_LINK
argument_list|,
name|AddLinkLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_ADD_MOVED_REC
argument_list|,
name|AddMovedValueLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_HEADER
argument_list|,
name|UpdateHeaderLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_LINK
argument_list|,
name|UpdateLinkLoggable
operator|::
operator|new
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|static
name|short
name|FILE_FORMAT_VERSION_ID
init|=
literal|10
decl_stmt|;
specifier|private
specifier|final
name|LockManager
name|lockManager
decl_stmt|;
comment|//Page types
specifier|public
specifier|final
specifier|static
name|byte
name|LOB
init|=
literal|21
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|RECORD
init|=
literal|20
decl_stmt|;
comment|//Data length for overflow pages
specifier|public
specifier|final
specifier|static
name|short
name|OVERFLOW
init|=
literal|0
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|DATA_SYNC_PERIOD
init|=
literal|4200
decl_stmt|;
specifier|private
specifier|final
name|Cache
argument_list|<
name|DOMPage
argument_list|>
name|dataCache
decl_stmt|;
specifier|private
specifier|final
name|BTreeFileHeader
name|fileHeader
decl_stmt|;
specifier|private
name|Object
name|owner
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|Reference2LongMap
argument_list|<
name|Object
argument_list|>
name|pages
decl_stmt|;
specifier|private
name|DocumentImpl
name|currentDocument
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|AddValueLoggable
name|addValueLog
init|=
operator|new
name|AddValueLoggable
argument_list|()
decl_stmt|;
specifier|public
name|DOMFile
parameter_list|(
specifier|final
name|BrokerPool
name|pool
parameter_list|,
specifier|final
name|byte
name|id
parameter_list|,
specifier|final
name|Path
name|dataDir
parameter_list|,
specifier|final
name|Configuration
name|config
parameter_list|)
throws|throws
name|DBException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|id
argument_list|,
name|FILE_FORMAT_VERSION_ID
argument_list|,
literal|true
argument_list|,
name|pool
operator|.
name|getCacheManager
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockManager
operator|=
name|pool
operator|.
name|getLockManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|pages
operator|=
operator|new
name|Reference2LongOpenHashMap
argument_list|<>
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|this
operator|.
name|pages
operator|.
name|defaultReturnValue
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|fileHeader
operator|=
operator|(
name|BTreeFileHeader
operator|)
name|getFileHeader
argument_list|()
expr_stmt|;
name|fileHeader
operator|.
name|setPageCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|setTotalCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dataCache
operator|=
operator|new
name|LRUCache
argument_list|<>
argument_list|(
name|getFileName
argument_list|()
argument_list|,
literal|256
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
name|Cache
operator|.
name|CacheType
operator|.
name|DATA
argument_list|)
expr_stmt|;
name|cacheManager
operator|.
name|registerCache
argument_list|(
name|dataCache
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|file
init|=
name|dataDir
operator|.
name|resolve
argument_list|(
name|getFileName
argument_list|()
argument_list|)
decl_stmt|;
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
argument_list|()
condition|)
block|{
name|open
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating data file: "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|create
argument_list|()
expr_stmt|;
block|}
name|config
operator|.
name|setProperty
argument_list|(
name|getConfigKeyForFile
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the current page.      *       * @param page The new page      */
specifier|private
specifier|final
name|void
name|setCurrentPage
parameter_list|(
specifier|final
name|DOMPage
name|page
parameter_list|)
block|{
specifier|final
name|long
name|pageNum
init|=
name|pages
operator|.
name|getLong
argument_list|(
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageNum
operator|==
name|page
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
condition|)
block|{
return|return;
block|}
name|pages
operator|.
name|put
argument_list|(
name|owner
argument_list|,
name|page
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Retrieve the last page in the current sequence.      *       * @return The current page      */
specifier|private
specifier|final
name|DOMPage
name|getCurrentPage
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
block|{
specifier|final
name|long
name|pageNum
init|=
name|pages
operator|.
name|getLong
argument_list|(
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageNum
operator|==
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|page
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|pages
operator|.
name|put
argument_list|(
name|owner
argument_list|,
name|page
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|CreatePageLoggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|NO_PAGE
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|NO_PAGE
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
return|return
name|page
return|;
block|}
else|else
block|{
return|return
name|getDOMPage
argument_list|(
name|pageNum
argument_list|)
return|;
block|}
block|}
comment|/**      * Retrieve the current page      *       * @param pointer Description of the Parameter      * @return The current page      */
specifier|protected
specifier|final
name|DOMPage
name|getDOMPage
parameter_list|(
specifier|final
name|long
name|pointer
parameter_list|)
block|{
name|DOMPage
name|page
init|=
name|dataCache
operator|.
name|get
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|page
operator|=
operator|new
name|DOMPage
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
block|}
return|return
name|page
return|;
block|}
comment|/**      * Open the file.      *       * @return Description of the Return Value      * @throws DBException   Description of the Exception      */
specifier|public
name|boolean
name|open
parameter_list|()
throws|throws
name|DBException
block|{
return|return
name|super
operator|.
name|open
argument_list|(
name|FILE_FORMAT_VERSION_ID
argument_list|)
return|;
block|}
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
name|pages
operator|.
name|removeLong
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|getFileName
parameter_list|()
block|{
return|return
name|FILE_NAME
return|;
block|}
specifier|public
specifier|static
name|String
name|getConfigKeyForFile
parameter_list|()
block|{
return|return
name|CONFIG_KEY_FOR_FILE
return|;
block|}
specifier|public
specifier|synchronized
specifier|final
name|void
name|addToBuffer
parameter_list|(
specifier|final
name|DOMPage
name|page
parameter_list|)
block|{
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|Cache
name|getPageBuffer
parameter_list|()
block|{
return|return
name|dataCache
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|create
parameter_list|()
throws|throws
name|DBException
block|{
return|return
name|super
operator|.
name|create
argument_list|(
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|DBException
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|deregisterCache
argument_list|(
name|dataCache
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setCurrentDocument
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|this
operator|.
name|currentDocument
operator|=
name|doc
expr_stmt|;
block|}
comment|/**      * Append a value to the current page.      *       * This method is called when storing a new document. Each writing thread      * gets its own sequence of pages for writing a document, so all document      * nodes are stored in sequential order. A new page will be allocated if the      * current page is full. If the value is larger than the page size, it will      * be written to an overflow page.      *      * @param transaction the database transaction      * @param value the value to append      * @return the virtual storage address of the value      *      * @throws ReadOnlyException if the DOM file is read-only      */
specifier|public
name|long
name|add
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|KEY_NOT_FOUND
return|;
block|}
comment|// overflow value?
if|if
condition|(
name|value
operator|.
name|length
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating overflow page"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|OverflowDOMPage
name|overflowPage
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
name|overflowPage
operator|.
name|write
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|pageNum
init|=
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|overflowPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|transaction
argument_list|,
name|pageNum
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|add
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
comment|/**      * Append a value to the current page. If overflowPage is true, the value      * will be saved into its own, reserved chain of pages. The current page      * will just contain a link to the first overflow page.      *       * @param value the value      * @param overflowPage the overflow page      * @return the virtual storage address of the value      * @throws ReadOnlyException if the DOMFile is read-only      */
specifier|private
name|long
name|add
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|boolean
name|overflowPage
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|valueLength
init|=
name|value
operator|.
name|length
decl_stmt|;
comment|//Always append data to the end of the file
name|DOMPage
name|currentPage
init|=
name|getCurrentPage
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
comment|//Does the value fit into current data page?
if|if
condition|(
name|currentPage
operator|.
name|len
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|valueLength
operator|>
name|currentPage
operator|.
name|data
operator|.
name|length
condition|)
block|{
specifier|final
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|currentPageHeader
init|=
name|currentPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|UpdateHeaderLoggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|currentPageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|currentPageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|currentPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|currentPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|currentPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|currentPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|CreatePageLoggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|currentPage
operator|==
literal|null
condition|?
name|NO_PAGE
else|:
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|NO_PAGE
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|newPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|currentPage
operator|=
name|newPage
expr_stmt|;
name|setCurrentPage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DOMFilePageHeader
name|currentPageHeader
init|=
name|currentPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|short
name|tupleID
init|=
name|currentPageHeader
operator|.
name|getNextTupleID
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
name|addValueLog
operator|.
name|clear
argument_list|(
name|transaction
argument_list|,
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tupleID
argument_list|,
name|value
argument_list|,
name|overflowPage
argument_list|)
expr_stmt|;
name|writeToLog
argument_list|(
name|addValueLog
argument_list|,
name|currentPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
comment|//Save tuple identifier
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tupleID
argument_list|,
name|currentPage
operator|.
name|data
argument_list|,
name|currentPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
comment|//Save data length
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|overflowPage
condition|?
name|OVERFLOW
else|:
operator|(
name|short
operator|)
name|valueLength
argument_list|,
name|currentPage
operator|.
name|data
argument_list|,
name|currentPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|len
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|//Save data
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|currentPage
operator|.
name|data
argument_list|,
name|currentPage
operator|.
name|len
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|len
operator|+=
name|valueLength
expr_stmt|;
name|currentPageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|currentPageHeader
operator|.
name|setDataLength
argument_list|(
name|currentPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|currentPage
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// return pointer from pageNum and offset into page
return|return
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tupleID
argument_list|)
return|;
block|}
specifier|private
name|void
name|writeToLog
parameter_list|(
specifier|final
name|Loggable
name|loggable
parameter_list|,
specifier|final
name|Page
name|page
parameter_list|)
block|{
if|if
condition|(
name|logManager
operator|.
name|isPresent
argument_list|()
condition|)
block|{
try|try
block|{
name|logManager
operator|.
name|get
argument_list|()
operator|.
name|journal
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|JournalException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Store a raw binary resource into the file. The data will always be      * written into an overflow page.      *      * @param transaction the database transaction      * @param doc the document to add      * @param value Binary resource as byte array      *      * @return the page number      */
specifier|public
name|long
name|addBinary
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|OverflowDOMPage
name|overflowPage
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pagesCount
init|=
name|overflowPage
operator|.
name|write
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setPageCount
argument_list|(
name|pagesCount
argument_list|)
expr_stmt|;
return|return
name|overflowPage
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/**      * Store a raw binary resource into the file. The data will always be      * written into an overflow page.      *      * @param transaction the transaction      * @param doc the document to add      * @param is Binary resource as stream.      *      * @return the page number      */
specifier|public
name|long
name|addBinary
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|OverflowDOMPage
name|overflowPage
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pagesCount
init|=
name|overflowPage
operator|.
name|write
argument_list|(
name|transaction
argument_list|,
name|is
argument_list|)
decl_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setPageCount
argument_list|(
name|pagesCount
argument_list|)
expr_stmt|;
return|return
name|overflowPage
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/**      * Return binary data stored with {@link #addBinary(Txn, DocumentImpl, byte[])}.      *       * @param pageNum the page number      * @return binary data stored      */
specifier|public
name|byte
index|[]
name|getBinary
parameter_list|(
specifier|final
name|long
name|pageNum
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
return|return
name|getOverflowValue
argument_list|(
name|pageNum
argument_list|)
return|;
block|}
specifier|public
name|void
name|readBinary
parameter_list|(
specifier|final
name|long
name|pageNum
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|OverflowDOMPage
name|overflowPage
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|pageNum
argument_list|)
decl_stmt|;
name|overflowPage
operator|.
name|streamTo
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO error while loading overflow value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Insert a new node after the specified node.      *      * @param transaction the database transaction      * @param doc the document      * @param key the key      * @param value the value      *      * @return the storage address pointer      */
specifier|public
name|long
name|insertAfter
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|long
name|address
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't find the value"
argument_list|)
expr_stmt|;
return|return
name|KEY_NOT_FOUND
return|;
block|}
return|return
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|address
argument_list|,
name|value
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"key not found"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO error"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|KEY_NOT_FOUND
return|;
block|}
comment|/**      * Insert a new node after the node located at the specified address.      *       * If the previous node is in the middle of a page, the page is split. If      * the node is appended at the end and the page does not have enough room      * for the node, a new page is added to the page sequence.      *      * @param transaction the database transaction      * @param doc       the document to which the new node belongs.      * @param address   the storage address of the node after which the       *                  new value should be inserted.      * @param value     the value of the new node.      *      * @return the storage address pointer      */
specifier|public
name|long
name|insertAfter
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|long
name|address
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
comment|// check if we need an overflow page
name|boolean
name|isOverflow
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
specifier|final
name|OverflowDOMPage
name|overflowPage
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating overflow page: "
operator|+
name|overflowPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|overflowPage
operator|.
name|write
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|overflowPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|isOverflow
operator|=
literal|true
expr_stmt|;
block|}
comment|// locate the node to insert after
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|rec
operator|==
literal|null
condition|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Page not found"
argument_list|)
expr_stmt|;
return|return
name|KEY_NOT_FOUND
return|;
block|}
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
if|if
condition|(
name|vlen
operator|==
name|OVERFLOW
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_OVERFLOW_LOCATION
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|.
name|offset
operator|+=
name|vlen
expr_stmt|;
block|}
comment|//OK : we now have an offset for the new node
specifier|final
name|int
name|dataLength
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|//Can we insert in the middle of the page?
if|if
condition|(
name|rec
operator|.
name|offset
operator|<
name|dataLength
condition|)
block|{
comment|//New value fits into the page
if|if
condition|(
name|dataLength
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
operator|<=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|&&
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|hasRoom
argument_list|()
condition|)
block|{
specifier|final
name|int
name|end
init|=
name|rec
operator|.
name|offset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|dataLength
operator|-
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|dataLength
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
comment|//Doesn't fit: split the page
block|}
else|else
block|{
name|rec
operator|=
name|splitDataPage
argument_list|(
name|transaction
argument_list|,
name|rec
argument_list|)
expr_stmt|;
comment|//Still not enough free space: create a new page
if|if
condition|(
name|rec
operator|.
name|offset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|||
operator|!
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|hasRoom
argument_list|()
condition|)
block|{
specifier|final
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating additional page: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; prev = "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; next = "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|CreatePageLoggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|newPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
comment|//Adjust page links
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|UpdateHeaderLoggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newPageHeader
operator|.
name|getNextDataPage
argument_list|()
operator|!=
name|NO_PAGE
condition|)
block|{
comment|//Link the next page in the chain back to the new page inserted
specifier|final
name|DOMPage
name|nextPage
init|=
name|getDOMPage
argument_list|(
name|newPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|nextPageHeader
init|=
name|nextPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|UpdateHeaderLoggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|nextPageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|nextPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
comment|//Switch record to new page...
name|rec
operator|.
name|setPage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
comment|//enough space in split page
block|}
else|else
block|{
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|rec
operator|.
name|offset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|//The value doesn't fit into page : create new page
block|}
if|else if
condition|(
name|dataLength
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|||
operator|!
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|hasRoom
argument_list|()
condition|)
block|{
specifier|final
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating new page: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|CreatePageLoggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|newPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|nextPageNum
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
decl_stmt|;
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|nextPageNum
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|UpdateHeaderLoggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextPageNum
operator|!=
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|nextPage
init|=
name|getDOMPage
argument_list|(
name|nextPageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|nextPageHeader
init|=
name|nextPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|UpdateHeaderLoggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|nextPageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|nextPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
comment|//Switch record to new page
name|rec
operator|.
name|setPage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
comment|//Append the value
block|}
else|else
block|{
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|dataLength
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
specifier|final
name|short
name|tupleID
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextTupleID
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|InsertValueLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|isOverflow
argument_list|,
name|tupleID
argument_list|,
name|value
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
comment|//Write tid
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tupleID
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_TID
expr_stmt|;
comment|//Write value length
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|isOverflow
condition|?
name|OVERFLOW
else|:
operator|(
name|short
operator|)
name|value
operator|.
name|length
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|//Write data
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
operator|&&
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getCurrentTupleID
argument_list|()
operator|>=
name|ItemId
operator|.
name|DEFRAG_LIMIT
condition|)
block|{
name|doc
operator|.
name|triggerDefrag
argument_list|()
expr_stmt|;
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tupleID
argument_list|)
return|;
block|}
comment|/**      * Split a data page at the position indicated by the rec parameter.      *       * The portion of the page starting at rec.offset is moved into a new page.      * Every moved record is marked as relocated and a link is stored into the      * original page to point to the new record position.      *      * @param transaction the database transaction      * @param rec the record position      *      * @return the updated record position      */
specifier|private
name|RecordPos
name|splitDataPage
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|RecordPos
name|rec
parameter_list|)
block|{
if|if
condition|(
name|currentDocument
operator|!=
literal|null
condition|)
block|{
name|currentDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|incSplitCount
argument_list|()
expr_stmt|;
block|}
comment|//Check if a split is really required. A split is not required if
comment|//all records following the split point are already links to other pages.
comment|//In this case, the new record is just appended to a new page linked to the old one.
name|boolean
name|requireSplit
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
name|rec
operator|.
name|offset
init|;
name|pos
operator|<
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
condition|;
control|)
block|{
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_TID
expr_stmt|;
if|if
condition|(
operator|!
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|requireSplit
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|pos
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|requireSplit
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"page: "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": no split required."
operator|+
literal|" Next page:"
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
operator|+
literal|" Previous page:"
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
expr_stmt|;
return|return
name|rec
return|;
block|}
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
comment|//Copy the old data up to the split point into a new array
specifier|final
name|int
name|oldDataLen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|oldData
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|SplitPageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|oldData
argument_list|,
name|oldDataLen
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
comment|//The old rec.page now contains a copy of the data up to the split point
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|rec
operator|.
name|offset
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//Create a first split page
name|DOMPage
name|firstSplitPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|firstSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|NO_PAGE
argument_list|,
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|firstSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|DOMPage
name|nextSplitPage
init|=
name|firstSplitPage
decl_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextTupleID
argument_list|(
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|backLink
decl_stmt|;
name|short
name|splitRecordCount
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Splitting "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" at "
operator|+
name|rec
operator|.
name|offset
operator|+
literal|": New page: "
operator|+
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; Next page: "
operator|+
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
comment|//Start copying records from rec.offset to the new split pages
for|for
control|(
name|int
name|pos
init|=
name|rec
operator|.
name|offset
init|;
name|pos
operator|<
name|oldDataLen
condition|;
name|splitRecordCount
operator|++
control|)
block|{
comment|//Read the current id
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_TID
expr_stmt|;
comment|//This is already a link, so we just copy it
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
comment|/* No room in the old page, append a new one */
if|if
condition|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_FORWARD_LOCATION
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
specifier|final
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|firstSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
name|loggable
operator|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|newPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Appending page after split: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
name|countRecordsInPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
comment|//Switch record to new page...
name|rec
operator|.
name|setPage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|long
name|oldLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
decl_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|AddLinkLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
argument_list|,
name|oldLink
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tupleID
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|,
name|LENGTH_FORWARD_LOCATION
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
name|pos
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
continue|continue;
block|}
comment|//Read data length
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|//If this is an overflow page, the real data length is always
comment|//LENGTH_LINK byte for the page number of the overflow page
specifier|final
name|short
name|realLen
init|=
operator|(
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_OVERFLOW_LOCATION
else|:
name|vlen
operator|)
decl_stmt|;
comment|//Check if we have room in the current split page
if|if
condition|(
name|nextSplitPage
operator|.
name|len
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|realLen
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|//Not enough room in the split page: append a new page
specifier|final
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|NO_PAGE
argument_list|,
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|firstSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
name|loggable
operator|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|newPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
comment|//No next page ? Well... we might want to enforce the value -pb
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating new split page: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
name|splitRecordCount
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
name|nextSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextSplitPage
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|=
name|newPage
expr_stmt|;
name|splitRecordCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/*              * If the record has already been relocated,               * read the original storage address and update the link there.              */
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|backLink
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
specifier|final
name|RecordPos
name|originalRecordPos
init|=
name|findRecord
argument_list|(
name|backLink
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|long
name|oldLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|originalRecordPos
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|originalRecordPos
operator|.
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|long
name|forwardLink
init|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateLinkLoggable
argument_list|(
name|transaction
argument_list|,
name|originalRecordPos
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|originalRecordPos
operator|.
name|offset
argument_list|,
name|forwardLink
argument_list|,
name|oldLink
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|originalRecordPos
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|forwardLink
argument_list|,
name|originalRecordPos
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|originalRecordPos
operator|.
name|offset
argument_list|)
expr_stmt|;
name|originalRecordPos
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|originalRecordPos
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|backLink
operator|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*              * Save the record to the split page:             */
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
comment|//What does this "log" mean really ? Original ? -pb
specifier|final
name|byte
index|[]
name|logData
init|=
operator|new
name|byte
index|[
name|realLen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|,
name|logData
argument_list|,
literal|0
argument_list|,
name|realLen
argument_list|)
expr_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|AddMovedValueLoggable
argument_list|(
name|transaction
argument_list|,
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tupleID
argument_list|,
name|logData
argument_list|,
name|backLink
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
comment|//Set the relocated flag and save the item id
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|ItemId
operator|.
name|setIsRelocated
argument_list|(
name|tupleID
argument_list|)
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
comment|//Save length field
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|vlen
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|len
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|//Save link to the original page
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|backLink
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|len
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
comment|//Now save the data
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|,
name|realLen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"pos = "
operator|+
name|pos
operator|+
literal|"; len = "
operator|+
name|nextSplitPage
operator|.
name|len
operator|+
literal|"; currentLen = "
operator|+
name|realLen
operator|+
literal|"; tupleID = "
operator|+
name|tupleID
operator|+
literal|"; page = "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|nextSplitPage
operator|.
name|len
operator|+=
name|realLen
expr_stmt|;
name|pos
operator|+=
name|realLen
expr_stmt|;
comment|// save a link pointer in the original page if the record has not
comment|// been relocated before.
if|if
condition|(
operator|!
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
comment|// the link doesn't fit into the old page. Append a new page
if|if
condition|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_FORWARD_LOCATION
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
specifier|final
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|firstSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
name|loggable
operator|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|newPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|pageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating new page after split: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
name|countRecordsInPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
comment|//switch record to new page...
name|rec
operator|.
name|setPage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|forwardLink
init|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|AddLinkLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tupleID
argument_list|,
name|forwardLink
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|ItemId
operator|.
name|setIsLink
argument_list|(
name|tupleID
argument_list|)
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|forwardLink
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
block|}
comment|//End of for loop: finished copying data
comment|//Link the split pages to the original page
if|if
condition|(
name|nextSplitPage
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Page "
operator|+
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" is empty. Remove it"
argument_list|)
expr_stmt|;
comment|//If nothing has been copied to the last split page, remove it
if|if
condition|(
name|nextSplitPage
operator|==
name|firstSplitPage
condition|)
block|{
name|firstSplitPage
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
name|unlinkPages
argument_list|(
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove empty split page: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|nextSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|nextSplitPage
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
name|splitRecordCount
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
name|nextSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextSplitPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|DOMFilePageHeader
name|fisrtPageHeader
init|=
name|firstSplitPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|firstSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|fisrtPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|fisrtPageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|fisrtPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|firstSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextSplitPage
operator|!=
name|firstSplitPage
condition|)
block|{
name|firstSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|firstSplitPage
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|long
name|nextPageNum
init|=
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|NO_PAGE
operator|!=
name|nextPageNum
condition|)
block|{
specifier|final
name|DOMPage
name|nextPage
init|=
name|getDOMPage
argument_list|(
name|nextPageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|NO_PAGE
argument_list|,
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|setPage
argument_list|(
name|getDOMPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstSplitPage
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateHeaderLoggable
argument_list|(
name|transaction
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|firstSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|firstSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
name|countRecordsInPage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
expr_stmt|;
return|return
name|rec
return|;
block|}
comment|/**      * Returns the number of records stored in a page.      *       * @param page the page      * @return The number of records      */
specifier|private
name|short
name|countRecordsInPage
parameter_list|(
specifier|final
name|DOMPage
name|page
parameter_list|)
block|{
name|short
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|dataLength
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dataLength
condition|;
name|count
operator|++
control|)
block|{
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_TID
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|LENGTH_OVERFLOW_LOCATION
else|:
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|vlen
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_OVERFLOW_LOCATION
else|:
name|vlen
expr_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
specifier|public
name|String
name|debugPageContents
parameter_list|(
specifier|final
name|DOMPage
name|page
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Page "
argument_list|)
operator|.
name|append
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|short
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|dataLength
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dataLength
condition|;
name|count
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|pos
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_TID
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"R"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
specifier|final
name|long
name|forwardLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|forwardLink
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|short
name|valueLength
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|valueLength
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Illegal length: "
operator|+
name|valueLength
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|append
argument_list|(
literal|"[Illegal length : "
argument_list|)
operator|.
name|append
argument_list|(
name|valueLength
argument_list|)
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
operator|.
name|toString
argument_list|()
return|;
comment|//Probably unable to continue...
block|}
if|else if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
comment|//TODO : output to buffer ?
name|pos
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Signatures
operator|.
name|getType
argument_list|(
name|page
operator|.
name|data
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"element "
argument_list|)
expr_stmt|;
name|int
name|readOffset
init|=
name|pos
decl_stmt|;
name|readOffset
operator|+=
literal|1
expr_stmt|;
specifier|final
name|int
name|children
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|ElementImpl
operator|.
name|LENGTH_ELEMENT_CHILD_COUNT
expr_stmt|;
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
comment|//That might happen during recovery runs : TODO, investigate
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"(Can't read data, owner is null)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
specifier|final
name|NodeId
name|nodeId
init|=
operator|(
operator|(
name|NativeBroker
operator|)
name|owner
operator|)
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|createFromData
argument_list|(
name|dlnLen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeId
operator|.
name|size
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|nodeId
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
specifier|final
name|short
name|attributes
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" children: "
argument_list|)
operator|.
name|append
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" attributes: "
argument_list|)
operator|.
name|append
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
comment|//TODO : more friendly message. Provide the array of bytes ?
name|buf
operator|.
name|append
argument_list|(
literal|"(Unable to read the node ID at: "
argument_list|)
operator|.
name|append
argument_list|(
name|readOffset
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" children : "
argument_list|)
operator|.
name|append
argument_list|(
name|children
argument_list|)
expr_stmt|;
comment|//Probably a wrong offset so... don't read it
name|buf
operator|.
name|append
argument_list|(
literal|" attributes : unknown"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
case|case
name|Node
operator|.
name|CDATA_SECTION_NODE
case|:
block|{
if|if
condition|(
name|Signatures
operator|.
name|getType
argument_list|(
name|page
operator|.
name|data
index|[
name|pos
index|]
argument_list|)
operator|==
name|Node
operator|.
name|TEXT_NODE
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"text "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"CDATA "
argument_list|)
expr_stmt|;
block|}
name|int
name|readOffset
init|=
name|pos
decl_stmt|;
name|readOffset
operator|+=
literal|1
expr_stmt|;
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
comment|//That might happen during recovery runs : TODO, investigate
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"(Can't read data, owner is null)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
specifier|final
name|NodeId
name|nodeId
init|=
operator|(
operator|(
name|NativeBroker
operator|)
name|owner
operator|)
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|createFromData
argument_list|(
name|dlnLen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeId
operator|.
name|size
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|nodeId
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|String
name|value
init|=
operator|new
name|String
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|,
name|valueLength
operator|-
operator|(
name|readOffset
operator|-
name|pos
operator|)
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|length
argument_list|()
operator|>
literal|15
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
operator|+
literal|"..."
operator|+
name|value
operator|.
name|substring
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|":'"
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
comment|//TODO : more friendly message. Provide the array of bytes ?
name|buf
operator|.
name|append
argument_list|(
literal|"(unable to read the node ID at : "
argument_list|)
operator|.
name|append
argument_list|(
name|readOffset
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"attribute "
argument_list|)
expr_stmt|;
name|int
name|readOffset
init|=
name|pos
decl_stmt|;
specifier|final
name|byte
name|idSizeType
init|=
operator|(
name|byte
operator|)
operator|(
name|page
operator|.
name|data
index|[
name|readOffset
index|]
operator|&
literal|0x3
operator|)
decl_stmt|;
specifier|final
name|boolean
name|hasNamespace
init|=
operator|(
name|page
operator|.
name|data
index|[
name|readOffset
index|]
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
decl_stmt|;
name|readOffset
operator|+=
literal|1
expr_stmt|;
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
comment|//That might happen during recovery runs : TODO, investigate
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"(can't read data, owner is null)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
specifier|final
name|NodeId
name|nodeId
init|=
operator|(
operator|(
name|NativeBroker
operator|)
name|owner
operator|)
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|createFromData
argument_list|(
name|dlnLen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeId
operator|.
name|size
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|nodeId
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|readOffset
operator|+=
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNamespace
condition|)
block|{
comment|//Untested
specifier|final
name|short
name|NSId
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|AttrImpl
operator|.
name|LENGTH_NS_ID
expr_stmt|;
specifier|final
name|short
name|prefixLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|AttrImpl
operator|.
name|LENGTH_PREFIX_LENGTH
operator|+
name|prefixLen
expr_stmt|;
specifier|final
name|String
name|prefix
init|=
operator|new
name|String
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|,
name|valueLength
operator|-
operator|(
name|readOffset
operator|-
name|prefixLen
operator|)
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
specifier|final
name|String
name|NsURI
init|=
operator|(
operator|(
name|NativeBroker
operator|)
name|owner
operator|)
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSymbols
argument_list|()
operator|.
name|getNamespace
argument_list|(
name|NSId
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
operator|.
name|append
argument_list|(
name|NsURI
argument_list|)
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|String
name|value
init|=
operator|new
name|String
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|readOffset
argument_list|,
name|valueLength
operator|-
operator|(
name|readOffset
operator|-
name|pos
operator|)
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|length
argument_list|()
operator|>
literal|15
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
operator|+
literal|"..."
operator|+
name|value
operator|.
name|substring
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|":'"
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
comment|//TODO : more friendly message. Provide the array of bytes ?
name|buf
operator|.
name|append
argument_list|(
literal|"(unable to read the node ID at : "
argument_list|)
operator|.
name|append
argument_list|(
name|readOffset
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|buf
operator|.
name|append
argument_list|(
literal|"Unknown node type !"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|valueLength
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"; records in page: "
argument_list|)
operator|.
name|append
argument_list|(
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|" (header says: "
argument_list|)
operator|.
name|append
argument_list|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getRecordCount
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"; currentTupleID: "
argument_list|)
operator|.
name|append
argument_list|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"; data length: "
argument_list|)
operator|.
name|append
argument_list|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|page
operator|.
name|data
operator|.
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|page
operator|.
name|data
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" (last non-zero byte: "
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
specifier|final
name|int
name|pageSize
parameter_list|)
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
literal|1024
argument_list|,
name|pageSize
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|unlinkPages
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|PageHeader
name|createPageHeader
parameter_list|()
block|{
return|return
operator|new
name|DOMFilePageHeader
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|Value
argument_list|>
name|findKeys
parameter_list|(
specifier|final
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FindCallback
name|callBack
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|KEYS
argument_list|)
decl_stmt|;
try|try
block|{
name|query
argument_list|(
name|query
argument_list|,
name|callBack
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
comment|// Should never happen here
name|LOG
operator|.
name|error
argument_list|(
literal|"Method terminated"
argument_list|)
expr_stmt|;
block|}
return|return
name|callBack
operator|.
name|getValues
argument_list|()
return|;
block|}
comment|/**      * Retrieve node at virtual address.      *      * @param broker the database broker      * @param node The virtual address      * @return The reference of the node      * @throws IOException if an I/O error occurs      * @throws BTreeException if an error occurs reading the tree      */
specifier|protected
name|long
name|findValue
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|NodeProxy
name|node
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|NodeRef
name|nodeRef
init|=
operator|new
name|NativeBroker
operator|.
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
comment|// first try to find the node in the index
specifier|final
name|long
name|pointer
init|=
name|findValue
argument_list|(
name|nodeRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointer
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
comment|// node not found in index: try to find the nearest available
comment|// ancestor and traverse it
name|NodeId
name|nodeID
init|=
name|node
operator|.
name|getNodeId
argument_list|()
decl_stmt|;
name|long
name|parentPointer
init|=
name|KEY_NOT_FOUND
decl_stmt|;
do|do
block|{
name|nodeID
operator|=
name|nodeID
operator|.
name|getParentId
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeID
operator|==
literal|null
condition|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Node "
operator|+
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|":"
operator|+
name|nodeID
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Node not found."
argument_list|)
throw|;
block|}
if|if
condition|(
name|nodeID
operator|==
name|NodeId
operator|.
name|DOCUMENT_NODE
condition|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Node "
operator|+
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|":"
operator|+
name|nodeID
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
return|return
name|KEY_NOT_FOUND
return|;
block|}
specifier|final
name|NativeBroker
operator|.
name|NodeRef
name|parentRef
init|=
operator|new
name|NativeBroker
operator|.
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|nodeID
argument_list|)
decl_stmt|;
try|try
block|{
name|parentPointer
operator|=
name|findValue
argument_list|(
name|parentRef
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"report me"
argument_list|,
name|bte
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|parentPointer
operator|==
name|KEY_NOT_FOUND
condition|)
do|;
try|try
block|{
specifier|final
name|int
name|thisLevel
init|=
name|nodeID
operator|.
name|getTreeLevel
argument_list|()
decl_stmt|;
name|Integer
name|childLevel
init|=
literal|null
decl_stmt|;
comment|// lazily initialized below
specifier|final
name|NodeProxy
name|parent
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|nodeID
argument_list|,
name|parentPointer
argument_list|)
decl_stmt|;
specifier|final
name|EmbeddedXMLStreamReader
name|reader
init|=
operator|(
name|EmbeddedXMLStreamReader
operator|)
name|broker
operator|.
name|getXMLStreamReader
argument_list|(
name|parent
argument_list|,
literal|true
argument_list|)
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|int
name|status
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|XMLStreamReader
operator|.
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|childLevel
operator|==
literal|null
condition|)
block|{
name|childLevel
operator|=
name|reader
operator|.
name|getNode
argument_list|()
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|?
name|thisLevel
operator|+
literal|1
else|:
name|thisLevel
expr_stmt|;
block|}
specifier|final
name|NodeId
name|otherId
init|=
operator|(
name|NodeId
operator|)
name|reader
operator|.
name|getProperty
argument_list|(
name|ExtendedXMLStreamReader
operator|.
name|PROPERTY_NODE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherId
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|reader
operator|.
name|getCurrentPosition
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|XMLStreamConstants
operator|.
name|END_ELEMENT
condition|)
block|{
specifier|final
name|NodeId
name|otherId
init|=
operator|(
name|NodeId
operator|)
name|reader
operator|.
name|getProperty
argument_list|(
name|ExtendedXMLStreamReader
operator|.
name|PROPERTY_NODE_ID
argument_list|)
decl_stmt|;
specifier|final
name|int
name|otherLevel
init|=
name|otherId
operator|.
name|getTreeLevel
argument_list|()
decl_stmt|;
if|if
condition|(
name|childLevel
operator|!=
literal|null
operator|&&
name|childLevel
operator|!=
name|otherLevel
operator|&&
name|otherLevel
operator|==
name|thisLevel
condition|)
block|{
comment|// finished `this` element...
break|break;
comment|// exit-while
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" could not be found. Giving up. This is usually not an error."
argument_list|)
expr_stmt|;
block|}
return|return
name|KEY_NOT_FOUND
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|XMLStreamException
name|e
parameter_list|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Node "
operator|+
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Node "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|pointer
return|;
block|}
block|}
comment|/**      * Find matching nodes for the given query.      *       * @param query Description of the Parameter      * @return Description of the Return Value      * @throws IOException Description of the Exception      * @throws BTreeException Description of the Exception      */
specifier|public
name|List
argument_list|<
name|Value
argument_list|>
name|findValues
parameter_list|(
specifier|final
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FindCallback
name|callBack
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|VALUES
argument_list|)
decl_stmt|;
try|try
block|{
name|query
argument_list|(
name|query
argument_list|,
name|callBack
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
comment|// Should never happen
name|LOG
operator|.
name|warn
argument_list|(
literal|"Method terminated"
argument_list|)
expr_stmt|;
block|}
return|return
name|callBack
operator|.
name|getValues
argument_list|()
return|;
block|}
comment|/**      * Flush all buffers to disk.      *      * @return true if the buffers were flushed      * @throws DBException if an error occurs      */
annotation|@
name|Override
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|DBException
block|{
name|boolean
name|flushed
init|=
literal|false
decl_stmt|;
comment|//TODO : record transaction as a valuable flush ?
if|if
condition|(
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
name|logManager
operator|.
name|get
argument_list|()
operator|.
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BrokerPool
operator|.
name|FORCE_CORRUPTION
condition|)
block|{
name|flushed
operator|=
name|flushed
operator||
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
name|flushed
operator|=
name|flushed
operator||
name|dataCache
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
name|flushed
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
name|super
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
specifier|final
name|NumberFormat
name|nf1
init|=
name|NumberFormat
operator|.
name|getPercentInstance
argument_list|()
decl_stmt|;
specifier|final
name|NumberFormat
name|nf2
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|FileUtils
operator|.
name|fileName
argument_list|(
name|getFile
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" DATA "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Buffers occupation : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
operator|==
literal|0
operator|&&
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
operator|==
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|nf1
operator|.
name|format
argument_list|(
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
operator|/
operator|(
name|float
operator|)
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
operator|.
name|append
argument_list|(
name|nf2
operator|.
name|format
argument_list|(
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" out of "
argument_list|)
operator|.
name|append
argument_list|(
name|nf2
operator|.
name|format
argument_list|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Cache efficiency : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataCache
operator|.
name|getHits
argument_list|()
operator|==
literal|0
operator|&&
name|dataCache
operator|.
name|getFails
argument_list|()
operator|==
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|nf1
operator|.
name|format
argument_list|(
name|dataCache
operator|.
name|getHits
argument_list|()
operator|/
operator|(
name|float
operator|)
operator|(
name|dataCache
operator|.
name|getFails
argument_list|()
operator|+
name|dataCache
operator|.
name|getHits
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOGSTATS
operator|.
name|info
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BufferStats
name|getDataBufferStats
parameter_list|()
block|{
return|return
operator|new
name|BufferStats
argument_list|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getHits
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getFails
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Retrieve a node by key      *       * @param key the key      * @return the value, or null      */
specifier|public
name|Value
name|get
parameter_list|(
specifier|final
name|Value
name|key
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|long
name|pointer
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointer
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Value not found : "
operator|+
name|key
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|get
argument_list|(
name|pointer
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|Value
name|get
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|NodeProxy
name|node
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|long
name|pointer
init|=
name|findValue
argument_list|(
name|broker
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointer
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|get
argument_list|(
name|pointer
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Retrieve node at virtual address.      *       * @param pointer The virtual address      * @return The node      */
specifier|public
name|Value
name|get
parameter_list|(
specifier|final
name|long
name|pointer
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|pointer
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Retrieve node at virtual address.      *       * @param pointer The virtual address      * @param warnIfMissing Whether or not a warning should be output       * if the node can not be found       * @return The node      */
specifier|public
name|Value
name|get
parameter_list|(
specifier|final
name|long
name|pointer
parameter_list|,
specifier|final
name|boolean
name|warnIfMissing
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|rec
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|warnIfMissing
condition|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Object at "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|pointer
argument_list|)
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
block|}
comment|//TODO : throw exception ?
return|return
literal|null
return|;
block|}
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
specifier|final
name|Value
name|value
decl_stmt|;
if|if
condition|(
name|vlen
operator|==
name|OVERFLOW
condition|)
block|{
specifier|final
name|long
name|pageNo
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|getOverflowValue
argument_list|(
name|pageNo
argument_list|)
decl_stmt|;
name|value
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|new
name|Value
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
name|value
operator|.
name|setAddress
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|dumpValue
parameter_list|(
specifier|final
name|Writer
name|writer
parameter_list|,
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|int
name|status
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|status
operator|==
name|BRANCH
condition|)
block|{
name|super
operator|.
name|dumpValue
argument_list|(
name|writer
argument_list|,
name|key
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|writer
operator|.
name|write
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|,
name|key
operator|.
name|start
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|int
name|bytes
init|=
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|4
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|key
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|DLNBase
operator|.
name|toBitString
argument_list|(
name|data
index|[
name|key
operator|.
name|start
argument_list|()
operator|+
literal|4
operator|+
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|": doc: "
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|,
name|key
operator|.
name|start
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Put a new key/value pair.      *      * @param transaction the database transaction      * @param key the key      * @param value the value      * @return pointer to the address      *      * @throws ReadOnlyException if the DOM file is read-only      */
specifier|public
name|long
name|put
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|pointer
init|=
name|add
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
decl_stmt|;
try|try
block|{
name|addValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|//TODO : throw exception ?
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|KEY_NOT_FOUND
return|;
block|}
return|return
name|pointer
return|;
block|}
comment|/**      * Physically remove a node. The data of the node will be removed from the      * page and the occupied space is freed.      *      * @param transaction the database transaction      * @param key the key      */
specifier|public
name|void
name|remove
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Value
name|key
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|long
name|pointer
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointer
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
comment|//TODO : throw exception ?
name|LOG
operator|.
name|error
argument_list|(
literal|"Value not found: "
operator|+
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|//TODO : throw exception ?
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|byte
index|[]
name|getOverflowValue
parameter_list|(
specifier|final
name|long
name|pointer
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
return|return
name|overflow
operator|.
name|read
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IO error while loading overflow value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ?
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Remove the overflow value.      *       * @param transaction The current transaction      * @param pointer The pointer to the value      */
specifier|public
name|void
name|removeOverflowValue
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|overflow
operator|.
name|delete
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO error while removing overflow value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Remove the link at the specified position from the file.      *      * @param transaction the current transaction      * @param pointer The pointer to the value      */
specifier|private
name|void
name|removeLink
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
block|{
specifier|final
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|LENGTH_LINK
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|LENGTH_LINK
argument_list|)
expr_stmt|;
comment|//Position the stream at the very beginning of the record
specifier|final
name|RemoveValueLoggable
name|loggable
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|,
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
argument_list|,
name|data
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|end
init|=
name|rec
operator|.
name|offset
operator|+
name|LENGTH_LINK
decl_stmt|;
comment|//Position the stream at the very beginning of the record
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_LINK
operator|)
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Page length< 0"
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pageHeader
operator|.
name|getRecordCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Empty page seems to have record!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|RemoveEmptyPageLoggable
name|loggable
init|=
operator|new
name|RemoveEmptyPageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|removePage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|setPage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Physically remove a node. The data of the node will be removed from the      * page and the occupied space is freed.      *      * @param transaction the database transaction      * @param pointer pointer to the node      */
specifier|public
name|void
name|removeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
comment|//Position the stream at the very beginning of the record
specifier|final
name|int
name|startOffset
init|=
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
name|short
name|realLen
init|=
name|vlen
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot remove link ..."
argument_list|)
throw|;
block|}
name|boolean
name|isOverflow
init|=
literal|false
decl_stmt|;
name|long
name|backLink
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|backLink
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
name|realLen
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
name|removeLink
argument_list|(
name|transaction
argument_list|,
name|backLink
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vlen
operator|==
name|OVERFLOW
condition|)
block|{
comment|// remove overflow value
name|isOverflow
operator|=
literal|true
expr_stmt|;
specifier|final
name|long
name|overflowLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_OVERFLOW_LOCATION
expr_stmt|;
try|try
block|{
specifier|final
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|overflowLink
argument_list|)
decl_stmt|;
name|overflow
operator|.
name|delete
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IO error while removing overflow page"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exception ? -pb
block|}
name|realLen
operator|+=
name|LENGTH_OVERFLOW_LOCATION
expr_stmt|;
block|}
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_OVERFLOW_LOCATION
else|:
name|vlen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_OVERFLOW_LOCATION
else|:
name|vlen
argument_list|)
expr_stmt|;
specifier|final
name|RemoveValueLoggable
name|loggable
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|,
name|startOffset
argument_list|,
name|data
argument_list|,
name|isOverflow
argument_list|,
name|backLink
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|dataLength
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|startOffset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|realLen
decl_stmt|;
comment|// remove old value
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|startOffset
argument_list|,
name|dataLength
operator|-
name|end
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|=
name|dataLength
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|realLen
operator|)
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Page length< 0"
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing page "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pageHeader
operator|.
name|getRecordCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Empty page seems to have record !"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|RemoveEmptyPageLoggable
name|loggable
init|=
operator|new
name|RemoveEmptyPageLoggable
argument_list|(
name|transaction
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|removePage
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|setPage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Physically remove a node. The data of the node will be removed from the      * page and the occupied space is freed.      *      * @param transaction the database transaction      * @param key the key      * @param pointer pointer to the value      */
specifier|public
name|void
name|remove
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
block|{
name|removeNode
argument_list|(
name|transaction
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
try|try
block|{
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"BTree error while removing node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exception ? -pb
block|}
block|}
comment|/**      * Remove the specified page. The page is added to the list of free pages.      *       * @param page the DOM page      */
specifier|private
name|void
name|removePage
parameter_list|(
specifier|final
name|DOMPage
name|page
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
operator|!=
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|nextPage
init|=
name|getDOMPage
argument_list|(
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
operator|!=
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|previousPage
init|=
name|getDOMPage
argument_list|(
name|pageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|previousPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|previousPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|previousPage
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
operator|.
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exception ? -pb
block|}
if|if
condition|(
name|currentDocument
operator|!=
literal|null
condition|)
block|{
name|currentDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|decPageCount
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Remove a sequence of pages, starting with the page denoted by the passed      * address pointer p.      *      * @param transaction the database transaction      * @param pointer the pointer to the first page      */
specifier|public
name|void
name|removeAll
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
name|long
name|pageNum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageNum
operator|==
name|NO_PAGE
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Tried to remove unknown page"
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
while|while
condition|(
name|pageNum
operator|!=
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|currentPage
init|=
name|getDOMPage
argument_list|(
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|currentPageHeader
init|=
name|currentPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|RemovePageLoggable
name|loggable
init|=
operator|new
name|RemovePageLoggable
argument_list|(
name|transaction
argument_list|,
name|pageNum
argument_list|,
name|currentPageHeader
operator|.
name|getPreviousDataPage
argument_list|()
argument_list|,
name|currentPageHeader
operator|.
name|getNextDataPage
argument_list|()
argument_list|,
name|currentPage
operator|.
name|data
argument_list|,
name|currentPage
operator|.
name|len
argument_list|,
name|currentPageHeader
operator|.
name|getCurrentTupleID
argument_list|()
argument_list|,
name|currentPageHeader
operator|.
name|getRecordCount
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|currentPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|pageNum
operator|=
name|currentPageHeader
operator|.
name|getNextDataPage
argument_list|()
expr_stmt|;
try|try
block|{
name|currentPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|currentPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|currentPageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|currentPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|currentPageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|unlinkPages
argument_list|(
name|currentPage
operator|.
name|page
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|currentPage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while removing page: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow the exception ? -pb
block|}
block|}
block|}
specifier|public
name|String
name|debugPages
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
name|boolean
name|showPageContents
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Pages used by "
argument_list|)
operator|.
name|append
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"; (docId: "
argument_list|)
operator|.
name|append
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"): "
argument_list|)
expr_stmt|;
name|long
name|pageNum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
operator|(
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
name|doc
operator|.
name|getFirstChild
argument_list|()
operator|)
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|pageNum
operator|!=
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|pageNum
argument_list|)
expr_stmt|;
name|pageNum
operator|=
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|showPageContents
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPageContents
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Update the key/value pair.      *      * @param transaction the database transaction      * @param key the key      * @param value the value      *      * @return true if the value was updated, false otherwise      *      * @throws ReadOnlyException if the DOM file is read-only      */
specifier|public
name|boolean
name|update
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
specifier|final
name|long
name|pointer
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointer
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
comment|//TODO : transform to error ? -pb
name|LOG
operator|.
name|warn
argument_list|(
literal|"Node value not found : "
operator|+
name|key
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|update
argument_list|(
name|transaction
argument_list|,
name|pointer
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|//TODO : rethrow exception ? -pb
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Update the key/value pair where the value is found at address p.      *      * @param transaction the database transaction      * @param pointer pointer to the existing value      * @param value the new value      *      * @throws ReadOnlyException if the DOM file is read-only      */
specifier|public
name|void
name|update
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLockedForWrite
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a write lock"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RecordPos
name|recordPos
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
specifier|final
name|short
name|valueLength
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|recordPos
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|recordPos
operator|.
name|offset
argument_list|)
decl_stmt|;
name|recordPos
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|recordPos
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|recordPos
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|.
name|length
operator|<
name|valueLength
condition|)
block|{
comment|// value is smaller than before
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Value too short. Expected: "
operator|+
name|value
operator|.
name|length
operator|+
literal|"; got: "
operator|+
name|valueLength
argument_list|)
throw|;
block|}
if|else if
condition|(
name|value
operator|.
name|length
operator|>
name|valueLength
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Value too long. Expected: "
operator|+
name|value
operator|.
name|length
operator|+
literal|"; got: "
operator|+
name|valueLength
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|ItemId
operator|.
name|getId
argument_list|(
name|recordPos
operator|.
name|getTupleID
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Tuple ID< 0"
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateValueLoggable
argument_list|(
name|transaction
argument_list|,
name|recordPos
operator|.
name|getPage
argument_list|()
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|recordPos
operator|.
name|getTupleID
argument_list|()
argument_list|,
name|value
argument_list|,
name|recordPos
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|recordPos
operator|.
name|offset
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|recordPos
operator|.
name|getPage
argument_list|()
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
comment|// value length unchanged
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|recordPos
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|recordPos
operator|.
name|offset
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|recordPos
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Retrieve the string value of the specified node. This is an optimized low-level method      * which will directly traverse the stored DOM nodes and collect the string values of      * the specified root node and all its descendants. By directly scanning the stored      * node data, we do not need to create a potentially large amount of node objects      * and thus save memory and time for garbage collection.       *      * @param broker the database broker      * @param node the node      * @param addWhitespace true if whitespace should be added to the node value      * @return string value of the specified node      */
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|RecordPos
name|recordPos
init|=
literal|null
decl_stmt|;
comment|// try to directly locate the root node through its storage address
if|if
condition|(
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|address
argument_list|)
condition|)
block|{
name|recordPos
operator|=
name|findRecord
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recordPos
operator|==
literal|null
condition|)
block|{
comment|// fallback to a BTree lookup if the node could not be found
comment|// by its storage address
name|address
operator|=
name|findValue
argument_list|(
name|broker
argument_list|,
operator|new
name|NodeProxy
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|BTree
operator|.
name|KEY_NOT_FOUND
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Node value not found: "
operator|+
name|node
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
return|return
literal|null
return|;
block|}
name|recordPos
operator|=
name|findRecord
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|THROW_ASSERT
argument_list|(
name|recordPos
operator|!=
literal|null
argument_list|,
literal|"Node data could not be found!"
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
comment|// we collect the string values in binary format and append them to a ByteArrayOutputStream
try|try
init|(
specifier|final
name|FastByteArrayOutputStream
name|os
init|=
operator|new
name|FastByteArrayOutputStream
argument_list|(
literal|32
argument_list|)
init|)
block|{
comment|// now traverse the tree
name|getNodeValue
argument_list|(
name|broker
operator|.
name|getBrokerPool
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|os
argument_list|,
name|recordPos
argument_list|,
literal|true
argument_list|,
name|addWhitespace
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|os
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|data
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"BTree error while reading node value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exception ? -pb
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO error while reading node value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exception ? -pb
block|}
comment|//TODO : remove if exceptions thrown...
return|return
literal|null
return|;
block|}
comment|/**      * Recursive method to retrieve the string values of the root node      * and all its descendants.      *      * @param pool the broker pool      * @param doc the document      * @param os the output stream to receive the value      * @param rec the record position      * @param isTopNode true if this is the top node, false otherwise      * @param addWhitespace true if whitespace should be added to the node value      */
specifier|private
name|void
name|getNodeValue
parameter_list|(
specifier|final
name|BrokerPool
name|pool
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|FastByteArrayOutputStream
name|os
parameter_list|,
specifier|final
name|RecordPos
name|rec
parameter_list|,
specifier|final
name|boolean
name|isTopNode
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
comment|//Locate the next real node, skipping relocated nodes
name|boolean
name|foundNext
init|=
literal|false
decl_stmt|;
do|do
block|{
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|rec
operator|.
name|offset
operator|>
name|pageHeader
operator|.
name|getDataLength
argument_list|()
condition|)
block|{
comment|// end of page reached, proceed to the next page
specifier|final
name|long
name|nextPage
init|=
name|pageHeader
operator|.
name|getNextDataPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextPage
operator|==
name|NO_PAGE
condition|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Bad link to next page! "
operator|+
literal|"Offset: "
operator|+
name|rec
operator|.
name|offset
operator|+
literal|", Len: "
operator|+
name|pageHeader
operator|.
name|getDataLength
argument_list|()
operator|+
literal|", Page info : "
operator|+
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|page
operator|.
name|getPageInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
return|return;
block|}
name|rec
operator|.
name|setPage
argument_list|(
name|getDOMPage
argument_list|(
name|nextPage
argument_list|)
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
name|LENGTH_TID
expr_stmt|;
block|}
comment|//Position the stream at the very beginning of the record
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
argument_list|)
decl_stmt|;
name|rec
operator|.
name|setTupleID
argument_list|(
name|tupleID
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
comment|//This is a link: skip it
comment|//We position the offset *after* the next TupleID
name|rec
operator|.
name|offset
operator|+=
operator|(
name|LENGTH_FORWARD_LOCATION
operator|+
name|LENGTH_TID
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//OK: node found
name|foundNext
operator|=
literal|true
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|foundNext
condition|)
do|;
specifier|final
name|short
name|valueLength
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|int
name|realLen
init|=
name|valueLength
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|//Check if the node was relocated
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
name|byte
index|[]
name|data
init|=
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
decl_stmt|;
name|int
name|readOffset
init|=
name|rec
operator|.
name|offset
decl_stmt|;
name|boolean
name|inOverflow
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|valueLength
operator|==
name|OVERFLOW
condition|)
block|{
comment|//If we have an overflow value, load it from the overflow page
specifier|final
name|long
name|p
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|data
operator|=
name|getOverflowValue
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|//We position the offset *after* the next TID
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_OVERFLOW_LOCATION
operator|+
name|LENGTH_TID
expr_stmt|;
name|realLen
operator|=
name|data
operator|.
name|length
expr_stmt|;
name|readOffset
operator|=
literal|0
expr_stmt|;
name|inOverflow
operator|=
literal|true
expr_stmt|;
block|}
comment|// check the type of the node
specifier|final
name|short
name|type
init|=
name|Signatures
operator|.
name|getType
argument_list|(
name|data
index|[
name|readOffset
index|]
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
expr_stmt|;
comment|//Switch on the node type
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
block|{
specifier|final
name|int
name|children
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|ElementImpl
operator|.
name|LENGTH_ELEMENT_CHILD_COUNT
expr_stmt|;
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
specifier|final
name|int
name|nodeIdLen
init|=
name|pool
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|lengthInBytes
argument_list|(
name|dlnLen
argument_list|,
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeIdLen
expr_stmt|;
specifier|final
name|short
name|attributes
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
comment|//Ignore the following NS data which are of no use
comment|//We position the offset *after* the next TID
name|rec
operator|.
name|offset
operator|+=
name|realLen
operator|+
name|LENGTH_TID
expr_stmt|;
specifier|final
name|boolean
name|extraWhitespace
init|=
name|addWhitespace
operator|&&
operator|(
name|children
operator|-
name|attributes
operator|)
operator|>
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
comment|//recursive call : we ignore attributes children
name|getNodeValue
argument_list|(
name|pool
argument_list|,
name|doc
argument_list|,
name|os
argument_list|,
name|rec
argument_list|,
literal|false
argument_list|,
name|addWhitespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraWhitespace
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
operator|(
name|byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
case|case
name|Node
operator|.
name|CDATA_SECTION_NODE
case|:
block|{
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
specifier|final
name|int
name|nodeIdLen
init|=
name|pool
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|lengthInBytes
argument_list|(
name|dlnLen
argument_list|,
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeIdLen
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|,
name|realLen
operator|-
operator|(
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
operator|+
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
operator|+
name|nodeIdLen
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
block|{
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
specifier|final
name|int
name|nodeIdLen
init|=
name|pool
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|lengthInBytes
argument_list|(
name|dlnLen
argument_list|,
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeIdLen
expr_stmt|;
specifier|final
name|int
name|targetLen
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
literal|4
operator|+
name|targetLen
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|,
name|realLen
operator|-
operator|(
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
operator|+
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
operator|+
name|nodeIdLen
operator|+
name|targetLen
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
block|{
if|if
condition|(
name|isTopNode
condition|)
block|{
specifier|final
name|int
name|start
init|=
name|readOffset
operator|-
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
decl_stmt|;
specifier|final
name|byte
name|idSizeType
init|=
operator|(
name|byte
operator|)
operator|(
name|data
index|[
name|start
index|]
operator|&
literal|0x3
operator|)
decl_stmt|;
specifier|final
name|boolean
name|hasNamespace
init|=
operator|(
name|data
index|[
name|start
index|]
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
decl_stmt|;
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
specifier|final
name|int
name|nodeIdLen
init|=
name|pool
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|lengthInBytes
argument_list|(
name|dlnLen
argument_list|,
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeIdLen
expr_stmt|;
name|readOffset
operator|+=
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNamespace
condition|)
block|{
name|readOffset
operator|+=
name|AttrImpl
operator|.
name|LENGTH_NS_ID
expr_stmt|;
comment|// skip namespace id
specifier|final
name|short
name|prefixLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|AttrImpl
operator|.
name|LENGTH_PREFIX_LENGTH
expr_stmt|;
name|readOffset
operator|+=
name|prefixLen
expr_stmt|;
comment|// skip prefix
block|}
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|,
name|realLen
operator|-
operator|(
name|readOffset
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
block|{
if|if
condition|(
name|isTopNode
condition|)
block|{
specifier|final
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
specifier|final
name|int
name|nodeIdLen
init|=
name|pool
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|lengthInBytes
argument_list|(
name|dlnLen
argument_list|,
name|data
argument_list|,
name|readOffset
argument_list|)
decl_stmt|;
name|readOffset
operator|+=
name|nodeIdLen
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|readOffset
argument_list|,
name|realLen
operator|-
operator|(
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
operator|+
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
operator|+
name|nodeIdLen
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|inOverflow
condition|)
block|{
comment|//If it isn't an overflow value, add the value length to the current offset
comment|//We position the offset *after* the next TID
name|rec
operator|.
name|offset
operator|+=
name|realLen
operator|+
name|LENGTH_TID
expr_stmt|;
block|}
block|}
specifier|protected
name|RecordPos
name|findRecord
parameter_list|(
specifier|final
name|long
name|pointer
parameter_list|)
block|{
return|return
name|findRecord
argument_list|(
name|pointer
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Find a record within the page or the pages linked to it.      *       * @param pointer the pointer to the page      * @param skipLinks true if links should be skipped, false otherwise      * @return The record position in the page      */
specifier|protected
name|RecordPos
name|findRecord
parameter_list|(
specifier|final
name|long
name|pointer
parameter_list|,
specifier|final
name|boolean
name|skipLinks
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
name|lockManager
operator|.
name|isBtreeLocked
argument_list|(
name|getLockName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The file doesn't own a lock"
argument_list|)
expr_stmt|;
block|}
name|long
name|pageNum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|short
name|tupleID
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
while|while
condition|(
name|pageNum
operator|!=
name|NO_PAGE
condition|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|pageNum
argument_list|)
decl_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
specifier|final
name|RecordPos
name|rec
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|tupleID
argument_list|)
decl_stmt|;
if|if
condition|(
name|rec
operator|==
literal|null
condition|)
block|{
name|pageNum
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|pageNum
operator|==
name|page
operator|.
name|getPageNum
argument_list|()
condition|)
block|{
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Circular link to next page on "
operator|+
name|pageNum
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ?
return|return
literal|null
return|;
block|}
block|}
if|else if
condition|(
name|rec
operator|.
name|isLink
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|skipLinks
condition|)
block|{
return|return
name|rec
return|;
block|}
specifier|final
name|long
name|forwardLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
comment|// load the link page
name|pageNum
operator|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|forwardLink
argument_list|)
expr_stmt|;
name|tupleID
operator|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|forwardLink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|rec
return|;
block|}
block|}
comment|//TODO : throw exception ? -pb
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getLockName
parameter_list|()
block|{
return|return
name|getFileName
argument_list|()
return|;
block|}
comment|/**      * The current object owning this file.      *       * @param ownerObject The new ownerObject value      */
specifier|public
specifier|synchronized
specifier|final
name|void
name|setOwnerObject
parameter_list|(
specifier|final
name|Object
name|ownerObject
parameter_list|)
block|{
if|if
condition|(
name|ownerObject
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"setOwnerObject(null)"
argument_list|)
expr_stmt|;
block|}
name|owner
operator|=
name|ownerObject
expr_stmt|;
block|}
comment|/*      * ---------------------------------------------------------------------------------      * Methods used by recovery and transaction management      * ---------------------------------------------------------------------------------      */
specifier|private
name|boolean
name|requiresRedo
parameter_list|(
specifier|final
name|Loggable
name|loggable
parameter_list|,
specifier|final
name|DOMPage
name|page
parameter_list|)
block|{
return|return
name|loggable
operator|.
name|getLsn
argument_list|()
operator|.
name|compareTo
argument_list|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
argument_list|)
operator|>
literal|0
return|;
block|}
specifier|protected
name|void
name|redoCreatePage
parameter_list|(
specifier|final
name|CreatePageLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|newPage
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|newPage
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|newPageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|||
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|newPage
argument_list|)
condition|)
block|{
try|try
block|{
name|dropFreePageList
argument_list|()
expr_stmt|;
name|newPageHeader
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|newPage
operator|.
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|nextTID
operator|!=
name|ItemId
operator|.
name|UNKNOWN_ID
condition|)
block|{
name|newPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|loggable
operator|.
name|nextTID
argument_list|)
expr_stmt|;
block|}
name|newPageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|nextPage
operator|==
name|NO_PAGE
condition|)
block|{
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loggable
operator|.
name|prevPage
operator|==
name|NO_PAGE
condition|)
block|{
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|loggable
operator|.
name|prevPage
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to redo "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exc eption ?
block|}
block|}
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|undoCreatePage
parameter_list|(
specifier|final
name|CreatePageLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|newPage
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
try|try
block|{
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
operator|.
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while removing page: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : exception ?
block|}
block|}
specifier|protected
name|void
name|redoAddValue
parameter_list|(
specifier|final
name|AddValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
try|try
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|loggable
operator|.
name|tid
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
comment|// save data length
comment|// overflow pages have length 0
specifier|final
name|short
name|vlen
init|=
operator|(
name|short
operator|)
name|loggable
operator|.
name|value
operator|.
name|length
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|loggable
operator|.
name|isOverflow
condition|?
name|OVERFLOW
else|:
name|vlen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|// save data
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|value
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|vlen
expr_stmt|;
name|pageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page: "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; len = "
operator|+
name|page
operator|.
name|len
operator|+
literal|"; value = "
operator|+
name|loggable
operator|.
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|undoAddValue
parameter_list|(
specifier|final
name|AddValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
comment|// is there anything to undo?
if|if
condition|(
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|||
name|pageHeader
operator|.
name|getStatus
argument_list|()
operator|==
name|UNUSED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Nothing to undo, but received: AddValueLoggable(txnId="
operator|+
name|loggable
operator|.
name|getTransactionId
argument_list|()
operator|+
literal|", lsn="
operator|+
name|loggable
operator|.
name|getLsn
argument_list|()
operator|+
literal|", pageNum="
operator|+
name|loggable
operator|.
name|pageNum
operator|+
literal|", isOverflow="
operator|+
name|loggable
operator|.
name|isOverflow
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|RecordPos
name|pos
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|pos
operator|!=
literal|null
argument_list|,
literal|"Record not found! isOverflow: "
operator|+
name|loggable
operator|.
name|isOverflow
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
comment|//Position the stream at the very beginning of the record
specifier|final
name|int
name|startOffset
init|=
name|pos
operator|.
name|offset
operator|-
name|LENGTH_TID
decl_stmt|;
comment|//Get the record length
specifier|final
name|short
name|vlen
init|=
name|loggable
operator|.
name|isOverflow
condition|?
literal|8
else|:
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
operator|.
name|offset
argument_list|)
decl_stmt|;
comment|//End offset
specifier|final
name|int
name|end
init|=
name|startOffset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|vlen
decl_stmt|;
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|//Remove old value
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|startOffset
argument_list|,
name|dlen
operator|-
name|end
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|dlen
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|vlen
operator|)
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
comment|//TODO : exception ?
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoUpdateValue
parameter_list|(
specifier|final
name|UpdateValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|ph
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
specifier|final
name|RecordPos
name|rec
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|THROW_ASSERT
argument_list|(
name|rec
operator|!=
literal|null
argument_list|,
literal|"tid "
operator|+
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
operator|+
literal|" not found on page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; contents: "
operator|+
name|debugPageContents
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
comment|//            ByteConversion.byteToShort(rec.getPage().data, rec.offset);
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|value
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|loggable
operator|.
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoUpdateValue
parameter_list|(
specifier|final
name|UpdateValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|RecordPos
name|rec
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|THROW_ASSERT
argument_list|(
name|rec
operator|!=
literal|null
argument_list|,
literal|"tid "
operator|+
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
operator|+
literal|" not found on page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; contents: "
operator|+
name|debugPageContents
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|THROW_ASSERT
argument_list|(
name|vlen
operator|==
name|loggable
operator|.
name|oldValue
operator|.
name|length
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|getTupleID
argument_list|()
argument_list|)
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|oldValue
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|loggable
operator|.
name|oldValue
operator|.
name|length
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoRemoveValue
parameter_list|(
specifier|final
name|RemoveValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
specifier|final
name|RecordPos
name|pos
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|pos
operator|!=
literal|null
argument_list|,
literal|"Record not found: "
operator|+
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
operator|+
literal|": "
operator|+
name|page
operator|.
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|"\n"
operator|+
name|debugPageContents
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
comment|//Position the stream at the very beginning of the record
specifier|final
name|int
name|startOffset
init|=
name|pos
operator|.
name|offset
operator|-
name|LENGTH_TID
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
specifier|final
name|int
name|end
init|=
name|pos
operator|.
name|offset
operator|+
name|LENGTH_FORWARD_LOCATION
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|startOffset
argument_list|,
name|page
operator|.
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|page
operator|.
name|len
operator|-
operator|(
name|LENGTH_DATA_LENGTH
operator|+
name|LENGTH_FORWARD_LOCATION
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// get the record length
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
operator|.
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
name|pos
operator|.
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
name|l
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
name|OVERFLOW
condition|)
block|{
name|l
operator|+=
name|LENGTH_OVERFLOW_LOCATION
expr_stmt|;
block|}
comment|// end offset
specifier|final
name|int
name|end
init|=
name|startOffset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|l
decl_stmt|;
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// remove old value
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|startOffset
argument_list|,
name|dlen
operator|-
name|end
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|dlen
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|l
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemoveValue
parameter_list|(
specifier|final
name|RemoveValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|loggable
operator|.
name|offset
decl_stmt|;
specifier|final
name|short
name|vlen
init|=
operator|(
name|short
operator|)
name|loggable
operator|.
name|oldData
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|pageHeader
operator|.
name|getDataLength
argument_list|()
condition|)
block|{
comment|// make room for the removed value
name|int
name|required
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
name|required
operator|=
name|LENGTH_TID
operator|+
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
else|else
block|{
name|required
operator|=
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|vlen
expr_stmt|;
block|}
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
name|required
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|required
decl_stmt|;
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|pageHeader
operator|.
name|getDataLength
argument_list|()
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Error while copying data on page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; tid: "
operator|+
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
operator|+
literal|"; required: "
operator|+
name|required
operator|+
literal|"; offset: "
operator|+
name|offset
operator|+
literal|"; end: "
operator|+
name|end
operator|+
literal|"; len: "
operator|+
operator|(
name|pageHeader
operator|.
name|getDataLength
argument_list|()
operator|-
name|offset
operator|)
operator|+
literal|"; avail: "
operator|+
name|page
operator|.
name|data
operator|.
name|length
operator|+
literal|"; work: "
operator|+
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//save TID
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|loggable
operator|.
name|tid
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_TID
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|oldData
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|LENGTH_FORWARD_LOCATION
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_FORWARD_LOCATION
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// save data length
comment|// overflow pages have length 0
if|if
condition|(
name|loggable
operator|.
name|isOverflow
condition|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|OVERFLOW
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|vlen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|loggable
operator|.
name|backLink
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
comment|// save data
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|oldData
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|vlen
operator|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoRemoveEmptyPage
parameter_list|(
specifier|final
name|RemoveEmptyPageLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|removePage
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemoveEmptyPage
parameter_list|(
specifier|final
name|RemoveEmptyPageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DOMPage
name|newPage
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|newPageHeader
init|=
name|newPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|dropFreePageList
argument_list|()
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|prevPage
operator|==
name|NO_PAGE
condition|)
block|{
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DOMPage
name|oldPage
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|prevPage
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|oldPageHeader
init|=
name|oldPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|newPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|oldPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|oldPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|oldPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|oldPage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loggable
operator|.
name|nextPage
operator|==
name|NO_PAGE
condition|)
block|{
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DOMPage
name|oldPage
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|oldPageHeader
init|=
name|oldPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|oldPageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPageHeader
operator|.
name|setNextDataPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
name|oldPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|oldPage
argument_list|)
expr_stmt|;
block|}
name|newPageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error during undo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
specifier|protected
name|void
name|redoRemovePage
parameter_list|(
specifier|final
name|RemovePageLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
try|try
block|{
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLen
argument_list|(
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
operator|.
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while removing page: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
block|}
specifier|protected
name|void
name|undoRemovePage
parameter_list|(
specifier|final
name|RemovePageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|dropFreePageList
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|loggable
operator|.
name|prevPage
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|oldTid
argument_list|)
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
name|loggable
operator|.
name|oldRecCnt
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|loggable
operator|.
name|oldLen
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|oldData
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|loggable
operator|.
name|oldLen
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|loggable
operator|.
name|oldLen
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
specifier|protected
name|void
name|redoWriteOverflow
parameter_list|(
specifier|final
name|WriteOverflowPageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|PageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|dropFreePageList
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|nextPage
operator|==
name|NO_PAGE
condition|)
block|{
name|pageHeader
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pageHeader
operator|.
name|setNextPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|page
argument_list|,
name|loggable
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to redo "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
specifier|protected
name|void
name|undoWriteOverflow
parameter_list|(
specifier|final
name|WriteOverflowPageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
specifier|protected
name|void
name|redoRemoveOverflow
parameter_list|(
specifier|final
name|RemoveOverflowLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
specifier|final
name|PageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
specifier|protected
name|void
name|undoRemoveOverflow
parameter_list|(
specifier|final
name|RemoveOverflowLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
specifier|final
name|PageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|dropFreePageList
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|nextPage
operator|==
name|NO_PAGE
condition|)
block|{
name|pageHeader
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pageHeader
operator|.
name|setNextPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|writeValue
argument_list|(
name|page
argument_list|,
name|loggable
operator|.
name|oldData
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to redo "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
block|}
specifier|protected
name|void
name|redoInsertValue
parameter_list|(
specifier|final
name|InsertValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|loggable
operator|.
name|offset
decl_stmt|;
comment|// insert in the middle of the page?
if|if
condition|(
name|offset
operator|<
name|dlen
condition|)
block|{
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|loggable
operator|.
name|value
operator|.
name|length
decl_stmt|;
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|dlen
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Error while copying data on page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; tid: "
operator|+
name|loggable
operator|.
name|tid
operator|+
literal|"; offset: "
operator|+
name|offset
operator|+
literal|"; end: "
operator|+
name|end
operator|+
literal|"; len: "
operator|+
operator|(
name|dlen
operator|-
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// writing tid
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|loggable
operator|.
name|tid
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_TID
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
comment|// writing value length
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|loggable
operator|.
name|isOverflow
argument_list|()
condition|?
name|OVERFLOW
else|:
operator|(
name|short
operator|)
name|loggable
operator|.
name|value
operator|.
name|length
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
comment|// writing data
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|value
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|loggable
operator|.
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|loggable
operator|.
name|value
operator|.
name|length
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|loggable
operator|.
name|value
operator|.
name|length
expr_stmt|;
name|pageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoInsertValue
parameter_list|(
specifier|final
name|InsertValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
specifier|final
name|int
name|end
init|=
name|loggable
operator|.
name|offset
operator|+
name|LENGTH_FORWARD_LOCATION
decl_stmt|;
comment|//Position the stream at the very beginning of the record
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|loggable
operator|.
name|offset
operator|-
name|LENGTH_TID
argument_list|,
name|page
operator|.
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|page
operator|.
name|len
operator|-
operator|(
name|LENGTH_DATA_LENGTH
operator|+
name|LENGTH_FORWARD_LOCATION
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// get the record length
specifier|final
name|int
name|offset
init|=
name|loggable
operator|.
name|offset
operator|+
name|LENGTH_TID
decl_stmt|;
comment|//TOUNDERSTAND Strange : in the lines above, the offset seems to be positionned *after* the TID
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
condition|)
block|{
name|l
operator|+=
name|LENGTH_ORIGINAL_LOCATION
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
name|OVERFLOW
condition|)
block|{
name|l
operator|+=
name|LENGTH_OVERFLOW_LOCATION
expr_stmt|;
block|}
comment|// end offset
specifier|final
name|int
name|end
init|=
name|loggable
operator|.
name|offset
operator|+
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|l
operator|)
decl_stmt|;
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// remove value
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|loggable
operator|.
name|offset
argument_list|,
name|dlen
operator|-
name|end
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Error while copying data on page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; tid: "
operator|+
name|loggable
operator|.
name|tid
operator|+
literal|"; offset: "
operator|+
name|loggable
operator|.
name|offset
operator|+
literal|"; end: "
operator|+
name|end
operator|+
literal|"; len: "
operator|+
operator|(
name|dlen
operator|-
name|end
operator|)
operator|+
literal|"; dataLength: "
operator|+
name|dlen
argument_list|)
expr_stmt|;
block|}
name|page
operator|.
name|len
operator|=
name|dlen
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|l
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoSplitPage
parameter_list|(
specifier|final
name|SplitPageLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
specifier|final
name|byte
index|[]
name|oldData
init|=
name|page
operator|.
name|data
decl_stmt|;
name|page
operator|.
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|loggable
operator|.
name|splitOffset
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|loggable
operator|.
name|splitOffset
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
name|countRecordsInPage
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoSplitPage
parameter_list|(
specifier|final
name|SplitPageLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|page
operator|.
name|data
operator|=
name|loggable
operator|.
name|oldData
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|loggable
operator|.
name|oldLen
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoAddLink
parameter_list|(
specifier|final
name|AddLinkLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|ItemId
operator|.
name|setIsLink
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|loggable
operator|.
name|link
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoAddLink
parameter_list|(
specifier|final
name|AddLinkLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|RecordPos
name|rec
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|rec
operator|.
name|offset
operator|+
name|LENGTH_FORWARD_LOCATION
decl_stmt|;
comment|//Position the stream at the very beginning of the record
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
argument_list|,
name|page
operator|.
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|=
name|page
operator|.
name|len
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_FORWARD_LOCATION
operator|)
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoUpdateLink
parameter_list|(
specifier|final
name|UpdateLinkLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|loggable
operator|.
name|link
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|loggable
operator|.
name|offset
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoUpdateLink
parameter_list|(
specifier|final
name|UpdateLinkLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|loggable
operator|.
name|oldLink
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|loggable
operator|.
name|offset
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoAddMovedValue
parameter_list|(
specifier|final
name|AddMovedValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
try|try
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|ItemId
operator|.
name|setIsRelocated
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_TID
expr_stmt|;
specifier|final
name|short
name|vlen
init|=
operator|(
name|short
operator|)
name|loggable
operator|.
name|value
operator|.
name|length
decl_stmt|;
comment|// save data length
comment|// overflow pages have length 0
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|vlen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|loggable
operator|.
name|backLink
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
comment|// save data
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|value
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|vlen
expr_stmt|;
comment|//TOUNDERSTAND : why 2 occurences of ph.incRecordCount(); ?
name|pageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page: "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; len = "
operator|+
name|page
operator|.
name|len
operator|+
literal|"; value = "
operator|+
name|loggable
operator|.
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|undoAddMovedValue
parameter_list|(
specifier|final
name|AddMovedValueLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|RecordPos
name|rec
init|=
name|page
operator|.
name|findRecord
argument_list|(
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|rec
operator|!=
literal|null
argument_list|,
literal|"Record with tid "
operator|+
name|ItemId
operator|.
name|getId
argument_list|(
name|loggable
operator|.
name|tid
argument_list|)
operator|+
literal|" not found: "
operator|+
name|debugPageContents
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
comment|// get the record's length
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|rec
operator|.
name|offset
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|vlen
decl_stmt|;
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// remove value
try|try
block|{
comment|//Position the stream at the very beginning of the record
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
argument_list|,
name|dlen
operator|-
name|end
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|TRACE
argument_list|(
literal|"Error while copying data on page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; tid: "
operator|+
name|loggable
operator|.
name|tid
operator|+
literal|"; offset: "
operator|+
operator|(
name|rec
operator|.
name|offset
operator|-
name|LENGTH_TID
operator|)
operator|+
literal|"; end: "
operator|+
name|end
operator|+
literal|"; len: "
operator|+
operator|(
name|dlen
operator|-
name|end
operator|)
argument_list|)
expr_stmt|;
block|}
name|page
operator|.
name|len
operator|=
name|dlen
operator|-
operator|(
name|LENGTH_TID
operator|+
name|LENGTH_DATA_LENGTH
operator|+
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|vlen
operator|)
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page length< 0"
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoUpdateHeader
parameter_list|(
specifier|final
name|UpdateHeaderLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pageHeader
operator|.
name|getLsn
argument_list|()
operator|.
name|equals
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
if|if
condition|(
name|loggable
operator|.
name|nextPage
operator|!=
name|NO_PAGE
condition|)
block|{
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loggable
operator|.
name|prevPage
operator|!=
name|NO_PAGE
condition|)
block|{
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|loggable
operator|.
name|prevPage
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoUpdateHeader
parameter_list|(
specifier|final
name|UpdateHeaderLoggable
name|loggable
parameter_list|)
block|{
specifier|final
name|DOMPage
name|page
init|=
name|getDOMPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|loggable
operator|.
name|oldPrev
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|loggable
operator|.
name|oldNext
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
class|class
name|DOMFilePageHeader
extends|extends
name|BTreePageHeader
block|{
specifier|protected
name|int
name|dataLength
init|=
literal|0
decl_stmt|;
specifier|protected
name|long
name|nextDataPage
init|=
name|NO_PAGE
decl_stmt|;
specifier|protected
name|long
name|previousDataPage
init|=
name|NO_PAGE
decl_stmt|;
specifier|protected
name|short
name|tupleID
init|=
name|ItemId
operator|.
name|UNKNOWN_ID
decl_stmt|;
specifier|protected
name|short
name|records
init|=
literal|0
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|short
name|LENGTH_RECORDS_COUNT
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|final
specifier|static
name|int
name|LENGTH_DATA_LENGTH
init|=
literal|4
decl_stmt|;
comment|//sizeof int
specifier|public
specifier|final
specifier|static
name|long
name|LENGTH_NEXT_PAGE_POINTER
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|final
specifier|static
name|long
name|LENGTH_PREV_PAGE_POINTER
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|final
specifier|static
name|short
name|LENGTH_CURRENT_TID
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
name|DOMFilePageHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|DOMFilePageHeader
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|decRecordCount
parameter_list|()
block|{
comment|//TODO : check negative value ? -pb
name|records
operator|--
expr_stmt|;
block|}
specifier|public
name|short
name|getCurrentTupleID
parameter_list|()
block|{
comment|//TODO : overflow check ? -pb
return|return
name|tupleID
return|;
block|}
specifier|public
name|short
name|getNextTupleID
parameter_list|()
block|{
if|if
condition|(
operator|++
name|tupleID
operator|==
name|ItemId
operator|.
name|ID_MASK
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No spare ids on page"
argument_list|)
throw|;
block|}
return|return
name|tupleID
return|;
block|}
specifier|public
name|boolean
name|hasRoom
parameter_list|()
block|{
return|return
name|tupleID
operator|<
name|ItemId
operator|.
name|MAX_ID
return|;
block|}
specifier|public
name|void
name|setNextTupleID
parameter_list|(
name|short
name|tupleID
parameter_list|)
block|{
if|if
condition|(
name|tupleID
operator|>
name|ItemId
operator|.
name|MAX_ID
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"TupleID overflow! TupleID = "
operator|+
name|tupleID
argument_list|)
throw|;
block|}
name|this
operator|.
name|tupleID
operator|=
name|tupleID
expr_stmt|;
block|}
specifier|public
name|int
name|getDataLength
parameter_list|()
block|{
return|return
name|dataLength
return|;
block|}
specifier|public
name|long
name|getNextDataPage
parameter_list|()
block|{
return|return
name|nextDataPage
return|;
block|}
specifier|public
name|long
name|getPreviousDataPage
parameter_list|()
block|{
return|return
name|previousDataPage
return|;
block|}
specifier|public
name|short
name|getRecordCount
parameter_list|()
block|{
return|return
name|records
return|;
block|}
specifier|public
name|void
name|incRecordCount
parameter_list|()
block|{
name|records
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|records
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_RECORDS_COUNT
expr_stmt|;
name|dataLength
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
name|nextDataPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_NEXT_PAGE_POINTER
expr_stmt|;
name|previousDataPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PREV_PAGE_POINTER
expr_stmt|;
name|tupleID
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
name|LENGTH_CURRENT_TID
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|records
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_RECORDS_COUNT
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|dataLength
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|nextDataPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_NEXT_PAGE_POINTER
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|previousDataPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PREV_PAGE_POINTER
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tupleID
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
name|LENGTH_CURRENT_TID
return|;
block|}
specifier|public
name|void
name|setDataLength
parameter_list|(
specifier|final
name|int
name|dataLength
parameter_list|)
block|{
if|if
condition|(
name|dataLength
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"data too long for file header !"
argument_list|)
expr_stmt|;
comment|//TODO  :throw exception ? -pb
block|}
name|this
operator|.
name|dataLength
operator|=
name|dataLength
expr_stmt|;
block|}
specifier|public
name|void
name|setNextDataPage
parameter_list|(
specifier|final
name|long
name|page
parameter_list|)
block|{
name|nextDataPage
operator|=
name|page
expr_stmt|;
block|}
specifier|public
name|void
name|setPrevDataPage
parameter_list|(
specifier|final
name|long
name|page
parameter_list|)
block|{
name|previousDataPage
operator|=
name|page
expr_stmt|;
block|}
specifier|public
name|void
name|setRecordCount
parameter_list|(
specifier|final
name|short
name|recs
parameter_list|)
block|{
name|records
operator|=
name|recs
expr_stmt|;
block|}
block|}
specifier|protected
specifier|final
class|class
name|DOMPage
implements|implements
name|Cacheable
block|{
comment|// the raw working data (without page header) of this page
name|byte
index|[]
name|data
decl_stmt|;
comment|// the current size of the used data
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|// the low-level page
name|Page
name|page
decl_stmt|;
name|DOMFilePageHeader
name|pageHeader
decl_stmt|;
comment|// fields required by Cacheable
name|int
name|refCount
init|=
literal|0
decl_stmt|;
name|int
name|timestamp
init|=
literal|0
decl_stmt|;
comment|// has the page been saved or is it dirty?
name|boolean
name|saved
init|=
literal|true
decl_stmt|;
comment|// set to true if the page has been removed from the cache
name|boolean
name|invalidated
init|=
literal|false
decl_stmt|;
specifier|public
name|DOMPage
parameter_list|()
block|{
name|this
operator|.
name|page
operator|=
name|createNewPage
argument_list|()
expr_stmt|;
name|pageHeader
operator|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|DOMPage
parameter_list|(
specifier|final
name|long
name|pos
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|page
operator|=
name|getPage
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
comment|//TODO  :throw exception ? -pb
block|}
block|}
specifier|public
name|DOMPage
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|load
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Page
name|createNewPage
parameter_list|()
block|{
try|try
block|{
specifier|final
name|Page
name|page
init|=
name|getFreePage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|pageHeader
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentDocument
operator|!=
literal|null
condition|)
block|{
name|currentDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|incPageCount
argument_list|()
expr_stmt|;
block|}
return|return
name|page
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|RecordPos
name|findRecord
parameter_list|(
specifier|final
name|short
name|targetId
parameter_list|)
block|{
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
name|RecordPos
name|rec
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dlen
condition|;
control|)
block|{
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_TID
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|matches
argument_list|(
name|tupleID
argument_list|,
name|targetId
argument_list|)
condition|)
block|{
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|rec
operator|=
operator|new
name|RecordPos
argument_list|(
name|pos
argument_list|,
name|this
argument_list|,
name|tupleID
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|=
operator|new
name|RecordPos
argument_list|(
name|pos
argument_list|,
name|this
argument_list|,
name|tupleID
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|else if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|vlen
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"page = "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; pos = "
operator|+
name|pos
operator|+
literal|"; vlen = "
operator|+
name|vlen
operator|+
literal|"; tupleID = "
operator|+
name|tupleID
operator|+
literal|"; target = "
operator|+
name|targetId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|vlen
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|+=
name|vlen
expr_stmt|;
block|}
if|if
condition|(
name|vlen
operator|==
name|OVERFLOW
condition|)
block|{
name|pos
operator|+=
name|LENGTH_OVERFLOW_LOCATION
expr_stmt|;
block|}
block|}
block|}
return|return
name|rec
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getKey
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
specifier|public
name|int
name|decReferenceCount
parameter_list|()
block|{
comment|//TODO : check if the decrementation is allowed ? -pb
return|return
name|refCount
operator|>
literal|0
condition|?
operator|--
name|refCount
else|:
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|incReferenceCount
parameter_list|()
block|{
comment|//TODO : check uf the incrementation is allowed ? -pb
if|if
condition|(
name|refCount
operator|<
name|Cacheable
operator|.
name|MAX_REF
condition|)
block|{
name|refCount
operator|++
expr_stmt|;
block|}
return|return
name|refCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReferenceCount
parameter_list|(
specifier|final
name|int
name|count
parameter_list|)
block|{
name|refCount
operator|=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setTimestamp
parameter_list|(
specifier|final
name|int
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
specifier|public
name|DOMFilePageHeader
name|getPageHeader
parameter_list|()
block|{
return|return
name|pageHeader
return|;
block|}
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
operator|!
name|saved
return|;
block|}
specifier|public
name|void
name|setDirty
parameter_list|(
specifier|final
name|boolean
name|dirty
parameter_list|)
block|{
name|saved
operator|=
operator|!
name|dirty
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDirty
argument_list|(
name|dirty
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|load
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|)
block|{
try|try
block|{
name|data
operator|=
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
name|pageHeader
operator|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
name|len
operator|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|saved
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|write
parameter_list|()
block|{
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|pageHeader
operator|.
name|isDirty
argument_list|()
condition|)
block|{
return|return;
block|}
name|pageHeader
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|page
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
comment|//TODO : thow exception ? -pb
block|}
block|}
specifier|public
name|String
name|dumpPage
parameter_list|()
block|{
return|return
literal|"Contents of page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": "
operator|+
name|hexDump
argument_list|(
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|sync
parameter_list|(
specifier|final
name|boolean
name|syncJournal
parameter_list|)
block|{
if|if
condition|(
name|isDirty
argument_list|()
condition|)
block|{
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
name|isRecoveryEnabled
argument_list|()
operator|&&
name|syncJournal
operator|&&
name|logManager
operator|.
name|get
argument_list|()
operator|.
name|lastWrittenLsn
argument_list|()
operator|.
name|compareTo
argument_list|(
name|pageHeader
operator|.
name|getLsn
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logManager
operator|.
name|get
argument_list|()
operator|.
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|allowUnload
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj
operator|instanceof
name|DOMPage
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|DOMPage
name|other
init|=
operator|(
name|DOMPage
operator|)
name|obj
decl_stmt|;
return|return
name|page
operator|.
name|equals
argument_list|(
name|other
operator|.
name|page
argument_list|)
return|;
block|}
specifier|public
name|void
name|invalidate
parameter_list|()
block|{
name|invalidated
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isInvalidated
parameter_list|()
block|{
return|return
name|invalidated
return|;
block|}
comment|/**          * Walk through the page after records have been removed. Set the tid          * counter to the next spare id that can be used for following          * insertions.          */
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
specifier|final
name|int
name|dlen
init|=
name|pageHeader
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
name|short
name|maxTupleID
init|=
literal|0
decl_stmt|;
name|short
name|recordCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dlen
condition|;
name|recordCount
operator|++
control|)
block|{
specifier|final
name|short
name|tupleID
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_TID
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
operator|>
name|ItemId
operator|.
name|MAX_ID
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|debugPageContents
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"TupleID overflow in page "
operator|+
name|getPageNum
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
operator|>
name|maxTupleID
condition|)
block|{
name|maxTupleID
operator|=
name|ItemId
operator|.
name|getId
argument_list|(
name|tupleID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|LENGTH_FORWARD_LOCATION
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|LENGTH_DATA_LENGTH
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|tupleID
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|LENGTH_OVERFLOW_LOCATION
else|:
name|LENGTH_ORIGINAL_LOCATION
operator|+
name|vlen
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
name|LENGTH_OVERFLOW_LOCATION
else|:
name|vlen
expr_stmt|;
block|}
block|}
block|}
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|maxTupleID
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This represents an overflow page. Overflow pages are created if the node      * data exceeds the size of one page. An overflow page is a sequence of      * DOMPages.      *       * @author wolf      *       */
specifier|protected
specifier|final
class|class
name|OverflowDOMPage
block|{
specifier|final
name|Page
name|firstPage
decl_stmt|;
specifier|public
name|OverflowDOMPage
parameter_list|()
block|{
name|firstPage
operator|=
name|createNewPage
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating overflow page: "
operator|+
name|firstPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|OverflowDOMPage
parameter_list|(
specifier|final
name|long
name|first
parameter_list|)
throws|throws
name|IOException
block|{
name|firstPage
operator|=
name|getPage
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Page
name|createNewPage
parameter_list|()
block|{
try|try
block|{
specifier|final
name|Page
name|page
init|=
name|getFreePage
argument_list|()
decl_stmt|;
specifier|final
name|DOMFilePageHeader
name|pageHeader
init|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|pageHeader
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setPrevDataPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setNextTupleID
argument_list|(
name|ItemId
operator|.
name|UNKNOWN_ID
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pageHeader
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentDocument
operator|!=
literal|null
condition|)
block|{
name|currentDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|incPageCount
argument_list|()
expr_stmt|;
block|}
return|return
name|page
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// Write binary resource from inputstream
specifier|public
name|int
name|write
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|)
block|{
name|int
name|pageCount
init|=
literal|0
decl_stmt|;
name|Page
name|currentPage
init|=
name|firstPage
decl_stmt|;
try|try
block|{
comment|// Transfer bytes from inputstream to db
specifier|final
name|int
name|chunkSize
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|chunkSize
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|altbuf
init|=
operator|new
name|byte
index|[
name|chunkSize
index|]
decl_stmt|;
name|byte
index|[]
name|currbuf
init|=
name|buf
decl_stmt|;
name|byte
index|[]
name|fullbuf
init|=
literal|null
decl_stmt|;
name|boolean
name|isaltbuf
init|=
literal|false
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|basebuf
init|=
literal|0
decl_stmt|;
name|int
name|basemax
init|=
name|chunkSize
decl_stmt|;
name|boolean
name|emptyPage
init|=
literal|true
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|currbuf
argument_list|,
name|basebuf
argument_list|,
name|basemax
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|emptyPage
operator|=
literal|false
expr_stmt|;
comment|// We are going to use a buffer swapping technique
if|if
condition|(
name|fullbuf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Value
name|value
init|=
operator|new
name|Value
argument_list|(
name|fullbuf
argument_list|,
literal|0
argument_list|,
name|chunkSize
argument_list|)
decl_stmt|;
specifier|final
name|Page
name|nextPage
init|=
name|createNewPage
argument_list|()
decl_stmt|;
name|currentPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|long
name|nextPageNum
init|=
name|nextPage
operator|.
name|getPageNum
argument_list|()
decl_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|WriteOverflowPageLoggable
argument_list|(
name|transaction
argument_list|,
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPageNum
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|currentPage
argument_list|)
expr_stmt|;
block|}
name|writeValue
argument_list|(
name|currentPage
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pageCount
operator|++
expr_stmt|;
name|currentPage
operator|=
name|nextPage
expr_stmt|;
name|fullbuf
operator|=
literal|null
expr_stmt|;
block|}
comment|// Let's swap the buffer
name|basebuf
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|basebuf
operator|==
name|chunkSize
condition|)
block|{
name|fullbuf
operator|=
name|currbuf
expr_stmt|;
name|currbuf
operator|=
operator|(
name|isaltbuf
operator|)
condition|?
name|buf
else|:
name|altbuf
expr_stmt|;
name|isaltbuf
operator|=
operator|!
name|isaltbuf
expr_stmt|;
name|basebuf
operator|=
literal|0
expr_stmt|;
name|basemax
operator|=
name|chunkSize
expr_stmt|;
block|}
else|else
block|{
name|basemax
operator|-=
name|len
expr_stmt|;
block|}
block|}
comment|// Detecting a zero byte stream
if|if
condition|(
name|emptyPage
condition|)
block|{
name|currentPage
operator|.
name|setPageNum
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
name|currentPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Just in the limit of a page
if|if
condition|(
name|fullbuf
operator|!=
literal|null
condition|)
block|{
name|basebuf
operator|=
name|chunkSize
expr_stmt|;
name|currbuf
operator|=
name|fullbuf
expr_stmt|;
block|}
specifier|final
name|Value
name|value
init|=
operator|new
name|Value
argument_list|(
name|currbuf
argument_list|,
literal|0
argument_list|,
name|basebuf
argument_list|)
decl_stmt|;
name|currentPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|long
name|nextPageNum
init|=
name|NO_PAGE
decl_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|WriteOverflowPageLoggable
argument_list|(
name|transaction
argument_list|,
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPageNum
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|currentPage
argument_list|)
expr_stmt|;
block|}
name|writeValue
argument_list|(
name|currentPage
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pageCount
operator|++
expr_stmt|;
block|}
comment|// TODO what if remaining length == 0 ?
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO error while writing overflow page"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
return|return
name|pageCount
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
name|int
name|pageCount
init|=
literal|0
decl_stmt|;
try|try
block|{
name|Page
name|currentPage
init|=
name|firstPage
decl_stmt|;
name|int
name|remaining
init|=
name|data
operator|.
name|length
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|chunkSize
init|=
name|remaining
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|?
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
else|:
name|remaining
decl_stmt|;
name|remaining
operator|-=
name|chunkSize
expr_stmt|;
specifier|final
name|Value
name|value
init|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|pos
argument_list|,
name|chunkSize
argument_list|)
decl_stmt|;
specifier|final
name|Page
name|nextPage
decl_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|nextPage
operator|=
name|createNewPage
argument_list|()
expr_stmt|;
name|currentPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextPage
operator|=
literal|null
expr_stmt|;
name|currentPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|WriteOverflowPageLoggable
argument_list|(
name|transaction
argument_list|,
name|currentPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|remaining
operator|>
literal|0
condition|?
name|nextPage
operator|.
name|getPageNum
argument_list|()
else|:
name|NO_PAGE
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|currentPage
argument_list|)
expr_stmt|;
block|}
name|writeValue
argument_list|(
name|currentPage
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|chunkSize
expr_stmt|;
name|currentPage
operator|=
name|nextPage
expr_stmt|;
operator|++
name|pageCount
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IO error while writing overflow page"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : throw exception ? -pb
block|}
return|return
name|pageCount
return|;
block|}
specifier|public
name|byte
index|[]
name|read
parameter_list|()
block|{
try|try
init|(
specifier|final
name|FastByteArrayOutputStream
name|os
init|=
operator|new
name|FastByteArrayOutputStream
argument_list|(
literal|32
argument_list|)
init|)
block|{
name|streamTo
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
name|os
operator|.
name|toByteArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|streamTo
parameter_list|(
specifier|final
name|OutputStream
name|os
parameter_list|)
block|{
name|Page
name|page
init|=
name|firstPage
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
try|try
block|{
specifier|final
name|byte
index|[]
name|chunk
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
specifier|final
name|long
name|nextPageNumber
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextPage
argument_list|()
decl_stmt|;
name|page
operator|=
operator|(
name|nextPageNumber
operator|==
name|NO_PAGE
operator|)
condition|?
literal|null
else|:
name|getPage
argument_list|(
name|nextPageNumber
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO error while loading overflow page "
operator|+
name|firstPage
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; read: "
operator|+
name|count
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : too soft ? throw the exception ?
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
block|{
name|Page
name|page
init|=
name|firstPage
decl_stmt|;
while|while
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing overflow page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|nextPageNumber
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isRecoveryEnabled
argument_list|()
condition|)
block|{
specifier|final
name|byte
index|[]
name|chunk
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|RemoveOverflowLoggable
argument_list|(
name|transaction
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPageNumber
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|=
operator|(
name|nextPageNumber
operator|==
name|NO_PAGE
operator|)
condition|?
literal|null
else|:
name|getPage
argument_list|(
name|nextPageNumber
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|firstPage
operator|.
name|getPageNum
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|FindCallback
implements|implements
name|BTreeCallback
block|{
specifier|public
specifier|final
specifier|static
name|int
name|KEYS
init|=
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|VALUES
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|mode
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Value
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|FindCallback
parameter_list|(
specifier|final
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|Value
argument_list|>
name|getValues
parameter_list|()
block|{
return|return
name|values
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|indexInfo
parameter_list|(
specifier|final
name|Value
name|value
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VALUES
case|:
specifier|final
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
specifier|final
name|short
name|vlen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|(
name|rec
operator|.
name|getPage
argument_list|()
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|+
name|LENGTH_DATA_LENGTH
argument_list|,
name|vlen
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|KEYS
case|:
name|values
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

