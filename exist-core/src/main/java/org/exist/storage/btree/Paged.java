begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-05 The eXist Project  *  http://exist-db.org  *    *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *    *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *    *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *    *  $Id$  *    *  This file is in part based on code from the dbXML Group. The original license  *  statement is included below:  *    *  -------------------------------------------------------------------------------------------------  *  dbXML License, Version 1.0  *  *  Copyright (c) 1999-2001 The dbXML Group, L.L.C.  *  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.  *  *  2. Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in  *  the documentation and/or other materials provided with the  *  distribution.  *  *  3. The end-user documentation included with the redistribution,  *  if any, must include the following acknowledgment:  *  "This product includes software developed by  *  The dbXML Group (http://www.dbxml.com/)."  *  Alternately, this acknowledgment may appear in the software  *  itself, if and wherever such third-party acknowledgments normally  *  appear.  *  *  4. The names "dbXML" and "The dbXML Group" must not be used to  *  endorse or promote products derived from this software without  *  prior written permission. For written permission, please contact  *  info@dbxml.com.  *  *  5. Products derived from this software may not be called "dbXML",  *  nor may "dbXML" appear in their name, without prior written  *  permission of The dbXML Group.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *  DISCLAIMED.  IN NO EVENT SHALL THE DBXML GROUP OR ITS CONTRIBUTORS  *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Lsn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|AutoCloseable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|NonWritableChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  *  Paged is a paged file foundation that is used by the BTree class and  *  its subclasses.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Paged
implements|implements
name|AutoCloseable
block|{
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_VERSION_ID
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_HEADER_SIZE
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_COUNT
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_SIZE
init|=
literal|4
decl_stmt|;
comment|//sizeof int
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_TOTAL_COUNT
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_FIRST_FREE_PAGE
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_LAST_FREE_PAGE
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_HEADER_SIZE
init|=
literal|1
decl_stmt|;
comment|//sizeof byte
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_MAX_KEY_SIZE
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_RECORD_COUNT
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_VERSION_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_HEADER_SIZE
init|=
name|OFFSET_VERSION_ID
operator|+
name|LENGTH_VERSION_ID
decl_stmt|;
comment|//2
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_PAGE_SIZE
init|=
name|OFFSET_HEADER_SIZE
operator|+
name|LENGTH_HEADER_SIZE
decl_stmt|;
comment|//4
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_PAGE_COUNT
init|=
name|OFFSET_PAGE_SIZE
operator|+
name|LENGTH_PAGE_SIZE
decl_stmt|;
comment|//8
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_TOTAL_COUNT
init|=
name|OFFSET_PAGE_COUNT
operator|+
name|LENGTH_PAGE_COUNT
decl_stmt|;
comment|//16
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_FIRST_FREE_PAGE
init|=
name|OFFSET_TOTAL_COUNT
operator|+
name|LENGTH_TOTAL_COUNT
decl_stmt|;
comment|//24
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_LAST_FREE_PAGE
init|=
name|OFFSET_FIRST_FREE_PAGE
operator|+
name|LENGTH_FIRST_FREE_PAGE
decl_stmt|;
comment|//32
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_PAGE_HEADER_SIZE
init|=
name|OFFSET_LAST_FREE_PAGE
operator|+
name|LENGTH_LAST_FREE_PAGE
decl_stmt|;
comment|//40
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_MAX_KEY_SIZE
init|=
name|OFFSET_PAGE_HEADER_SIZE
operator|+
name|LENGTH_PAGE_HEADER_SIZE
decl_stmt|;
comment|//41
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_RECORD_COUNT
init|=
name|OFFSET_MAX_KEY_SIZE
operator|+
name|LENGTH_MAX_KEY_SIZE
decl_stmt|;
comment|//43
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_REMAINDER
init|=
name|OFFSET_RECORD_COUNT
operator|+
name|LENGTH_RECORD_COUNT
decl_stmt|;
comment|//51
specifier|protected
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|Paged
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|byte
name|DELETED
init|=
literal|127
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|byte
name|OVERFLOW
init|=
literal|126
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|byte
name|UNUSED
init|=
literal|0
decl_stmt|;
specifier|protected
specifier|static
name|int
name|PAGE_SIZE
init|=
literal|4096
decl_stmt|;
specifier|protected
specifier|final
name|short
name|fileVersion
decl_stmt|;
specifier|private
specifier|final
name|FileHeader
name|fileHeader
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|tempPageData
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|tempHeaderData
decl_stmt|;
specifier|private
name|RandomAccessFile
name|raf
decl_stmt|;
specifier|private
name|Path
name|file
decl_stmt|;
specifier|private
name|boolean
name|readOnly
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|fileIsNew
init|=
literal|false
decl_stmt|;
specifier|public
name|Paged
parameter_list|(
specifier|final
name|BrokerPool
name|pool
parameter_list|,
specifier|final
name|short
name|fileVersion
parameter_list|)
block|{
name|this
operator|.
name|fileVersion
operator|=
name|fileVersion
expr_stmt|;
name|this
operator|.
name|fileHeader
operator|=
name|createFileHeader
argument_list|(
name|pool
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|tempPageData
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|pageSize
index|]
expr_stmt|;
name|this
operator|.
name|tempHeaderData
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|pageHeaderSize
index|]
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|static
name|void
name|setPageSize
parameter_list|(
specifier|final
name|int
name|pageSize
parameter_list|)
block|{
name|PAGE_SIZE
operator|=
name|pageSize
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|static
name|int
name|getPageSize
parameter_list|()
block|{
return|return
name|PAGE_SIZE
return|;
block|}
specifier|public
specifier|final
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
comment|/**      * Close the underlying files.      *      * @throws DBException      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|DBException
block|{
try|try
block|{
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DBException
argument_list|(
literal|"an error occurred while closing database file: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|create
parameter_list|()
throws|throws
name|DBException
block|{
try|try
block|{
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|DBException
argument_list|(
literal|0
argument_list|,
literal|"Error creating "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|file
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**      * createFileHeader must be implemented by a Paged implementation in order      * to create an appropriate subclass instance of a FileHeader.      *      * @return A new file header      */
specifier|public
specifier|abstract
name|FileHeader
name|createFileHeader
parameter_list|(
name|int
name|pageSize
parameter_list|)
function_decl|;
comment|/**      * createPageHeader must be implemented by a Paged implementation in order      * to create an appropriate subclass instance of a PageHeader.      *      * @return A new page header      */
specifier|public
specifier|abstract
name|PageHeader
name|createPageHeader
parameter_list|()
function_decl|;
specifier|public
name|boolean
name|exists
parameter_list|()
block|{
return|return
operator|!
name|fileIsNew
return|;
block|}
comment|/** Flushes {@link org.exist.storage.btree.Paged#flush()} dirty data to the disk and cleans up the cache.      * @return<code>true</code> if something has actually been cleaned      * @throws DBException      */
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|DBException
block|{
name|boolean
name|flushed
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fileHeader
operator|.
name|isDirty
argument_list|()
operator|&&
operator|!
name|readOnly
condition|)
block|{
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
name|flushed
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"report me"
argument_list|)
expr_stmt|;
comment|//TODO : this exception is *silently* ignored ?
block|}
return|return
name|flushed
return|;
block|}
comment|/**      * Backup the entire contents of the underlying file to       * an output stream.      *       * @param os      * @throws IOException      */
specifier|public
name|void
name|backupToStream
parameter_list|(
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|raf
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * getPath returns the file object for this Paged.      *      * @return The File      */
specifier|public
specifier|final
name|Path
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/**      * getFileHeader returns the FileHeader      *      * @return The FileHeader      */
specifier|public
name|FileHeader
name|getFileHeader
parameter_list|()
block|{
return|return
name|fileHeader
return|;
block|}
comment|/**      * Completely close down the instance and      * all underlying resources and caches.      */
specifier|public
name|void
name|closeAndRemove
parameter_list|()
block|{
try|try
block|{
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
comment|//TODO : forward the exception ? -pb
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close data file: "
operator|+
name|file
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|Page
name|getFreePage
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getFreePage
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**      * Returns the first free page it can find, either by reusing a deleted page      * or by appending a new one to secondary storage.      *      * @param reuseDeleted if set to false, the method will not try to reuse a      * previously deleted page. This is required by btree page split operations to avoid       * concurrency conflicts within a transaction.      *      * @return a free page      * @throws IOException      */
specifier|protected
specifier|final
name|Page
name|getFreePage
parameter_list|(
specifier|final
name|boolean
name|reuseDeleted
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Page
name|page
decl_stmt|;
synchronized|synchronized
init|(
name|fileHeader
init|)
block|{
name|long
name|pageNum
init|=
name|fileHeader
operator|.
name|firstFreePage
decl_stmt|;
if|if
condition|(
name|reuseDeleted
operator|&&
name|pageNum
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
comment|// Steal a deleted page
name|page
operator|=
operator|new
name|Page
argument_list|(
name|pageNum
argument_list|)
expr_stmt|;
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
name|fileHeader
operator|.
name|firstFreePage
operator|=
name|page
operator|.
name|header
operator|.
name|nextPage
expr_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|firstFreePage
operator|==
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|fileHeader
operator|.
name|setLastFreePage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Grow the file
name|pageNum
operator|=
name|fileHeader
operator|.
name|totalCount
expr_stmt|;
if|if
condition|(
name|pageNum
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"page limit reached: "
operator|+
name|pageNum
argument_list|)
throw|;
block|}
name|fileHeader
operator|.
name|setTotalCount
argument_list|(
name|pageNum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|page
operator|=
operator|new
name|Page
argument_list|(
name|pageNum
argument_list|)
expr_stmt|;
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Cleanly initialize The Page Header
name|page
operator|.
name|header
operator|.
name|setNextPage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
name|page
operator|.
name|header
operator|.
name|setStatus
argument_list|(
name|UNUSED
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// write out the file header
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
return|return
name|page
return|;
block|}
comment|/**      * getPage returns the page specified by pageNum.      *      * @param pageNum The Page number      *      * @return The requested Page      * @throws IOException if an exception occurs      */
specifier|protected
specifier|final
name|Page
name|getPage
parameter_list|(
specifier|final
name|long
name|pageNum
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Page
argument_list|(
name|pageNum
argument_list|)
return|;
block|}
comment|/**      * Gets the opened attribute of the Paged object      *      * @return The opened value      */
specifier|public
name|boolean
name|isOpened
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**      * @param requiredVersion The required version of the file      */
specifier|public
name|boolean
name|open
parameter_list|(
specifier|final
name|short
name|requiredVersion
parameter_list|)
throws|throws
name|DBException
block|{
try|try
block|{
if|if
condition|(
name|exists
argument_list|()
condition|)
block|{
name|fileHeader
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|getVersion
argument_list|()
operator|!=
name|requiredVersion
condition|)
block|{
throw|throw
operator|new
name|DBException
argument_list|(
literal|"Database file "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|getFile
argument_list|()
argument_list|)
operator|+
literal|" has a storage format incompatible with this "
operator|+
literal|"version of eXist. You need to upgrade your database by creating a backup, "
operator|+
literal|"cleaning your data directory and restoring the data. In some cases, "
operator|+
literal|"a reindex may be sufficient. "
operator|+
literal|"Please follow the instructions for the version you installed. "
operator|+
literal|"File version is: "
operator|+
name|fileHeader
operator|.
name|getVersion
argument_list|()
operator|+
literal|"; db requires version: "
operator|+
name|requiredVersion
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|DBException
argument_list|(
literal|0
argument_list|,
literal|"Error opening "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|file
argument_list|)
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Debug      *      * @exception IOException Description of the Exception      */
specifier|public
name|void
name|printFreeSpaceList
parameter_list|(
specifier|final
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|pageNum
init|=
name|fileHeader
operator|.
name|firstFreePage
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"first free page: "
operator|+
name|pageNum
argument_list|)
expr_stmt|;
name|Page
name|next
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"free pages for "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|pageNum
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|next
operator|=
name|getPage
argument_list|(
name|pageNum
argument_list|)
expr_stmt|;
name|next
operator|.
name|read
argument_list|()
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
name|pageNum
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|pageNum
operator|=
name|next
operator|.
name|header
operator|.
name|nextPage
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * setFile sets the file object for this Paged.      *      * @param file The File      */
specifier|protected
specifier|final
name|void
name|setFile
parameter_list|(
specifier|final
name|Path
name|file
parameter_list|)
throws|throws
name|DBException
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|fileIsNew
operator|=
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|file
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|file
argument_list|)
operator|)
operator|||
name|Files
operator|.
name|isWritable
argument_list|(
name|file
argument_list|)
condition|)
block|{
try|try
block|{
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
operator|.
name|toFile
argument_list|()
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
specifier|final
name|FileChannel
name|channel
init|=
name|raf
operator|.
name|getChannel
argument_list|()
decl_stmt|;
specifier|final
name|FileLock
name|lock
init|=
name|channel
operator|.
name|tryLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lock
operator|==
literal|null
condition|)
block|{
name|readOnly
operator|=
literal|true
expr_stmt|;
block|}
comment|//TODO : who will release the lock ? -pb
block|}
catch|catch
parameter_list|(
specifier|final
name|NonWritableChannelException
name|e
parameter_list|)
block|{
comment|//No way : switch to read-only mode
name|readOnly
operator|=
literal|true
expr_stmt|;
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
operator|.
name|toFile
argument_list|()
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|readOnly
operator|=
literal|true
expr_stmt|;
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
operator|.
name|toFile
argument_list|()
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An exception occurred while opening database file "
operator|+
name|file
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Unlinks a set of pages starting at the specified page.      *      * @param page The starting Page to unlink      * @throws IOException If an exception occurs      */
specifier|protected
name|void
name|unlinkPages
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|//Mmmmh... is this null test accurate ? -pb
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
comment|// Walk the chain and add it to the unused list
name|page
operator|.
name|header
operator|.
name|setStatus
argument_list|(
name|UNUSED
argument_list|)
expr_stmt|;
name|page
operator|.
name|header
operator|.
name|lsn
operator|=
name|Lsn
operator|.
name|LSN_INVALID
expr_stmt|;
synchronized|synchronized
init|(
name|fileHeader
init|)
block|{
if|if
condition|(
name|fileHeader
operator|.
name|firstFreePage
operator|==
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|fileHeader
operator|.
name|setFirstFreePage
argument_list|(
name|page
operator|.
name|pageNum
argument_list|)
expr_stmt|;
name|page
operator|.
name|header
operator|.
name|setNextPage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|firstFreePage
init|=
name|fileHeader
operator|.
name|firstFreePage
decl_stmt|;
name|fileHeader
operator|.
name|setFirstFreePage
argument_list|(
name|page
operator|.
name|pageNum
argument_list|)
expr_stmt|;
name|page
operator|.
name|header
operator|.
name|setNextPage
argument_list|(
name|firstFreePage
argument_list|)
expr_stmt|;
block|}
name|page
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fileHeader
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Unlinks a set of pages starting at the specified page      * number.      *      * @param pageNum A page number      * @throws IOException if an exception occurs      */
specifier|protected
specifier|final
name|void
name|unlinkPages
parameter_list|(
specifier|final
name|long
name|pageNum
parameter_list|)
throws|throws
name|IOException
block|{
name|unlinkPages
argument_list|(
name|getPage
argument_list|(
name|pageNum
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Clears the {@link FileHeader#firstFreePage} and      *  {@link FileHeader#lastFreePage}.      *      * This is needed in recovery, as the free page list      * may have become corrupted.      *      * Unfortunately this means we loose some space      * that we will never recover, but it does mean      * we are more likely to correctly recover.      */
specifier|protected
name|void
name|dropFreePageList
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|updated
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|getFirstFreePage
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|fileHeader
operator|.
name|setFirstFreePage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
name|updated
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|fileHeader
operator|.
name|getLastFreePage
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|fileHeader
operator|.
name|setLastFreePage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
name|updated
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|updated
condition|)
block|{
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|reuseDeleted
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|page
operator|!=
literal|null
operator|&&
name|fileHeader
operator|.
name|getFirstFreePage
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|long
name|firstFreePageNum
init|=
name|fileHeader
operator|.
name|getFirstFreePage
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstFreePageNum
operator|==
name|page
operator|.
name|pageNum
condition|)
block|{
name|fileHeader
operator|.
name|setFirstFreePage
argument_list|(
name|page
operator|.
name|header
operator|.
name|getNextPage
argument_list|()
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
return|return;
block|}
name|Page
name|firstFreePage
init|=
name|getPage
argument_list|(
name|firstFreePageNum
argument_list|)
decl_stmt|;
name|firstFreePage
operator|.
name|read
argument_list|()
expr_stmt|;
name|firstFreePageNum
operator|=
name|firstFreePage
operator|.
name|header
operator|.
name|getNextPage
argument_list|()
expr_stmt|;
while|while
condition|(
name|firstFreePageNum
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
if|if
condition|(
name|firstFreePageNum
operator|==
name|page
operator|.
name|pageNum
condition|)
block|{
name|firstFreePage
operator|.
name|header
operator|.
name|setNextPage
argument_list|(
name|page
operator|.
name|header
operator|.
name|getNextPage
argument_list|()
argument_list|)
expr_stmt|;
name|firstFreePage
operator|.
name|header
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|firstFreePage
operator|.
name|write
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
name|firstFreePage
operator|=
name|getPage
argument_list|(
name|firstFreePageNum
argument_list|)
expr_stmt|;
name|firstFreePage
operator|.
name|read
argument_list|()
expr_stmt|;
name|firstFreePageNum
operator|=
name|firstFreePage
operator|.
name|header
operator|.
name|getNextPage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Writes the multi-paged value starting at the specified Page.      *      * @param page The starting Page      * @param value The value to write      *      * @throws IOException if an Exception occurs      */
specifier|protected
specifier|final
name|void
name|writeValue
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|,
specifier|final
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|writeValue
argument_list|(
name|page
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|writeValue
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|PageHeader
name|pageHeader
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|pageHeader
operator|.
name|dataLen
operator|=
name|fileHeader
operator|.
name|workSize
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|!=
name|pageHeader
operator|.
name|dataLen
condition|)
block|{
comment|//TODO : where to get this 64 from ?
if|if
condition|(
name|pageHeader
operator|.
name|dataLen
operator|!=
name|getPageSize
argument_list|()
operator|-
literal|64
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ouch: "
operator|+
name|fileHeader
operator|.
name|workSize
operator|+
literal|" != "
operator|+
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|pageHeader
operator|.
name|dataLen
operator|=
name|data
operator|.
name|length
expr_stmt|;
block|}
name|page
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the multi-Paged Value starting at the specified page number.      *      * @param page The starting page number      * @param value The Value to write      * @throws IOException if an Exception occurs      */
specifier|protected
specifier|final
name|void
name|writeValue
parameter_list|(
specifier|final
name|long
name|page
parameter_list|,
specifier|final
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeValue
argument_list|(
name|getPage
argument_list|(
name|page
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * FileHeader      *      * @author Wolfgang Meier<meier@ifs.tu-darmstadt.de>      */
specifier|public
specifier|abstract
class|class
name|FileHeader
block|{
specifier|private
name|short
name|version
decl_stmt|;
specifier|private
name|boolean
name|dirty
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|firstFreePage
init|=
name|Page
operator|.
name|NO_PAGE
decl_stmt|;
specifier|private
name|short
name|headerSize
decl_stmt|;
specifier|private
name|long
name|lastFreePage
init|=
name|Page
operator|.
name|NO_PAGE
decl_stmt|;
specifier|private
name|short
name|maxKeySize
init|=
literal|256
decl_stmt|;
specifier|private
name|long
name|pageCount
decl_stmt|;
specifier|private
name|byte
name|pageHeaderSize
init|=
literal|64
decl_stmt|;
specifier|private
name|int
name|pageSize
decl_stmt|;
specifier|private
name|long
name|recordCount
decl_stmt|;
specifier|private
name|long
name|totalCount
decl_stmt|;
specifier|private
name|int
name|workSize
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|buf
decl_stmt|;
specifier|public
name|FileHeader
parameter_list|(
specifier|final
name|long
name|pageCount
parameter_list|,
specifier|final
name|int
name|pageSize
parameter_list|)
block|{
name|this
operator|.
name|pageSize
operator|=
name|pageSize
expr_stmt|;
name|this
operator|.
name|pageCount
operator|=
name|pageCount
expr_stmt|;
name|this
operator|.
name|totalCount
operator|=
name|pageCount
expr_stmt|;
name|this
operator|.
name|headerSize
operator|=
operator|(
name|short
operator|)
name|pageSize
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|fileVersion
expr_stmt|;
name|this
operator|.
name|buf
operator|=
operator|new
name|byte
index|[
name|headerSize
index|]
expr_stmt|;
name|calculateWorkSize
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|calculateWorkSize
parameter_list|()
block|{
name|workSize
operator|=
name|pageSize
operator|-
name|pageHeaderSize
expr_stmt|;
block|}
comment|/**          * Decrement the number of records being managed by the file          */
specifier|public
specifier|final
specifier|synchronized
name|void
name|decRecordCount
parameter_list|()
block|{
name|recordCount
operator|--
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The first free page in unused secondary space          *          * @return The firstFreePage value          */
specifier|public
specifier|final
name|long
name|getFirstFreePage
parameter_list|()
block|{
return|return
name|firstFreePage
return|;
block|}
comment|/**          * The size of the FileHeader. Usually 1 OS Page          *          * @return The size value          */
specifier|public
specifier|final
name|short
name|getHeaderSize
parameter_list|()
block|{
return|return
name|headerSize
return|;
block|}
comment|/**          * The last free page in unused secondary space          *          * @return The lastFreePage value          */
specifier|public
specifier|final
name|long
name|getLastFreePage
parameter_list|()
block|{
return|return
name|lastFreePage
return|;
block|}
comment|/**          * The maximum number of bytes a key can be. 256 is good          *          * @return The maxKeySize value          */
specifier|public
name|int
name|getMaxKeySize
parameter_list|()
block|{
return|return
name|maxKeySize
return|;
block|}
comment|/**          * The number of pages in primary storage          *          * @return The pageCount value          */
specifier|public
specifier|final
name|long
name|getPageCount
parameter_list|()
block|{
return|return
name|pageCount
return|;
block|}
comment|/**          * The size of a page header. 64 is sufficient          *          *@return The pageHeaderSize value          */
specifier|public
specifier|final
name|byte
name|getPageHeaderSize
parameter_list|()
block|{
return|return
name|pageHeaderSize
return|;
block|}
comment|/**          * The size of a page. Usually a multiple of a FS block          *          * @return The page size          */
specifier|public
specifier|final
name|int
name|getPageSize
parameter_list|()
block|{
return|return
name|pageSize
return|;
block|}
comment|/**          *  The number of records being managed by the file (not pages)          *          *@return    The number of records          */
specifier|public
specifier|final
name|long
name|getRecordCount
parameter_list|()
block|{
return|return
name|recordCount
return|;
block|}
comment|/**          * The total number of pages in the file          *          * @return The total number of pages          */
specifier|public
specifier|final
name|long
name|getTotalCount
parameter_list|()
block|{
return|return
name|totalCount
return|;
block|}
comment|/**          * Gets the workSize attribute of the FileHeader object          *          * @return The workSize value          */
specifier|public
specifier|final
name|int
name|getWorkSize
parameter_list|()
block|{
return|return
name|workSize
return|;
block|}
specifier|public
specifier|final
name|short
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/**          * Increment the number of records being managed by the file          */
specifier|public
specifier|final
specifier|synchronized
name|void
name|incRecordCount
parameter_list|()
block|{
name|recordCount
operator|++
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * Returns whether this page has been modified or not.          *          * @return<code>true</code> if this page has been modified          */
specifier|public
specifier|final
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
name|dirty
return|;
block|}
specifier|public
specifier|final
specifier|synchronized
name|void
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|raf
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|calculateWorkSize
argument_list|()
expr_stmt|;
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|version
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|buf
argument_list|,
name|OFFSET_VERSION_ID
argument_list|)
expr_stmt|;
name|headerSize
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|buf
argument_list|,
name|OFFSET_HEADER_SIZE
argument_list|)
expr_stmt|;
name|pageSize
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|buf
argument_list|,
name|OFFSET_PAGE_SIZE
argument_list|)
expr_stmt|;
name|pageCount
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|OFFSET_PAGE_COUNT
argument_list|)
expr_stmt|;
name|totalCount
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|OFFSET_TOTAL_COUNT
argument_list|)
expr_stmt|;
name|firstFreePage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|OFFSET_FIRST_FREE_PAGE
argument_list|)
expr_stmt|;
name|lastFreePage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|OFFSET_LAST_FREE_PAGE
argument_list|)
expr_stmt|;
name|pageHeaderSize
operator|=
name|buf
index|[
name|OFFSET_PAGE_HEADER_SIZE
index|]
expr_stmt|;
name|maxKeySize
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|buf
argument_list|,
name|OFFSET_MAX_KEY_SIZE
argument_list|)
expr_stmt|;
name|recordCount
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|OFFSET_RECORD_COUNT
argument_list|)
expr_stmt|;
return|return
name|OFFSET_REMAINDER
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|version
argument_list|,
name|buf
argument_list|,
name|OFFSET_VERSION_ID
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|headerSize
argument_list|,
name|buf
argument_list|,
name|OFFSET_HEADER_SIZE
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|pageSize
argument_list|,
name|buf
argument_list|,
name|OFFSET_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|pageCount
argument_list|,
name|buf
argument_list|,
name|OFFSET_PAGE_COUNT
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|totalCount
argument_list|,
name|buf
argument_list|,
name|OFFSET_TOTAL_COUNT
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|firstFreePage
argument_list|,
name|buf
argument_list|,
name|OFFSET_FIRST_FREE_PAGE
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|lastFreePage
argument_list|,
name|buf
argument_list|,
name|OFFSET_LAST_FREE_PAGE
argument_list|)
expr_stmt|;
name|buf
index|[
name|OFFSET_PAGE_HEADER_SIZE
index|]
operator|=
name|pageHeaderSize
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|maxKeySize
argument_list|,
name|buf
argument_list|,
name|OFFSET_MAX_KEY_SIZE
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|recordCount
argument_list|,
name|buf
argument_list|,
name|OFFSET_RECORD_COUNT
argument_list|)
expr_stmt|;
return|return
name|OFFSET_REMAINDER
return|;
block|}
comment|/**          * Sets the dirty attribute of the FileHeader object          *          * @param dirty The new dirty value          */
specifier|public
specifier|final
name|void
name|setDirty
parameter_list|(
specifier|final
name|boolean
name|dirty
parameter_list|)
block|{
name|this
operator|.
name|dirty
operator|=
name|dirty
expr_stmt|;
block|}
comment|/**          * The first free page in unused secondary space          *          * @param firstFreePage The new first free page number          */
specifier|public
specifier|final
name|void
name|setFirstFreePage
parameter_list|(
specifier|final
name|long
name|firstFreePage
parameter_list|)
block|{
name|this
operator|.
name|firstFreePage
operator|=
name|firstFreePage
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The size of the FileHeader. Usually 1 OS Page          *          * @param headerSize The new headerSize value          */
specifier|public
specifier|final
name|void
name|setHeaderSize
parameter_list|(
specifier|final
name|short
name|headerSize
parameter_list|)
block|{
name|this
operator|.
name|headerSize
operator|=
name|headerSize
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The last free page in unused secondary space          *          * @param lastFreePage The new lastFreePage value          */
specifier|public
specifier|final
name|void
name|setLastFreePage
parameter_list|(
specifier|final
name|long
name|lastFreePage
parameter_list|)
block|{
name|this
operator|.
name|lastFreePage
operator|=
name|lastFreePage
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The maximum number of bytes a key can be. 256 is good          *          * @param maxKeySize The new maximum size for a key          */
specifier|public
specifier|final
name|void
name|setMaxKeySize
parameter_list|(
specifier|final
name|short
name|maxKeySize
parameter_list|)
block|{
name|this
operator|.
name|maxKeySize
operator|=
name|maxKeySize
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The number of pages in primary storage          *          * @param  pageCount  The new pageCount value          */
specifier|public
specifier|final
name|void
name|setPageCount
parameter_list|(
specifier|final
name|long
name|pageCount
parameter_list|)
block|{
name|this
operator|.
name|pageCount
operator|=
name|pageCount
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The size of a page header. 64 is sufficient          *          * @param pageHeaderSize The new pageHeaderSize value          */
specifier|public
specifier|final
name|void
name|setPageHeaderSize
parameter_list|(
specifier|final
name|byte
name|pageHeaderSize
parameter_list|)
block|{
name|this
operator|.
name|pageHeaderSize
operator|=
name|pageHeaderSize
expr_stmt|;
name|calculateWorkSize
argument_list|()
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The size of a page. Usually a multiple of a FS block          *          * @param pageSize The new pageSize value          */
specifier|public
specifier|final
name|void
name|setPageSize
parameter_list|(
specifier|final
name|int
name|pageSize
parameter_list|)
block|{
name|this
operator|.
name|pageSize
operator|=
name|pageSize
expr_stmt|;
name|calculateWorkSize
argument_list|()
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The number of records being managed by the file (not pages)          *          * @param recordCount The new recordCount value          */
specifier|public
specifier|final
name|void
name|setRecordCount
parameter_list|(
specifier|final
name|long
name|recordCount
parameter_list|)
block|{
name|this
operator|.
name|recordCount
operator|=
name|recordCount
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The number of total pages in the file          *          * @param totalCount The new totalCount value          */
specifier|public
specifier|final
name|void
name|setTotalCount
parameter_list|(
specifier|final
name|long
name|totalCount
parameter_list|)
block|{
name|this
operator|.
name|totalCount
operator|=
name|totalCount
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|synchronized
name|void
name|write
parameter_list|()
throws|throws
name|IOException
block|{
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|raf
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**      * Page      */
specifier|public
specifier|final
class|class
name|Page
implements|implements
name|Comparable
argument_list|<
name|Page
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|long
name|NO_PAGE
init|=
operator|-
literal|1
decl_stmt|;
comment|/**  The Header for this Page */
specifier|private
specifier|final
name|PageHeader
name|header
decl_stmt|;
comment|/**  The offset into the file that this page starts */
specifier|private
name|long
name|offset
decl_stmt|;
comment|/**  This page number */
specifier|private
name|long
name|pageNum
decl_stmt|;
specifier|private
name|int
name|refCount
init|=
literal|0
decl_stmt|;
specifier|public
name|Page
parameter_list|()
block|{
name|this
operator|.
name|header
operator|=
name|createPageHeader
argument_list|()
expr_stmt|;
block|}
comment|/**          * Constructor for the Page object          *          * @param pageNum Description of the Parameter          *          * @exception IOException Description of the Exception          */
specifier|public
name|Page
parameter_list|(
specifier|final
name|long
name|pageNum
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|()
expr_stmt|;
if|if
condition|(
name|pageNum
operator|==
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Illegal page num: "
operator|+
name|pageNum
argument_list|)
throw|;
block|}
name|setPageNum
argument_list|(
name|pageNum
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|decRefCount
parameter_list|()
block|{
name|refCount
operator|--
expr_stmt|;
block|}
comment|/**          * Gets the offset attribute of the Page object          *          * @return The offset value          */
specifier|public
name|long
name|getOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
comment|/**          * Gets the pageHeader attribute of the Page object          *          * @return The pageHeader value          */
specifier|public
name|PageHeader
name|getPageHeader
parameter_list|()
block|{
return|return
name|header
return|;
block|}
comment|/**          * Gets the pageInfo attribute of the Page object          *          * @return The pageInfo value          */
specifier|public
name|String
name|getPageInfo
parameter_list|()
block|{
return|return
literal|"page: "
operator|+
name|pageNum
operator|+
literal|"; file = "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|getFile
argument_list|()
argument_list|)
operator|+
literal|"; address = "
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|offset
argument_list|)
operator|+
literal|"; page header = "
operator|+
name|fileHeader
operator|.
name|getPageHeaderSize
argument_list|()
operator|+
literal|"; data start = "
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|offset
operator|+
name|fileHeader
operator|.
name|getPageHeaderSize
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|pageNum
return|;
block|}
specifier|public
name|int
name|getRefCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
specifier|public
name|int
name|getDataPos
parameter_list|()
block|{
return|return
name|fileHeader
operator|.
name|pageHeaderSize
return|;
block|}
specifier|public
name|void
name|incRefCount
parameter_list|()
block|{
name|refCount
operator|++
expr_stmt|;
block|}
specifier|public
name|byte
index|[]
name|read
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|raf
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|offset
condition|)
block|{
name|raf
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|tempHeaderData
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|raf
operator|.
name|read
argument_list|(
name|tempHeaderData
argument_list|)
expr_stmt|;
comment|// Read in the header
name|header
operator|.
name|read
argument_list|(
name|tempHeaderData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Read the working data
specifier|final
name|byte
index|[]
name|workData
init|=
operator|new
name|byte
index|[
name|header
operator|.
name|dataLen
index|]
decl_stmt|;
name|raf
operator|.
name|read
argument_list|(
name|workData
argument_list|)
expr_stmt|;
return|return
name|workData
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while reading page: "
operator|+
name|getPageInfo
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|setPageNum
parameter_list|(
specifier|final
name|long
name|pageNum
parameter_list|)
block|{
name|this
operator|.
name|pageNum
operator|=
name|pageNum
expr_stmt|;
name|offset
operator|=
name|fileHeader
operator|.
name|headerSize
operator|+
operator|(
name|pageNum
operator|*
name|fileHeader
operator|.
name|pageSize
operator|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
throws|throws
name|IOException
block|{
name|write
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
comment|// Removed page: fill with 0
name|Arrays
operator|.
name|fill
argument_list|(
name|tempPageData
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|header
operator|.
name|setLsn
argument_list|(
name|Lsn
operator|.
name|LSN_INVALID
argument_list|)
expr_stmt|;
block|}
comment|// Write out the header
name|header
operator|.
name|write
argument_list|(
name|tempPageData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|header
operator|.
name|dirty
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|length
operator|>
name|fileHeader
operator|.
name|workSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"page: "
operator|+
name|getPageInfo
argument_list|()
operator|+
literal|": data length too large: "
operator|+
name|data
operator|.
name|length
argument_list|)
throw|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|tempPageData
argument_list|,
name|fileHeader
operator|.
name|pageHeaderSize
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|raf
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|offset
condition|)
block|{
name|raf
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|raf
operator|.
name|write
argument_list|(
name|tempPageData
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|obj
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Page
operator|)
name|obj
operator|)
operator|.
name|pageNum
operator|==
name|pageNum
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
specifier|final
name|Page
name|other
parameter_list|)
block|{
if|if
condition|(
name|pageNum
operator|==
name|other
operator|.
name|pageNum
condition|)
block|{
return|return
name|Constants
operator|.
name|EQUAL
return|;
block|}
if|else if
condition|(
name|pageNum
operator|>
name|other
operator|.
name|pageNum
condition|)
block|{
return|return
name|Constants
operator|.
name|SUPERIOR
return|;
block|}
else|else
block|{
return|return
name|Constants
operator|.
name|INFERIOR
return|;
block|}
block|}
specifier|public
name|void
name|dumpPage
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|raf
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|offset
condition|)
block|{
name|raf
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|pageSize
index|]
decl_stmt|;
name|raf
operator|.
name|read
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Contents of page "
operator|+
name|pageNum
operator|+
literal|": "
operator|+
name|hexDump
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
specifier|abstract
class|class
name|PageHeader
block|{
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_STATUS
init|=
literal|1
decl_stmt|;
comment|//sizeof byte
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_DATA_LENGTH
init|=
literal|4
decl_stmt|;
comment|//sizeof int
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_NEXT_PAGE
init|=
literal|8
decl_stmt|;
comment|//sizeof long
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_PAGE_LSN
init|=
name|Lsn
operator|.
name|RAW_LENGTH
decl_stmt|;
specifier|private
name|int
name|dataLen
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|dirty
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|nextPage
init|=
name|Page
operator|.
name|NO_PAGE
decl_stmt|;
specifier|private
name|byte
name|status
init|=
name|UNUSED
decl_stmt|;
specifier|private
name|Lsn
name|lsn
init|=
name|Lsn
operator|.
name|LSN_INVALID
decl_stmt|;
specifier|public
name|PageHeader
parameter_list|()
block|{
block|}
specifier|public
name|PageHeader
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/**          * The length of the Data          *          * @return The dataLen value          */
specifier|public
specifier|final
name|int
name|getDataLen
parameter_list|()
block|{
return|return
name|dataLen
return|;
block|}
comment|/**          * The next page for this Record (if overflowed)          *          * @return The nextPage value          */
specifier|public
specifier|final
name|long
name|getNextPage
parameter_list|()
block|{
return|return
name|nextPage
return|;
block|}
comment|/**          * The status of this page (UNUSED, RECORD, DELETED, etc...)          * - jmv - DESIGN_NOTE : 44 calls to this functions, mostly with switch;          * the "state" design pattern is appropriate to eliminate these non - object oriented switches,          * and put together all the behavior related to one state.           *           * @return    The status value          */
specifier|public
specifier|final
name|byte
name|getStatus
parameter_list|()
block|{
return|return
name|status
return|;
block|}
comment|/**          *  Gets the dirty attribute of the PageHeader object          *          *@return    The dirty value          */
specifier|public
specifier|final
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
name|dirty
return|;
block|}
comment|/**          * Returns the LSN, i.e. the log sequence number, of the last          * operation that modified this page. This information is used          * during recovery: if the log sequence number of a log record          * is smaller or equal to the LSN stored in this page header, then          * the page has already been written to disk before the database          * failure. Otherwise, the modification is not yet reflected in the page          * and the operation needs to be redone.          *           * @return log sequence number of the last operation that modified this page.          */
specifier|public
specifier|final
name|Lsn
name|getLsn
parameter_list|()
block|{
return|return
name|lsn
return|;
block|}
specifier|public
specifier|final
name|void
name|setLsn
parameter_list|(
specifier|final
name|Lsn
name|lsn
parameter_list|)
block|{
name|this
operator|.
name|lsn
operator|=
name|lsn
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|status
operator|=
name|data
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_STATUS
expr_stmt|;
name|dataLen
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_DATA_LENGTH
expr_stmt|;
name|nextPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_NEXT_PAGE
expr_stmt|;
name|lsn
operator|=
name|Lsn
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_LSN
expr_stmt|;
return|return
name|offset
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
index|[
name|offset
index|]
operator|=
name|status
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_STATUS
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|dataLen
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_DATA_LENGTH
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|nextPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_NEXT_PAGE
expr_stmt|;
name|lsn
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_PAGE_LSN
expr_stmt|;
name|dirty
operator|=
literal|false
expr_stmt|;
return|return
name|offset
return|;
block|}
comment|/**          * The length of the Data          *          * @param  dataLen  The new dataLen value          */
specifier|public
specifier|final
name|void
name|setDataLen
parameter_list|(
specifier|final
name|int
name|dataLen
parameter_list|)
block|{
name|this
operator|.
name|dataLen
operator|=
name|dataLen
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
specifier|final
name|void
name|setDirty
parameter_list|(
specifier|final
name|boolean
name|dirty
parameter_list|)
block|{
name|this
operator|.
name|dirty
operator|=
name|dirty
expr_stmt|;
block|}
comment|/**          * The next page for this Record (if overflowed)          *          * @param nextPage The new nextPage value          */
specifier|public
specifier|final
name|void
name|setNextPage
parameter_list|(
specifier|final
name|long
name|nextPage
parameter_list|)
block|{
name|this
operator|.
name|nextPage
operator|=
name|nextPage
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * The status of this page (UNUSED, RECORD, DELETED, etc...)          *          * @param status The new status value          */
specifier|public
specifier|final
name|void
name|setStatus
parameter_list|(
specifier|final
name|byte
name|status
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
index|[]
name|hex
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|}
decl_stmt|;
specifier|public
specifier|static
name|String
name|hexDump
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|columns
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
operator|,
name|columns
operator|++
control|)
block|{
name|byteToHex
argument_list|(
name|buf
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|16
condition|)
block|{
name|columns
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|byteToHex
parameter_list|(
specifier|final
name|StringBuilder
name|buf
parameter_list|,
specifier|final
name|byte
name|b
parameter_list|)
block|{
name|int
name|n
init|=
name|b
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
literal|256
operator|+
name|n
expr_stmt|;
block|}
specifier|final
name|int
name|d1
init|=
name|n
operator|/
literal|16
decl_stmt|;
specifier|final
name|int
name|d2
init|=
name|n
operator|%
literal|16
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|hex
index|[
name|d1
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|hex
index|[
name|d2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

