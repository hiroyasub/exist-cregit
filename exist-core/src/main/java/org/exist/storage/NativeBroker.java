begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2015 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|function
operator|.
name|FunctionE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|DOMIndexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Indexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|backup
operator|.
name|RawDataBackup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
operator|.
name|SubCollectionEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
operator|.
name|ReindexMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StructuralIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|internal
operator|.
name|aider
operator|.
name|ACEAider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|EmbeddedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|IEmbeddedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|RawNodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
operator|.
name|LockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|NativeSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|DigestType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|FastByteArrayInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|FastByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|InputStreamUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DocumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|INodeIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple2
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
operator|.
name|DEFAULT_TEMPORARY_COLLECTION_PERM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
operator|.
name|InputStreamUtil
operator|.
name|copy
import|;
end_import

begin_comment
comment|/**  * Main class for the native XML storage backend.  * By "native" it is meant file-based, embedded backend.  *  * Provides access to all low-level operations required by  * the database. Extends {@link DBBroker}.  *  * This class dispatches the various events (defined by the methods  * of {@link org.exist.storage.ContentLoadingObserver}) to indexing classes.  *  * @author Wolfgang Meier  */
end_comment

begin_class
specifier|public
class|class
name|NativeBroker
extends|extends
name|DBBroker
block|{
specifier|public
specifier|final
specifier|static
name|String
name|EXIST_STATISTICS_LOGGER
init|=
literal|"org.exist.statistics"
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|Logger
name|LOG_STATS
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|EXIST_STATISTICS_LOGGER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_ALWAYS
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_NEVER
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_AS_NEEDED
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|COLLECTIONS_DBX_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|VALUES_DBX_ID
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|DOM_DBX_ID
init|=
literal|3
decl_stmt|;
comment|//Note : no ID for symbols ? Too bad...
specifier|public
specifier|static
specifier|final
name|String
name|PAGE_SIZE_ATTRIBUTE
init|=
literal|"pageSize"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_DEPTH_ATTRIBUTE
init|=
literal|"index-depth"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_INDEX_DEPTH
init|=
literal|"indexer.index-depth"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ALL_STORAGE_FILES
init|=
block|{
name|COLLECTIONS_DBX_ID
block|,
name|VALUES_DBX_ID
block|,
name|DOM_DBX_ID
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EXCEPTION_DURING_REINDEX
init|=
literal|"exception during reindex"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DATABASE_IS_READ_ONLY
init|=
literal|"Database is read-only"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_DATA_DIR
init|=
literal|"data"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INDEX_DEPTH
init|=
literal|1
decl_stmt|;
comment|/** check available memory after storing DEFAULT_NODES_BEFORE_MEMORY_CHECK nodes */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
init|=
literal|500
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|FIRST_COLLECTION_ID
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_COLLECTION_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|INIT_COLLECTION_CONFIG
init|=
literal|"collection.xconf.init"
decl_stmt|;
comment|/** in-memory buffer size to use when copying binary resources */
specifier|private
specifier|final
specifier|static
name|int
name|BINARY_RESOURCE_BUF_SIZE
init|=
literal|65536
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|DigestType
name|BINARY_RESOURCE_DIGEST_TYPE
init|=
name|DigestType
operator|.
name|BLAKE_256
decl_stmt|;
comment|/** the database files */
specifier|private
specifier|final
name|CollectionStore
name|collectionsDb
decl_stmt|;
specifier|private
specifier|final
name|DOMFile
name|domDb
decl_stmt|;
comment|/** the index processors */
specifier|private
name|NativeValueIndex
name|valueIndex
decl_stmt|;
specifier|private
specifier|final
name|IndexSpec
name|indexConfiguration
decl_stmt|;
specifier|private
name|int
name|defaultIndexDepth
decl_stmt|;
specifier|private
specifier|final
name|Serializer
name|xmlSerializer
decl_stmt|;
comment|/** used to count the nodes inserted after the last memory check */
specifier|private
name|int
name|nodesCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|nodesCountThreshold
init|=
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
decl_stmt|;
specifier|private
specifier|final
name|Path
name|dataDir
decl_stmt|;
specifier|private
specifier|final
name|byte
name|prepend
decl_stmt|;
specifier|private
specifier|final
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|NodeProcessor
name|nodeProcessor
init|=
operator|new
name|NodeProcessor
argument_list|()
decl_stmt|;
specifier|private
name|IEmbeddedXMLStreamReader
name|streamReader
decl_stmt|;
specifier|private
specifier|final
name|LockManager
name|lockManager
decl_stmt|;
specifier|private
specifier|final
name|Optional
argument_list|<
name|JournalManager
argument_list|>
name|logManager
decl_stmt|;
comment|// initialize database; read configuration, etc.
specifier|public
name|NativeBroker
parameter_list|(
specifier|final
name|BrokerPool
name|pool
parameter_list|,
specifier|final
name|Configuration
name|config
parameter_list|)
throws|throws
name|EXistException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockManager
operator|=
name|pool
operator|.
name|getLockManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|logManager
operator|=
name|pool
operator|.
name|getJournalManager
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing broker {}"
argument_list|,
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|prependDB
init|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.prepend-db"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"always"
operator|.
name|equalsIgnoreCase
argument_list|(
name|prependDB
argument_list|)
condition|)
block|{
name|this
operator|.
name|prepend
operator|=
name|PREPEND_DB_ALWAYS
expr_stmt|;
block|}
if|else if
condition|(
literal|"never"
operator|.
name|equalsIgnoreCase
argument_list|(
name|prependDB
argument_list|)
condition|)
block|{
name|this
operator|.
name|prepend
operator|=
name|PREPEND_DB_NEVER
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|prepend
operator|=
name|PREPEND_DB_AS_NEEDED
expr_stmt|;
block|}
name|this
operator|.
name|dataDir
operator|=
name|config
operator|.
name|getProperty
argument_list|(
name|BrokerPool
operator|.
name|PROPERTY_DATA_DIR
argument_list|,
name|Paths
operator|.
name|get
argument_list|(
name|DEFAULT_DATA_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|nodesCountThreshold
operator|=
name|config
operator|.
name|getInteger
argument_list|(
name|BrokerPool
operator|.
name|PROPERTY_NODES_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodesCountThreshold
operator|>
literal|0
condition|)
block|{
name|nodesCountThreshold
operator|=
name|nodesCountThreshold
operator|*
literal|1000
expr_stmt|;
block|}
name|defaultIndexDepth
operator|=
name|config
operator|.
name|getInteger
argument_list|(
name|PROPERTY_INDEX_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultIndexDepth
operator|<
literal|0
condition|)
block|{
name|defaultIndexDepth
operator|=
name|DEFAULT_INDEX_DEPTH
expr_stmt|;
block|}
name|this
operator|.
name|indexConfiguration
operator|=
operator|(
name|IndexSpec
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|Indexer
operator|.
name|PROPERTY_INDEXER_CONFIG
argument_list|)
expr_stmt|;
name|this
operator|.
name|xmlSerializer
operator|=
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
try|try
block|{
name|pushSubject
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : refactor so that we can,
comment|//1) customize the different properties (file names, cache settings...)
comment|//2) have a consistent READ-ONLY behaviour (based on *mandatory* files ?)
comment|//3) have consistent file creation behaviour (we can probably avoid some unnecessary files)
comment|//4) use... *customized* factories for a better index extensibility ;-)
comment|// Initialize DOM storage
specifier|final
name|DOMFile
name|configuredDomFile
init|=
operator|(
name|DOMFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|DOMFile
operator|.
name|getConfigKeyForFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|configuredDomFile
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|domDb
operator|=
name|configuredDomFile
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|domDb
operator|=
operator|new
name|DOMFile
argument_list|(
name|pool
argument_list|,
name|DOM_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domDb
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} is read-only!"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|domDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
block|}
comment|//Initialize collections storage
specifier|final
name|CollectionStore
name|configuredCollectionsDb
init|=
operator|(
name|CollectionStore
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|CollectionStore
operator|.
name|getConfigKeyForFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|configuredCollectionsDb
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|collectionsDb
operator|=
name|configuredCollectionsDb
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|collectionsDb
operator|=
operator|new
name|CollectionStore
argument_list|(
name|pool
argument_list|,
name|COLLECTIONS_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collectionsDb
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} is read-only!"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|VALUES_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|popSubject
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ElementIndex
name|getElementIndex
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|// ============ dispatch the various events to indexing classes ==========
specifier|private
name|void
name|notifyRemoveNode
parameter_list|(
specifier|final
name|NodeHandle
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
specifier|final
name|String
name|content
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|removeNode
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
comment|//private void notifyStoreAttribute(AttrImpl attr, NodePath currentPath, int indexingHint, RangeIndexSpec spec, boolean remove) {
comment|//    for (int i = 0; i< contentLoadingObservers.size(); i++) {
comment|//        ContentLoadingObserver observer = (ContentLoadingObserver) contentLoadingObservers.get(i);
comment|//        observer.storeAttribute(attr, currentPath, indexingHint, spec, remove);
comment|//    }
comment|//}
specifier|private
name|void
name|notifyStoreText
parameter_list|(
specifier|final
name|TextImpl
name|text
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|storeText
argument_list|(
name|text
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
specifier|final
name|Collection
name|collection
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyRemove
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifySync
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyFlush
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
try|try
block|{
name|observer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|//Ignore the exception ; try to continue on other files
block|}
block|}
block|}
specifier|private
name|void
name|notifyPrintStatistics
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyClose
parameter_list|()
throws|throws
name|DBException
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|notifyCloseAndRemove
parameter_list|()
throws|throws
name|DBException
block|{
for|for
control|(
specifier|final
name|ContentLoadingObserver
name|observer
range|:
name|contentLoadingObservers
control|)
block|{
name|observer
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
block|}
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
block|}
comment|/**      * Update indexes for the given element node. This method is called when the indexer      * encounters a closing element tag. It updates any range indexes defined on the      * element value and adds the element id to the structural index.      *      * @param node        the current element node      * @param currentPath node path leading to the element      * @param content     contains the string value of the element. Needed if a range index      *                    is defined on it.      */
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|endElement
parameter_list|(
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|,
specifier|final
name|boolean
name|remove
parameter_list|)
block|{
specifier|final
name|int
name|indexType
init|=
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
comment|//TODO : do not care about the current code redundancy : this will move in the (near) future
comment|// TODO : move to NativeValueIndex
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|node
operator|.
name|setQName
argument_list|(
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
comment|//NodeProxy p = new NodeProxy(node);
comment|//if (node.getOldInternalAddress() != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)
comment|//    p.setInternalAddress(node.getOldInternalAddress());
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//Curious... I assume getNodeValue() needs the old address
comment|//p.setInternalAddress(node.getInternalAddress());
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
name|remove
argument_list|)
expr_stmt|;
block|}
comment|// TODO : move to NativeValueIndexByQName
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasQNameIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|node
operator|.
name|setQName
argument_list|(
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
comment|//NodeProxy p = new NodeProxy(node);
comment|//if (node.getOldInternalAddress() != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)
comment|//    p.setInternalAddress(node.getOldInternalAddress());
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//Curious... I assume getNodeValue() needs the old address
comment|//p.setInternalAddress(node.getInternalAddress());
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|QNAME
argument_list|,
name|remove
argument_list|)
expr_stmt|;
comment|//qnameValueIndex.setDocument((DocumentImpl) node.getOwnerDocument());
comment|//qnameValueIndex.endElement((ElementImpl) node, currentPath, content);
block|}
block|}
comment|/*       private String getOldNodeContent(StoredNode node, long oldAddress) {           NodeProxy p = new NodeProxy(node);           if (oldAddress != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)               p.setInternalAddress(oldAddress);           String content = getNodeValue(node, false);           //Curious... I assume getNodeValue() needs the old address           p.setInternalAddress(node.getInternalAddress());           return content;       }       */
comment|/**      * Takes care of actually removing entries from the indices;      * must be called after one or more call to {@link #removeNode(Txn, IStoredNode, NodePath, String)}.      */
annotation|@
name|Override
specifier|public
name|void
name|endRemove
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
block|{
name|notifyRemove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|pool
operator|.
name|isReadOnly
argument_list|()
return|;
block|}
specifier|public
name|DOMFile
name|getDOMFile
parameter_list|()
block|{
return|return
name|domDb
return|;
block|}
specifier|public
name|BTree
name|getStorage
parameter_list|(
specifier|final
name|byte
name|id
parameter_list|)
block|{
comment|//Notice that there is no entry for the symbols table
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|DOM_DBX_ID
case|:
return|return
name|domDb
return|;
case|case
name|COLLECTIONS_DBX_ID
case|:
return|return
name|collectionsDb
return|;
case|case
name|VALUES_DBX_ID
case|:
return|return
name|valueIndex
operator|.
name|dbValues
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|byte
index|[]
name|getStorageFileIds
parameter_list|()
block|{
return|return
name|ALL_STORAGE_FILES
return|;
block|}
specifier|public
name|int
name|getDefaultIndexDepth
parameter_list|()
block|{
return|return
name|defaultIndexDepth
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|backupToArchive
parameter_list|(
specifier|final
name|RawDataBackup
name|backup
parameter_list|)
throws|throws
name|IOException
throws|,
name|EXistException
block|{
for|for
control|(
specifier|final
name|byte
name|i
range|:
name|ALL_STORAGE_FILES
control|)
block|{
specifier|final
name|Paged
name|paged
init|=
name|getStorage
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|paged
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage file is null: "
operator|+
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// do not use try-with-resources here, closing the OutputStream will close the entire backup
comment|//            try(final OutputStream os = backup.newEntry(FileUtils.fileName(paged.getFile()))) {
try|try
block|{
specifier|final
name|OutputStream
name|os
init|=
name|backup
operator|.
name|newEntry
argument_list|(
name|FileUtils
operator|.
name|fileName
argument_list|(
name|paged
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|paged
operator|.
name|backupToStream
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
block|}
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|backupToArchive
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getBlobStore
argument_list|()
operator|.
name|backupToArchive
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|backupToArchive
argument_list|(
name|backup
argument_list|)
expr_stmt|;
comment|//TODO backup counters
comment|//TODO USE zip64 or tar to create snapshots larger then 4Gb
block|}
annotation|@
name|Override
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|()
block|{
return|return
name|indexConfiguration
return|;
block|}
annotation|@
name|Override
specifier|public
name|StructuralIndex
name|getStructuralIndex
parameter_list|()
block|{
return|return
operator|(
name|StructuralIndex
operator|)
name|getIndexController
argument_list|()
operator|.
name|getWorkerByIndexName
argument_list|(
name|StructuralIndex
operator|.
name|STRUCTURAL_INDEX_ID
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NativeValueIndex
name|getValueIndex
parameter_list|()
block|{
return|return
name|valueIndex
return|;
block|}
annotation|@
name|Override
specifier|public
name|IEmbeddedXMLStreamReader
name|getXMLStreamReader
parameter_list|(
specifier|final
name|NodeHandle
name|node
parameter_list|,
specifier|final
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
name|streamReader
operator|==
literal|null
condition|)
block|{
specifier|final
name|RawNodeIterator
name|iterator
init|=
operator|new
name|RawNodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|streamReader
operator|=
operator|new
name|EmbeddedXMLStreamReader
argument_list|(
name|this
argument_list|,
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|reportAttributes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|streamReader
operator|.
name|reposition
argument_list|(
name|this
argument_list|,
name|node
argument_list|,
name|reportAttributes
argument_list|)
expr_stmt|;
block|}
return|return
name|streamReader
return|;
block|}
annotation|@
name|Override
specifier|public
name|IEmbeddedXMLStreamReader
name|newXMLStreamReader
parameter_list|(
specifier|final
name|NodeHandle
name|node
parameter_list|,
specifier|final
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
specifier|final
name|RawNodeIterator
name|iterator
init|=
operator|new
name|RawNodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|)
decl_stmt|;
return|return
operator|new
name|EmbeddedXMLStreamReader
argument_list|(
name|this
argument_list|,
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|iterator
argument_list|,
literal|null
argument_list|,
name|reportAttributes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|INodeIterator
name|getNodeIterator
parameter_list|(
specifier|final
name|NodeHandle
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The node parameter cannot be null."
argument_list|)
throw|;
block|}
try|try
block|{
return|return
operator|new
name|NodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Serializer
name|getSerializer
parameter_list|()
block|{
name|xmlSerializer
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|xmlSerializer
return|;
block|}
annotation|@
name|Override
specifier|public
name|Serializer
name|newSerializer
parameter_list|()
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Serializer
name|newSerializer
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|chainOfReceivers
parameter_list|)
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|,
name|chainOfReceivers
argument_list|)
return|;
block|}
specifier|public
name|XmldbURI
name|prepend
parameter_list|(
specifier|final
name|XmldbURI
name|uri
parameter_list|)
block|{
switch|switch
condition|(
name|prepend
condition|)
block|{
case|case
name|PREPEND_DB_ALWAYS
case|:
return|return
name|uri
operator|.
name|prepend
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
return|;
case|case
name|PREPEND_DB_AS_NEEDED
case|:
return|return
name|uri
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|?
name|uri
else|:
name|uri
operator|.
name|prepend
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
return|;
default|default:
return|return
name|uri
return|;
block|}
block|}
comment|/**      * Creates a temporary collection      *      * @param transaction The transaction, which registers the acquired write locks.      *                    The locks should be released on commit/abort.      * @return The temporary collection      * @throws LockException      * @throws PermissionDeniedException      * @throws IOException      * @throws TriggerException      */
specifier|private
annotation|@
name|EnsureUnlocked
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|getOrCreateTempCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
try|try
block|{
name|pushSubject
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|temp
init|=
name|getOrCreateCollectionExplicit
argument_list|(
name|transaction
argument_list|,
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|,
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|.
name|_1
condition|)
block|{
name|temp
operator|.
name|_2
operator|.
name|setPermissions
argument_list|(
name|this
argument_list|,
name|DEFAULT_TEMPORARY_COLLECTION_PERM
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|temp
operator|.
name|_2
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
finally|finally
block|{
name|popSubject
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
annotation|@
name|Nullable
name|String
name|readInitCollectionConfig
parameter_list|()
block|{
try|try
block|{
comment|// 1) try and load from etc/ dir
specifier|final
name|Path
name|fInitCollectionConfig
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getExistHome
argument_list|()
operator|.
name|map
argument_list|(
name|h
lambda|->
name|h
operator|.
name|resolve
argument_list|(
literal|"etc"
argument_list|)
operator|.
name|resolve
argument_list|(
name|INIT_COLLECTION_CONFIG
argument_list|)
argument_list|)
operator|.
name|orElse
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
literal|"etc"
argument_list|)
operator|.
name|resolve
argument_list|(
name|INIT_COLLECTION_CONFIG
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|fInitCollectionConfig
argument_list|)
condition|)
block|{
return|return
operator|new
name|String
argument_list|(
name|Files
operator|.
name|readAllBytes
argument_list|(
name|fInitCollectionConfig
argument_list|)
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
comment|// 2) fallback to attempting to load from classpath
try|try
init|(
specifier|final
name|InputStream
name|is
init|=
name|pool
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|INIT_COLLECTION_CONFIG
argument_list|)
init|)
block|{
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|InputStreamUtil
operator|.
name|readString
argument_list|(
name|is
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
comment|// 3) could not load!
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
return|return
name|getOrCreateCollectionExplicit
argument_list|(
name|transaction
argument_list|,
name|name
argument_list|,
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
operator|.
name|_2
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|XmldbURI
name|name
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|Tuple2
argument_list|<
name|Permission
argument_list|,
name|Long
argument_list|>
argument_list|>
name|creationAttributes
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
return|return
name|getOrCreateCollectionExplicit
argument_list|(
name|transaction
argument_list|,
name|name
argument_list|,
name|creationAttributes
argument_list|)
operator|.
name|_2
return|;
block|}
comment|/**      * Gets the database Collection identified by the specified path.      * If the Collection does not yet exist, it is created - including all ancestors.      * The Collection is identified by its absolute path, e.g. /db/shakespeare.      * The returned Collection will NOT HAVE a lock.      *      * The caller should take care to release any associated resource by      * calling {@link Collection#close()}      *      * @param transaction The current transaction      * @param path The Collection's URI      *      * @return A tuple whose first boolean value is set to true if the      * collection was created, or false if the collection already existed. The      * second value is the existing or created Collection      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws IOException If an error occurs whilst reading (get) or writing (create) a Collection to disk      * @throws TriggerException If a CollectionTrigger throws an exception      */
specifier|private
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|getOrCreateCollectionExplicit
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|XmldbURI
name|path
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|Tuple2
argument_list|<
name|Permission
argument_list|,
name|Long
argument_list|>
argument_list|>
name|creationAttributes
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
specifier|final
name|XmldbURI
name|collectionUri
init|=
name|prepend
argument_list|(
name|path
operator|.
name|toCollectionPathURI
argument_list|()
operator|.
name|normalizeCollectionPath
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|XmldbURI
name|parentCollectionUri
init|=
name|collectionUri
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
try|try
block|{
comment|// 1) optimize for the existence of the Collection in the cache
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|collectionLock
init|=
name|readLockCollection
argument_list|(
name|collectionUri
argument_list|)
init|)
block|{
specifier|final
name|Collection
name|collection
init|=
name|collectionsCache
operator|.
name|getIfPresent
argument_list|(
name|collectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|collection
argument_list|)
return|;
block|}
block|}
comment|// 2) try and read the Collection from disk, if not on disk then create it
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|parentCollectionLock
init|=
name|writeLockCollection
argument_list|(
name|parentCollectionUri
operator|.
name|numSegments
argument_list|()
operator|==
literal|0
condition|?
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
else|:
name|parentCollectionUri
argument_list|)
init|)
block|{
comment|// we write lock the parent (as we may need to add a new Collection to it)
comment|// check for preemption between READ -> WRITE lock, is the Collection now in the cache?
specifier|final
name|Collection
name|collection
init|=
name|collectionsCache
operator|.
name|getIfPresent
argument_list|(
name|collectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|collection
argument_list|)
return|;
block|}
comment|// is the parent Collection in the cache?
if|if
condition|(
name|parentCollectionUri
operator|==
name|XmldbURI
operator|.
name|EMPTY_URI
condition|)
block|{
comment|// no parent... so, this is the root collection!
return|return
name|getOrCreateCollectionExplicit_rootCollection
argument_list|(
name|transaction
argument_list|,
name|collectionUri
argument_list|,
name|collectionsCache
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|Collection
name|parentCollection
init|=
name|collectionsCache
operator|.
name|getIfPresent
argument_list|(
name|parentCollectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
comment|// parent collection is in cache, is our Collection present on disk?
specifier|final
name|Collection
name|loadedCollection
init|=
name|loadCollection
argument_list|(
name|collectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|loadedCollection
operator|!=
literal|null
condition|)
block|{
comment|// loaded it from disk
comment|// add it to the cache and return it
name|collectionsCache
operator|.
name|put
argument_list|(
name|loadedCollection
argument_list|)
expr_stmt|;
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|loadedCollection
argument_list|)
return|;
block|}
else|else
block|{
comment|// not on disk, create the collection
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
literal|true
argument_list|,
name|createCollection
argument_list|(
name|transaction
argument_list|,
name|parentCollection
argument_list|,
name|collectionUri
argument_list|,
name|collectionsCache
argument_list|,
name|creationAttributes
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/*                          * No parent Collection in the cache so that needs to be loaded/created                          * (or will be read from cache if we are pre-empted) before we can create this Collection.                          * However to do this, we need to yield the collectionLock, so we will continue outside                          * the ManagedCollectionLock at (3)                          */
block|}
block|}
block|}
comment|//TODO(AR) below, should we just fall back to recursive descent creating the collection hierarchy in the same manner that getOrCreateCollection used to do?
comment|// 3) No parent collection was previously found in cache so we need to call this function for the parent Collection and then ourselves
specifier|final
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|newOrExistingParentCollection
init|=
name|getOrCreateCollectionExplicit
argument_list|(
name|transaction
argument_list|,
name|parentCollectionUri
argument_list|,
name|creationAttributes
argument_list|)
decl_stmt|;
return|return
name|getOrCreateCollectionExplicit
argument_list|(
name|transaction
argument_list|,
name|collectionUri
argument_list|,
name|creationAttributes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|getOrCreateCollectionExplicit_rootCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|,
specifier|final
name|CollectionCache
name|collectionsCache
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
throws|,
name|ReadOnlyException
throws|,
name|TriggerException
block|{
comment|// this is the root collection, so no parent, is the Collection present on disk?
specifier|final
name|Collection
name|loadedRootCollection
init|=
name|loadCollection
argument_list|(
name|collectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|loadedRootCollection
operator|!=
literal|null
condition|)
block|{
comment|// loaded it from disk
comment|// add it to the cache and return it
name|collectionsCache
operator|.
name|put
argument_list|(
name|loadedRootCollection
argument_list|)
expr_stmt|;
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
literal|false
argument_list|,
name|loadedRootCollection
argument_list|)
return|;
block|}
else|else
block|{
comment|// not on disk, create the root collection
specifier|final
name|Collection
name|rootCollection
init|=
name|createCollection
argument_list|(
name|transaction
argument_list|,
literal|null
argument_list|,
name|collectionUri
argument_list|,
name|collectionsCache
argument_list|,
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
decl_stmt|;
comment|//import an initial collection configuration
try|try
block|{
specifier|final
name|String
name|initCollectionConfig
init|=
name|readInitCollectionConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|initCollectionConfig
operator|!=
literal|null
condition|)
block|{
name|CollectionConfigurationManager
name|collectionConfigurationManager
init|=
name|pool
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|collectionConfigurationManager
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|pool
operator|.
name|getConfigurationManager
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
comment|//might not yet have been initialised
comment|//pool.initCollectionConfigurationManager(this, transaction);
block|}
name|collectionConfigurationManager
operator|=
name|pool
operator|.
name|getConfigurationManager
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|collectionConfigurationManager
operator|!=
literal|null
condition|)
block|{
name|collectionConfigurationManager
operator|.
name|addConfiguration
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|rootCollection
argument_list|,
name|initCollectionConfig
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|CollectionConfigurationException
name|cce
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not load initial collection configuration for /db: "
operator|+
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|,
name|cce
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Tuple2
argument_list|<>
argument_list|(
literal|true
argument_list|,
name|rootCollection
argument_list|)
return|;
block|}
block|}
comment|/**      * NOTE - When this is called there must be a WRITE_LOCK on collectionUri      * and a WRITE_LOCK on parentCollection (if it is not null)      */
specifier|private
annotation|@
name|EnsureUnlocked
name|Collection
name|createCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|parentCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|,
specifier|final
name|CollectionCache
name|collectionCache
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|Tuple2
argument_list|<
name|Permission
argument_list|,
name|Long
argument_list|>
argument_list|>
name|creationAttributes
parameter_list|)
throws|throws
name|TriggerException
throws|,
name|ReadOnlyException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|CollectionTrigger
name|trigger
decl_stmt|;
if|if
condition|(
name|parentCollection
operator|==
literal|null
condition|)
block|{
name|trigger
operator|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trigger
operator|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|parentCollection
argument_list|)
expr_stmt|;
block|}
name|trigger
operator|.
name|beforeCreateCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
specifier|final
name|Collection
name|collectionObj
init|=
name|createCollectionObject
argument_list|(
name|transaction
argument_list|,
name|parentCollection
argument_list|,
name|collectionUri
argument_list|,
name|creationAttributes
argument_list|)
decl_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collectionObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
name|parentCollection
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|collectionObj
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parentCollection
argument_list|)
expr_stmt|;
block|}
name|collectionCache
operator|.
name|put
argument_list|(
name|collectionObj
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterCreateCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collectionObj
argument_list|)
expr_stmt|;
return|return
name|collectionObj
return|;
block|}
comment|/**      * NOTE - When this is called there must be a WRITE_LOCK on collectionUri      * and at least a READ_LOCK on parentCollection (if it is not null)      */
specifier|private
name|Collection
name|createCollectionObject
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|parentCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|Tuple2
argument_list|<
name|Permission
argument_list|,
name|Long
argument_list|>
argument_list|>
name|creationAttributes
parameter_list|)
throws|throws
name|ReadOnlyException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
specifier|final
name|int
name|collectionId
init|=
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|collection
init|=
name|creationAttributes
operator|.
name|map
argument_list|(
name|attrs
lambda|->
operator|new
name|MutableCollection
argument_list|(
name|this
argument_list|,
name|collectionId
argument_list|,
name|collectionUri
argument_list|,
name|attrs
operator|.
name|_1
argument_list|,
name|attrs
operator|.
name|_2
argument_list|)
argument_list|)
operator|.
name|orElseGet
argument_list|(
parameter_list|()
lambda|->
operator|new
name|MutableCollection
argument_list|(
name|this
argument_list|,
name|collectionId
argument_list|,
name|collectionUri
argument_list|)
argument_list|)
decl_stmt|;
comment|//inherit the group to collection if parent-collection is setGid
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Permission
name|parentPermissions
init|=
name|parentCollection
operator|.
name|getPermissionsNoLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentPermissions
operator|.
name|isSetGid
argument_list|()
condition|)
block|{
specifier|final
name|Permission
name|collectionPermissions
init|=
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
decl_stmt|;
name|collectionPermissions
operator|.
name|setGroupFrom
argument_list|(
name|parentPermissions
argument_list|)
expr_stmt|;
comment|//inherit group
name|collectionPermissions
operator|.
name|setSetGid
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//inherit setGid bit
block|}
block|}
return|return
name|collection
return|;
block|}
comment|/**      * Loads a Collection from disk      *      * @param collectionUri The URI of the Collection to load      *      * @return The Collection object loaded from disk, or null if the record does not exist on disk      */
specifier|private
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
name|Collection
name|loadCollection
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collectionUri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteInput
name|is
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|is
operator|==
literal|null
condition|?
literal|null
else|:
name|MutableCollection
operator|.
name|load
argument_list|(
name|this
argument_list|,
name|collectionUri
argument_list|,
name|is
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Collection
name|getCollection
parameter_list|(
specifier|final
name|XmldbURI
name|uri
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|openCollection
argument_list|(
name|uri
argument_list|,
name|LockMode
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
name|openCollection
parameter_list|(
specifier|final
name|XmldbURI
name|uri
parameter_list|,
specifier|final
name|LockMode
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|XmldbURI
name|collectionUri
init|=
name|prepend
argument_list|(
name|uri
operator|.
name|toCollectionPathURI
argument_list|()
operator|.
name|normalizeCollectionPath
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ManagedCollectionLock
name|collectionLock
decl_stmt|;
specifier|final
name|Runnable
name|unlockFn
decl_stmt|;
comment|// we unlock on error, or if there is no Collection
try|try
block|{
switch|switch
condition|(
name|lockMode
condition|)
block|{
case|case
name|WRITE_LOCK
case|:
name|collectionLock
operator|=
name|writeLockCollection
argument_list|(
name|collectionUri
argument_list|)
expr_stmt|;
name|unlockFn
operator|=
name|collectionLock
operator|::
name|close
expr_stmt|;
break|break;
case|case
name|READ_LOCK
case|:
name|collectionLock
operator|=
name|readLockCollection
argument_list|(
name|collectionUri
argument_list|)
expr_stmt|;
name|unlockFn
operator|=
name|collectionLock
operator|::
name|close
expr_stmt|;
break|break;
case|case
name|NO_LOCK
case|:
default|default:
name|collectionLock
operator|=
name|ManagedCollectionLock
operator|.
name|notLocked
argument_list|(
name|collectionUri
argument_list|)
expr_stmt|;
name|unlockFn
operator|=
parameter_list|()
lambda|->
block|{
block|}
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on Collection: {}"
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|collection
decl_stmt|;
try|try
block|{
comment|// NOTE: getCollectionForOpen will perform the Permission.EXECUTE security check on Collection at collectionUri
name|collection
operator|=
name|getCollectionForOpen
argument_list|(
name|collectionsCache
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|unlockFn
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IllegalStateException
decl||
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|unlockFn
operator|.
name|run
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
comment|// Must ALSO perform a security check up the collection hierarchy to ensure that we have Permission.EXECUTE all the way
try|try
block|{
name|checkCollectionAncestorPermissions
argument_list|(
name|collectionsCache
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IllegalStateException
decl||
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|unlockFn
operator|.
name|run
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|unlockFn
operator|.
name|run
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on Collection: {}"
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|LockedCollection
argument_list|(
name|collectionLock
argument_list|,
name|collection
argument_list|)
return|;
block|}
comment|// NOTE: READ_LOCK in the @EnsureLocked parameter annotation here means "at least" READ
specifier|private
annotation|@
name|Nullable
name|Collection
name|getCollectionForOpen
parameter_list|(
specifier|final
name|CollectionCache
name|collectionsCache
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|,
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|)
throws|throws
name|IllegalStateException
throws|,
name|PermissionDeniedException
block|{
comment|// 1) optimize for reading from the Collection from the cache
specifier|final
name|Collection
name|collection
init|=
name|collectionsCache
operator|.
name|getIfPresent
argument_list|(
name|collectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
comment|// sanity check
if|if
condition|(
operator|!
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equalsInternal
argument_list|(
name|collectionUri
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"openCollection: The Collection received from the cache: {} is not the requested: {}"
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
comment|// does the user have permission to access THIS Collection
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to open collection: "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" by "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|collection
return|;
block|}
else|else
block|{
comment|// 2) if not in the cache, load from disk
specifier|final
name|Collection
name|loadedCollection
decl_stmt|;
try|try
block|{
comment|// NOTE: loadCollection via. MutableCollection's constructor will perform the Permission.EXECUTE security check
name|loadedCollection
operator|=
name|loadCollection
argument_list|(
name|collectionUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on: {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// if we loaded a Collection add it to the cache (if it isn't already there)
if|if
condition|(
name|loadedCollection
operator|!=
literal|null
condition|)
block|{
return|return
name|collectionsCache
operator|.
name|getOrCreate
argument_list|(
name|collectionUri
argument_list|,
name|key
lambda|->
name|loadedCollection
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// NOTE: READ_LOCK in the @EnsureLocked parameter annotation here means "at least" READ
specifier|private
name|void
name|checkCollectionAncestorPermissions
parameter_list|(
specifier|final
name|CollectionCache
name|collectionsCache
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|,
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|IllegalStateException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
comment|/*             When we are called we hold either a READ or WRITE Lock on the Collection.             As we are using hierarchical locking for Collections we can             assume that we also hold either an INTENTION_READ or INTENTION_WRITE Lock             on each ancestor Collection up to the root,             therefore we don't really need to acquire any more locks.              The permissions are checked bottom-up on the Collection hierarchy as we             assume that the more specific/restrictive permissions are likely to be             closer to the target Collection.          */
name|Collection
name|c
init|=
name|collection
decl_stmt|;
name|XmldbURI
name|parentUri
init|=
name|c
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
while|while
condition|(
name|parentUri
operator|!=
literal|null
condition|)
block|{
comment|// this will throw a PermissionDeniedException if the user does not have Permission.EXECUTE on the Collection at the parentUri
name|c
operator|=
name|getCollectionForOpen
argument_list|(
name|collectionsCache
argument_list|,
name|parentUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Parent collection {} was null for collection {} "
argument_list|,
name|parentUri
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|parentUri
operator|=
name|c
operator|.
name|getParentURI
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findCollectionsMatching
parameter_list|(
specifier|final
name|String
name|regexp
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|collections
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regexp
argument_list|)
decl_stmt|;
specifier|final
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
literal|""
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
comment|//TODO write a regexp lookup for key data in BTree.query
comment|//final IndexQuery idxQuery = new IndexQuery(IndexQuery.REGEXP, regexp);
comment|//List<Value> keys = collectionsDb.findKeysByCollectionName(idxQuery);
specifier|final
name|List
argument_list|<
name|Value
argument_list|>
name|keys
init|=
name|collectionsDb
operator|.
name|getKeys
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Value
name|key
range|:
name|keys
control|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|key
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
name|CollectionStore
operator|.
name|KEY_TYPE_COLLECTION
condition|)
block|{
specifier|final
name|String
name|collectionName
init|=
name|UTF8
operator|.
name|decode
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|m
operator|.
name|reset
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|matches
argument_list|()
condition|)
block|{
name|collections
operator|.
name|add
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|//LOG.error("Unable to encode '" + uri + "' in UTF-8");
comment|//return null;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//return null;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
decl||
name|IOException
decl||
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//return null;
block|}
return|return
name|collections
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readCollectionEntry
parameter_list|(
specifier|final
name|SubCollectionEntry
name|entry
parameter_list|)
throws|throws
name|IOException
throws|,
name|LockException
block|{
specifier|final
name|XmldbURI
name|uri
init|=
name|prepend
argument_list|(
name|entry
operator|.
name|getUri
argument_list|()
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|collection
init|=
name|collectionsCache
operator|.
name|getIfPresent
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteInput
name|is
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find collection entry for: "
operator|+
name|uri
argument_list|)
throw|;
block|}
comment|//read the entry details
name|entry
operator|.
name|read
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equalsInternal
argument_list|(
name|uri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"readCollectionEntry: The Collection received from the cache: %s is not the requested: %s"
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
name|uri
argument_list|)
argument_list|)
throw|;
block|}
name|entry
operator|.
name|read
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|copyCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Collection
name|collection
parameter_list|,
specifier|final
name|Collection
name|destination
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
block|{
name|copyCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|,
name|PreserveType
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|copyCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Collection
name|sourceCollection
parameter_list|,
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
block|{
assert|assert
operator|(
name|sourceCollection
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|targetCollection
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|newName
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"newName name must be just a name i.e. an XmldbURI with one segment!"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|sourceCollectionUri
init|=
name|sourceCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|destinationCollectionUri
init|=
name|targetCollectionUri
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceCollection
operator|.
name|getId
argument_list|()
operator|==
name|targetCollection
operator|.
name|getId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy collection to itself '"
operator|+
name|sourceCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sourceCollectionUri
operator|.
name|equals
argument_list|(
name|destinationCollectionUri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy collection to itself '"
operator|+
name|sourceCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isSubCollection
argument_list|(
name|sourceCollectionUri
argument_list|,
name|targetCollectionUri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy collection '"
operator|+
name|sourceCollectionUri
operator|+
literal|"' inside itself  '"
operator|+
name|targetCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|sourceCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" has insufficient privileges on collection to copy collection "
operator|+
name|sourceCollectionUri
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|targetCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" has insufficient privileges on target collection "
operator|+
name|targetCollectionUri
operator|+
literal|" to copy collection "
operator|+
name|sourceCollectionUri
argument_list|)
throw|;
block|}
comment|/*          * At this point this thread should hold:          *   READ_LOCK on:          *     1) sourceCollection          *          *   WRITE_LOCK on:          *     1) targetCollection          *          *  Remember a lock on a node in the Collection tree,          *  implies locking the entire sub-tree, therefore          *  we don't need to explicitly lock sub-collections (just documents).          */
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_COPY_COLLECTION
argument_list|,
name|sourceCollection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|XmldbURI
name|sourceCollectionParentUri
init|=
name|sourceCollection
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
comment|// READ_LOCK the parent of the source Collection for the triggers
try|try
init|(
specifier|final
name|Collection
name|sourceCollectionParent
init|=
name|sourceCollectionParentUri
operator|==
literal|null
condition|?
name|sourceCollection
else|:
name|openCollection
argument_list|(
name|sourceCollectionParentUri
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
comment|// fire before copy collection triggers
specifier|final
name|CollectionTrigger
name|trigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollectionParent
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeCopyCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollection
argument_list|,
name|destinationCollectionUri
argument_list|)
expr_stmt|;
specifier|final
name|DocumentTrigger
name|docTrigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|)
decl_stmt|;
comment|// pessimistically obtain READ_LOCKs on all descendant documents of sourceCollection, and WRITE_LOCKs on all target documents
specifier|final
name|Collection
name|newCollection
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedLocks
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|sourceDocLocks
init|=
operator|new
name|ManagedLocks
argument_list|(
name|lockDescendantDocuments
argument_list|(
name|sourceCollection
argument_list|,
name|lockManager
operator|::
name|acquireDocumentReadLock
argument_list|)
argument_list|)
init|;
specifier|final
name|ManagedLocks
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|targetDocLocks
init|=
operator|new
name|ManagedLocks
argument_list|(
name|lockTargetDocuments
argument_list|(
name|sourceCollectionUri
argument_list|,
name|sourceDocLocks
argument_list|,
name|destinationCollectionUri
argument_list|,
name|lockManager
operator|::
name|acquireDocumentWriteLock
argument_list|)
argument_list|)
init|)
block|{
comment|// check all permissions in the tree to ensure a copy operation will succeed before starting copying
name|checkPermissionsForCopy
argument_list|(
name|sourceCollection
argument_list|,
name|targetCollection
argument_list|,
name|newName
argument_list|)
expr_stmt|;
name|newCollection
operator|=
name|doCopyCollection
argument_list|(
name|transaction
argument_list|,
name|docTrigger
argument_list|,
name|sourceCollection
argument_list|,
name|targetCollection
argument_list|,
name|destinationCollectionUri
argument_list|,
literal|true
argument_list|,
name|preserve
argument_list|)
expr_stmt|;
block|}
comment|// fire after copy collection triggers
name|trigger
operator|.
name|afterCopyCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|newCollection
argument_list|,
name|sourceCollectionUri
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Checks all permissions in the tree to ensure that a copy operation      * will not fail due to a lack of rights      *      * @param sourceCollection The Collection to copy      * @param targetCollection The target Collection to copy the sourceCollection into      * @param newName The new name the sourceCollection should have in the targetCollection      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      */
specifier|protected
name|void
name|checkPermissionsForCopy
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
annotation|@
name|Nullable
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
operator|!
name|sourceCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
operator||
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|sourceCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|destinationCollectionUri
init|=
name|targetCollection
operator|==
literal|null
condition|?
literal|null
else|:
name|targetCollection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|destinationCollection
init|=
name|destinationCollectionUri
operator|==
literal|null
condition|?
literal|null
else|:
name|getCollection
argument_list|(
name|destinationCollectionUri
argument_list|)
decl_stmt|;
comment|// NOTE: we already have a WRITE_LOCK on destinationCollectionUri
if|if
condition|(
name|targetCollection
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|targetCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
operator||
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|sourceCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" to "
operator|+
name|targetCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|destinationCollection
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|destinationCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
operator||
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|sourceCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" to "
operator|+
name|destinationCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|// check document permissions
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|itSrcSubDoc
init|=
name|sourceCollection
operator|.
name|iteratorNoLock
argument_list|(
name|this
argument_list|)
init|;
name|itSrcSubDoc
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// NOTE: we already have a READ lock on sourceCollection implicitly
specifier|final
name|DocumentImpl
name|srcSubDoc
init|=
name|itSrcSubDoc
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|srcSubDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|sourceCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" for resource "
operator|+
name|srcSubDoc
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|//if the destination resource exists, we must have write access to replace it's metadata etc. (this follows the Linux convention)
if|if
condition|(
name|destinationCollection
operator|!=
literal|null
operator|&&
operator|!
name|destinationCollection
operator|.
name|isEmpty
argument_list|(
name|this
argument_list|)
condition|)
block|{
specifier|final
name|DocumentImpl
name|newDestSubDoc
init|=
name|destinationCollection
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|srcSubDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
comment|//TODO check this uri is just the filename!
if|if
condition|(
name|newDestSubDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|newDestSubDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|sourceCollection
operator|.
name|getURI
argument_list|()
operator|+
literal|" for resource "
operator|+
name|newDestSubDoc
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// descend into sub-collections
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|itSrcSubColUri
init|=
name|sourceCollection
operator|.
name|collectionIteratorNoLock
argument_list|(
name|this
argument_list|)
init|;
name|itSrcSubColUri
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// NOTE: we already have a READ lock on sourceCollection implicitly
specifier|final
name|XmldbURI
name|srcSubColUri
init|=
name|itSrcSubColUri
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|srcSubCol
init|=
name|getCollection
argument_list|(
name|sourceCollection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|srcSubColUri
argument_list|)
argument_list|)
decl_stmt|;
comment|// NOTE: we already have a READ_LOCK on destinationCollectionUri
name|checkPermissionsForCopy
argument_list|(
name|srcSubCol
argument_list|,
name|destinationCollection
argument_list|,
name|srcSubColUri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Copy a collection and all its sub-Collections.      *      * @param transaction The current transaction      * @param documentTrigger The trigger to use for document events      * @param sourceCollection The Collection to copy      * @param destinationCollectionUri The destination Collection URI for the sourceCollection copy      * @param copyCollectionMode false on the first call, true on recursive calls      *      * @return A reference to the Collection, no additional locks are held on the Collection      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst copying the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception      * @throws EXistException If no more Document IDs are available      */
specifier|private
name|Collection
name|doCopyCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentTrigger
name|documentTrigger
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|destinationParentCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|,
name|type
operator|=
name|LockType
operator|.
name|COLLECTION
argument_list|)
specifier|final
name|XmldbURI
name|destinationCollectionUri
parameter_list|,
specifier|final
name|boolean
name|copyCollectionMode
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|EXistException
throws|,
name|TriggerException
throws|,
name|LockException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying collection to '{}'"
argument_list|,
name|destinationCollectionUri
argument_list|)
expr_stmt|;
block|}
comment|// permissions and attributes for the destCollection (if we have to create it)
specifier|final
name|Permission
name|createCollectionPerms
init|=
name|PermissionFactory
operator|.
name|getDefaultCollectionPermission
argument_list|(
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
argument_list|)
decl_stmt|;
name|copyModeAndAcl
argument_list|(
name|sourceCollection
operator|.
name|getPermissions
argument_list|()
argument_list|,
name|createCollectionPerms
argument_list|)
expr_stmt|;
specifier|final
name|long
name|created
decl_stmt|;
if|if
condition|(
name|preserveOnCopy
argument_list|(
name|preserve
argument_list|)
condition|)
block|{
comment|// only copy the owner and group from the source if we are creating a new collection and we are the DBA
if|if
condition|(
name|getCurrentSubject
argument_list|()
operator|.
name|hasDbaRole
argument_list|()
condition|)
block|{
name|PermissionFactory
operator|.
name|chown
argument_list|(
name|this
argument_list|,
name|createCollectionPerms
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|sourceCollection
operator|.
name|getPermissions
argument_list|()
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|sourceCollection
operator|.
name|getPermissions
argument_list|()
operator|.
name|getGroup
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|created
operator|=
name|sourceCollection
operator|.
name|getMetadata
argument_list|()
operator|.
name|getCreated
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|created
operator|=
literal|0
expr_stmt|;
block|}
specifier|final
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|destinationCollection
init|=
name|getOrCreateCollectionExplicit
argument_list|(
name|transaction
argument_list|,
name|destinationCollectionUri
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|Tuple2
argument_list|<>
argument_list|(
name|createCollectionPerms
argument_list|,
name|created
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// if we didn't create destCollection but we need to preserve the attributes
if|if
condition|(
operator|(
operator|!
name|destinationCollection
operator|.
name|_1
operator|)
operator|&&
name|preserveOnCopy
argument_list|(
name|preserve
argument_list|)
condition|)
block|{
name|copyModeAndAcl
argument_list|(
name|sourceCollection
operator|.
name|getPermissions
argument_list|()
argument_list|,
name|destinationCollection
operator|.
name|_2
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// inherit the group to the destinationCollection if parent is setGid
if|if
condition|(
name|destinationParentCollection
operator|!=
literal|null
operator|&&
name|destinationParentCollection
operator|.
name|getPermissions
argument_list|()
operator|.
name|isSetGid
argument_list|()
condition|)
block|{
name|destinationCollection
operator|.
name|_2
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroupFrom
argument_list|(
name|destinationParentCollection
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
comment|//inherit group
name|destinationCollection
operator|.
name|_2
operator|.
name|getPermissions
argument_list|()
operator|.
name|setSetGid
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//inherit setGid bit
block|}
name|doCopyCollectionDocuments
argument_list|(
name|transaction
argument_list|,
name|documentTrigger
argument_list|,
name|sourceCollection
argument_list|,
name|destinationCollection
operator|.
name|_2
argument_list|,
name|preserve
argument_list|)
expr_stmt|;
specifier|final
name|XmldbURI
name|sourceCollectionUri
init|=
name|sourceCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|sourceCollection
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|childUri
init|=
name|sourceCollectionUri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|child
init|=
name|getCollection
argument_list|(
name|childUri
argument_list|)
init|)
block|{
comment|// NOTE: we already have a READ lock on child implicitly
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Child collection "
operator|+
name|childUri
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
else|else
block|{
name|doCopyCollection
argument_list|(
name|transaction
argument_list|,
name|documentTrigger
argument_list|,
name|child
argument_list|,
name|destinationCollection
operator|.
name|_2
argument_list|,
name|destinationCollection
operator|.
name|_2
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
literal|true
argument_list|,
name|preserve
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|destinationCollection
operator|.
name|_2
return|;
block|}
comment|/**      * Copy the documents in one Collection to another (non-recursive)      *      * @param transaction The current transaction      * @param documentTrigger The trigger to use for document events      * @param sourceCollection The Collection to copy documents from      * @param targetCollection The Collection to copy documents to      *      * @throws PermissionDeniedException If the current user does not have appropriate permissions      * @throws LockException If an exception occurs whilst acquiring locks      * @throws IOException If an error occurs whilst copying the Collection on disk      * @throws TriggerException If a CollectionTrigger throws an exception      * @throws EXistException If no more Document IDs are available      */
specifier|private
name|void
name|doCopyCollectionDocuments
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentTrigger
name|documentTrigger
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
block|{
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|sourceCollection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|sourceDocument
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying resource: '{}'"
argument_list|,
name|sourceDocument
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|XmldbURI
name|newDocName
init|=
name|sourceDocument
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|LockedDocument
name|oldLockedDoc
init|=
name|targetCollection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|newDocName
argument_list|,
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
init|)
block|{
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|oldLockedDoc
operator|==
literal|null
condition|?
literal|null
else|:
name|oldLockedDoc
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|doCopyDocument
argument_list|(
name|transaction
argument_list|,
name|documentTrigger
argument_list|,
name|sourceDocument
argument_list|,
name|targetCollection
argument_list|,
name|newDocName
argument_list|,
name|oldDoc
argument_list|,
name|preserve
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Copies just the mode and ACL from the src to the dest      *      * @param srcPermission The source to copy from      * @param destPermission The destination to copy to      */
specifier|private
name|void
name|copyModeAndAcl
parameter_list|(
specifier|final
name|Permission
name|srcPermission
parameter_list|,
specifier|final
name|Permission
name|destPermission
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|List
argument_list|<
name|ACEAider
argument_list|>
name|aces
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcPermission
operator|instanceof
name|SimpleACLPermission
operator|&&
name|destPermission
operator|instanceof
name|SimpleACLPermission
condition|)
block|{
specifier|final
name|SimpleACLPermission
name|srcAclPermission
init|=
operator|(
name|SimpleACLPermission
operator|)
name|srcPermission
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcAclPermission
operator|.
name|getACECount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|aces
operator|.
name|add
argument_list|(
operator|new
name|ACEAider
argument_list|(
name|srcAclPermission
operator|.
name|getACEAccessType
argument_list|(
name|i
argument_list|)
argument_list|,
name|srcAclPermission
operator|.
name|getACETarget
argument_list|(
name|i
argument_list|)
argument_list|,
name|srcAclPermission
operator|.
name|getACEWho
argument_list|(
name|i
argument_list|)
argument_list|,
name|srcAclPermission
operator|.
name|getACEMode
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|PermissionFactory
operator|.
name|chmod
argument_list|(
name|this
argument_list|,
name|destPermission
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|srcPermission
operator|.
name|getMode
argument_list|()
argument_list|)
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|aces
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isSubCollection
parameter_list|(
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|col
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|sub
parameter_list|)
block|{
return|return
name|isSubCollection
argument_list|(
name|col
operator|.
name|getURI
argument_list|()
argument_list|,
name|sub
operator|.
name|getURI
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isSubCollection
parameter_list|(
specifier|final
name|XmldbURI
name|col
parameter_list|,
specifier|final
name|XmldbURI
name|sub
parameter_list|)
block|{
return|return
name|sub
operator|.
name|startsWith
argument_list|(
name|col
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|moveCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Collection
name|sourceCollection
parameter_list|,
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
assert|assert
operator|(
name|sourceCollection
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|targetCollection
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|newName
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"newName name must be just a name i.e. an XmldbURI with one segment!"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|sourceCollectionUri
init|=
name|sourceCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|destinationCollectionUri
init|=
name|targetCollectionUri
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceCollection
operator|.
name|getId
argument_list|()
operator|==
name|targetCollection
operator|.
name|getId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself '"
operator|+
name|sourceCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sourceCollectionUri
operator|.
name|equals
argument_list|(
name|destinationCollectionUri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself '"
operator|+
name|sourceCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sourceCollectionUri
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move the db root collection /db"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isSubCollection
argument_list|(
name|sourceCollectionUri
argument_list|,
name|targetCollectionUri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection '"
operator|+
name|sourceCollectionUri
operator|+
literal|"' inside itself '"
operator|+
name|targetCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|sourceCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" has insufficient privileges on collection to move collection "
operator|+
name|sourceCollectionUri
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|targetCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" has insufficient privileges on destination collection "
operator|+
name|destinationCollectionUri
operator|+
literal|" to move collection "
operator|+
name|sourceCollectionUri
argument_list|)
throw|;
block|}
comment|// WRITE LOCK the parent of the sourceCollection (as we will want to remove the sourceCollection from it eventually)
specifier|final
name|XmldbURI
name|sourceCollectionParentUri
init|=
name|sourceCollectionUri
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|sourceCollectionParent
init|=
name|openCollection
argument_list|(
name|sourceCollectionParentUri
argument_list|,
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|sourceCollectionParent
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|sourceCollectionParentUri
operator|+
literal|" to move collection "
operator|+
name|sourceCollectionUri
argument_list|)
throw|;
block|}
comment|/*              * If replacing another collection in the move              * i.e. sourceCollection=/db/col1/A, targetCollection=/db/col2, newName=A              * where /db/col2/A already exists we have to make sure the permissions to              * remove /db/col2/A are okay!              *              * So we must call removeCollection on /db/col2/A              * Which will ensure that collection can be removed and then remove it.              */
try|try
init|(
specifier|final
name|Collection
name|existingDestinationCollection
init|=
name|getCollection
argument_list|(
name|destinationCollectionUri
argument_list|)
init|)
block|{
comment|// NOTE: we already have a WRITE lock on destinationCollection (implicitly as targetCollection is locked)
if|if
condition|(
name|existingDestinationCollection
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|existingDestinationCollection
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination collection '"
operator|+
name|destinationCollectionUri
operator|+
literal|"' already exists and cannot be removed"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/*              * At this point this thread should hold WRITE_LOCKs on:              *   1) parent of sourceCollection              *   2) sourceCollection              *   3) targetCollection              *              *  Remember a lock on a node in the Collection tree,              *  implies locking the entire sub-tree, therefore              *  we don't need to explicitly lock sub-collections (just documents).              */
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_MOVE_COLLECTION
argument_list|,
name|sourceCollection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|CollectionTrigger
name|trigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollectionParent
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollection
argument_list|,
name|destinationCollectionUri
argument_list|)
expr_stmt|;
comment|// pessimistically obtain WRITE_LOCKs on all descendant documents of sourceCollection, and WRITE_LOCKs on all target documents
comment|// we do this as whilst the document objects won't change, their method getURI() will return a different URI after the move
try|try
init|(
specifier|final
name|ManagedLocks
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|sourceDocLocks
init|=
operator|new
name|ManagedLocks
argument_list|(
name|lockDescendantDocuments
argument_list|(
name|sourceCollection
argument_list|,
name|lockManager
operator|::
name|acquireDocumentWriteLock
argument_list|)
argument_list|)
init|;
specifier|final
name|ManagedLocks
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|targetDocLocks
init|=
operator|new
name|ManagedLocks
argument_list|(
name|lockTargetDocuments
argument_list|(
name|sourceCollectionUri
argument_list|,
name|sourceDocLocks
argument_list|,
name|destinationCollectionUri
argument_list|,
name|lockManager
operator|::
name|acquireDocumentWriteLock
argument_list|)
argument_list|)
init|)
block|{
comment|// Need to move each collection in the source tree individually, so recurse.
name|moveCollectionRecursive
argument_list|(
name|transaction
argument_list|,
name|trigger
argument_list|,
name|sourceCollectionParent
argument_list|,
name|sourceCollection
argument_list|,
name|targetCollection
argument_list|,
name|newName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|trigger
operator|.
name|afterMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollection
argument_list|,
name|sourceCollectionUri
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Acquires locks on all descendant Collections of a specific Collection      *      * Locks are acquired in a top-down, left-to-right order      *      * NOTE: It is assumed that the caller holds a lock on the      *     `collection` of the same mode as those that we should acquire on the descendants      *      * @param collection The Collection whose descendant locks should be acquired      * @param lockFn A function for acquiring a lock      *      * @return A list of locks in the same order as collectionUris. Note that these should be released in reverse order      */
specifier|private
name|List
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|lockDescendantDocuments
parameter_list|(
specifier|final
name|Collection
name|collection
parameter_list|,
specifier|final
name|FunctionE
argument_list|<
name|XmldbURI
argument_list|,
name|ManagedDocumentLock
argument_list|,
name|LockException
argument_list|>
name|lockFn
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
specifier|final
name|List
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|locks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|itDoc
init|=
name|collection
operator|.
name|iteratorNoLock
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|itDoc
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|itDoc
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockFn
operator|.
name|apply
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
decl_stmt|;
name|locks
operator|.
name|add
argument_list|(
name|docLock
argument_list|)
expr_stmt|;
block|}
specifier|final
name|XmldbURI
name|collectionUri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|it
init|=
name|collection
operator|.
name|collectionIteratorNoLock
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// NOTE: we should already have a lock on collection
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|XmldbURI
name|childCollectionName
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|childCollectionUri
init|=
name|collectionUri
operator|.
name|append
argument_list|(
name|childCollectionName
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|childCollection
init|=
name|getCollection
argument_list|(
name|childCollectionUri
argument_list|)
decl_stmt|;
comment|// NOTE: we don't need to lock the collection as we should already implicitly have a lock on the collection sub-tree
specifier|final
name|List
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|descendantLocks
init|=
name|lockDescendantDocuments
argument_list|(
name|childCollection
argument_list|,
name|lockFn
argument_list|)
decl_stmt|;
name|locks
operator|.
name|addAll
argument_list|(
name|descendantLocks
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|LockException
name|e
parameter_list|)
block|{
comment|// unlock in reverse order
try|try
block|{
name|ManagedLocks
operator|.
name|closeAll
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|RuntimeException
name|re
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
return|return
name|locks
return|;
block|}
comment|/**      * Locks target documents (useful for copy/move operations).      *      * @param sourceCollectionUri The source collection URI root of the copy/move operation      * @param sourceDocumentLocks Locks on the source documents, for which target document locks should be acquired      * @param targetCollectionUri The target collection URI root of the copy/move operation      * @param lockFn The function for locking the target document.      *      * @return A list of locks on the target documents.      */
specifier|private
name|List
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|lockTargetDocuments
parameter_list|(
specifier|final
name|XmldbURI
name|sourceCollectionUri
parameter_list|,
specifier|final
name|ManagedLocks
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|sourceDocumentLocks
parameter_list|,
specifier|final
name|XmldbURI
name|targetCollectionUri
parameter_list|,
specifier|final
name|FunctionE
argument_list|<
name|XmldbURI
argument_list|,
name|ManagedDocumentLock
argument_list|,
name|LockException
argument_list|>
name|lockFn
parameter_list|)
throws|throws
name|LockException
block|{
specifier|final
name|List
argument_list|<
name|ManagedDocumentLock
argument_list|>
name|locks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
specifier|final
name|ManagedDocumentLock
name|sourceDocumentLock
range|:
name|sourceDocumentLocks
control|)
block|{
specifier|final
name|XmldbURI
name|sourceDocumentUri
init|=
name|sourceDocumentLock
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|URI
name|relativeDocumentUri
init|=
name|sourceCollectionUri
operator|.
name|relativizeCollectionPath
argument_list|(
name|sourceDocumentUri
operator|.
name|getURI
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|XmldbURI
name|targetDocumentUri
init|=
name|XmldbURI
operator|.
name|create
argument_list|(
name|targetCollectionUri
operator|.
name|resolveCollectionPath
argument_list|(
name|relativeDocumentUri
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ManagedDocumentLock
name|documentLock
init|=
name|lockFn
operator|.
name|apply
argument_list|(
name|targetDocumentUri
argument_list|)
decl_stmt|;
name|locks
operator|.
name|add
argument_list|(
name|documentLock
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
comment|// unlock in reverse order
try|try
block|{
name|ManagedLocks
operator|.
name|closeAll
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|RuntimeException
name|re
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
return|return
name|locks
return|;
block|}
comment|//TODO bug the trigger param is reused as this is a recursive method, but in the current design triggers are only meant to be called once for each action and then destroyed!
comment|/**      * Recursive-descent Collection move, only meant to be      * called from {@link #moveCollection(Txn, Collection, Collection, XmldbURI)}      *      * @param transaction The current transaction      * @param trigger The trigger to fire on Collection events      * @param sourceCollection The Collection to move      * @param targetCollection The target Collection to move the sourceCollection into      * @param newName The new name the sourceCollection should have in the targetCollection      * @param fireTrigger Indicates whether the CollectionTrigger should be fired      *     on the Collection the first time this function is called. Triggers will always      *     be fired for recursive calls of this function.      */
specifier|private
name|void
name|moveCollectionRecursive
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|CollectionTrigger
name|trigger
parameter_list|,
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|sourceCollectionParent
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|sourceCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|,
specifier|final
name|boolean
name|fireTrigger
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
specifier|final
name|XmldbURI
name|sourceCollectionUri
init|=
name|sourceCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|destinationCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fireTrigger
condition|)
block|{
name|trigger
operator|.
name|beforeMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollection
argument_list|,
name|destinationCollectionUri
argument_list|)
expr_stmt|;
block|}
comment|// de-reference any existing binaries in the destination from the blob store
try|try
init|(
specifier|final
name|Collection
name|dst
init|=
name|openCollection
argument_list|(
name|destinationCollectionUri
argument_list|,
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|dst
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|itDoc
init|=
name|dst
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|itDoc
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|dstDoc
init|=
name|itDoc
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstDoc
operator|instanceof
name|BinaryDocument
condition|)
block|{
specifier|final
name|BinaryDocument
name|binDstDoc
init|=
operator|(
name|BinaryDocument
operator|)
name|dstDoc
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|dstDocLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|dstDoc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|binDstDoc
argument_list|)
expr_stmt|;
name|binDstDoc
operator|.
name|setBlobId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// remove source from parent
if|if
condition|(
name|sourceCollectionParent
operator|!=
literal|null
condition|)
block|{
specifier|final
name|XmldbURI
name|sourceCollectionName
init|=
name|sourceCollectionUri
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
name|sourceCollectionParent
operator|.
name|removeCollection
argument_list|(
name|this
argument_list|,
name|sourceCollectionName
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|sourceCollectionParent
argument_list|)
expr_stmt|;
block|}
comment|// remove source from cache
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
name|collectionsCache
operator|.
name|invalidate
argument_list|(
name|sourceCollection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove source from disk
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|sourceCollectionUri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|// set source path to destination... source is now the destination
name|sourceCollection
operator|.
name|setPath
argument_list|(
name|destinationCollectionUri
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|sourceCollection
argument_list|)
expr_stmt|;
comment|// add destination to target
name|targetCollection
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|sourceCollection
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceCollectionParent
operator|!=
name|targetCollection
condition|)
block|{
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|targetCollection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fireTrigger
condition|)
block|{
name|trigger
operator|.
name|afterMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollection
argument_list|,
name|sourceCollectionUri
argument_list|)
expr_stmt|;
block|}
comment|// move the descendants
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|sourceCollection
operator|.
name|collectionIteratorNoLock
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// NOTE: we already have a WRITE lock on sourceCollection
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|childUri
init|=
name|sourceCollectionUri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|child
init|=
name|getCollectionForOpen
argument_list|(
name|collectionsCache
argument_list|,
name|childUri
argument_list|)
decl_stmt|;
comment|// NOTE: we have a write lock on the sourceCollection, which means we don't need to lock sub-collections in the tree
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Child collection "
operator|+
name|childUri
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
else|else
block|{
name|moveCollectionRecursive
argument_list|(
name|transaction
argument_list|,
name|trigger
argument_list|,
literal|null
argument_list|,
name|child
argument_list|,
name|sourceCollection
argument_list|,
name|childName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|removeCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
comment|// WRITE LOCK the collection's parent (as we will remove this collection from it)
specifier|final
name|XmldbURI
name|parentCollectionUri
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
operator|==
literal|null
condition|?
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
else|:
name|collection
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedCollectionLock
name|parentCollectionLock
init|=
name|writeLockCollection
argument_list|(
name|parentCollectionUri
argument_list|)
init|)
block|{
return|return
name|_removeCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to lock Collection: {}"
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|boolean
name|_removeCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|IOException
block|{
specifier|final
name|XmldbURI
name|collectionUri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REMOVE_COLLECTION
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
try|try
block|{
annotation|@
name|Nullable
specifier|final
name|Collection
name|parentCollection
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|getCollection
argument_list|(
name|collection
operator|.
name|getParentURI
argument_list|()
argument_list|)
decl_stmt|;
comment|// NOTE: we already have a WRITE lock on the parent of the Collection we set out to remove
comment|// 1) check the current user has permission to delete the Collection
comment|//TODO(AR) the below permissions check could be optimised when descending the tree so we don't check the same collection(s) twice in some cases
if|if
condition|(
operator|!
name|checkRemoveCollectionPermissions
argument_list|(
name|parentCollection
argument_list|,
name|collection
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' is not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
specifier|final
name|CollectionTrigger
name|colTrigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|parentCollection
operator|==
literal|null
condition|?
name|collection
else|:
name|parentCollection
argument_list|)
decl_stmt|;
name|colTrigger
operator|.
name|beforeDeleteCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
comment|// 2) remove descendant collections
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|subCollectionName
init|=
name|collection
operator|.
name|collectionIteratorNoLock
argument_list|(
name|this
argument_list|)
init|;
name|subCollectionName
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// NOTE: we already have a WRITE lock on the parent of the Collection we set out to remove
specifier|final
name|XmldbURI
name|subCollectionUri
init|=
name|collectionUri
operator|.
name|append
argument_list|(
name|subCollectionName
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|removedSubCollection
init|=
name|_removeCollection
argument_list|(
name|transaction
argument_list|,
name|getCollection
argument_list|(
name|subCollectionUri
argument_list|)
argument_list|)
decl_stmt|;
comment|// NOTE: we already have a WRITE lock on the parent of the Collection we set out to remove
if|if
condition|(
operator|!
name|removedSubCollection
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to remove Collection: {}"
argument_list|,
name|subCollectionUri
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|//TODO(AR) this can be executed asynchronously as a task, Do we need to await the completion before unlocking the collection? or just await completion before returning from the first call to _removeCollection?
comment|// 3) drop indexes for this Collection
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// 4) remove this Collection from the parent Collection
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
name|parentCollection
operator|.
name|removeCollection
argument_list|(
name|this
argument_list|,
name|collectionUri
operator|.
name|lastSegment
argument_list|()
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parentCollection
argument_list|)
expr_stmt|;
block|}
comment|// 5) remove Collection from collections.dbx
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collectionUri
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//TODO(AR) is this the correct place to invalidate the config?
comment|// Notify the collection configuration manager
specifier|final
name|CollectionConfigurationManager
name|manager
init|=
name|pool
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
name|manager
operator|.
name|invalidate
argument_list|(
name|collectionUri
argument_list|,
name|getBrokerPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// invalidate the cache entry
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
name|collectionsCache
operator|.
name|invalidate
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if this is the root collection we just have to save
comment|// it to persist the removal of any subCollections to collections.dbx
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
comment|//TODO(AR) this could possibly be executed asynchronously as a task, we don't need to know when it completes (this is because access to documents is through a Collection, and the Collection was removed above), however we cannot recycle the collectionId until all docs are gone
comment|// 6) unlink all documents from the Collection
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|docKey
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|docKey
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
comment|// we must not free the root collection id!
name|collectionsDb
operator|.
name|freeCollectionId
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to unlink documents from the Collection: {}"
argument_list|,
name|collectionUri
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//TODO(AR) this can be executed asynchronously as a task, we need to await the completion before unlocking the collection
comment|// 7) remove the documents nodes and binary documents of the Collection from dom.dbx
name|removeCollectionsDocumentNodes
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
name|colTrigger
operator|.
name|afterDeleteCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collectionUri
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to lock Collection: {}"
argument_list|,
name|collectionUri
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|getBrokerPool
argument_list|()
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeCollectionsDocumentNodes
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|TriggerException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|DocumentTrigger
name|docTrigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|itDocument
init|=
name|collection
operator|.
name|iteratorNoLock
argument_list|(
name|this
argument_list|)
init|;
name|itDocument
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// NOTE: we already have a WRITE_LOCK on the collection
specifier|final
name|DocumentImpl
name|doc
init|=
name|itDocument
operator|.
name|next
argument_list|()
decl_stmt|;
name|docTrigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|//Remove doc's metadata
comment|// WM: now removed in one step. see above.
comment|//removeResourceMetadata(transaction, doc);
comment|//Remove document nodes' index entries
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
try|try
block|{
specifier|final
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//Remove nodes themselves
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
specifier|final
name|NodeHandle
name|node
init|=
operator|(
name|NodeHandle
operator|)
name|doc
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// if it is a binary document remove the content from disk
end_comment

begin_if_stmt
if|if
condition|(
name|doc
operator|instanceof
name|BinaryDocument
condition|)
block|{
name|removeCollectionBinary
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
end_if_stmt

begin_expr_stmt
name|docTrigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|//Make doc's id available again
end_comment

begin_expr_stmt
name|collectionsDb
operator|.
name|freeResourceId
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}     }
specifier|private
name|void
name|removeCollectionBinary
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
name|blobStore
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|doc
operator|.
name|getBlobId
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Checks that the current user has permissions to remove the Collection      *      * @param parentCollection The parent Collection or null if we are testing the root Collection      * @param collection The Collection to check permissions for removal      *      * @return true if the current user is allowed to remove the Collection      */
end_comment

begin_function
specifier|private
name|boolean
name|checkRemoveCollectionPermissions
parameter_list|(
annotation|@
name|Nullable
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|parentCollection
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|// parent collection permissions
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|parentCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|parentCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// collection permissions
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|isEmpty
argument_list|(
name|this
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/**      * Acquires a write lock on a Collection      *      * @param collectionUri The uri of the collection to lock      *      * @return A managed lock for the Collection      */
end_comment

begin_function
specifier|private
name|ManagedCollectionLock
name|writeLockCollection
parameter_list|(
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|collectionUri
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * Acquires a READ lock on a Collection      *      * @param collectionUri The uri of the collection to lock      *      * @return A managed lock for the Collection      */
end_comment

begin_function
specifier|private
name|ManagedCollectionLock
name|readLockCollection
parameter_list|(
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|lockManager
operator|.
name|acquireCollectionReadLock
argument_list|(
name|collectionUri
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|saveCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"NativeBroker.saveCollection called with collection == null! Aborting."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
name|collectionsCache
operator|.
name|put
argument_list|(
name|collection
argument_list|)
expr_stmt|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|name
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|VariableByteOutputStream
name|os
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
init|)
block|{
name|collection
operator|.
name|serialize
argument_list|(
name|os
argument_list|)
expr_stmt|;
specifier|final
name|long
name|address
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|name
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not store collection data for '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"', address=BFile.UNKNOWN_ADDRESS"
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**      * Get the next available unique collection id.      * @param transaction the transaction      * @return next available unique collection id      * @throws ReadOnlyException in response to an readonly error      * @throws LockException in case of a lock error      */
end_comment

begin_function
specifier|public
name|int
name|getNextCollectionId
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
throws|,
name|LockException
block|{
name|int
name|nextCollectionId
init|=
name|collectionsDb
operator|.
name|getFreeCollectionId
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextCollectionId
operator|!=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
block|{
return|return
name|nextCollectionId
return|;
block|}
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|NEXT_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
else|else
block|{
name|nextCollectionId
operator|=
name|FIRST_COLLECTION_ID
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|nextCollectionId
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|reindexCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|fqUri
init|=
name|prepend
argument_list|(
name|collectionUri
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|collection
init|=
name|openCollection
argument_list|(
name|fqUri
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection {} not found!"
argument_list|,
name|fqUri
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Start indexing collection {}"
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REINDEX_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
name|IndexMode
operator|.
name|STORE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|PermissionDeniedException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"An error occurred during reindex: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished indexing collection {} in {} ms."
argument_list|,
name|fqUri
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|reindexCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|,
specifier|final
name|IndexMode
name|mode
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reindexing collection {}"
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|IndexMode
operator|.
name|STORE
condition|)
block|{
name|dropCollectionIndex
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// reindex documents
try|try
block|{
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|next
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|next
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"LockException while reindexing documents of collection '{}'. Skipping..."
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// descend into child collections
try|try
block|{
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|childUri
init|=
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|childName
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|childUri
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Collection '"
operator|+
name|childUri
operator|+
literal|"' not found"
argument_list|)
throw|;
block|}
else|else
block|{
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"LockException while reindexing child collections of collection '{}'. Skipping..."
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|dropCollectionIndex
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
name|dropCollectionIndex
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|dropCollectionIndex
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|Collection
name|collection
parameter_list|,
specifier|final
name|boolean
name|reindex
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|,
name|this
argument_list|,
name|reindex
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dropping index for document {}"
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
try|try
block|{
specifier|final
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
decl||
name|IOException
decl||
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while removing Document '{}' from Collection index: {}"
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}     }
comment|/**      * Store into the temporary collection of the database a given in-memory Document      *      * The in-memory Document is stored without a transaction and is not journalled,      * if there is no temporary collection, this will first be created with a transaction      *      * @param doc The in-memory Document to store      * @return The document stored in the temp collection      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|storeTempResource
parameter_list|(
specifier|final
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
try|try
block|{
comment|//elevate getUser() to DBA_USER
name|pushSubject
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
comment|//start a transaction
specifier|final
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
comment|//create a name for the temporary document
specifier|final
name|XmldbURI
name|docName
init|=
name|XmldbURI
operator|.
name|create
argument_list|(
name|MessageDigester
operator|.
name|md5
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|+
literal|".xml"
argument_list|)
decl_stmt|;
comment|//get the temp collection
try|try
init|(
specifier|final
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
init|;
specifier|final
name|ManagedCollectionLock
name|tempCollectionLock
init|=
name|lockManager
operator|.
name|acquireCollectionWriteLock
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|)
init|)
block|{
comment|// if temp collection does not exist, creates temp collection (with write lock in Txn)
specifier|final
name|Tuple2
argument_list|<
name|Boolean
argument_list|,
name|Collection
argument_list|>
name|createdOrExistingTemp
init|=
name|getOrCreateTempCollection
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|createdOrExistingTemp
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create temporary collection"
argument_list|)
expr_stmt|;
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|Collection
name|temp
init|=
name|createdOrExistingTemp
operator|.
name|_2
decl_stmt|;
comment|//create a temporary document
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|docLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|temp
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|docName
argument_list|)
argument_list|)
init|)
block|{
specifier|final
name|int
name|tmpDocId
init|=
name|getNextResourceId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
specifier|final
name|Permission
name|permission
init|=
name|PermissionFactory
operator|.
name|getDefaultResourcePermission
argument_list|(
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
argument_list|)
decl_stmt|;
name|permission
operator|.
name|setMode
argument_list|(
name|Permission
operator|.
name|DEFAULT_TEMPORARY_DOCUMENT_PERM
argument_list|)
expr_stmt|;
specifier|final
name|DocumentMetadata
name|metadata
init|=
operator|new
name|DocumentMetadata
argument_list|()
decl_stmt|;
specifier|final
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setLastModified
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|now
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|targetDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|temp
argument_list|,
name|tmpDocId
argument_list|,
name|docName
argument_list|,
name|permission
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|metadata
argument_list|)
decl_stmt|;
comment|//index the temporary document
specifier|final
name|DOMIndexer
name|indexer
init|=
operator|new
name|DOMIndexer
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|targetDoc
argument_list|)
decl_stmt|;
name|indexer
operator|.
name|scan
argument_list|()
expr_stmt|;
name|indexer
operator|.
name|store
argument_list|()
expr_stmt|;
comment|//store the temporary document
name|temp
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|temp
operator|.
name|close
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
comment|//commit the transaction
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
return|return
name|targetDoc
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to store temporary fragment: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|//restore the user
name|popSubject
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**      * remove all documents from temporary collection      *      * @param forceRemoval Should temporary resources be forcefully removed      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|cleanUpTempResources
parameter_list|(
specifier|final
name|boolean
name|forceRemoval
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
try|try
init|(
specifier|final
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|,
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
init|)
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to remove temp collection: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getResourceById
parameter_list|(
specifier|final
name|int
name|collectionId
parameter_list|,
specifier|final
name|byte
name|resourceType
parameter_list|,
specifier|final
name|int
name|documentId
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|XmldbURI
name|uri
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
comment|//get the collection uri
name|String
name|collectionUri
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|collectionId
operator|==
name|FIRST_COLLECTION_ID
condition|)
block|{
name|collectionUri
operator|=
literal|"/db"
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
specifier|final
name|Value
name|collectionDbKey
range|:
name|collectionsDb
operator|.
name|getKeys
argument_list|()
control|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|collectionDbKey
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
name|CollectionStore
operator|.
name|KEY_TYPE_COLLECTION
condition|)
block|{
comment|//Value collectionDbValue = collectionsDb.get(collectionDbKey);
specifier|final
name|VariableByteInput
name|vbi
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|collectionDbKey
argument_list|)
decl_stmt|;
specifier|final
name|int
name|id
init|=
name|vbi
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|//check if the collection id matches (first 4 bytes)
if|if
condition|(
name|collectionId
operator|==
name|id
condition|)
block|{
name|collectionUri
operator|=
operator|new
name|String
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|data
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|//get the resource uri
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collectionId
argument_list|,
name|resourceType
argument_list|,
name|documentId
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteInput
name|vbi
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|vbi
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|//skip doc id
specifier|final
name|String
name|resourceUri
init|=
name|vbi
operator|.
name|readUTF
argument_list|()
decl_stmt|;
comment|//get the resource
name|uri
operator|=
name|XmldbURI
operator|.
name|createInternal
argument_list|(
name|collectionUri
operator|+
literal|"/"
operator|+
name|resourceUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|te
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Query Terminated"
argument_list|,
name|te
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Problem reading btree"
argument_list|,
name|bte
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IOException while reading resource data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|getResource
argument_list|(
name|uri
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * store Document entry into its collection.      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|storeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
try|try
init|(
specifier|final
name|VariableByteOutputStream
name|os
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
init|;
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
name|doc
operator|.
name|write
argument_list|(
name|os
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//} catch (ReadOnlyException e) {
comment|//LOG.warn(DATABASE_IS_READ_ONLY);
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IOException while writing document data: {}"
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|storeMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|TriggerException
block|{
specifier|final
name|Collection
name|col
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|col
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeUpdateDocumentMetadata
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterUpdateDocumentMetadata
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
specifier|final
name|InputStream
name|is
init|=
operator|new
name|FastByteArrayInputStream
argument_list|(
name|data
argument_list|)
init|)
block|{
name|storeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
specifier|final
name|Tuple2
argument_list|<
name|BlobId
argument_list|,
name|Long
argument_list|>
name|blobIdLen
init|=
name|blobStore
operator|.
name|add
argument_list|(
name|transaction
argument_list|,
name|is
argument_list|)
decl_stmt|;
name|blob
operator|.
name|setBlobId
argument_list|(
name|blobIdLen
operator|.
name|_1
argument_list|)
expr_stmt|;
name|blob
operator|.
name|setContentLength
argument_list|(
name|blobIdLen
operator|.
name|_2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|Document
name|getXMLResource
parameter_list|(
specifier|final
name|XmldbURI
name|fileName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|getResource
argument_list|(
name|fileName
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|,
specifier|final
name|int
name|accessType
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|fileName
operator|=
name|prepend
argument_list|(
name|fileName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !!!
specifier|final
name|XmldbURI
name|collUri
init|=
name|fileName
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|docUri
init|=
name|fileName
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|collection
init|=
name|openCollection
argument_list|(
name|collUri
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '{}' not found!"
argument_list|,
name|collUri
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//if(!collection.getPermissions().validate(getCurrentSubject(), Permission.READ)) {
comment|//throw new PermissionDeniedException("Permission denied to read collection '" + collUri + "' by " + getCurrentSubject().getName());
comment|//}
try|try
init|(
specifier|final
name|LockedDocument
name|lockedDocument
init|=
name|collection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|docUri
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collection
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|lockedDocument
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document '{}' not found!"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
name|lockedDocument
operator|.
name|getDocument
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|accessType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed requested access to document '"
operator|+
name|fileName
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|doc
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|LockedDocument
name|getXMLResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|,
specifier|final
name|LockMode
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|fileName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|fileName
operator|=
name|prepend
argument_list|(
name|fileName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !
specifier|final
name|XmldbURI
name|collUri
init|=
name|fileName
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|docUri
init|=
name|fileName
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|collection
init|=
name|openCollection
argument_list|(
name|collUri
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Collection '{}' not found!"
argument_list|,
name|collUri
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
comment|//if (!collection.getPermissions().validate(getCurrentSubject(), Permission.EXECUTE)) {
comment|//    throw new PermissionDeniedException("Permission denied to read collection '" + collUri + "' by " + getCurrentSubject().getName());
comment|//}
specifier|final
name|LockedDocument
name|lockedDocument
init|=
name|collection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|docUri
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
comment|// NOTE: early release of Collection lock inline with Asymmetrical Locking scheme
name|collection
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|lockedDocument
operator|==
literal|null
condition|)
block|{
comment|//LOG.debug("document '" + fileName + "' not found!");
return|return
literal|null
return|;
block|}
comment|//if (!doc.getMode().validate(getUser(), Permission.READ))
comment|//throw new PermissionDeniedException("not allowed to read document");
specifier|final
name|DocumentImpl
name|doc
init|=
name|lockedDocument
operator|.
name|getDocument
argument_list|()
decl_stmt|;
return|return
name|lockedDocument
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not acquire lock on document {}"
argument_list|,
name|fileName
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : exception ? -pb
block|}
block|}
return|return
literal|null
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|readBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
specifier|final
name|Txn
name|transaction
init|=
name|continueOrBeginTransaction
argument_list|()
init|)
block|{
name|readBinaryResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|transaction
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|readBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|InputStream
name|is
init|=
name|blobStore
operator|.
name|get
argument_list|(
name|transaction
argument_list|,
name|blob
operator|.
name|getBlobId
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|os
operator|instanceof
name|FastByteArrayOutputStream
condition|)
block|{
operator|(
operator|(
name|FastByteArrayOutputStream
operator|)
name|os
operator|)
operator|.
name|write
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy
argument_list|(
name|is
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|long
name|getBinaryResourceSize
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|blob
operator|.
name|getContentLength
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MessageDigest
name|getBinaryResourceContentDigest
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|binaryDocument
parameter_list|,
specifier|final
name|DigestType
name|digestType
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
return|return
name|blobStore
operator|.
name|getDigest
argument_list|(
name|transaction
argument_list|,
name|binaryDocument
operator|.
name|getBlobId
argument_list|()
argument_list|,
name|digestType
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|Path
name|getBinaryFile
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"No longer supported, use DBBroker#withBinaryFile(Txn, BinaryDocument, Function)"
argument_list|)
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|withBinaryFile
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|binaryDocument
parameter_list|,
specifier|final
name|Function
argument_list|<
name|Path
argument_list|,
name|T
argument_list|>
name|fnFile
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
return|return
name|blobStore
operator|.
name|with
argument_list|(
name|transaction
argument_list|,
name|binaryDocument
operator|.
name|getBlobId
argument_list|()
argument_list|,
name|fnFile
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|InputStream
name|getBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO(AR) how best to get the transaction?
try|try
init|(
specifier|final
name|Txn
name|transaction
init|=
name|continueOrBeginTransaction
argument_list|()
init|)
block|{
specifier|final
name|InputStream
name|is
init|=
name|getBinaryResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
decl_stmt|;
name|transaction
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|is
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|InputStream
name|getBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
return|return
name|blobStore
operator|.
name|get
argument_list|(
name|transaction
argument_list|,
name|blob
operator|.
name|getBlobId
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//TODO : consider a better cooperation with Collection -pb
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|getCollectionResources
parameter_list|(
specifier|final
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
parameter_list|)
block|{
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collectionInternalAccess
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
operator|new
name|DocumentCallback
argument_list|(
name|collectionInternalAccess
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
decl||
name|BTreeException
decl||
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|getResourcesFailsafe
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BTreeCallback
name|callback
parameter_list|,
specifier|final
name|boolean
name|fullScan
parameter_list|)
throws|throws
name|TerminatedException
block|{
assert|assert
operator|(
name|transaction
operator|!=
literal|null
operator|&&
name|transaction
operator|.
name|getState
argument_list|()
operator|==
name|Txn
operator|.
name|State
operator|.
name|STARTED
operator|)
assert|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|()
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullScan
condition|)
block|{
name|collectionsDb
operator|.
name|rawScan
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
decl||
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|getCollectionsFailsafe
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
block|{
assert|assert
operator|(
name|transaction
operator|!=
literal|null
operator|&&
name|transaction
operator|.
name|getState
argument_list|()
operator|==
name|Txn
operator|.
name|State
operator|.
name|STARTED
operator|)
assert|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|()
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
decl||
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MutableDocumentSet
name|getXMLResourcesByDoctype
parameter_list|(
specifier|final
name|String
name|doctypeName
parameter_list|,
specifier|final
name|MutableDocumentSet
name|result
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
specifier|final
name|MutableDocumentSet
name|docs
init|=
name|getAllXMLResources
argument_list|(
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|docs
operator|.
name|getDocumentIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|documentLock
init|=
name|lockManager
operator|.
name|acquireDocumentReadLock
argument_list|(
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|DocumentType
name|doctype
init|=
name|doc
operator|.
name|getDoctype
argument_list|()
decl_stmt|;
if|if
condition|(
name|doctype
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|doctypeName
operator|.
name|equals
argument_list|(
name|doctype
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
operator|&&
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MutableDocumentSet
name|getAllXMLResources
parameter_list|(
specifier|final
name|MutableDocumentSet
name|docs
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Collection
name|rootCollection
init|=
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|,
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
init|)
block|{
name|rootCollection
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getAllDocuments(DocumentSet) - end - loading {} documents took {} ms."
argument_list|,
name|docs
operator|.
name|getDocumentCount
argument_list|()
argument_list|,
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|copyResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|sourceDocument
parameter_list|,
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
block|{
name|copyResource
argument_list|(
name|transaction
argument_list|,
name|sourceDocument
argument_list|,
name|targetCollection
argument_list|,
name|newName
argument_list|,
name|PreserveType
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|copyResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|sourceDocument
parameter_list|,
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newDocName
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
block|{
assert|assert
operator|(
name|sourceDocument
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|targetCollection
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|newDocName
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|newDocName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"newName name must be just a name i.e. an XmldbURI with one segment!"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|sourceDocumentUri
init|=
name|sourceDocument
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetDocumentUri
init|=
name|targetCollectionUri
operator|.
name|append
argument_list|(
name|newDocName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceDocument
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' has insufficient privileges to copy the resource '"
operator|+
name|sourceDocumentUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// we assume the caller holds a READ_LOCK (or better) on sourceDocument#getCollection()
specifier|final
name|Collection
name|sourceCollection
init|=
name|sourceDocument
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sourceCollection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' has insufficient privileges to copy the resource '"
operator|+
name|sourceDocumentUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|targetCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' does not have execute access on the destination collection '"
operator|+
name|targetCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|targetCollection
operator|.
name|hasChildCollection
argument_list|(
name|this
argument_list|,
name|newDocName
operator|.
name|lastSegment
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"The collection '"
operator|+
name|targetCollectionUri
operator|+
literal|"' already has a sub-collection named '"
operator|+
name|newDocName
operator|.
name|lastSegment
argument_list|()
operator|+
literal|"', you cannot create a Document with the same name as an existing collection."
argument_list|)
throw|;
block|}
try|try
init|(
specifier|final
name|LockedDocument
name|oldLockedDoc
init|=
name|targetCollection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|newDocName
argument_list|,
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
init|)
block|{
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|targetCollection
argument_list|)
decl_stmt|;
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|oldLockedDoc
operator|==
literal|null
condition|?
literal|null
else|:
name|oldLockedDoc
operator|.
name|getDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|targetCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' does not have write access on the destination collection '"
operator|+
name|targetCollectionUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//overwrite existing document
if|if
condition|(
name|sourceDocument
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy resource to itself '"
operator|+
name|sourceDocumentUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource with the same name already exists in the target collection '"
operator|+
name|oldDoc
operator|.
name|getURI
argument_list|()
operator|+
literal|"', and you do not have write access on that resource."
argument_list|)
throw|;
block|}
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|targetDocumentUri
argument_list|)
expr_stmt|;
block|}
name|doCopyDocument
argument_list|(
name|transaction
argument_list|,
name|trigger
argument_list|,
name|sourceDocument
argument_list|,
name|targetCollection
argument_list|,
name|newDocName
argument_list|,
name|oldDoc
argument_list|,
name|preserve
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Creates a new Document object for the destination document      * - copies the nodes from the source document to the destination document      * - if no existing document in the destination:      *      - adds the destination document to the destination collection      *   else, switches the existing document object for the new document in the destination collection      *      *   asynchronously deletes the nodes of the old existing document      */
end_comment

begin_function
specifier|private
name|void
name|doCopyDocument
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentTrigger
name|trigger
parameter_list|,
specifier|final
name|DocumentImpl
name|sourceDocument
parameter_list|,
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newDocName
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
annotation|@
name|Nullable
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
specifier|final
name|PreserveType
name|preserve
parameter_list|)
throws|throws
name|TriggerException
throws|,
name|LockException
throws|,
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|EXistException
block|{
specifier|final
name|XmldbURI
name|sourceDocumentUri
init|=
name|sourceDocument
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetDocumentUri
init|=
name|targetCollectionUri
operator|.
name|append
argument_list|(
name|newDocName
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeCopyDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceDocument
argument_list|,
name|targetDocumentUri
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|newDocument
decl_stmt|;
specifier|final
name|LockManager
name|lockManager
init|=
name|getBrokerPool
argument_list|()
operator|.
name|getLockManager
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedDocumentLock
name|newDocLock
init|=
name|lockManager
operator|.
name|acquireDocumentWriteLock
argument_list|(
name|targetDocumentUri
argument_list|)
init|)
block|{
specifier|final
name|int
name|copiedDocId
init|=
name|getNextResourceId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceDocument
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
specifier|final
name|BinaryDocument
name|newDoc
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|newDoc
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|copiedDocId
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newDoc
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|getBrokerPool
argument_list|()
argument_list|,
name|targetCollection
argument_list|,
name|copiedDocId
argument_list|,
name|newDocName
argument_list|)
expr_stmt|;
block|}
name|newDoc
operator|.
name|copyOf
argument_list|(
name|this
argument_list|,
name|sourceDocument
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserveOnCopy
argument_list|(
name|preserve
argument_list|)
condition|)
block|{
name|copyResource_preserve
argument_list|(
name|this
argument_list|,
name|sourceDocument
argument_list|,
name|newDoc
argument_list|,
name|oldDoc
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
name|copyBinaryResource
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|sourceDocument
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|newDocument
operator|=
name|newDoc
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DocumentImpl
name|newDoc
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|newDoc
operator|=
operator|new
name|DocumentImpl
argument_list|(
name|copiedDocId
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newDoc
operator|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|targetCollection
argument_list|,
name|copiedDocId
argument_list|,
name|newDocName
argument_list|)
expr_stmt|;
block|}
name|newDoc
operator|.
name|copyOf
argument_list|(
name|this
argument_list|,
name|sourceDocument
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|sourceDocument
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserveOnCopy
argument_list|(
name|preserve
argument_list|)
condition|)
block|{
name|copyResource_preserve
argument_list|(
name|this
argument_list|,
name|sourceDocument
argument_list|,
name|newDoc
argument_list|,
name|oldDoc
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
name|newDocument
operator|=
name|newDoc
expr_stmt|;
block|}
comment|/*              * Stores the document entry for newDstDoc,              * or overwrites the document entry for currentDstDoc with              * the entry for newDstDoc, in collections.dbx.              */
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDocument
argument_list|)
expr_stmt|;
comment|// must be the last action (before cleanup), as this will make newDstDoc available to other threads!
name|targetCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDocument
argument_list|)
expr_stmt|;
comment|// NOTE: copied document is now live!
comment|// TODO (AR) this could be done asynchronously in future perhaps?
comment|// cleanup the old destination doc (if present)
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
comment|// drop the index and dom nodes of the old document
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|dropDomNodes
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// remove the blob of the old document
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
name|blobStore
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|(
operator|(
name|BinaryDocument
operator|)
name|oldDoc
operator|)
operator|.
name|getBlobId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// remove oldDoc entry from collections.dbx
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
comment|// TODO(AR) do we need a freeId flag to control this?
comment|// recycle the id
name|collectionsDb
operator|.
name|freeResourceId
argument_list|(
name|oldDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|// The Collection object oldDstDoc is now an empty husk which is
comment|// not available or referenced from anywhere, it will be subject
comment|// to garbage collection
block|}
block|}
name|trigger
operator|.
name|afterCopyDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|newDocument
argument_list|,
name|sourceDocumentUri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Preserves attributes when copying a resource.      * e.g. `cp --preserve`      *      * @param broker the eXist-db DBBroker      * @param srcDocument The source document.      * @param destDocument The destination document.      * @param overwrittingDest if true it overwrites the destination resource      * @throws PermissionDeniedException if user does not have sufficient rights      *      */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|copyResource_preserve
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|DocumentImpl
name|srcDocument
parameter_list|,
specifier|final
name|DocumentImpl
name|destDocument
parameter_list|,
specifier|final
name|boolean
name|overwrittingDest
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|Permission
name|srcPermissions
init|=
name|srcDocument
operator|.
name|getPermissions
argument_list|()
decl_stmt|;
specifier|final
name|Permission
name|destPermissions
init|=
name|destDocument
operator|.
name|getPermissions
argument_list|()
decl_stmt|;
comment|// only copy the owner and group from the source if we are creating a new file and we are the DBA
if|if
condition|(
operator|(
operator|!
name|overwrittingDest
operator|)
operator|&&
name|broker
operator|.
name|getCurrentSubject
argument_list|()
operator|.
name|hasDbaRole
argument_list|()
condition|)
block|{
name|PermissionFactory
operator|.
name|chown
argument_list|(
name|broker
argument_list|,
name|destPermissions
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|srcPermissions
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|srcPermissions
operator|.
name|getGroup
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|copyModeAcl
argument_list|(
name|broker
argument_list|,
name|srcPermissions
argument_list|,
name|destPermissions
argument_list|)
expr_stmt|;
comment|// btime (birth time)
if|if
condition|(
operator|!
name|overwrittingDest
condition|)
block|{
name|destDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|setCreated
argument_list|(
name|srcDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
argument_list|)
expr_stmt|;
comment|// Indeed! ...the birth time of the dest file is the last modified time of the source file
block|}
comment|// mtime (modified time)
name|destDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|setLastModified
argument_list|(
name|srcDocument
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Copies the Mode and ACL (if present) from one      * object to another.      *      * @param srcPermissions The permissions of the source object.      * @param destPermissions The permissions of the destination object.      */
end_comment

begin_function
specifier|private
specifier|static
name|void
name|copyModeAcl
parameter_list|(
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|Permission
name|srcPermissions
parameter_list|,
specifier|final
name|Permission
name|destPermissions
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|PermissionFactory
operator|.
name|chmod
argument_list|(
name|broker
argument_list|,
name|destPermissions
argument_list|,
name|Optional
operator|.
name|of
argument_list|(
name|srcPermissions
operator|.
name|getMode
argument_list|()
argument_list|)
argument_list|,
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcPermissions
operator|instanceof
name|SimpleACLPermission
operator|&&
name|destPermissions
operator|instanceof
name|SimpleACLPermission
condition|)
block|{
name|PermissionFactory
operator|.
name|chacl
argument_list|(
name|destPermissions
argument_list|,
name|newAcl
lambda|->
operator|(
operator|(
name|SimpleACLPermission
operator|)
name|newAcl
operator|)
operator|.
name|copyAclOf
argument_list|(
operator|(
name|SimpleACLPermission
operator|)
name|srcPermissions
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|copyXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|READ_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|newDoc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying document {} to {}"
argument_list|,
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|,
name|newDoc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|getIndexController
argument_list|()
operator|.
name|getStreamListener
argument_list|(
name|newDoc
argument_list|,
name|ReindexMode
operator|.
name|STORE
argument_list|)
decl_stmt|;
specifier|final
name|NodeList
name|nodes
init|=
name|oldDoc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
argument_list|<
name|?
argument_list|>
name|node
init|=
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|INodeIterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
init|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath2
argument_list|()
argument_list|,
name|newDoc
argument_list|,
literal|false
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copy took {} ms."
argument_list|,
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|copyBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|srcDoc
parameter_list|,
specifier|final
name|BinaryDocument
name|dstDoc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
specifier|final
name|BlobId
name|dstBlobId
init|=
name|blobStore
operator|.
name|copy
argument_list|(
name|transaction
argument_list|,
name|srcDoc
operator|.
name|getBlobId
argument_list|()
argument_list|)
decl_stmt|;
name|dstDoc
operator|.
name|setBlobId
argument_list|(
name|dstBlobId
argument_list|)
expr_stmt|;
name|dstDoc
operator|.
name|setContentLength
argument_list|(
name|srcDoc
operator|.
name|getContentLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|moveResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|sourceDocument
parameter_list|,
specifier|final
name|Collection
name|targetCollection
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
assert|assert
operator|(
name|sourceDocument
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|targetCollection
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|newName
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"newName name must be just a name i.e. an XmldbURI with one segment!"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|sourceDocumentUri
init|=
name|sourceDocument
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|targetCollectionUri
init|=
name|targetCollection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|destinationDocumentUri
init|=
name|targetCollectionUri
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
specifier|final
name|Account
name|docUser
init|=
name|sourceDocument
operator|.
name|getUserLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|docUser
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|docUser
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move '"
operator|+
name|sourceDocumentUri
operator|+
literal|" because is locked by getUser() '"
operator|+
name|docUser
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|/**          * As per the rules of Linux -          *          * mv is NOT a copy operation unless we are traversing filesystems.          * We consider eXist to be a single filesystem, so we only need          * WRITE and EXECUTE access on the source and destination collections          * as we are effectively just re-linking the file.          *          * - Adam 2013-03-26          */
comment|// we assume the caller holds a WRITE_LOCK on sourceDocument#getCollection()
specifier|final
name|Collection
name|sourceCollection
init|=
name|sourceDocument
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sourceCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on source Collection to move resource: "
operator|+
name|sourceDocumentUri
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|targetCollection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getCurrentSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getCurrentSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on destination Collection '"
operator|+
name|targetCollectionUri
operator|+
literal|"' to move resource: "
operator|+
name|sourceDocumentUri
argument_list|)
throw|;
block|}
if|if
condition|(
name|targetCollection
operator|.
name|hasChildCollection
argument_list|(
name|this
argument_list|,
name|newName
operator|.
name|lastSegment
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"The Collection '"
operator|+
name|targetCollectionUri
operator|+
literal|"' has a sub-collection '"
operator|+
name|newName
operator|+
literal|"'; cannot create a Document with the same name!"
argument_list|)
throw|;
block|}
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceCollection
argument_list|)
decl_stmt|;
comment|// check if the move would overwrite a document
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|targetCollection
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sourceDocument
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move resource to itself '"
operator|+
name|sourceDocumentUri
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// GNU mv command would prompt for Confirmation here, you can say yes or pass the '-f' flag. As we cant prompt for confirmation we assume OK
comment|/* if(!oldDoc.getPermissions().validate(getCurrentSubject(), Permission.WRITE)) {                 throw new PermissionDeniedException("Resource with same name exists in target collection and write is denied");             }             */
comment|// remove the existing document
name|removeResource
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|renameOnly
init|=
name|sourceCollection
operator|.
name|getId
argument_list|()
operator|==
name|targetCollection
operator|.
name|getId
argument_list|()
decl_stmt|;
name|trigger
operator|.
name|beforeMoveDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceDocument
argument_list|,
name|destinationDocumentUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceDocument
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|sourceDocument
argument_list|)
expr_stmt|;
block|}
block|}
name|sourceCollection
operator|.
name|unlinkDocument
argument_list|(
name|this
argument_list|,
name|sourceDocument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|sourceCollection
argument_list|)
expr_stmt|;
block|}
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|sourceDocument
argument_list|)
expr_stmt|;
name|sourceDocument
operator|.
name|setFileURI
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|sourceDocument
operator|.
name|setCollection
argument_list|(
name|targetCollection
argument_list|)
expr_stmt|;
name|targetCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|sourceDocument
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceDocument
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
comment|// reindexing
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|sourceDocument
argument_list|,
name|IndexMode
operator|.
name|REPAIR
argument_list|)
expr_stmt|;
block|}
block|}
comment|// NOTE: nothing needs to be done for binary resources as the reference to the Blob does not change
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|sourceDocument
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|targetCollection
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterMoveDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceDocument
argument_list|,
name|sourceDocumentUri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|removeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|,
specifier|final
name|boolean
name|freeDocId
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing document {} ({}) ..."
argument_list|,
name|document
operator|.
name|getFileURI
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|freeDocId
condition|)
block|{
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - removing dom"
argument_list|)
expr_stmt|;
block|}
name|dropDomNodes
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeDocId
condition|)
block|{
name|collectionsDb
operator|.
name|freeResourceId
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|document
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|TriggerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|dropIndex
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
specifier|final
name|StreamListener
name|listener
init|=
name|getIndexController
argument_list|()
operator|.
name|getStreamListener
argument_list|(
name|document
argument_list|,
name|ReindexMode
operator|.
name|REMOVE_ALL_NODES
argument_list|)
decl_stmt|;
name|listener
operator|.
name|startIndexDocument
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
specifier|final
name|NodeList
name|nodes
init|=
name|document
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
argument_list|<
name|?
argument_list|>
name|node
init|=
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|INodeIterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
init|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath2
argument_list|()
argument_list|,
name|IndexMode
operator|.
name|REMOVE
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to close node iterator"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|listener
operator|.
name|endIndexDocument
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|notifyDropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|dropDomNodes
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|document
operator|.
name|getMetadata
argument_list|()
operator|.
name|isReferenced
argument_list|()
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                     @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
name|final
name|NodeHandle
name|node
operator|=
operator|(
name|NodeHandle
operator|)
name|document
operator|.
name|getFirstChild
argument_list|()
block|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
block|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|} catch
operator|(
name|final
name|NullPointerException
name|npe0
operator|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught NPE in DOMTransaction to actually be able to remove the document."
argument_list|)
block|;         }
name|final
name|NodeRef
name|ref
operator|=
operator|new
name|NodeRef
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
literal|null
return|;
end_return

begin_expr_stmt
unit|}         }
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing binary resource {}..."
argument_list|,
name|blob
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blob
operator|.
name|getBlobId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to delete binary document: {}, but blobId was null"
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|BlobStore
name|blobStore
init|=
name|pool
operator|.
name|getBlobStore
argument_list|()
decl_stmt|;
name|blobStore
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|blob
operator|.
name|getBlobId
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove the file from the database metadata and indexes
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|setDocument
argument_list|(
name|blob
argument_list|,
name|ReindexMode
operator|.
name|REMOVE_BINARY
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|removeResourceMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
comment|// remove document metadata
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing resource metadata for {}"
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|document
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|removeResource
parameter_list|(
specifier|final
name|Txn
name|tx
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|PermissionDeniedException
block|{
if|if
condition|(
name|doc
operator|instanceof
name|BinaryDocument
condition|)
block|{
name|removeBinaryResource
argument_list|(
name|tx
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeXMLResource
argument_list|(
name|tx
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * get next Free Doc Id      *      * @throws EXistException If there's no free document id      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|int
name|getNextResourceId
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|)
throws|throws
name|EXistException
throws|,
name|LockException
block|{
name|int
name|nextDocId
init|=
name|collectionsDb
operator|.
name|getFreeResourceId
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextDocId
operator|!=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
condition|)
block|{
return|return
name|nextDocId
return|;
block|}
name|nextDocId
operator|=
literal|1
expr_stmt|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|NEXT_DOC_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
if|if
condition|(
name|nextDocId
operator|==
literal|0x7FFFFFFF
condition|)
block|{
name|pool
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Max. number of document ids reached. Database is set to "
operator|+
literal|"read-only state. Please do a complete backup/restore to compact the db and "
operator|+
literal|"free document ids."
argument_list|)
throw|;
block|}
block|}
specifier|final
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//} catch (ReadOnlyException e) {
comment|//LOG.warn("Database is read-only");
comment|//return DocumentImpl.UNKNOWN_DOCUMENT_ID;
comment|//TODO : rethrow ? -pb
block|}
return|return
name|nextDocId
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|reindexXMLResource
parameter_list|(
specifier|final
name|Txn
name|txn
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|reindexXMLResource
argument_list|(
name|txn
argument_list|,
name|doc
argument_list|,
name|IndexMode
operator|.
name|REPAIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Reindex the nodes in the document. This method will either reindex all      * descendant nodes of the passed node, or all nodes below some level of      * the document if node is null.      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|reindexXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|IndexMode
name|mode
parameter_list|)
block|{
specifier|final
name|StreamListener
name|listener
init|=
name|getIndexController
argument_list|()
operator|.
name|getStreamListener
argument_list|(
name|doc
argument_list|,
name|ReindexMode
operator|.
name|STORE
argument_list|)
decl_stmt|;
name|getIndexController
argument_list|()
operator|.
name|startIndexDocument
argument_list|(
name|transaction
argument_list|,
name|listener
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
argument_list|<
name|?
argument_list|>
name|node
init|=
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|INodeIterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
init|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath2
argument_list|()
argument_list|,
name|mode
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to close node iterator"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|getIndexController
argument_list|()
operator|.
name|endIndexDocument
argument_list|(
name|transaction
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|defragXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
comment|//TODO : use dedicated function in XmldbURI
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"============> Defragmenting document {}"
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|firstChild
init|=
name|doc
operator|.
name|getFirstChildAddress
argument_list|()
decl_stmt|;
comment|// dropping old structure index
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// dropping dom index
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
decl||
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// create a copy of the old doc to copy the nodes into it
end_comment

begin_decl_stmt
specifier|final
name|DocumentImpl
name|tempDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|tempDoc
operator|.
name|copyOf
argument_list|(
name|this
argument_list|,
name|doc
argument_list|,
name|doc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|final
name|StreamListener
name|listener
init|=
name|getIndexController
argument_list|()
operator|.
name|getStreamListener
argument_list|(
name|doc
argument_list|,
name|ReindexMode
operator|.
name|STORE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// copy the nodes
end_comment

begin_decl_stmt
specifier|final
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
argument_list|<
name|?
argument_list|>
name|node
init|=
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|INodeIterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
init|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath2
argument_list|()
argument_list|,
name|tempDoc
argument_list|,
literal|true
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
name|flush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// remove the old nodes
end_comment

begin_expr_stmt
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|firstChild
argument_list|)
block|;
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"start() - error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
end_expr_stmt

begin_expr_stmt
unit|}             }
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|doc
operator|.
name|copyChildren
argument_list|(
name|tempDoc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setSplitCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setPageCount
argument_list|(
name|tempDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getPageCount
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|closeDocument
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if_stmt
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Defragmentation took {} ms."
argument_list|,
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
end_if_stmt

begin_expr_stmt
unit|} catch
operator|(
name|final
name|PermissionDeniedException
operator||
name|IOException
name|e
operator|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
block|;         }
end_expr_stmt

begin_comment
unit|}
comment|/**      * consistency Check of the database; useful after XUpdates;      * called if xupdate.consistency-checks is true in configuration      */
end_comment

begin_function
unit|@
name|Override
specifier|public
name|void
name|checkXMLResourceConsistency
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
block|{
name|boolean
name|xupdateConsistencyChecks
init|=
literal|false
decl_stmt|;
specifier|final
name|Object
name|property
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getProperty
argument_list|(
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
name|xupdateConsistencyChecks
operator|=
operator|(
name|Boolean
operator|)
name|property
expr_stmt|;
block|}
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking document {}"
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|checkXMLResourceTree
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * consistency Check of the database; useful after XUpdates;      * called by {@link #checkXMLResourceConsistency(DocumentImpl)}      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|checkXMLResourceTree
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking DOM tree for document {}"
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|xupdateConsistencyChecks
init|=
literal|false
decl_stmt|;
specifier|final
name|Object
name|property
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getProperty
argument_list|(
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
name|xupdateConsistencyChecks
operator|=
operator|(
name|Boolean
operator|)
name|property
expr_stmt|;
block|}
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
throws|throws
name|ReadOnlyException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pages used: {}"
argument_list|,
name|domDb
operator|.
name|debugPages
argument_list|(
name|doc
argument_list|,
literal|false
argument_list|)
argument_list|)
block|;
return|return
literal|null
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|final
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
name|node
init|=
operator|(
name|IStoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|INodeIterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
init|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//Pass buf to the following method to get a dump of all node ids in the document
if|if
condition|(
operator|!
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|node
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"node tree: {}"
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in document tree structure"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_decl_stmt
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|findKeys
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
end_expr_stmt

begin_expr_stmt
unit|}             }
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}     }
comment|/**      * Store a node into the database. This method is called by the parser to      * write a node to the storage backend.      *      * @param node        the node to be stored      * @param currentPath path expression which points to this node's      *                    element-parent or to itself if it is an element.      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|storeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
specifier|final
name|IndexSpec
name|indexSpec
parameter_list|)
block|{
name|checkAvailableMemory
argument_list|()
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
throws|throws
name|ReadOnlyException
block|{
name|final
name|long
name|address
block|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|TEXT_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|CDATA_SECTION_NODE
operator|||
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
operator|>
name|defaultIndexDepth
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|add
argument_list|(
name|transaction
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|address
operator|=
name|domDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"address is missing"
argument_list|)
expr_stmt|;
block|}
comment|//TODO : how can we continue here ? -pb
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
end_function

begin_expr_stmt
unit|}.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|nodesCount
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|indexSpec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nodeProcessor
operator|.
name|doIndex
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
specifier|public
argument_list|<
name|T
extends|extends
name|IStoredNode
argument_list|>
name|void
name|updateNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|boolean
name|reindex
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|internalAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|internalAddress
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
name|internalAddress
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} catch
operator|(
name|final
name|Exception
name|e
operator|)
block|{
name|final
name|Value
name|oldVal
operator|=
name|domDb
operator|.
name|get
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
block|;
comment|//TODO what can we do about abstracting this out?
name|final
name|IStoredNode
name|old
operator|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|oldVal
operator|.
name|data
argument_list|()
argument_list|,
name|oldVal
operator|.
name|start
argument_list|()
argument_list|,
name|oldVal
operator|.
name|getLength
argument_list|()
argument_list|,
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
literal|false
argument_list|)
block|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while storing {}; gid = {}; old = {}"
argument_list|,
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|old
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|e
argument_list|)
block|;         }
end_expr_stmt

begin_comment
unit|}
comment|/**      * Physically insert a node into the DOM storage.      */
end_comment

begin_function
unit|@
name|Override
specifier|public
name|void
name|insertNodeAfter
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|NodeHandle
name|previous
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
name|previous
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
name|long
name|address
operator|=
name|previous
operator|.
name|getInternalAddress
argument_list|()
block|;
if|if
condition|(
name|address
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
end_function

begin_expr_stmt
unit|}.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}      private
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|copyNodes
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|INodeIterator
name|iterator
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|newDoc
parameter_list|,
specifier|final
name|boolean
name|defragment
parameter_list|,
specifier|final
name|StreamListener
name|listener
parameter_list|)
block|{
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|defragment
argument_list|,
name|listener
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|copyNodes
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|INodeIterator
name|iterator
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
annotation|@
name|EnsureLocked
argument_list|(
name|mode
operator|=
name|LockMode
operator|.
name|WRITE_LOCK
argument_list|)
specifier|final
name|DocumentImpl
name|newDoc
parameter_list|,
specifier|final
name|boolean
name|defragment
parameter_list|,
specifier|final
name|StreamListener
name|listener
parameter_list|,
name|NodeId
name|oldNodeId
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|)
expr_stmt|;
name|storeNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|defragment
operator|&&
name|oldNodeId
operator|!=
literal|null
condition|)
block|{
name|pool
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyMove
argument_list|(
name|oldNodeId
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
comment|//save old value, whatever it is
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|oldAddress
argument_list|)
expr_stmt|;
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//restore old value, whatever it was
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|node
operator|.
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
operator|==
literal|1
condition|)
block|{
name|newDoc
operator|.
name|appendChild
argument_list|(
operator|(
name|NodeHandle
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unhandled node type: {}"
argument_list|,
name|node
operator|.
name|getNodeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
operator|||
name|node
operator|.
name|hasAttributes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|NodeId
name|nodeId
init|=
name|node
operator|.
name|getNodeId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|oldNodeId
operator|=
name|child
operator|.
name|getNodeId
argument_list|()
expr_stmt|;
if|if
condition|(
name|defragment
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|nodeId
operator|=
name|nodeId
operator|.
name|newChild
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nodeId
operator|=
name|nodeId
operator|.
name|nextSibling
argument_list|()
expr_stmt|;
block|}
name|child
operator|.
name|setNodeId
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|defragment
argument_list|,
name|listener
argument_list|,
name|oldNodeId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Removes the Node Reference from the database.      * The index will be updated later, i.e. after all nodes have been physically      * removed. See {@link #endRemove(org.exist.storage.txn.Txn)}.      * removeNode() just adds the node ids to the list in elementIndex      * for later removal.      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|removeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
specifier|final
name|String
name|content
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
name|final
name|long
name|address
operator|=
name|node
operator|.
name|getInternalAddress
argument_list|()
block|;
if|if
condition|(
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|address
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
end_function

begin_expr_stmt
unit|}.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|notifyRemoveNode
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|final
name|QName
name|qname
decl_stmt|;
end_decl_stmt

begin_switch
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|node
operator|.
name|setQName
argument_list|(
name|qname
argument_list|)
expr_stmt|;
specifier|final
name|GeneralRangeIndexSpec
name|spec1
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec1
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|spec1
operator|.
name|getType
argument_list|()
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|QNameRangeIndexSpec
name|qnSpecElement
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|qname
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnSpecElement
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|qnSpecElement
operator|.
name|getType
argument_list|()
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|QNAME
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|node
operator|.
name|setQName
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
comment|//Strange : does it mean that the node is added 2 times under 2 different identities ?
specifier|final
name|AttrImpl
name|attr
decl_stmt|;
name|attr
operator|=
operator|(
name|AttrImpl
operator|)
name|node
expr_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|AttrImpl
operator|.
name|ID
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|Type
operator|.
name|ID
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREF
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREFS
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// do nothing special
block|}
specifier|final
name|RangeIndexSpec
name|spec2
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec2
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
literal|null
argument_list|,
name|spec2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|QNameRangeIndexSpec
name|qnSpecAttribute
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|qname
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnSpecAttribute
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
literal|null
argument_list|,
name|qnSpecAttribute
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
break|break;
block|}
end_switch

begin_function
unit|}      @
name|Override
specifier|public
name|void
name|removeAllNodes
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
specifier|final
name|StreamListener
name|listener
parameter_list|)
block|{
try|try
init|(
specifier|final
name|INodeIterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
init|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
specifier|final
name|Deque
argument_list|<
name|RemovedNode
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|collectNodesForRemoval
argument_list|(
name|transaction
argument_list|,
name|stack
argument_list|,
name|iterator
argument_list|,
name|listener
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RemovedNode
name|next
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|removeNode
argument_list|(
name|transaction
argument_list|,
name|next
operator|.
name|node
argument_list|,
name|next
operator|.
name|path
argument_list|,
name|next
operator|.
name|content
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to close node iterator"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|collectNodesForRemoval
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Deque
argument_list|<
name|RemovedNode
argument_list|>
name|stack
parameter_list|,
specifier|final
name|INodeIterator
name|iterator
parameter_list|,
specifier|final
name|StreamListener
name|listener
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|)
block|{
name|RemovedNode
name|removed
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|String
name|content
init|=
literal|null
decl_stmt|;
specifier|final
name|GeneralRangeIndexSpec
name|spec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
operator|||
name|node
operator|.
name|hasAttributes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|childCount
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|child
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectNodesForRemoval
argument_list|(
name|transaction
argument_list|,
name|stack
argument_list|,
name|iterator
argument_list|,
name|listener
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|!=
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Index a single node, which has been added through an XUpdate      * operation. This method is only called if inserting the node is possible      * without changing the node identifiers of sibling or parent nodes. In other      * cases, reindex will be called.      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|indexNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|)
block|{
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|IndexMode
operator|.
name|STORE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|indexNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
specifier|final
name|IndexMode
name|repairMode
parameter_list|)
block|{
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|setIndexMode
argument_list|(
name|repairMode
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|index
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|boolean
name|checkNodeTree
parameter_list|(
specifier|final
name|INodeIterator
name|iterator
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|docIsValid
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
operator|||
name|node
operator|.
name|hasAttributes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|IStoredNode
name|previous
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|isSiblingOf
argument_list|(
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|&&
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"node {} cannot be a sibling of {}; node read from {}"
argument_list|,
name|child
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|StorageAddress
operator|.
name|toString
argument_list|(
name|child
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
name|previous
operator|=
name|child
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child {} not found for node: {}: {}; children = {}"
argument_list|,
name|i
argument_list|,
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
comment|//TODO : emergency exit ?
block|}
specifier|final
name|NodeId
name|parentId
init|=
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|getParentId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentId
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"{} is not a child of {}"
argument_list|,
name|child
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
specifier|final
name|boolean
name|check
init|=
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIsValid
condition|)
block|{
name|docIsValid
operator|=
name|check
expr_stmt|;
block|}
block|}
block|}
return|return
name|docIsValid
return|;
block|}
end_function

begin_comment
comment|/**      * Called by reindex to walk through all nodes in the tree and reindex them      * if necessary.      *      * @param iterator      * @param node      * @param currentPath      */
end_comment

begin_function
specifier|private
name|void
name|scanNodes
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|INodeIterator
name|iterator
parameter_list|,
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|NodePath2
name|currentPath
parameter_list|,
specifier|final
name|IndexMode
name|mode
parameter_list|,
specifier|final
name|StreamListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|addNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
case|case
name|Node
operator|.
name|CDATA_SECTION_NODE
case|:
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|AbstractCharacterData
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unhandled node type: {}"
argument_list|,
name|node
operator|.
name|getNodeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
operator|||
name|node
operator|.
name|hasAttributes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IStoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child {} not found for node: {}; children = {}"
argument_list|,
name|i
argument_list|,
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|mode
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
name|mode
operator|==
name|IndexMode
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastNode
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
return|return
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|node
argument_list|,
name|addWhitespace
argument_list|)
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
specifier|public
name|IStoredNode
name|objectWith
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|NodeId
name|nodeId
parameter_list|)
block|{
return|return
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
name|final
name|Value
name|val
operator|=
name|domDb
operator|.
name|get
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|,
name|nodeId
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node {} not found. This is usually not an error."
argument_list|,
name|nodeId
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|final
name|IStoredNode
name|node
operator|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
return|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_expr_stmt
unit|}.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
specifier|public
name|IStoredNode
name|objectWith
parameter_list|(
specifier|final
name|NodeProxy
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|(
name|IStoredNode
argument_list|<
name|?
argument_list|>
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeReadLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
comment|// DocumentImpl sets the nodeId to DOCUMENT_NODE when it's trying to find its top-level
comment|// children (for which it doesn't persist the actual node ids), so ignore that.  Nobody else
comment|// should be passing DOCUMENT_NODE into here.
name|final
name|boolean
name|fakeNodeId
operator|=
name|p
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|NodeId
operator|.
name|DOCUMENT_NODE
argument_list|)
block|;
name|final
name|Value
name|val
operator|=
name|domDb
operator|.
name|get
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|,
literal|false
argument_list|)
block|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node {} not found in document {}; docId = {}: {}"
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|p
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getURI
argument_list|()
argument_list|,
name|p
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
argument_list|,
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakeNodeId
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
specifier|final
name|IStoredNode
argument_list|<
name|?
extends|extends
name|IStoredNode
argument_list|>
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
name|p
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|p
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakeNodeId
condition|)
block|{
return|return
name|node
return|;
block|}
if|if
condition|(
name|p
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|==
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|&&
name|p
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node {} not found in document {}; docId = {}: {}; found node {} instead"
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|p
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getURI
argument_list|()
argument_list|,
name|p
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
argument_list|,
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// retry based on node id
specifier|final
name|IStoredNode
name|node
init|=
name|objectWith
argument_list|(
name|p
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|p
operator|.
name|setInternalAddress
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// update proxy with correct address
return|return
name|node
return|;
block|}
end_function

begin_expr_stmt
unit|}.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
specifier|public
name|void
name|repair
parameter_list|()
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing index files ..."
argument_list|)
expr_stmt|;
try|try
block|{
name|notifyCloseAndRemove
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|removeIndexes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to remove index files during repair: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Recreating index files ..."
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|VALUES_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception during repair: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|reopenIndexes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DatabaseConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to reopen index files after repair: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|loadIndexModules
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reindexing database files ..."
argument_list|)
expr_stmt|;
comment|//Reindex from root collection
name|reindexCollection
argument_list|(
literal|null
argument_list|,
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
argument_list|,
name|IndexMode
operator|.
name|REPAIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|repairPrimary
parameter_list|()
block|{
name|rebuildIndex
argument_list|(
name|DOM_DBX_ID
argument_list|)
expr_stmt|;
name|rebuildIndex
argument_list|(
name|COLLECTIONS_DBX_ID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|protected
name|void
name|rebuildIndex
parameter_list|(
specifier|final
name|byte
name|indexId
parameter_list|)
block|{
specifier|final
name|BTree
name|btree
init|=
name|getStorage
argument_list|(
name|indexId
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|btreeLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|btree
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rebuilding index {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|btree
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|btree
operator|.
name|rebuild
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Index {} was rebuilt."
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|btree
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
decl||
name|IOException
decl||
name|TerminatedException
decl||
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught error while rebuilding core index {}: {}"
argument_list|,
name|FileUtils
operator|.
name|fileName
argument_list|(
name|btree
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|notifyFlush
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|getIndexController
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|long
name|nextReportTS
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
specifier|final
name|Sync
name|syncEvent
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                 @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error while flushing dom.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if_stmt
if|if
condition|(
name|syncEvent
operator|==
name|Sync
operator|.
name|MAJOR
condition|)
block|{
try|try
init|(
specifier|final
name|ManagedLock
argument_list|<
name|ReentrantLock
argument_list|>
name|collectionsDbLock
init|=
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|collectionsDb
operator|.
name|getLockName
argument_list|()
argument_list|)
init|)
block|{
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|FileUtils
operator|.
name|fileName
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|notifySync
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
name|nextReportTS
condition|)
block|{
specifier|final
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
name|LOG_STATS
operator|.
name|info
argument_list|(
literal|"Memory: {}K total; {}K max; {}K free"
argument_list|,
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|1024
argument_list|)
argument_list|,
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|maxMemory
argument_list|()
operator|/
literal|1024
argument_list|)
argument_list|,
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|notifyPrintStatistics
argument_list|()
expr_stmt|;
name|nextReportTS
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
literal|10
operator|*
literal|60
operator|*
literal|1000
operator|)
expr_stmt|;
comment|// occurs after 10 minutes from now
block|}
block|}
end_if_stmt

begin_expr_stmt
unit|} catch
operator|(
name|final
name|DBException
name|dbe
operator|)
block|{
name|dbe
operator|.
name|printStackTrace
argument_list|()
block|;
name|LOG
operator|.
name|error
argument_list|(
name|dbe
argument_list|)
block|;         }
end_expr_stmt

begin_function
unit|}      @
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|notifyClose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * check available memory      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|nodesCountThreshold
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
if|if
condition|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|>=
name|run
operator|.
name|maxMemory
argument_list|()
operator|&&
name|run
operator|.
name|freeMemory
argument_list|()
operator|<
name|pool
operator|.
name|getReservedMem
argument_list|()
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|nodesCount
operator|>
name|nodesCountThreshold
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//TODO UNDERSTAND : why not use shutdown ? -pb
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{             @
name|Override
specifier|public
name|Object
name|start
argument_list|()
block|{
name|domDb
operator|.
name|closeDocument
argument_list|()
block|;
return|return
literal|null
return|;
block|}
block|}
end_function

begin_expr_stmt
operator|.
name|run
argument_list|()
expr_stmt|;
end_expr_stmt

begin_class
unit|}      public
specifier|final
specifier|static
class|class
name|NodeRef
extends|extends
name|Value
block|{
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_DOCUMENT_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|OFFSET_NODE_ID
init|=
name|OFFSET_DOCUMENT_ID
operator|+
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
decl_stmt|;
specifier|public
name|NodeRef
parameter_list|(
specifier|final
name|int
name|docId
parameter_list|)
block|{
name|len
operator|=
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
expr_stmt|;
name|pos
operator|=
name|OFFSET_DOCUMENT_ID
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
specifier|final
name|int
name|docId
parameter_list|,
specifier|final
name|NodeId
name|nodeId
parameter_list|)
block|{
name|len
operator|=
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
operator|+
name|nodeId
operator|.
name|size
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
expr_stmt|;
name|nodeId
operator|.
name|serialize
argument_list|(
name|data
argument_list|,
name|OFFSET_NODE_ID
argument_list|)
expr_stmt|;
name|pos
operator|=
name|OFFSET_DOCUMENT_ID
expr_stmt|;
block|}
name|int
name|getDocId
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
return|;
block|}
block|}
end_class

begin_class
specifier|private
specifier|final
specifier|static
class|class
name|RemovedNode
block|{
specifier|final
name|IStoredNode
name|node
decl_stmt|;
specifier|final
name|String
name|content
decl_stmt|;
specifier|final
name|NodePath
name|path
decl_stmt|;
name|RemovedNode
parameter_list|(
specifier|final
name|IStoredNode
name|node
parameter_list|,
specifier|final
name|NodePath
name|path
parameter_list|,
specifier|final
name|String
name|content
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**      * Delegate for Node Processing : indexing      */
end_comment

begin_class
specifier|private
class|class
name|NodeProcessor
block|{
specifier|private
name|Txn
name|transaction
decl_stmt|;
specifier|private
name|IStoredNode
argument_list|<
name|?
extends|extends
name|IStoredNode
argument_list|>
name|node
decl_stmt|;
specifier|private
name|NodePath
name|currentPath
decl_stmt|;
comment|/**          * work variables          */
specifier|private
name|DocumentImpl
name|doc
decl_stmt|;
specifier|private
name|long
name|address
decl_stmt|;
specifier|private
name|IndexSpec
name|idxSpec
decl_stmt|;
specifier|private
name|int
name|level
decl_stmt|;
specifier|private
name|IndexMode
name|indexMode
init|=
name|IndexMode
operator|.
name|STORE
decl_stmt|;
name|NodeProcessor
parameter_list|()
block|{
comment|//ignore
block|}
specifier|public
parameter_list|<
name|T
extends|extends
name|IStoredNode
parameter_list|>
name|void
name|reset
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|IStoredNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|,
specifier|final
name|NodePath
name|currentPath
parameter_list|,
name|IndexSpec
name|indexSpec
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"illegal node: {}"
argument_list|,
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//TODO : why continue processing ? return ? -pb
name|this
operator|.
name|transaction
operator|=
name|transaction
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|currentPath
operator|=
name|currentPath
expr_stmt|;
name|this
operator|.
name|indexMode
operator|=
name|IndexMode
operator|.
name|STORE
expr_stmt|;
name|doc
operator|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
expr_stmt|;
name|address
operator|=
name|node
operator|.
name|getInternalAddress
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexSpec
operator|==
literal|null
condition|)
block|{
name|indexSpec
operator|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexConfiguration
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
name|idxSpec
operator|=
name|indexSpec
expr_stmt|;
name|level
operator|=
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setIndexMode
parameter_list|(
specifier|final
name|IndexMode
name|indexMode
parameter_list|)
block|{
name|this
operator|.
name|indexMode
operator|=
name|indexMode
expr_stmt|;
block|}
comment|/**          * Updates the various indices          */
specifier|public
name|void
name|doIndex
parameter_list|()
block|{
comment|//TODO : resolve URI !
comment|//final boolean isTemp = XmldbURI.TEMP_COLLECTION_URI.equalsInternal(((DocumentImpl) node.getOwnerDocument()).getCollection().getURI());
name|int
name|indexType
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|//Compute index type
comment|//TODO : let indexers OR it themselves
comment|//we'd need to notify the ElementIndexer at the very end then...
name|indexType
operator|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
operator|&&
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|QNAME_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|indexType
operator||=
name|qnIdx
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
specifier|final
name|QName
name|qname
init|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
block|}
comment|//Compute index type
comment|//TODO : let indexers OR it themselves
comment|//we'd need to notify the ElementIndexer at the very end then...
name|indexType
operator|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RangeIndexSpec
name|rangeSpec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangeSpec
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|rangeSpec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rangeSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|//Oh dear : is it the right semantics then ?
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|rangeSpec
argument_list|,
name|indexMode
operator|==
name|IndexMode
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
block|}
specifier|final
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|QNAME_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|indexType
operator||=
name|qnIdx
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|//Oh dear : is it the right semantics then ?
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|qnIdx
argument_list|,
name|indexMode
operator|==
name|IndexMode
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
block|}
block|}
name|node
operator|.
name|setQName
argument_list|(
operator|new
name|QName
argument_list|(
name|qname
argument_list|,
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|AttrImpl
name|attr
init|=
operator|(
name|AttrImpl
operator|)
name|node
decl_stmt|;
name|attr
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|AttrImpl
operator|.
name|ID
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|Type
operator|.
name|ID
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
name|indexMode
operator|==
name|IndexMode
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREF
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
name|indexMode
operator|==
name|IndexMode
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREFS
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IndexType
operator|.
name|GENERIC
argument_list|,
name|indexMode
operator|==
name|IndexMode
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// do nothing special
block|}
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|notifyStoreText
argument_list|(
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/**          * Stores this node into the database, if it's an element          */
specifier|public
name|void
name|store
parameter_list|()
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
comment|// we store all nodes at level 1 (see - https://github.com/eXist-db/exist/issues/1691), and only element nodes after!
if|if
condition|(
name|indexMode
operator|==
name|IndexMode
operator|.
name|STORE
operator|&&
operator|(
name|level
operator|==
literal|1
operator|||
operator|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|defaultIndexDepth
operator|)
operator|)
condition|)
block|{
comment|//TODO : used to be this, but NativeBroker.this avoids an owner change
operator|new
name|DOMTransaction
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|domDb
argument_list|,
parameter_list|()
lambda|->
name|lockManager
operator|.
name|acquireBtreeWriteLock
argument_list|(
name|domDb
operator|.
name|getLockName
argument_list|()
argument_list|)
argument_list|)
block|{                     @
name|Override
specifier|public
name|Object
name|start
argument_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
end_class

begin_comment
unit|}
comment|/**          * check available memory          */
end_comment

begin_function
unit|private
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|indexMode
operator|!=
name|IndexMode
operator|.
name|REMOVE
operator|&&
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
if|if
condition|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|>=
name|run
operator|.
name|maxMemory
argument_list|()
operator|&&
name|run
operator|.
name|freeMemory
argument_list|()
operator|<
name|pool
operator|.
name|getReservedMem
argument_list|()
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**          * Updates the various indices and stores this node into the database          */
end_comment

begin_function
specifier|public
name|void
name|index
parameter_list|()
block|{
operator|++
name|nodesCount
expr_stmt|;
name|checkAvailableMemory
argument_list|()
expr_stmt|;
name|doIndex
argument_list|()
expr_stmt|;
name|store
argument_list|()
expr_stmt|;
block|}
end_function

begin_class
unit|}      private
specifier|final
class|class
name|DocumentCallback
implements|implements
name|BTreeCallback
block|{
specifier|private
specifier|final
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
decl_stmt|;
specifier|private
name|DocumentCallback
parameter_list|(
specifier|final
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
parameter_list|)
block|{
name|this
operator|.
name|collectionInternalAccess
operator|=
name|collectionInternalAccess
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|indexInfo
parameter_list|(
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
try|try
block|{
specifier|final
name|byte
name|type
init|=
name|key
operator|.
name|data
argument_list|()
index|[
name|key
operator|.
name|start
argument_list|()
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
operator|+
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_TYPE
index|]
decl_stmt|;
specifier|final
name|VariableByteInput
name|is
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|doc
operator|=
name|BinaryDocument
operator|.
name|read
argument_list|(
name|pool
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|=
name|DocumentImpl
operator|.
name|read
argument_list|(
name|pool
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
name|collectionInternalAccess
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

unit|}
end_unit

