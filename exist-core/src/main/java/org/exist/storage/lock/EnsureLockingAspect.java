begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database  * Copyright (C) 2001-2017 The eXist Project  * http://exist-db.org  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|JoinPoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|annotation
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|lang
operator|.
name|reflect
operator|.
name|MethodSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|persistent
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Stacktrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_comment
comment|/**  * An Aspect which when compiled in to the codebase, enforces the locking constraints set by the {@link EnsureLocked}  * and {@link EnsureContainerLocked} annotations.  *  * Typically this is envisaged only being used for development or debugging purposes, and is unlikely to be compiled  * into a production application as the reflection overhead would likely be too much of a performance drain.  *  * When compiled into eXist-db, the aspect may be disabled by setting the system  * property `exist.ensurelocking.disabled=true`.  *  * Throws a LockException(s) if the appropriate locks are not held and  * the System property `exist.ensurelocking.enforce=true` is set.  *  * The System property `exist.ensurelocking.output` decides whether logger output goes to StdErr or the log file. Values  * are `console` for StdOut/StdErr or `log` for the log file. The System property  * `exist.ensurelocking.output.stack.depth` determines the length of the stack trace to output, by default this is 0.  *  * The System property `exist.ensurelocking.trace=true` can be enabled to show detail about the checks being performed.  *  * {@link EnsureLocked} on a parameter, ensures that a lock of the correct type is already held for that parameter.  *  * {@link EnsureLocked} on a method, ensures that the object returned by the method has gained a lock of the correct  * type for the calling thread.  *  * {@link EnsureUnlocked} on a parameter, ensures that no locks are already held for that parameter.  *  * {@link EnsureUnlocked} on a method, ensures that the object returned by the method has no lock.  *  * {@link EnsureContainerLocked} on a method, ensures that the encapsulating object on which the method operates holds  * a lock of the correct type before the method is called.  *  * {@link EnsureContainerUnlocked} on a method, ensures that the encapsulating object on which the method operates holds  * no locks before the method is called.  *  * @author<a href="mailto:adam@evolvedbinary.com>Adam Retter</a>  */
end_comment

begin_class
annotation|@
name|Aspect
specifier|public
class|class
name|EnsureLockingAspect
block|{
specifier|public
specifier|static
specifier|final
name|String
name|PROP_DISABLED
init|=
literal|"exist.ensurelocking.disabled"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROP_ENFORCE
init|=
literal|"exist.ensurelocking.enforce"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROP_OUTPUT
init|=
literal|"exist.ensurelocking.output"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROP_OUTPUT_STACK_DEPTH
init|=
literal|"exist.ensurelocking.output.stack.depth"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROP_TRACE
init|=
literal|"exist.ensurelocking.trace"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|DISABLED
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|PROP_DISABLED
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|ENFORCE
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|PROP_ENFORCE
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|OUTPUT_TO_CONSOLE
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|PROP_OUTPUT
argument_list|,
literal|"console"
argument_list|)
operator|.
name|equals
argument_list|(
literal|"console"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|OUTPUT_STACK_DEPTH
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|PROP_OUTPUT_STACK_DEPTH
argument_list|,
literal|"0"
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|TRACE
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|PROP_TRACE
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogManager
operator|.
name|getLogger
argument_list|(
name|EnsureLockingAspect
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Pointcut
argument_list|(
literal|"execution(* *(..,@org.exist.storage.lock.EnsureLocked (*),..))"
argument_list|)
specifier|public
name|void
name|methodWithEnsureLockedParameters
parameter_list|()
block|{
block|}
annotation|@
name|Pointcut
argument_list|(
literal|"execution(@org.exist.storage.lock.EnsureLocked (*) *(..))"
argument_list|)
specifier|public
name|void
name|methodWithEnsureLockedReturnType
parameter_list|()
block|{
block|}
annotation|@
name|Pointcut
argument_list|(
literal|"execution(@org.exist.storage.lock.EnsureContainerLocked (*) *(..))"
argument_list|)
specifier|public
name|void
name|methodWithEnsureContainerLocked
parameter_list|()
block|{
block|}
annotation|@
name|Pointcut
argument_list|(
literal|"execution(* *(..,@org.exist.storage.lock.EnsureUnlocked (*),..))"
argument_list|)
specifier|public
name|void
name|methodWithEnsureUnlockedParameters
parameter_list|()
block|{
block|}
annotation|@
name|Pointcut
argument_list|(
literal|"execution(@org.exist.storage.lock.EnsureUnlocked (*) *(..))"
argument_list|)
specifier|public
name|void
name|methodWithEnsureUnlockedReturnType
parameter_list|()
block|{
block|}
annotation|@
name|Pointcut
argument_list|(
literal|"execution(@org.exist.storage.lock.EnsureContainerUnlocked (*) *(..))"
argument_list|)
specifier|public
name|void
name|methodWithEnsureContainerUnlocked
parameter_list|()
block|{
block|}
comment|/**      * Ensures that the parameters to a method      * annotated by {@link EnsureLocked} hold      * the indicated locks.      *      * @throws LockException if the appropriate locks are not held and      *  the System property `exist.ensurelocking.enforce=true` is set.      */
annotation|@
name|Before
argument_list|(
literal|"methodWithEnsureLockedParameters()"
argument_list|)
specifier|public
name|void
name|enforceEnsureLockedParameters
parameter_list|(
specifier|final
name|JoinPoint
name|joinPoint
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|ms
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|Object
index|[]
name|args
init|=
name|joinPoint
operator|.
name|getArgs
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AnnotatedParameterConstraint
argument_list|<
name|EnsureLocked
argument_list|>
argument_list|>
name|ensureLockedParameters
init|=
name|getAllParameterAnnotations
argument_list|(
name|method
argument_list|,
name|EnsureLocked
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|AnnotatedParameterConstraint
argument_list|<
name|EnsureLocked
argument_list|>
name|ensureLockedConstraint
range|:
name|ensureLockedParameters
control|)
block|{
comment|// check the lock constraint holds
specifier|final
name|LockManager
name|lockManager
init|=
name|getLockManager
argument_list|()
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|lockManager
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|idx
init|=
name|ensureLockedConstraint
operator|.
name|getParameterIndex
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|arg
init|=
name|args
index|[
name|idx
index|]
decl_stmt|;
comment|// if the argument is null, and annotated @Nullable, we can skip the check
if|if
condition|(
name|arg
operator|==
literal|null
operator|&&
operator|!
name|getAllParameterAnnotations
argument_list|(
name|method
argument_list|,
name|Nullable
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Skipping method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|" for null argument(idx="
operator|+
name|idx
operator|+
literal|") with @EnsureLocked @Nullable"
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|EnsureLockDetail
name|ensureLockDetail
init|=
name|resolveLockDetail
argument_list|(
name|ensureLockedConstraint
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Checking: method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|"( "
operator|+
name|toAnnotationString
argument_list|(
name|EnsureLocked
operator|.
name|class
argument_list|,
name|ensureLockDetail
argument_list|)
operator|+
literal|" "
operator|+
name|ensureLockedConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|") ..."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ensureLockDetail
operator|.
name|type
condition|)
block|{
case|case
name|COLLECTION
case|:
specifier|final
name|XmldbURI
name|collectionUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|arg
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|collectionUri
operator|=
operator|(
name|XmldbURI
operator|)
name|arg
expr_stmt|;
block|}
else|else
block|{
name|collectionUri
operator|=
operator|(
operator|(
name|Collection
operator|)
name|arg
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasCollectionLock
argument_list|(
name|lockManager
argument_list|,
name|collectionUri
argument_list|,
name|ensureLockDetail
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require lock mode "
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|" on Collection: "
operator|+
name|collectionUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|DOCUMENT
case|:
specifier|final
name|XmldbURI
name|documentUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|arg
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|documentUri
operator|=
operator|(
name|XmldbURI
operator|)
name|arg
expr_stmt|;
block|}
else|else
block|{
name|documentUri
operator|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|arg
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasDocumentLock
argument_list|(
name|lockManager
argument_list|,
name|documentUri
argument_list|,
name|ensureLockDetail
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require lock mode "
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|" on Document: "
operator|+
name|documentUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only Collection or Document locks are supported"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"PASSED."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Ensures that the object returned by a method      * has an lock taken upon it before it is returned.      *      * @throws LockException if the appropriate locks are not held and      *  the System property `exist.ensurelocking.enforce=true` is set.      */
annotation|@
name|AfterReturning
argument_list|(
name|value
operator|=
literal|"methodWithEnsureLockedReturnType()"
argument_list|,
name|returning
operator|=
literal|"result"
argument_list|)
specifier|public
name|void
name|enforceEnsureLockedReturnType
parameter_list|(
specifier|final
name|JoinPoint
name|joinPoint
parameter_list|,
specifier|final
name|Object
name|result
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|ms
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureLocked
argument_list|>
name|ensureLockedConstraint
init|=
name|getMethodAnnotation
argument_list|(
name|method
argument_list|,
name|EnsureLocked
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|EnsureLockDetail
name|ensureLockDetail
init|=
name|resolveLockDetail
argument_list|(
name|ensureLockedConstraint
argument_list|,
name|joinPoint
operator|.
name|getArgs
argument_list|()
argument_list|)
decl_stmt|;
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Checking: "
operator|+
name|toAnnotationString
argument_list|(
name|EnsureLocked
operator|.
name|class
argument_list|,
name|ensureLockDetail
argument_list|)
operator|+
literal|" method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
comment|// check the lock constraint holds
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
specifier|final
name|LockManager
name|lockManager
init|=
name|getLockManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|lockManager
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|ensureLockDetail
operator|.
name|type
condition|)
block|{
case|case
name|COLLECTION
case|:
specifier|final
name|XmldbURI
name|collectionUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|collectionUri
operator|=
operator|(
name|XmldbURI
operator|)
name|result
expr_stmt|;
block|}
else|else
block|{
name|collectionUri
operator|=
operator|(
operator|(
name|Collection
operator|)
name|result
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasCollectionLock
argument_list|(
name|lockManager
argument_list|,
name|collectionUri
argument_list|,
name|ensureLockDetail
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require lock mode "
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|" on Collection: "
operator|+
name|collectionUri
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|DOCUMENT
case|:
specifier|final
name|XmldbURI
name|documentUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|documentUri
operator|=
operator|(
name|XmldbURI
operator|)
name|result
expr_stmt|;
block|}
else|else
block|{
name|documentUri
operator|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|result
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasDocumentLock
argument_list|(
name|lockManager
argument_list|,
name|documentUri
argument_list|,
name|ensureLockDetail
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require lock mode "
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|" on Document: "
operator|+
name|documentUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only Collection or Document locks are supported"
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Unable to check return type as value is null!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"PASSED."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Ensures that the appropriate lock is held on the container      * object which houses the method before the method is called.      *      * @throws LockException if the appropriate locks are not held and      *  the System property `exist.ensurelocking.enforce=true` is set.      */
annotation|@
name|Before
argument_list|(
literal|"methodWithEnsureContainerLocked()&& target(container)"
argument_list|)
specifier|public
name|void
name|enforceEnsureLockedContainer
parameter_list|(
specifier|final
name|JoinPoint
name|joinPoint
parameter_list|,
specifier|final
name|Object
name|container
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|ms
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureContainerLocked
argument_list|>
name|ensureContainerLockedConstraint
init|=
name|getMethodAnnotation
argument_list|(
name|method
argument_list|,
name|EnsureContainerLocked
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|EnsureLockDetail
name|ensureLockDetail
init|=
name|resolveContainerLockDetail
argument_list|(
name|ensureContainerLockedConstraint
argument_list|,
name|joinPoint
operator|.
name|getArgs
argument_list|()
argument_list|)
decl_stmt|;
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Checking: "
operator|+
name|toAnnotationString
argument_list|(
name|EnsureContainerLocked
operator|.
name|class
argument_list|,
name|ensureLockDetail
argument_list|)
operator|+
literal|" method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
comment|// check the lock constraint holds
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
specifier|final
name|LockManager
name|lockManager
init|=
name|getLockManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|lockManager
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|ensureLockDetail
operator|.
name|type
condition|)
block|{
case|case
name|COLLECTION
case|:
specifier|final
name|XmldbURI
name|collectionUri
decl_stmt|;
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|container
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|collectionUri
operator|=
operator|(
operator|(
name|Collection
operator|)
name|container
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Container type was identified as Collection, but the container is not an implementation of Collection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|collectionUri
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"collectionUri is null, unable to validate contract"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|hasCollectionLock
argument_list|(
name|lockManager
argument_list|,
name|collectionUri
argument_list|,
name|ensureLockDetail
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require lock mode "
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|" on Collection: "
operator|+
name|collectionUri
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|DOCUMENT
case|:
specifier|final
name|XmldbURI
name|documentUri
decl_stmt|;
if|if
condition|(
name|DocumentImpl
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|container
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|documentUri
operator|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|container
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Container type was identified as Document, but the container is not an implementation of DocumentImpl"
argument_list|)
throw|;
block|}
if|if
condition|(
name|documentUri
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"documentUri is null, unable to validate contract"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|hasDocumentLock
argument_list|(
name|lockManager
argument_list|,
name|documentUri
argument_list|,
name|ensureLockDetail
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require lock mode "
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|" on Document: "
operator|+
name|documentUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only Collection or Document container locks are supported"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"PASSED."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Ensures that the parameters to a method      * annotated by {@link EnsureUnlocked} do not hold      * any locks.      *      * @throws LockException if any locks are held and      *  the System property `exist.ensurelocking.enforce=true` is set.      */
annotation|@
name|Before
argument_list|(
literal|"methodWithEnsureUnlockedParameters()"
argument_list|)
specifier|public
name|void
name|enforceEnsureUnlockedParameters
parameter_list|(
specifier|final
name|JoinPoint
name|joinPoint
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|ms
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|Object
index|[]
name|args
init|=
name|joinPoint
operator|.
name|getArgs
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AnnotatedParameterConstraint
argument_list|<
name|EnsureUnlocked
argument_list|>
argument_list|>
name|ensureUnlockedParameters
init|=
name|getAllParameterAnnotations
argument_list|(
name|method
argument_list|,
name|EnsureUnlocked
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|AnnotatedParameterConstraint
argument_list|<
name|EnsureUnlocked
argument_list|>
name|ensureUnlockedConstraint
range|:
name|ensureUnlockedParameters
control|)
block|{
specifier|final
name|Lock
operator|.
name|LockType
name|lockType
init|=
name|resolveLockDetail
argument_list|(
name|ensureUnlockedConstraint
argument_list|)
decl_stmt|;
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Checking: method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|"( "
operator|+
name|toAnnotationString
argument_list|(
name|EnsureUnlocked
operator|.
name|class
argument_list|,
name|lockType
argument_list|)
operator|+
literal|" "
operator|+
name|ensureUnlockedConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|") ..."
argument_list|)
expr_stmt|;
comment|// check the lock constraint holds
specifier|final
name|LockManager
name|lockManager
init|=
name|getLockManager
argument_list|()
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|lockManager
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|idx
init|=
name|ensureUnlockedConstraint
operator|.
name|getParameterIndex
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|arg
init|=
name|args
index|[
name|idx
index|]
decl_stmt|;
comment|// if the argument is null, and annotated @Nullable, we can skip the check
if|if
condition|(
name|arg
operator|==
literal|null
operator|&&
operator|!
name|getAllParameterAnnotations
argument_list|(
name|method
argument_list|,
name|Nullable
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Skipping method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|" for null argument(idx="
operator|+
name|idx
operator|+
literal|") with @EnsureUnlocked @Nullable"
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|COLLECTION
case|:
specifier|final
name|XmldbURI
name|collectionUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|arg
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|collectionUri
operator|=
operator|(
name|XmldbURI
operator|)
name|arg
expr_stmt|;
block|}
else|else
block|{
name|collectionUri
operator|=
operator|(
operator|(
name|Collection
operator|)
name|arg
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasNoCollectionLocks
argument_list|(
name|lockManager
argument_list|,
name|collectionUri
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require no locks on Collection: "
operator|+
name|collectionUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|DOCUMENT
case|:
specifier|final
name|XmldbURI
name|documentUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|arg
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|documentUri
operator|=
operator|(
name|XmldbURI
operator|)
name|arg
expr_stmt|;
block|}
else|else
block|{
name|documentUri
operator|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|arg
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasNoDocumentLocks
argument_list|(
name|lockManager
argument_list|,
name|documentUri
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require no locks on Document: "
operator|+
name|documentUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only Collection or Document locks are supported"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"PASSED."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Ensures that the object returned by a method      * has no lock held upon it before it is returned.      *      * @throws LockException if any locks are held and      *  the System property `exist.ensurelocking.enforce=true` is set.      */
annotation|@
name|AfterReturning
argument_list|(
name|value
operator|=
literal|"methodWithEnsureUnlockedReturnType()"
argument_list|,
name|returning
operator|=
literal|"result"
argument_list|)
specifier|public
name|void
name|enforceEnsureUnlockedReturnType
parameter_list|(
specifier|final
name|JoinPoint
name|joinPoint
parameter_list|,
specifier|final
name|Object
name|result
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|ms
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureUnlocked
argument_list|>
name|ensureUnlockedConstraint
init|=
name|getMethodAnnotation
argument_list|(
name|method
argument_list|,
name|EnsureUnlocked
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Lock
operator|.
name|LockType
name|lockType
init|=
name|resolveLockDetail
argument_list|(
name|ensureUnlockedConstraint
argument_list|)
decl_stmt|;
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Checking: "
operator|+
name|toAnnotationString
argument_list|(
name|EnsureUnlocked
operator|.
name|class
argument_list|,
name|lockType
argument_list|)
operator|+
literal|" method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
comment|// check the lock constraint holds
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
specifier|final
name|LockManager
name|lockManager
init|=
name|getLockManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|lockManager
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|COLLECTION
case|:
specifier|final
name|XmldbURI
name|collectionUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|collectionUri
operator|=
operator|(
name|XmldbURI
operator|)
name|result
expr_stmt|;
block|}
else|else
block|{
name|collectionUri
operator|=
operator|(
operator|(
name|Collection
operator|)
name|result
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasNoCollectionLocks
argument_list|(
name|lockManager
argument_list|,
name|collectionUri
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require no locks on Collection: "
operator|+
name|collectionUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|DOCUMENT
case|:
specifier|final
name|XmldbURI
name|documentUri
decl_stmt|;
if|if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|documentUri
operator|=
operator|(
name|XmldbURI
operator|)
name|result
expr_stmt|;
block|}
else|else
block|{
name|documentUri
operator|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|result
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasNoDocumentLocks
argument_list|(
name|lockManager
argument_list|,
name|documentUri
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require no locks on Document: "
operator|+
name|documentUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only Collection or Document locks are supported"
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Unable to check return type as value is null!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"PASSED."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Ensures that the no locks are held on the container      * object which houses the method before the method is called.      *      * @throws LockException if any locks are held and      *  the System property `exist.ensurelocking.enforce=true` is set.      */
annotation|@
name|Before
argument_list|(
literal|"methodWithEnsureContainerUnlocked()&& target(container)"
argument_list|)
specifier|public
name|void
name|enforceEnsureUnlockedContainer
parameter_list|(
specifier|final
name|JoinPoint
name|joinPoint
parameter_list|,
specifier|final
name|Object
name|container
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
specifier|final
name|MethodSignature
name|ms
init|=
operator|(
name|MethodSignature
operator|)
name|joinPoint
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|ms
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureContainerUnlocked
argument_list|>
name|ensureContainerUnlockedConstraint
init|=
name|getMethodAnnotation
argument_list|(
name|method
argument_list|,
name|EnsureContainerUnlocked
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Lock
operator|.
name|LockType
name|lockType
init|=
name|resolveContainerLockDetail
argument_list|(
name|ensureContainerUnlockedConstraint
argument_list|)
decl_stmt|;
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Checking: "
operator|+
name|toAnnotationString
argument_list|(
name|EnsureContainerUnlocked
operator|.
name|class
argument_list|,
name|lockType
argument_list|)
operator|+
literal|" method="
operator|+
name|ms
operator|.
name|getDeclaringType
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"#"
operator|+
name|ms
operator|.
name|getName
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
comment|// check the lock constraint holds
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
specifier|final
name|LockManager
name|lockManager
init|=
name|getLockManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|lockManager
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|lockType
condition|)
block|{
case|case
name|COLLECTION
case|:
specifier|final
name|XmldbURI
name|collectionUri
decl_stmt|;
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|container
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|collectionUri
operator|=
operator|(
operator|(
name|Collection
operator|)
name|container
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Container type was identified as Collection, but the container is not an implementation of Collection"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|hasNoCollectionLocks
argument_list|(
name|lockManager
argument_list|,
name|collectionUri
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require no locks on Collection: "
operator|+
name|collectionUri
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|DOCUMENT
case|:
specifier|final
name|XmldbURI
name|documentUri
decl_stmt|;
if|if
condition|(
name|DocumentImpl
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|container
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|documentUri
operator|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|container
operator|)
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Container type was identified as Document, but the container is not an implementation of DocumentImpl"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|hasNoDocumentLocks
argument_list|(
name|lockManager
argument_list|,
name|documentUri
argument_list|)
condition|)
block|{
name|report
argument_list|(
literal|"FAILED: Constraint to require no locks on Document: "
operator|+
name|documentUri
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only Collection or Document container locks are supported"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"PASSED."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
annotation|@
name|Nullable
name|LockManager
name|getLockManager
parameter_list|()
block|{
if|if
condition|(
name|BrokerPool
operator|.
name|isConfigured
argument_list|()
condition|)
block|{
try|try
block|{
return|return
name|BrokerPool
operator|.
name|getInstance
argument_list|()
operator|.
name|getLockManager
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Waiting for BrokerPool to become available..."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|boolean
name|hasDocumentLock
parameter_list|(
specifier|final
name|LockManager
name|lockManager
parameter_list|,
specifier|final
name|XmldbURI
name|documentUri
parameter_list|,
specifier|final
name|EnsureLockDetail
name|ensureLockDetail
parameter_list|)
block|{
switch|switch
condition|(
name|ensureLockDetail
operator|.
name|mode
condition|)
block|{
case|case
name|READ_LOCK
case|:
return|return
name|lockManager
operator|.
name|isDocumentLockedForRead
argument_list|(
name|documentUri
argument_list|)
operator|||
name|lockManager
operator|.
name|isDocumentLockedForWrite
argument_list|(
name|documentUri
argument_list|)
return|;
case|case
name|WRITE_LOCK
case|:
return|return
name|lockManager
operator|.
name|isDocumentLockedForWrite
argument_list|(
name|documentUri
argument_list|)
return|;
case|case
name|NO_LOCK
case|:
if|if
condition|(
name|ensureLockDetail
operator|.
name|modeWasFromParam
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Nothing to trace for NO_LOCK"
argument_list|)
expr_stmt|;
comment|// TODO(AR) consider implementation strategies? although it is likely we will obsolete NO_LOCK
return|return
literal|true
return|;
block|}
comment|//intentional fallthrough
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only READ or WRITE lock modes are supported"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks if a Collection is locked explicitly, or implicitly through a parent lock for the correct mode on the sub-tree.      *      * @true if a collection is locked either explicitly or implicitly      */
specifier|private
name|boolean
name|hasCollectionLock
parameter_list|(
specifier|final
name|LockManager
name|lockManager
parameter_list|,
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|,
specifier|final
name|EnsureLockDetail
name|ensureLockDetail
parameter_list|)
block|{
name|XmldbURI
name|uri
init|=
name|collectionUri
decl_stmt|;
while|while
condition|(
name|uri
operator|.
name|numSegments
argument_list|()
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|ensureLockDetail
operator|.
name|mode
condition|)
block|{
case|case
name|READ_LOCK
case|:
if|if
condition|(
name|lockManager
operator|.
name|isCollectionLockedForRead
argument_list|(
name|uri
argument_list|)
operator|||
name|lockManager
operator|.
name|isCollectionLockedForWrite
argument_list|(
name|uri
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|WRITE_LOCK
case|:
if|if
condition|(
name|lockManager
operator|.
name|isCollectionLockedForWrite
argument_list|(
name|uri
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|NO_LOCK
case|:
if|if
condition|(
name|ensureLockDetail
operator|.
name|modeWasFromParam
condition|)
block|{
name|traceln
argument_list|(
parameter_list|()
lambda|->
literal|"Nothing to trace for NO_LOCK"
argument_list|)
expr_stmt|;
comment|// TODO(AR) consider implementation strategies? although it is likely we will obsolete NO_LOCK
return|return
literal|true
return|;
block|}
comment|//intentional fallthrough
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Currently only READ or WRITE lock modes are supported"
argument_list|)
throw|;
block|}
if|if
condition|(
name|uri
operator|.
name|numSegments
argument_list|()
operator|==
literal|2
operator|&&
name|uri
operator|.
name|getCollectionPath
argument_list|()
operator|.
name|equals
argument_list|(
literal|"/db"
argument_list|)
condition|)
block|{
comment|// we are at the root!
break|break;
block|}
comment|// loop round to parent collection
name|uri
operator|=
name|uri
operator|.
name|removeLastSegment
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|hasNoDocumentLocks
parameter_list|(
specifier|final
name|LockManager
name|lockManager
parameter_list|,
specifier|final
name|XmldbURI
name|documentUri
parameter_list|)
block|{
return|return
operator|!
operator|(
name|lockManager
operator|.
name|isDocumentLockedForRead
argument_list|(
name|documentUri
argument_list|)
operator|&&
name|lockManager
operator|.
name|isDocumentLockedForWrite
argument_list|(
name|documentUri
argument_list|)
operator|)
return|;
block|}
specifier|private
name|boolean
name|hasNoCollectionLocks
parameter_list|(
specifier|final
name|LockManager
name|lockManager
parameter_list|,
specifier|final
name|XmldbURI
name|collectionUri
parameter_list|)
block|{
return|return
operator|!
operator|(
name|lockManager
operator|.
name|isCollectionLockedForRead
argument_list|(
name|collectionUri
argument_list|)
operator|&&
name|lockManager
operator|.
name|isCollectionLockedForWrite
argument_list|(
name|collectionUri
argument_list|)
operator|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|>
name|String
name|toAnnotationString
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|,
specifier|final
name|EnsureLockDetail
name|ensureLockDetail
parameter_list|)
block|{
return|return
literal|"@"
operator|+
name|annotationClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(mode="
operator|+
name|ensureLockDetail
operator|.
name|mode
operator|+
literal|", type="
operator|+
name|ensureLockDetail
operator|.
name|type
operator|+
literal|")"
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|>
name|String
name|toAnnotationString
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|,
specifier|final
name|Lock
operator|.
name|LockType
name|lockType
parameter_list|)
block|{
return|return
literal|"@"
operator|+
name|annotationClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(type="
operator|+
name|lockType
operator|+
literal|")"
return|;
block|}
specifier|private
name|EnsureLockDetail
name|resolveContainerLockDetail
parameter_list|(
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureContainerLocked
argument_list|>
name|lockConstraint
parameter_list|,
specifier|final
name|Object
name|args
index|[]
parameter_list|)
block|{
specifier|final
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|mode
init|=
name|getLockMode
argument_list|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|COLLECTION
expr_stmt|;
block|}
if|else if
condition|(
name|Document
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|DOCUMENT
expr_stmt|;
block|}
else|else
block|{
comment|// error
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureContainerLocked is specified on a method whose container object is neither a Collection nor a Document"
argument_list|)
throw|;
block|}
return|return
operator|new
name|EnsureLockDetail
argument_list|(
name|mode
operator|.
name|_1
argument_list|,
name|mode
operator|.
name|_2
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|private
name|EnsureLockDetail
name|resolveLockDetail
parameter_list|(
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureLocked
argument_list|>
name|lockConstraint
parameter_list|,
specifier|final
name|Object
name|args
index|[]
parameter_list|)
block|{
specifier|final
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|mode
init|=
name|getLockMode
argument_list|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
if|if
condition|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|Lock
operator|.
name|LockType
operator|.
name|UNKNOWN
condition|)
block|{
name|type
operator|=
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|COLLECTION
expr_stmt|;
block|}
if|else if
condition|(
name|Document
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|DOCUMENT
expr_stmt|;
block|}
else|else
block|{
comment|// error
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureLocked is specified on a method that returns neither a Collection nor a Document"
argument_list|)
throw|;
block|}
return|return
operator|new
name|EnsureLockDetail
argument_list|(
name|mode
operator|.
name|_1
argument_list|,
name|mode
operator|.
name|_2
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|private
name|EnsureLockDetail
name|resolveLockDetail
parameter_list|(
specifier|final
name|AnnotatedParameterConstraint
argument_list|<
name|EnsureLocked
argument_list|>
name|lockConstraint
parameter_list|,
specifier|final
name|Object
name|args
index|[]
parameter_list|)
block|{
specifier|final
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|mode
init|=
name|getLockMode
argument_list|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
if|if
condition|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|Lock
operator|.
name|LockType
operator|.
name|UNKNOWN
condition|)
block|{
name|type
operator|=
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|COLLECTION
expr_stmt|;
block|}
if|else if
condition|(
name|Document
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|DOCUMENT
expr_stmt|;
block|}
if|else if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureLocked is specified on an XmldbURI method parameter, but is missing the `lockType` value"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// error
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureLocked is specified on a method parameter that is neither a Collection, Document, nor an XmldbURI"
argument_list|)
throw|;
block|}
return|return
operator|new
name|EnsureLockDetail
argument_list|(
name|mode
operator|.
name|_1
argument_list|,
name|mode
operator|.
name|_2
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|private
name|Lock
operator|.
name|LockType
name|resolveContainerLockDetail
parameter_list|(
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureContainerUnlocked
argument_list|>
name|lockConstraint
parameter_list|)
block|{
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|COLLECTION
expr_stmt|;
block|}
if|else if
condition|(
name|Document
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|DOCUMENT
expr_stmt|;
block|}
else|else
block|{
comment|// error
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureContainerUnlocked is specified on a method whose container object is neither a Collection nor a Document"
argument_list|)
throw|;
block|}
return|return
name|type
return|;
block|}
specifier|private
name|Lock
operator|.
name|LockType
name|resolveLockDetail
parameter_list|(
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|EnsureUnlocked
argument_list|>
name|lockConstraint
parameter_list|)
block|{
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
if|if
condition|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|Lock
operator|.
name|LockType
operator|.
name|UNKNOWN
condition|)
block|{
name|type
operator|=
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|COLLECTION
expr_stmt|;
block|}
if|else if
condition|(
name|Document
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getMethod
argument_list|()
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|DOCUMENT
expr_stmt|;
block|}
else|else
block|{
comment|// error
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureUnlocked is specified on a method that returns neither a Collection nor a Document"
argument_list|)
throw|;
block|}
return|return
name|type
return|;
block|}
specifier|private
name|Lock
operator|.
name|LockType
name|resolveLockDetail
parameter_list|(
specifier|final
name|AnnotatedParameterConstraint
argument_list|<
name|EnsureUnlocked
argument_list|>
name|lockConstraint
parameter_list|)
block|{
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
if|if
condition|(
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|Lock
operator|.
name|LockType
operator|.
name|UNKNOWN
condition|)
block|{
name|type
operator|=
name|lockConstraint
operator|.
name|getAnnotation
argument_list|()
operator|.
name|type
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|COLLECTION
expr_stmt|;
block|}
if|else if
condition|(
name|Document
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|Lock
operator|.
name|LockType
operator|.
name|DOCUMENT
expr_stmt|;
block|}
if|else if
condition|(
name|XmldbURI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|lockConstraint
operator|.
name|getParameter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureUnlocked is specified on an XmldbURI method parameter, but is missing the `lockType` value"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// error
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"@EnsureUnlocked is specified on a method parameter that is neither a Collection, Document, nor an XmldbURI"
argument_list|)
throw|;
block|}
return|return
name|type
return|;
block|}
specifier|private
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|getLockMode
parameter_list|(
specifier|final
name|EnsureLocked
name|ensureLocked
parameter_list|,
specifier|final
name|Object
name|args
index|[]
parameter_list|)
block|{
return|return
name|getLockMode
argument_list|(
name|ensureLocked
operator|.
name|mode
argument_list|()
argument_list|,
name|ensureLocked
operator|.
name|modeParam
argument_list|()
argument_list|,
name|args
argument_list|)
return|;
block|}
specifier|private
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|getLockMode
parameter_list|(
specifier|final
name|EnsureContainerLocked
name|ensureContainerLocked
parameter_list|,
specifier|final
name|Object
name|args
index|[]
parameter_list|)
block|{
return|return
name|getLockMode
argument_list|(
name|ensureContainerLocked
operator|.
name|mode
argument_list|()
argument_list|,
name|ensureContainerLocked
operator|.
name|modeParam
argument_list|()
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**      * @return A tuple, whose first value is the lock mode,      * and whose second value is true if the mode was resolved from args.      */
specifier|private
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|getLockMode
parameter_list|(
specifier|final
name|Lock
operator|.
name|LockMode
name|specifiedLockMode
parameter_list|,
specifier|final
name|short
name|specifiedLockModeParam
parameter_list|,
specifier|final
name|Object
name|args
index|[]
parameter_list|)
block|{
specifier|final
name|Tuple2
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|,
name|Boolean
argument_list|>
name|mode
decl_stmt|;
if|if
condition|(
name|specifiedLockMode
operator|!=
name|Lock
operator|.
name|LockMode
operator|.
name|NO_LOCK
condition|)
block|{
name|mode
operator|=
operator|new
name|Tuple2
argument_list|<>
argument_list|(
name|specifiedLockMode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|specifiedLockModeParam
operator|!=
name|EnsureLocked
operator|.
name|NO_MODE_PARAM
condition|)
block|{
specifier|final
name|short
name|idx
init|=
name|specifiedLockModeParam
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|args
operator|.
name|length
condition|)
block|{
specifier|final
name|Object
name|arg
init|=
name|args
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|instanceof
name|Lock
operator|.
name|LockMode
condition|)
block|{
name|mode
operator|=
operator|new
name|Tuple2
argument_list|<>
argument_list|(
operator|(
name|Lock
operator|.
name|LockMode
operator|)
name|arg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"modeParam was specified on @EnsureLocked but its index was not a Lock.LockMode parameter, found:  "
operator|+
name|arg
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"modeParam was specified on @EnsureLocked but its index was out-of-bounds"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|>
name|lockModeArgs
init|=
name|getLockModeArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|lockModeArgs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|mode
operator|=
operator|new
name|Tuple2
argument_list|<>
argument_list|(
name|lockModeArgs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|lockModeArgs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No mode or modeParam was specified on @EnsureLocked and no LockMode parameter was found"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No mode or modeParam was specified on @EnsureLocked and more than one LockMode parameter was found"
argument_list|)
throw|;
block|}
block|}
return|return
name|mode
return|;
block|}
specifier|private
name|List
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|>
name|getLockModeArgs
parameter_list|(
specifier|final
name|Object
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Lock
operator|.
name|LockMode
argument_list|>
name|lockModeArgs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|arg
range|:
name|args
control|)
block|{
if|if
condition|(
name|arg
operator|instanceof
name|Lock
operator|.
name|LockMode
condition|)
block|{
name|lockModeArgs
operator|.
name|add
argument_list|(
operator|(
name|Lock
operator|.
name|LockMode
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lockModeArgs
return|;
block|}
specifier|private
annotation|@
name|Nullable
argument_list|<
name|T
extends|extends
name|Annotation
argument_list|>
name|AnnotatedMethodConstraint
argument_list|<
name|T
argument_list|>
name|getMethodAnnotation
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|)
block|{
specifier|final
name|T
name|methodAnnotation
init|=
name|method
operator|.
name|getDeclaredAnnotation
argument_list|(
name|annotationClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|methodAnnotation
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|AnnotatedMethodConstraint
argument_list|<>
argument_list|(
name|methodAnnotation
argument_list|,
name|method
argument_list|)
return|;
block|}
specifier|final
name|Class
name|declaringClazz
init|=
name|method
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
name|superClazz
init|=
name|declaringClazz
operator|.
name|getSuperclass
argument_list|()
decl_stmt|;
if|if
condition|(
name|superClazz
operator|!=
literal|null
operator|&&
operator|!
name|superClazz
operator|.
name|equals
argument_list|(
name|Object
operator|.
name|class
argument_list|)
condition|)
block|{
specifier|final
name|Method
name|superMethod
init|=
name|findMethodOnOtherClass
argument_list|(
name|method
argument_list|,
name|superClazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|superMethod
operator|!=
literal|null
condition|)
block|{
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|T
argument_list|>
name|superMethodAnnotation
init|=
name|getMethodAnnotation
argument_list|(
name|superMethod
argument_list|,
name|annotationClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|superMethodAnnotation
operator|!=
literal|null
condition|)
block|{
return|return
name|superMethodAnnotation
return|;
block|}
block|}
block|}
for|for
control|(
specifier|final
name|Class
name|interfaceClazz
range|:
name|declaringClazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
specifier|final
name|Method
name|interfaceMethod
init|=
name|findMethodOnOtherClass
argument_list|(
name|method
argument_list|,
name|interfaceClazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|interfaceMethod
operator|!=
literal|null
condition|)
block|{
specifier|final
name|AnnotatedMethodConstraint
argument_list|<
name|T
argument_list|>
name|interfaceMethodAnnotation
init|=
name|getMethodAnnotation
argument_list|(
name|interfaceMethod
argument_list|,
name|annotationClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|interfaceMethodAnnotation
operator|!=
literal|null
condition|)
block|{
return|return
name|interfaceMethodAnnotation
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|>
name|List
argument_list|<
name|AnnotatedParameterConstraint
argument_list|<
name|T
argument_list|>
argument_list|>
name|getAllParameterAnnotations
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|AnnotatedParameterConstraint
argument_list|<
name|T
argument_list|>
argument_list|>
name|annotatedParameters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|getAllParameterAnnotations
argument_list|(
name|method
argument_list|,
name|annotationClass
argument_list|,
name|annotatedParameters
argument_list|)
expr_stmt|;
return|return
name|annotatedParameters
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|>
name|void
name|getAllParameterAnnotations
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|,
specifier|final
name|List
argument_list|<
name|AnnotatedParameterConstraint
argument_list|<
name|T
argument_list|>
argument_list|>
name|results
parameter_list|)
block|{
specifier|final
name|Parameter
index|[]
name|parameters
init|=
name|method
operator|.
name|getParameters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parameters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Parameter
name|parameter
init|=
name|parameters
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|T
name|parameterAnnotation
init|=
name|parameter
operator|.
name|getDeclaredAnnotation
argument_list|(
name|annotationClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|parameterAnnotation
operator|!=
literal|null
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
operator|new
name|AnnotatedParameterConstraint
argument_list|<>
argument_list|(
name|parameterAnnotation
argument_list|,
name|parameter
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Class
name|declaringClazz
init|=
name|method
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
name|superClazz
init|=
name|declaringClazz
operator|.
name|getSuperclass
argument_list|()
decl_stmt|;
if|if
condition|(
name|superClazz
operator|!=
literal|null
operator|&&
operator|!
name|superClazz
operator|.
name|equals
argument_list|(
name|Object
operator|.
name|class
argument_list|)
condition|)
block|{
specifier|final
name|Method
name|superMethod
init|=
name|findMethodOnOtherClass
argument_list|(
name|method
argument_list|,
name|superClazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|superMethod
operator|!=
literal|null
condition|)
block|{
name|getAllParameterAnnotations
argument_list|(
name|superMethod
argument_list|,
name|annotationClass
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
name|interfaceClazz
range|:
name|declaringClazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
specifier|final
name|Method
name|interfaceMethod
init|=
name|findMethodOnOtherClass
argument_list|(
name|method
argument_list|,
name|interfaceClazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|interfaceMethod
operator|!=
literal|null
condition|)
block|{
name|getAllParameterAnnotations
argument_list|(
name|interfaceMethod
argument_list|,
name|annotationClass
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
annotation|@
name|Nullable
name|Method
name|findMethodOnOtherClass
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Class
name|otherClazz
parameter_list|)
block|{
try|try
block|{
return|return
name|otherClazz
operator|.
name|getDeclaredMethod
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|method
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NoSuchMethodException
name|e
parameter_list|)
block|{
comment|// nothing to do
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|report
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
throws|throws
name|LockException
block|{
specifier|final
name|String
name|reportMessage
decl_stmt|;
if|if
condition|(
name|OUTPUT_STACK_DEPTH
operator|>
literal|0
condition|)
block|{
name|reportMessage
operator|=
name|message
operator|+
literal|": "
operator|+
name|Stacktrace
operator|.
name|asString
argument_list|(
name|Stacktrace
operator|.
name|substack
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|,
literal|2
argument_list|,
name|OUTPUT_STACK_DEPTH
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reportMessage
operator|=
name|message
expr_stmt|;
block|}
if|if
condition|(
name|OUTPUT_TO_CONSOLE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|reportMessage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|reportMessage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ENFORCE
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|void
name|traceln
parameter_list|(
specifier|final
name|Supplier
argument_list|<
name|String
argument_list|>
name|messageFn
parameter_list|)
block|{
if|if
condition|(
name|TRACE
condition|)
block|{
if|if
condition|(
name|OUTPUT_TO_CONSOLE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|messageFn
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|messageFn
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|AnnotatedParameterConstraint
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|>
extends|extends
name|AnnotatedConstraint
argument_list|<
name|T
argument_list|,
name|Parameter
argument_list|>
block|{
specifier|private
specifier|final
name|int
name|parameterIndex
decl_stmt|;
specifier|public
name|AnnotatedParameterConstraint
parameter_list|(
specifier|final
name|T
name|annotation
parameter_list|,
specifier|final
name|Parameter
name|parameter
parameter_list|,
specifier|final
name|int
name|parameterIndex
parameter_list|)
block|{
name|super
argument_list|(
name|annotation
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
name|this
operator|.
name|parameterIndex
operator|=
name|parameterIndex
expr_stmt|;
block|}
specifier|public
name|Parameter
name|getParameter
parameter_list|()
block|{
return|return
name|annotationTarget
return|;
block|}
specifier|public
name|int
name|getParameterIndex
parameter_list|()
block|{
return|return
name|parameterIndex
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|AnnotatedMethodConstraint
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|>
extends|extends
name|AnnotatedConstraint
argument_list|<
name|T
argument_list|,
name|Method
argument_list|>
block|{
specifier|public
name|AnnotatedMethodConstraint
parameter_list|(
specifier|final
name|T
name|annotation
parameter_list|,
specifier|final
name|Method
name|method
parameter_list|)
block|{
name|super
argument_list|(
name|annotation
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Method
name|getMethod
parameter_list|()
block|{
return|return
name|annotationTarget
return|;
block|}
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|AnnotatedConstraint
parameter_list|<
name|T
extends|extends
name|Annotation
parameter_list|,
name|U
parameter_list|>
block|{
specifier|private
specifier|final
name|T
name|annotation
decl_stmt|;
specifier|protected
specifier|final
name|U
name|annotationTarget
decl_stmt|;
specifier|public
name|AnnotatedConstraint
parameter_list|(
specifier|final
name|T
name|annotation
parameter_list|,
specifier|final
name|U
name|annotationTarget
parameter_list|)
block|{
name|this
operator|.
name|annotation
operator|=
name|annotation
expr_stmt|;
name|this
operator|.
name|annotationTarget
operator|=
name|annotationTarget
expr_stmt|;
block|}
specifier|public
name|T
name|getAnnotation
parameter_list|()
block|{
return|return
name|annotation
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|EnsureLockDetail
block|{
specifier|private
specifier|final
name|Lock
operator|.
name|LockMode
name|mode
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|modeWasFromParam
decl_stmt|;
specifier|private
specifier|final
name|Lock
operator|.
name|LockType
name|type
decl_stmt|;
specifier|public
name|EnsureLockDetail
parameter_list|(
specifier|final
name|Lock
operator|.
name|LockMode
name|mode
parameter_list|,
specifier|final
name|boolean
name|modeWasFromParam
parameter_list|,
specifier|final
name|Lock
operator|.
name|LockType
name|type
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|this
operator|.
name|modeWasFromParam
operator|=
name|modeWasFromParam
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

