begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2012 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  *  *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|fn
package|;
end_package

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|util
operator|.
name|NumberFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_class
specifier|public
class|class
name|FnFormatDates
extends|extends
name|BasicFunction
block|{
specifier|private
specifier|final
specifier|static
name|String
name|DEFAULT_LANGUAGE
init|=
name|Locale
operator|.
name|getDefault
argument_list|()
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|DATETIME
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"value"
argument_list|,
name|Type
operator|.
name|DATE_TIME
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The datetime"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|DATE
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"value"
argument_list|,
name|Type
operator|.
name|DATE
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The date"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|TIME
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"value"
argument_list|,
name|Type
operator|.
name|TIME
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The time"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|PICTURE
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"picture"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|EXACTLY_ONE
argument_list|,
literal|"The picture string"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|LANGUAGE
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"language"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The language string"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|CALENDAR
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"calendar"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The calendar string"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionParameterSequenceType
name|PLACE
init|=
operator|new
name|FunctionParameterSequenceType
argument_list|(
literal|"place"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The place string"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|FunctionReturnSequenceType
name|RETURN
init|=
operator|new
name|FunctionReturnSequenceType
argument_list|(
name|Type
operator|.
name|STRING
argument_list|,
name|Cardinality
operator|.
name|ZERO_OR_ONE
argument_list|,
literal|"The formatted date"
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|FNS_FORMAT_DATETIME_2
init|=
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"format-dateTime"
argument_list|,
name|Function
operator|.
name|BUILTIN_FUNCTION_NS
argument_list|)
argument_list|,
literal|"Returns a string containing an xs:date value formatted for display."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
name|DATETIME
block|,
name|PICTURE
block|}
argument_list|,
name|RETURN
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|FNS_FORMAT_DATETIME_5
init|=
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"format-dateTime"
argument_list|,
name|Function
operator|.
name|BUILTIN_FUNCTION_NS
argument_list|)
argument_list|,
literal|"Returns a string containing an xs:date value formatted for display."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
name|DATETIME
block|,
name|PICTURE
block|,
name|LANGUAGE
block|,
name|CALENDAR
block|,
name|PLACE
block|}
argument_list|,
name|RETURN
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|FNS_FORMAT_DATE_2
init|=
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"format-date"
argument_list|,
name|Function
operator|.
name|BUILTIN_FUNCTION_NS
argument_list|)
argument_list|,
literal|"Returns a string containing an xs:date value formatted for display."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
name|DATE
block|,
name|PICTURE
block|}
argument_list|,
name|RETURN
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|FNS_FORMAT_DATE_5
init|=
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"format-date"
argument_list|,
name|Function
operator|.
name|BUILTIN_FUNCTION_NS
argument_list|)
argument_list|,
literal|"Returns a string containing an xs:date value formatted for display."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
name|DATE
block|,
name|PICTURE
block|,
name|LANGUAGE
block|,
name|CALENDAR
block|,
name|PLACE
block|}
argument_list|,
name|RETURN
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|FNS_FORMAT_TIME_2
init|=
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"format-time"
argument_list|,
name|Function
operator|.
name|BUILTIN_FUNCTION_NS
argument_list|)
argument_list|,
literal|"Returns a string containing an xs:time value formatted for display."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
name|TIME
block|,
name|PICTURE
block|}
argument_list|,
name|RETURN
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|FunctionSignature
name|FNS_FORMAT_TIME_5
init|=
operator|new
name|FunctionSignature
argument_list|(
operator|new
name|QName
argument_list|(
literal|"format-time"
argument_list|,
name|Function
operator|.
name|BUILTIN_FUNCTION_NS
argument_list|)
argument_list|,
literal|"Returns a string containing an xs:time value formatted for display."
argument_list|,
operator|new
name|SequenceType
index|[]
block|{
name|TIME
block|,
name|PICTURE
block|,
name|LANGUAGE
block|,
name|CALENDAR
block|,
name|PLACE
block|}
argument_list|,
name|RETURN
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|componentPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([YMDdWwFHhmsfZzPCE])\\s*(.*)"
argument_list|)
decl_stmt|;
specifier|public
name|FnFormatDates
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|FunctionSignature
name|signature
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Sequence
name|eval
parameter_list|(
name|Sequence
index|[]
name|args
parameter_list|,
name|Sequence
name|contextSequence
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Sequence
operator|.
name|EMPTY_SEQUENCE
return|;
block|}
specifier|final
name|AbstractDateTimeValue
name|value
init|=
operator|(
name|AbstractDateTimeValue
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|itemAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|picture
init|=
name|args
index|[
literal|1
index|]
operator|.
name|getStringValue
argument_list|()
decl_stmt|;
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|language
decl_stmt|;
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|place
decl_stmt|;
if|if
condition|(
name|getArgumentCount
argument_list|()
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|2
index|]
operator|.
name|hasOne
argument_list|()
condition|)
block|{
name|language
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|args
index|[
literal|2
index|]
operator|.
name|getStringValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|language
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
literal|4
index|]
operator|.
name|hasOne
argument_list|()
condition|)
block|{
name|place
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|args
index|[
literal|4
index|]
operator|.
name|getStringValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|place
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|language
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
name|place
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|StringValue
argument_list|(
name|formatDate
argument_list|(
name|picture
argument_list|,
name|value
argument_list|,
name|language
argument_list|,
name|place
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|String
name|formatDate
parameter_list|(
name|String
name|pic
parameter_list|,
name|AbstractDateTimeValue
name|dt
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|language
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|place
parameter_list|)
throws|throws
name|XPathException
block|{
specifier|final
name|boolean
name|tzHMZNPictureHint
init|=
name|pic
operator|.
name|equals
argument_list|(
literal|"[H00]:[M00] [ZN]"
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|pic
operator|.
name|length
argument_list|()
operator|&&
name|pic
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'['
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|pic
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pic
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|']'
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|pic
operator|.
name|length
argument_list|()
operator|||
name|pic
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|']'
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1340
argument_list|,
literal|"Closing ']' in date picture must be written as ']]'"
argument_list|)
throw|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|pic
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// look for '[['
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|pic
operator|.
name|length
argument_list|()
operator|&&
name|pic
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'['
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|close
init|=
operator|(
name|i
operator|<
name|pic
operator|.
name|length
argument_list|()
condition|?
name|pic
operator|.
name|indexOf
argument_list|(
literal|']'
argument_list|,
name|i
argument_list|)
else|:
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|close
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1340
argument_list|,
literal|"Date format contains a '[' with no matching ']'"
argument_list|)
throw|;
block|}
specifier|final
name|String
name|component
init|=
name|pic
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|close
argument_list|)
decl_stmt|;
name|formatComponent
argument_list|(
name|component
argument_list|,
name|dt
argument_list|,
name|language
argument_list|,
name|place
argument_list|,
name|tzHMZNPictureHint
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|i
operator|=
name|close
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|formatComponent
parameter_list|(
name|String
name|component
parameter_list|,
name|AbstractDateTimeValue
name|dt
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|language
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|place
parameter_list|,
specifier|final
name|boolean
name|tzHMZNPictureHint
parameter_list|,
specifier|final
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|XPathException
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|componentPattern
operator|.
name|matcher
argument_list|(
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1340
argument_list|,
literal|"Unrecognized date/time component: "
operator|+
name|component
argument_list|)
throw|;
block|}
specifier|final
name|char
name|specifier
init|=
name|component
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|width
init|=
literal|null
decl_stmt|;
name|String
name|picture
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// check if there's an optional width specifier
specifier|final
name|int
name|widthSep
init|=
name|picture
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<
name|widthSep
condition|)
block|{
name|width
operator|=
name|picture
operator|.
name|substring
argument_list|(
name|widthSep
operator|+
literal|1
argument_list|)
expr_stmt|;
name|picture
operator|=
name|picture
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|widthSep
argument_list|)
expr_stmt|;
block|}
comment|// get default format picture if none was specified
if|if
condition|(
name|picture
operator|==
literal|null
operator|||
name|picture
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|picture
operator|=
name|getDefaultFormat
argument_list|(
name|specifier
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|allowDate
init|=
operator|!
name|Type
operator|.
name|subTypeOf
argument_list|(
name|dt
operator|.
name|getType
argument_list|()
argument_list|,
name|Type
operator|.
name|TIME
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|allowTime
init|=
operator|!
name|Type
operator|.
name|subTypeOf
argument_list|(
name|dt
operator|.
name|getType
argument_list|()
argument_list|,
name|Type
operator|.
name|DATE
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|specifier
condition|)
block|{
case|case
literal|'Y'
case|:
if|if
condition|(
name|allowDate
condition|)
block|{
specifier|final
name|int
name|year
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|year
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a year component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|tzHMZNPictureHint
condition|)
block|{
if|if
condition|(
name|allowDate
condition|)
block|{
specifier|final
name|int
name|month
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|MONTH
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|month
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a month component"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|allowTime
condition|)
block|{
specifier|final
name|int
name|minute
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|MINUTE
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|minute
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support a minute component"
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|allowDate
condition|)
block|{
specifier|final
name|int
name|day
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|DAY
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|day
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a day component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|allowDate
condition|)
block|{
specifier|final
name|int
name|dayInYear
init|=
name|dt
operator|.
name|getDayWithinYear
argument_list|()
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|dayInYear
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a day component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|allowDate
condition|)
block|{
specifier|final
name|int
name|week
init|=
name|dt
operator|.
name|getWeekWithinYear
argument_list|()
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|week
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a week component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|allowDate
condition|)
block|{
specifier|final
name|int
name|week
init|=
name|dt
operator|.
name|getWeekWithinMonth
argument_list|()
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|week
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a week component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|allowDate
condition|)
block|{
name|int
name|day
init|=
name|dt
operator|.
name|getDayOfWeek
argument_list|()
decl_stmt|;
comment|/**                      * We convert from the 1 == Sunday base                      * used by {@link AbstractDateTimeValue#getDayOfWeek()}                      * to the 1 == Monday base expected                      * by {@link #formatNumber(char, String, String, int, Optional, StringBuilder)}.                      */
if|if
condition|(
name|day
operator|==
name|Calendar
operator|.
name|SUNDAY
condition|)
block|{
name|day
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|day
operator|--
expr_stmt|;
block|}
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|day
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-time does not support a day component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|allowTime
condition|)
block|{
specifier|final
name|int
name|hour
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|HOUR
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|hour
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support a hour component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|allowTime
condition|)
block|{
name|int
name|hour
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|HOUR
argument_list|)
operator|%
literal|12
decl_stmt|;
if|if
condition|(
name|hour
operator|==
literal|0
condition|)
block|{
name|hour
operator|=
literal|12
expr_stmt|;
block|}
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|hour
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support a hour component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|allowTime
condition|)
block|{
specifier|final
name|int
name|minute
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|MINUTE
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|minute
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support a minute component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|allowTime
condition|)
block|{
specifier|final
name|int
name|second
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|SECOND
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|second
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support a second component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|allowTime
condition|)
block|{
specifier|final
name|int
name|fraction
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|MILLISECOND
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|fraction
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support a fractional seconds component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|allowTime
condition|)
block|{
specifier|final
name|int
name|hour
init|=
name|dt
operator|.
name|getPart
argument_list|(
name|AbstractDateTimeValue
operator|.
name|HOUR
argument_list|)
decl_stmt|;
name|formatNumber
argument_list|(
name|specifier
argument_list|,
name|picture
argument_list|,
name|width
argument_list|,
name|hour
argument_list|,
name|language
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"format-date does not support an am/pm component"
argument_list|)
throw|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|dt
operator|.
name|getTimezone
argument_list|()
operator|!=
name|Sequence
operator|.
name|EMPTY_SEQUENCE
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"GMT"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'Z'
case|:
specifier|final
name|Calendar
name|cal
init|=
name|dt
operator|.
name|toJavaObject
argument_list|(
name|Calendar
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Sequence
name|tz
init|=
name|dt
operator|.
name|getTimezone
argument_list|()
decl_stmt|;
if|if
condition|(
name|tz
operator|!=
name|Sequence
operator|.
name|EMPTY_SEQUENCE
condition|)
block|{
specifier|final
name|DayTimeDurationValue
name|dtv
init|=
operator|(
operator|(
name|DayTimeDurationValue
operator|)
name|tz
operator|)
decl_stmt|;
comment|//cope with eXist's duration class's weird #getPart method
name|int
name|minute
init|=
name|dtv
operator|.
name|getPart
argument_list|(
name|DurationValue
operator|.
name|MINUTE
argument_list|)
decl_stmt|;
if|if
condition|(
name|minute
operator|<
literal|0
condition|)
block|{
name|minute
operator|=
name|minute
operator|*
operator|-
literal|1
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|formatTimeZone
argument_list|(
name|picture
argument_list|,
name|dtv
operator|.
name|getPart
argument_list|(
name|DurationValue
operator|.
name|HOUR
argument_list|)
argument_list|,
name|minute
argument_list|,
name|cal
operator|.
name|getTimeZone
argument_list|()
argument_list|,
name|language
argument_list|,
name|place
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1340
argument_list|,
literal|"Unrecognized date/time component: "
operator|+
name|component
argument_list|)
throw|;
block|}
block|}
specifier|private
name|String
name|formatTimeZone
parameter_list|(
specifier|final
name|String
name|timezonePicture
parameter_list|,
specifier|final
name|int
name|hour
parameter_list|,
specifier|final
name|int
name|minute
parameter_list|,
specifier|final
name|TimeZone
name|timeZone
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|language
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|place
parameter_list|)
block|{
specifier|final
name|Locale
name|locale
init|=
operator|new
name|Locale
argument_list|(
name|language
operator|.
name|orElse
argument_list|(
name|DEFAULT_LANGUAGE
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|format
decl_stmt|;
switch|switch
condition|(
name|timezonePicture
condition|)
block|{
case|case
literal|"0"
case|:
if|if
condition|(
name|minute
operator|!=
literal|0
condition|)
block|{
name|format
operator|=
literal|"%+d:%02d"
expr_stmt|;
block|}
else|else
block|{
name|format
operator|=
literal|"%+d"
expr_stmt|;
block|}
break|break;
case|case
literal|"0000"
case|:
name|format
operator|=
literal|"%+03d%02d"
expr_stmt|;
break|break;
case|case
literal|"0:00"
case|:
name|format
operator|=
literal|"%+d:%02d"
expr_stmt|;
break|break;
case|case
literal|"00:00t"
case|:
if|if
condition|(
name|hour
operator|==
literal|0
operator|&&
name|minute
operator|==
literal|0
condition|)
block|{
name|format
operator|=
literal|"Z"
expr_stmt|;
block|}
else|else
block|{
name|format
operator|=
literal|"%+03d:%02d"
expr_stmt|;
block|}
break|break;
case|case
literal|"N"
case|:
specifier|final
name|TimeZone
name|tz
init|=
name|place
operator|.
name|map
argument_list|(
name|TimeZone
operator|::
name|getTimeZone
argument_list|)
operator|.
name|orElse
argument_list|(
name|timeZone
argument_list|)
decl_stmt|;
return|return
name|tz
operator|.
name|getDisplayName
argument_list|(
name|timeZone
operator|.
name|useDaylightTime
argument_list|()
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|,
name|locale
argument_list|)
return|;
case|case
literal|"Z"
case|:
return|return
name|formatMilitaryTimeZone
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|)
return|;
case|case
literal|"00:00"
case|:
default|default:
name|format
operator|=
literal|"%+03d:%02d"
expr_stmt|;
block|}
return|return
name|String
operator|.
name|format
argument_list|(
name|locale
argument_list|,
name|format
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|)
return|;
block|}
specifier|private
specifier|final
specifier|static
name|char
index|[]
name|MILITARY_TZ_CHARS
init|=
block|{
literal|'Z'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|}
decl_stmt|;
comment|/**      * Military time zone      *      * Z = +00:00, A = +01:00, B = +02:00, ..., M = +12:00, N = -01:00, O = -02:00, ... Y = -12:00.      *      * The letter J (meaning local time) is used in the case of a value that does not specify a timezone      * offset.      *      * Timezone offsets that have no representation in this system (for example Indian Standard Time, +05:30)      * are output as if the format 01:01 had been requested.      */
specifier|private
name|String
name|formatMilitaryTimeZone
parameter_list|(
specifier|final
name|int
name|hour
parameter_list|,
specifier|final
name|int
name|minute
parameter_list|)
block|{
if|if
condition|(
name|minute
operator|==
literal|0
operator|&&
name|hour
operator|>
operator|-
literal|12
operator|&&
name|hour
operator|<
literal|12
condition|)
block|{
specifier|final
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|hour
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
literal|13
operator|+
operator|(
name|hour
operator|*
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|hour
expr_stmt|;
block|}
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|MILITARY_TZ_CHARS
index|[
name|offset
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%+03d:%02d"
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|)
return|;
block|}
block|}
specifier|private
name|String
name|getDefaultFormat
parameter_list|(
name|char
name|specifier
parameter_list|)
block|{
switch|switch
condition|(
name|specifier
condition|)
block|{
case|case
literal|'F'
case|:
return|return
literal|"Nn"
return|;
case|case
literal|'P'
case|:
return|return
literal|"n"
return|;
case|case
literal|'C'
case|:
case|case
literal|'E'
case|:
return|return
literal|"N"
return|;
case|case
literal|'m'
case|:
case|case
literal|'s'
case|:
return|return
literal|"01"
return|;
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
return|return
literal|"00:00"
return|;
default|default:
return|return
literal|"1"
return|;
block|}
block|}
specifier|private
name|void
name|formatNumber
parameter_list|(
name|char
name|specifier
parameter_list|,
name|String
name|picture
parameter_list|,
name|String
name|width
parameter_list|,
name|int
name|num
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|String
argument_list|>
name|language
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|XPathException
block|{
specifier|final
name|NumberFormatter
name|formatter
init|=
name|NumberFormatter
operator|.
name|getInstance
argument_list|(
name|language
operator|.
name|orElse
argument_list|(
name|DEFAULT_LANGUAGE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"N"
operator|.
name|equals
argument_list|(
name|picture
argument_list|)
operator|||
literal|"n"
operator|.
name|equals
argument_list|(
name|picture
argument_list|)
operator|||
literal|"Nn"
operator|.
name|equals
argument_list|(
name|picture
argument_list|)
condition|)
block|{
name|String
name|name
decl_stmt|;
switch|switch
condition|(
name|specifier
condition|)
block|{
case|case
literal|'M'
case|:
name|name
operator|=
name|formatter
operator|.
name|getMonth
argument_list|(
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|name
operator|=
name|formatter
operator|.
name|getDay
argument_list|(
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|name
operator|=
name|formatter
operator|.
name|getAmPm
argument_list|(
name|num
argument_list|)
expr_stmt|;
break|break;
default|default:
name|name
operator|=
literal|""
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|"N"
operator|.
name|equals
argument_list|(
name|picture
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
literal|"n"
operator|.
name|equals
argument_list|(
name|picture
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|widths
index|[]
init|=
name|getWidths
argument_list|(
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|widths
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|min
init|=
name|widths
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|max
init|=
name|widths
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|StringBuilder
name|ws
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|name
operator|.
name|length
argument_list|()
operator|<
name|min
condition|)
block|{
name|ws
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|name
operator|+
name|ws
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
name|max
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// determine min and max width
name|int
name|min
init|=
name|NumberFormatter
operator|.
name|getMinDigits
argument_list|(
name|picture
argument_list|)
decl_stmt|;
name|int
name|max
init|=
name|NumberFormatter
operator|.
name|getMaxDigits
argument_list|(
name|picture
argument_list|)
decl_stmt|;
if|if
condition|(
name|max
operator|==
literal|1
condition|)
block|{
name|max
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|// explicit width takes precedence
specifier|final
name|int
name|widths
index|[]
init|=
name|getWidths
argument_list|(
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|widths
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|widths
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
name|min
operator|=
name|widths
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|widths
index|[
literal|1
index|]
operator|>
literal|0
condition|)
block|{
name|max
operator|=
name|widths
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
try|try
block|{
name|sb
operator|.
name|append
argument_list|(
name|formatter
operator|.
name|formatNumber
argument_list|(
name|num
argument_list|,
name|picture
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|XPathException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|int
index|[]
name|getWidths
parameter_list|(
name|String
name|width
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|width
operator|==
literal|null
operator|||
name|width
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|max
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|minPart
init|=
name|width
decl_stmt|;
name|String
name|maxPart
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|p
init|=
name|width
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
block|{
name|minPart
operator|=
name|width
expr_stmt|;
block|}
else|else
block|{
name|minPart
operator|=
name|width
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|maxPart
operator|=
name|width
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|minPart
argument_list|)
condition|)
block|{
name|min
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|min
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|minPart
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NumberFormatException
name|e
parameter_list|)
block|{
block|}
block|}
if|if
condition|(
name|maxPart
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|maxPart
argument_list|)
condition|)
block|{
name|max
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|max
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|maxPart
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NumberFormatException
name|e
parameter_list|)
block|{
block|}
block|}
block|}
if|if
condition|(
name|max
operator|!=
operator|-
literal|1
operator|&&
name|min
operator|>
name|max
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FOFD1350
argument_list|,
literal|"Minimum width> maximum width in component"
argument_list|)
throw|;
block|}
return|return
operator|new
name|int
index|[]
block|{
name|min
block|,
name|max
block|}
return|;
block|}
block|}
end_class

end_unit

