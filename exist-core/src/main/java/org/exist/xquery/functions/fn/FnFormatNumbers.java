begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2019 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|fn
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|CodePointString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|String
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|MathContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple
operator|.
name|Tuple
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|FunctionDSL
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|fn
operator|.
name|FnModule
operator|.
name|functionSignatures
import|;
end_import

begin_comment
comment|/**  * Implements fn:format-number as per W3C XPath and XQuery Functions and Operators 3.1  *  * fn:format-number($value as numeric?, $picture as xs:string) as xs:string  * fn:format-number($value as numeric?, $picture as xs:string, $decimal-format-name as xs:string) as xs:string  *  * @author<a href="mailto:adam@evolvedbinary.com">Adam Retter</a>  */
end_comment

begin_class
specifier|public
class|class
name|FnFormatNumbers
extends|extends
name|BasicFunction
block|{
specifier|private
specifier|static
specifier|final
name|FunctionParameterSequenceType
name|FS_PARAM_VALUE
init|=
name|optParam
argument_list|(
literal|"value"
argument_list|,
name|Type
operator|.
name|NUMBER
argument_list|,
literal|"The number to format"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|FunctionParameterSequenceType
name|FS_PARAM_PICTURE
init|=
name|param
argument_list|(
literal|"picture"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
literal|"The picture string to use for formatting. To understand the picture string syntax, see: https://www.w3.org/TR/xpath-functions-31/#func-format-number"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FS_FORMAT_NUMBER_NAME
init|=
literal|"format-number"
decl_stmt|;
specifier|static
specifier|final
name|FunctionSignature
index|[]
name|FS_FORMAT_NUMBER
init|=
name|functionSignatures
argument_list|(
name|FS_FORMAT_NUMBER_NAME
argument_list|,
literal|"Returns a string containing a number formatted according to a given picture string, taking account of decimal formats specified in the static context."
argument_list|,
name|returns
argument_list|(
name|Type
operator|.
name|STRING
argument_list|,
literal|"The formatted string representation of the supplied number"
argument_list|)
argument_list|,
name|arities
argument_list|(
name|arity
argument_list|(
name|FS_PARAM_VALUE
argument_list|,
name|FS_PARAM_PICTURE
argument_list|)
argument_list|,
name|arity
argument_list|(
name|FS_PARAM_VALUE
argument_list|,
name|FS_PARAM_PICTURE
argument_list|,
name|optParam
argument_list|(
literal|"decimal-format-name"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
literal|"The name (as an EQName) of a decimal format to use."
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
name|FnFormatNumbers
parameter_list|(
specifier|final
name|XQueryContext
name|context
parameter_list|,
specifier|final
name|FunctionSignature
name|signature
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Sequence
name|eval
parameter_list|(
specifier|final
name|Sequence
index|[]
name|args
parameter_list|,
specifier|final
name|Sequence
name|contextSequence
parameter_list|)
throws|throws
name|XPathException
block|{
comment|// get the decimal format
specifier|final
name|QName
name|qnDecimalFormat
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|3
operator|&&
operator|!
name|args
index|[
literal|2
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|String
name|decimalFormatName
init|=
name|args
index|[
literal|2
index|]
operator|.
name|itemAt
argument_list|(
literal|0
argument_list|)
operator|.
name|getStringValue
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
try|try
block|{
name|qnDecimalFormat
operator|=
name|QName
operator|.
name|parse
argument_list|(
name|context
argument_list|,
name|decimalFormatName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|QName
operator|.
name|IllegalQNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1280
argument_list|,
literal|"Invalid decimal format QName."
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|qnDecimalFormat
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|DecimalFormat
name|decimalFormat
init|=
name|context
operator|.
name|getStaticDecimalFormat
argument_list|(
name|qnDecimalFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|decimalFormat
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1280
argument_list|,
literal|"No known decimal format of that name."
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
throw|;
block|}
specifier|final
name|NumericValue
name|number
decl_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|number
operator|=
operator|new
name|DoubleValue
argument_list|(
name|Double
operator|.
name|NaN
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|context
operator|.
name|isBackwardsCompatible
argument_list|()
operator|&&
operator|!
name|Type
operator|.
name|subTypeOf
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|getItemType
argument_list|()
argument_list|,
name|Type
operator|.
name|NUMBER
argument_list|)
condition|)
block|{
name|number
operator|=
operator|new
name|DoubleValue
argument_list|(
name|Double
operator|.
name|NaN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|number
operator|=
operator|(
name|NumericValue
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|itemAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CodePointString
name|pictureString
init|=
operator|new
name|CodePointString
argument_list|(
name|args
index|[
literal|1
index|]
operator|.
name|itemAt
argument_list|(
literal|0
argument_list|)
operator|.
name|getStringValue
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Tuple2
argument_list|<
name|SubPicture
argument_list|,
name|Optional
argument_list|<
name|SubPicture
argument_list|>
argument_list|>
name|subPictures
init|=
name|analyzePictureString
argument_list|(
name|decimalFormat
argument_list|,
name|pictureString
argument_list|)
decl_stmt|;
specifier|final
name|String
name|value
init|=
name|format
argument_list|(
name|number
argument_list|,
name|decimalFormat
argument_list|,
name|subPictures
argument_list|)
decl_stmt|;
return|return
operator|new
name|StringValue
argument_list|(
name|value
argument_list|)
return|;
block|}
enum|enum
name|AnalyzeState
block|{
name|MANTISSA_PART
block|,
name|INTEGER_PART
block|,
name|FRACTIONAL_PART
block|,
name|EXPONENT_PART
block|}
comment|/**      * Analyzes a picture-string sent to fn:format-number.      *      * See https://www.w3.org/TR/xpath-functions-31/#syntax-of-picture-string      * See https://www.w3.org/TR/xpath-functions-31/#analyzing-picture-string      *      * @param decimalFormat the decimal format to use      * @param pictureString the picture-string      *      * @return A tuple containing one or two sub-pictures      *      * @throws XPathException if the picture-string is invalid      */
specifier|private
name|Tuple2
argument_list|<
name|SubPicture
argument_list|,
name|Optional
argument_list|<
name|SubPicture
argument_list|>
argument_list|>
name|analyzePictureString
parameter_list|(
specifier|final
name|DecimalFormat
name|decimalFormat
parameter_list|,
specifier|final
name|CodePointString
name|pictureString
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|pictureString
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() $picture string is zero-length"
argument_list|)
throw|;
block|}
specifier|final
name|SubPicture
name|firstSubPicture
init|=
operator|new
name|SubPicture
argument_list|()
decl_stmt|;
annotation|@
name|Nullable
name|SubPicture
name|secondSubPicture
init|=
literal|null
decl_stmt|;
name|SubPicture
name|subPicture
init|=
name|firstSubPicture
decl_stmt|;
name|AnalyzeState
name|state
init|=
name|AnalyzeState
operator|.
name|INTEGER_PART
decl_stmt|;
comment|// we start in the integer part of the mantissa
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|boolean
name|capturePrefix
init|=
literal|true
decl_stmt|;
comment|// we need two characters of look-behind to be able to detect
comment|// various invalid sub-pictures:
comment|//   1) active-passive-active characters
comment|//   2) grouping-separator character that appears adjacent to a decimal-separator character
name|int
name|prevPrevChar
init|=
literal|'\0'
decl_stmt|;
name|int
name|prevChar
init|=
literal|'\0'
decl_stmt|;
for|for
control|(
init|;
name|idx
operator|<
name|pictureString
operator|.
name|length
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|pictureString
operator|.
name|codePointAt
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|prevPrevChar
argument_list|)
operator|&&
operator|(
operator|!
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|prevChar
argument_list|)
operator|)
operator|&&
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|INTEGER_PART
case|:
comment|/* active characters */
if|if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|decimalSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a grouping-separator character that appears adjacent to a decimal-separator character."
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|setHasDecimalSeparator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|state
operator|=
name|AnalyzeState
operator|.
name|FRACTIONAL_PART
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|exponentSeparator
condition|)
block|{
comment|/*                         A character that matches the exponent-separator property is treated as an                         exponent-separator-sign if it is both preceded and followed within the                         sub-picture by an active character.                         */
comment|// we need to peek at the next char to determine if it is active
specifier|final
name|boolean
name|nextIsActive
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|<
name|pictureString
operator|.
name|length
argument_list|()
condition|)
block|{
name|nextIsActive
operator|=
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|pictureString
operator|.
name|codePointAt
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextIsActive
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|prevChar
argument_list|)
operator|&&
name|nextIsActive
condition|)
block|{
comment|// this is an exponent-separator-sign
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|subPicture
operator|.
name|hasPercent
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture cannot contain an exponent separator sign as it already has a percent character."
argument_list|)
throw|;
block|}
if|if
condition|(
name|subPicture
operator|.
name|hasPerMille
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture cannot contain an exponent separator sign as it already has a per-mille character."
argument_list|)
throw|;
block|}
name|state
operator|=
name|AnalyzeState
operator|.
name|EXPONENT_PART
expr_stmt|;
block|}
else|else
block|{
comment|// just another passive char
name|analyzePassiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|,
name|capturePrefix
argument_list|,
name|subPicture
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|decimalSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a grouping-separator character that appears adjacent to a decimal-separator character."
argument_list|)
throw|;
block|}
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain two adjacent instances of the grouping-separator character."
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|newIntegerPartGroupingPosition
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|digit
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|isDecimalDigit
argument_list|(
name|decimalFormat
argument_list|,
name|prevChar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a member of the decimal digit family that is followed by an instance of the optional digit character within its integer part."
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|incrementIntegerPartGroupingPosition
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|setHasIntegerOptionalDigit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|patternSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|subPicture
operator|==
name|secondSubPicture
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() $picture string contains more than two sub-pictures"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// store/check any outstanding picture state
if|if
condition|(
operator|!
operator|(
name|subPicture
operator|.
name|hasIntegerOptionalDigit
argument_list|()
operator|||
name|subPicture
operator|.
name|getMinimumIntegerPartSize
argument_list|()
operator|>
literal|0
operator|||
name|subPicture
operator|.
name|getMaximumFractionalPartSize
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() mantissa part of sub-picture in $picture must contain at least one character that is either an optional digit character or a member of the decimal digit family"
argument_list|)
throw|;
block|}
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a grouping-separator character in the absence of a decimal-separator character, at the end of the integer part."
argument_list|)
throw|;
block|}
comment|// switch to 2nd sub-picture
name|secondSubPicture
operator|=
operator|new
name|SubPicture
argument_list|()
expr_stmt|;
name|subPicture
operator|=
name|secondSubPicture
expr_stmt|;
comment|// reset analyze state
name|state
operator|=
name|AnalyzeState
operator|.
name|INTEGER_PART
expr_stmt|;
name|prevPrevChar
operator|=
literal|'\0'
expr_stmt|;
name|prevChar
operator|=
literal|'\0'
expr_stmt|;
name|capturePrefix
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|isDecimalDigit
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// decimal digit family
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|incrementIntegerPartGroupingPosition
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|incrementMinimumIntegerPartSize
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|incrementScalingFactor
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* passive character */
name|analyzePassiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|,
name|capturePrefix
argument_list|,
name|subPicture
argument_list|)
expr_stmt|;
block|}
break|break;
comment|// end of INTEGER_PART
case|case
name|FRACTIONAL_PART
case|:
comment|/* active characters */
if|if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|decimalSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a grouping-separator character that appears adjacent to a decimal-separator character."
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|setHasDecimalSeparator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture string contains more than one decimal-separator characters"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|exponentSeparator
condition|)
block|{
comment|/*                         A character that matches the exponent-separator property is treated as an                         exponent-separator-sign if it is both preceded and followed within the                         sub-picture by an active character.                         */
comment|// we need to peek at the next char to determine if it is active
specifier|final
name|boolean
name|nextIsActive
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|<
name|pictureString
operator|.
name|length
argument_list|()
condition|)
block|{
name|nextIsActive
operator|=
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|pictureString
operator|.
name|codePointAt
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextIsActive
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|isActiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|prevChar
argument_list|)
operator|&&
name|nextIsActive
condition|)
block|{
comment|// this is an exponent-separator-sign
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|subPicture
operator|.
name|hasPercent
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture cannot contain an exponent separator sign as it already has a percent character."
argument_list|)
throw|;
block|}
if|if
condition|(
name|subPicture
operator|.
name|hasPerMille
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture cannot contain an exponent separator sign as it already has a per-mille character."
argument_list|)
throw|;
block|}
name|state
operator|=
name|AnalyzeState
operator|.
name|EXPONENT_PART
expr_stmt|;
block|}
else|else
block|{
comment|// just another passive char
name|analyzePassiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|,
name|capturePrefix
argument_list|,
name|subPicture
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|decimalSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a grouping-separator character that appears adjacent to a decimal-separator character."
argument_list|)
throw|;
block|}
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain two adjacent instances of the grouping-separator character."
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|newFractionalPartGroupingPosition
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|digit
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|incrementMaximumFractionalPartSize
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|patternSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|subPicture
operator|==
name|secondSubPicture
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() $picture string contains more than two sub-pictures"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// store/check any outstanding picture state
if|if
condition|(
operator|!
operator|(
name|subPicture
operator|.
name|hasIntegerOptionalDigit
argument_list|()
operator|||
name|subPicture
operator|.
name|getMinimumIntegerPartSize
argument_list|()
operator|>
literal|0
operator|||
name|subPicture
operator|.
name|getMaximumFractionalPartSize
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() mantissa part of sub-picture in $picture must contain at least one character that is either an optional digit character or a member of the decimal digit family"
argument_list|)
throw|;
block|}
comment|// switch to 2nd sub-picture
name|secondSubPicture
operator|=
operator|new
name|SubPicture
argument_list|()
expr_stmt|;
name|subPicture
operator|=
name|secondSubPicture
expr_stmt|;
comment|// reset analyze state
name|state
operator|=
name|AnalyzeState
operator|.
name|INTEGER_PART
expr_stmt|;
name|prevPrevChar
operator|=
literal|'\0'
expr_stmt|;
name|prevChar
operator|=
literal|'\0'
expr_stmt|;
name|capturePrefix
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|isDecimalDigit
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// decimal digit family
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevChar
operator|==
name|decimalFormat
operator|.
name|digit
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain an instance of the optional digit character that is followed by a member of the decimal digit family within its fractional part."
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|incrementMinimumFractionalPartSize
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|incrementMaximumFractionalPartSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* passive character */
name|analyzePassiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|,
name|capturePrefix
argument_list|,
name|subPicture
argument_list|)
expr_stmt|;
block|}
break|break;
comment|// end of FRACTIONAL_PART
case|case
name|EXPONENT_PART
case|:
if|if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|decimalSeparator
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|exponentSeparator
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|digit
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture cannot have any active characters following the exponent-separator-sign"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|patternSeparator
condition|)
block|{
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|subPicture
operator|==
name|secondSubPicture
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() $picture string contains more than two sub-pictures"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// store/check any outstanding picture state
if|if
condition|(
operator|!
operator|(
name|subPicture
operator|.
name|hasIntegerOptionalDigit
argument_list|()
operator|||
name|subPicture
operator|.
name|getMinimumIntegerPartSize
argument_list|()
operator|>
literal|0
operator|||
name|subPicture
operator|.
name|getMaximumFractionalPartSize
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() mantissa part of sub-picture in $picture must contain at least one character that is either an optional digit character or a member of the decimal digit family"
argument_list|)
throw|;
block|}
comment|// switch to 2nd sub-picture
name|secondSubPicture
operator|=
operator|new
name|SubPicture
argument_list|()
expr_stmt|;
name|subPicture
operator|=
name|secondSubPicture
expr_stmt|;
comment|// reset analyze state
name|state
operator|=
name|AnalyzeState
operator|.
name|INTEGER_PART
expr_stmt|;
name|prevPrevChar
operator|=
literal|'\0'
expr_stmt|;
name|prevChar
operator|=
literal|'\0'
expr_stmt|;
name|capturePrefix
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|isDecimalDigit
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// decimal digit family
name|capturePrefix
operator|=
literal|false
expr_stmt|;
name|subPicture
operator|.
name|clearSuffix
argument_list|()
expr_stmt|;
name|subPicture
operator|.
name|incrementMinimumExponentSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* passive character */
name|analyzePassiveChar
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|,
name|capturePrefix
argument_list|,
name|subPicture
argument_list|)
expr_stmt|;
block|}
break|break;
comment|// end of EXPONENT_PART
block|}
if|if
condition|(
name|c
operator|!=
name|decimalFormat
operator|.
name|patternSeparator
condition|)
block|{
name|prevPrevChar
operator|=
name|prevChar
expr_stmt|;
name|prevChar
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|subPicture
operator|.
name|hasIntegerOptionalDigit
argument_list|()
operator|||
name|subPicture
operator|.
name|getMinimumIntegerPartSize
argument_list|()
operator|>
literal|0
operator|||
name|subPicture
operator|.
name|getMaximumFractionalPartSize
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() mantissa part of sub-picture in $picture must contain at least one character that is either an optional digit character or a member of the decimal digit family"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|subPicture
operator|.
name|hasDecimalSeparator
argument_list|()
operator|)
operator|&&
name|prevChar
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture must not contain a grouping-separator character in the absence of a decimal-separator character, at the end of the integer part."
argument_list|)
throw|;
block|}
return|return
name|Tuple
argument_list|(
name|firstSubPicture
operator|.
name|adjust
argument_list|()
argument_list|,
name|Optional
operator|.
name|ofNullable
argument_list|(
name|secondSubPicture
argument_list|)
operator|.
name|map
argument_list|(
name|SubPicture
operator|::
name|adjust
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|void
name|analyzePassiveChar
parameter_list|(
specifier|final
name|DecimalFormat
name|decimalFormat
parameter_list|,
specifier|final
name|int
name|c
parameter_list|,
specifier|final
name|boolean
name|capturePrefix
parameter_list|,
specifier|final
name|SubPicture
name|subPicture
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|capturePrefix
condition|)
block|{
name|subPicture
operator|.
name|appendPrefix
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|subPicture
operator|.
name|appendSuffix
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|percent
condition|)
block|{
if|if
condition|(
name|subPicture
operator|.
name|hasPercent
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture string contains more than one percent character"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|subPicture
operator|.
name|hasPerMille
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture string cannot contain a per-mille character and a percent character"
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|setHasPercent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
name|decimalFormat
operator|.
name|perMille
condition|)
block|{
if|if
condition|(
name|subPicture
operator|.
name|hasPerMille
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture string contains more than one per-mille character"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|subPicture
operator|.
name|hasPercent
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|this
argument_list|,
name|ErrorCodes
operator|.
name|FODF1310
argument_list|,
literal|"format-number() sub-picture in $picture string cannot contain a percent character and a per-mille character"
argument_list|)
throw|;
block|}
name|subPicture
operator|.
name|setHasPerMille
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isDecimalDigit
parameter_list|(
specifier|final
name|DecimalFormat
name|decimalFormat
parameter_list|,
specifier|final
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
name|decimalFormat
operator|.
name|zeroDigit
operator|&&
name|c
operator|<=
name|decimalFormat
operator|.
name|zeroDigit
operator|+
literal|9
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isActiveChar
parameter_list|(
specifier|final
name|DecimalFormat
name|decimalFormat
parameter_list|,
specifier|final
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|decimalFormat
operator|.
name|decimalSeparator
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|exponentSeparator
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|groupingSeparator
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|digit
operator|||
name|c
operator|==
name|decimalFormat
operator|.
name|patternSeparator
operator|||
name|isDecimalDigit
argument_list|(
name|decimalFormat
argument_list|,
name|c
argument_list|)
return|;
block|}
specifier|private
name|String
name|format
parameter_list|(
specifier|final
name|NumericValue
name|number
parameter_list|,
specifier|final
name|DecimalFormat
name|decimalFormat
parameter_list|,
specifier|final
name|Tuple2
argument_list|<
name|SubPicture
argument_list|,
name|Optional
argument_list|<
name|SubPicture
argument_list|>
argument_list|>
name|subPictures
parameter_list|)
throws|throws
name|XPathException
block|{
comment|// Rule 1: return NaN for NaN
if|if
condition|(
name|number
operator|.
name|isNaN
argument_list|()
condition|)
block|{
return|return
name|decimalFormat
operator|.
name|NaN
return|;
block|}
comment|// Rule 2: should we use the positive or negative sub-picture
specifier|final
name|SubPicture
name|subPicture
decl_stmt|;
if|if
condition|(
name|number
operator|.
name|isNegative
argument_list|()
condition|)
block|{
name|subPicture
operator|=
name|subPictures
operator|.
name|_2
operator|.
name|orElseGet
argument_list|(
parameter_list|()
lambda|->
name|subPictures
operator|.
name|_1
operator|.
name|copy
argument_list|()
operator|.
name|negate
argument_list|(
name|decimalFormat
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subPicture
operator|=
name|subPictures
operator|.
name|_1
expr_stmt|;
block|}
comment|/*         In the rules below, the positive sub-picture and its associated variables are used if the input number is positive,         and the negative sub-picture and its associated variables are used if it is negative. For xs:double and xs:float,         negative zero is taken as negative, positive zero as positive. For xs:decimal and xs:integer, the positive         sub-picture is used for zero.          */
comment|// Rule 3: adjust for percent or permille
name|NumericValue
name|adjustedNumber
decl_stmt|;
if|if
condition|(
name|subPicture
operator|.
name|hasPercent
argument_list|()
condition|)
block|{
name|adjustedNumber
operator|=
operator|(
name|NumericValue
operator|)
name|number
operator|.
name|mult
argument_list|(
operator|new
name|IntegerValue
argument_list|(
literal|100
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|subPicture
operator|.
name|hasPerMille
argument_list|()
condition|)
block|{
name|adjustedNumber
operator|=
operator|(
name|NumericValue
operator|)
name|number
operator|.
name|mult
argument_list|(
operator|new
name|IntegerValue
argument_list|(
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjustedNumber
operator|=
name|number
expr_stmt|;
block|}
comment|// Rule 4: return infinity for infinity
if|if
condition|(
name|adjustedNumber
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
return|return
name|subPicture
operator|.
name|getPrefixString
argument_list|()
operator|+
name|decimalFormat
operator|.
name|infinity
operator|+
name|subPicture
operator|.
name|getSuffixString
argument_list|()
return|;
block|}
comment|// Rule 5 and 6: adjust for exponent
comment|// Rule 5 and 6 were modified from BaseX code, Copyright BaseX Team 2005-19, BSD License
name|int
name|exp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|subPicture
operator|.
name|getMinimumExponentSize
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|number
operator|.
name|isZero
argument_list|()
condition|)
block|{
name|BigDecimal
name|dec
init|=
name|number
operator|.
name|convertTo
argument_list|(
name|Type
operator|.
name|DECIMAL
argument_list|)
operator|.
name|toJavaObject
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|abs
argument_list|()
operator|.
name|stripTrailingZeros
argument_list|()
decl_stmt|;
name|int
name|scl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dec
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|scl
operator|=
name|dec
operator|.
name|setScale
argument_list|(
literal|0
argument_list|,
name|RoundingMode
operator|.
name|HALF_DOWN
argument_list|)
operator|.
name|precision
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|dec
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dec
operator|=
name|dec
operator|.
name|multiply
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
expr_stmt|;
name|scl
operator|--
expr_stmt|;
block|}
name|scl
operator|++
expr_stmt|;
block|}
name|exp
operator|=
name|scl
operator|-
name|subPicture
operator|.
name|getScalingFactor
argument_list|()
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
block|{
specifier|final
name|BigDecimal
name|n
init|=
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|adjustedNumber
operator|=
operator|(
name|NumericValue
operator|)
name|adjustedNumber
operator|.
name|mult
argument_list|(
operator|new
name|DecimalValue
argument_list|(
name|exp
operator|>
literal|0
condition|?
name|BigDecimal
operator|.
name|ONE
operator|.
name|divide
argument_list|(
name|n
argument_list|,
name|MathContext
operator|.
name|DECIMAL64
argument_list|)
else|:
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|adjustedNumber
operator|=
operator|new
name|DecimalValue
argument_list|(
name|adjustedNumber
operator|.
name|convertTo
argument_list|(
name|Type
operator|.
name|DECIMAL
argument_list|)
operator|.
name|toJavaObject
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|MathContext
operator|.
name|DECIMAL64
argument_list|)
argument_list|)
operator|.
name|round
argument_list|(
operator|new
name|IntegerValue
argument_list|(
name|subPicture
operator|.
name|getMaximumFractionalPartSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|abs
argument_list|()
expr_stmt|;
comment|/* we can now start formatting for display */
comment|// Rule 7 - must always contain a decimal-separator, and it must contain no leading zeroes and no trailing zeroes.
specifier|final
name|CodePointString
name|formatted
init|=
operator|new
name|CodePointString
argument_list|(
name|adjustedNumber
operator|.
name|toJavaObject
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|toPlainString
argument_list|()
argument_list|)
decl_stmt|;
name|formatted
operator|.
name|replaceFirst
argument_list|(
literal|'.'
argument_list|,
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
comment|// this string must always contain a decimal-separator
if|if
condition|(
operator|!
name|formatted
operator|.
name|contains
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
condition|)
block|{
name|formatted
operator|.
name|append
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
block|}
comment|// must contain no leading zeroes and no trailing zeroes
name|formatted
operator|.
name|leftTrim
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|formatted
operator|.
name|rightTrim
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
comment|// covert to using the digits in the decimal digit family to represent the ten decimal digits
if|if
condition|(
name|decimalFormat
operator|.
name|zeroDigit
operator|!=
literal|'0'
condition|)
block|{
name|formatted
operator|.
name|transform
argument_list|(
literal|'0'
argument_list|,
literal|'9'
argument_list|,
name|decimalFormat
operator|.
name|zeroDigit
argument_list|)
expr_stmt|;
block|}
name|int
name|idxDecimalSeparator
init|=
name|formatted
operator|.
name|indexOf
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
decl_stmt|;
comment|// Rule 8 - Left pad
name|int
name|intLength
init|=
name|idxDecimalSeparator
operator|>
operator|-
literal|1
condition|?
name|idxDecimalSeparator
else|:
name|formatted
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftPadLen
init|=
name|subPicture
operator|.
name|getMinimumIntegerPartSize
argument_list|()
operator|-
name|intLength
decl_stmt|;
if|if
condition|(
name|leftPadLen
operator|>
literal|0
condition|)
block|{
name|formatted
operator|.
name|leftPad
argument_list|(
name|decimalFormat
operator|.
name|zeroDigit
argument_list|,
name|leftPadLen
argument_list|)
expr_stmt|;
name|idxDecimalSeparator
operator|=
name|formatted
operator|.
name|indexOf
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
name|intLength
operator|=
name|idxDecimalSeparator
operator|>
operator|-
literal|1
condition|?
name|idxDecimalSeparator
else|:
name|formatted
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
comment|// Rule 9 - Right pad
name|int
name|fractLen
init|=
name|idxDecimalSeparator
operator|>
operator|-
literal|1
condition|?
name|formatted
operator|.
name|length
argument_list|()
operator|-
operator|(
name|idxDecimalSeparator
operator|+
literal|1
operator|)
else|:
literal|0
decl_stmt|;
specifier|final
name|int
name|rightPadLen
init|=
name|subPicture
operator|.
name|getMinimumFractionalPartSize
argument_list|()
operator|-
name|fractLen
decl_stmt|;
if|if
condition|(
name|rightPadLen
operator|>
literal|0
condition|)
block|{
name|formatted
operator|.
name|rightPad
argument_list|(
name|decimalFormat
operator|.
name|zeroDigit
argument_list|,
name|rightPadLen
argument_list|)
expr_stmt|;
name|idxDecimalSeparator
operator|=
name|formatted
operator|.
name|indexOf
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
name|fractLen
operator|=
name|idxDecimalSeparator
operator|>
operator|-
literal|1
condition|?
name|formatted
operator|.
name|length
argument_list|()
operator|-
operator|(
name|idxDecimalSeparator
operator|+
literal|1
operator|)
else|:
literal|0
expr_stmt|;
block|}
comment|// Rule 10 - Integer part groupings
annotation|@
name|Nullable
specifier|final
name|int
index|[]
name|integerPartGroupingPositions
init|=
name|subPicture
operator|.
name|getIntegerPartGroupingPositions
argument_list|()
decl_stmt|;
if|if
condition|(
name|integerPartGroupingPositions
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|g
init|=
name|subPicture
operator|.
name|integerPartGroupingPositionsAreRegular
argument_list|()
decl_stmt|;
if|if
condition|(
name|g
operator|>
operator|-
literal|1
condition|)
block|{
comment|// regular grouping
name|int
name|m
init|=
name|intLength
operator|/
name|g
decl_stmt|;
if|if
condition|(
name|intLength
operator|%
name|g
operator|==
literal|0
condition|)
block|{
name|m
operator|--
expr_stmt|;
comment|// prevents a group separator being inseted at index 0
block|}
specifier|final
name|int
index|[]
name|relGroupingOffsets
init|=
operator|new
name|int
index|[
name|m
index|]
decl_stmt|;
for|for
control|(
init|;
name|m
operator|>
literal|0
condition|;
name|m
operator|--
control|)
block|{
specifier|final
name|int
name|groupingIdx
init|=
name|idxDecimalSeparator
operator|-
operator|(
name|m
operator|*
name|g
operator|)
decl_stmt|;
name|relGroupingOffsets
index|[
name|m
operator|-
literal|1
index|]
operator|=
name|groupingIdx
expr_stmt|;
block|}
name|formatted
operator|.
name|insert
argument_list|(
name|relGroupingOffsets
argument_list|,
name|decimalFormat
operator|.
name|groupingSeparator
argument_list|)
expr_stmt|;
name|idxDecimalSeparator
operator|=
name|formatted
operator|.
name|indexOf
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// non-regular grouping
specifier|final
name|int
index|[]
name|relGroupingOffsets
init|=
operator|new
name|int
index|[
name|integerPartGroupingPositions
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|integerPartGroupingPositions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|integerPartGroupingPosition
init|=
name|integerPartGroupingPositions
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|groupingIdx
init|=
name|idxDecimalSeparator
operator|-
name|integerPartGroupingPosition
decl_stmt|;
name|relGroupingOffsets
index|[
name|i
index|]
operator|=
name|groupingIdx
expr_stmt|;
block|}
name|formatted
operator|.
name|insert
argument_list|(
name|relGroupingOffsets
argument_list|,
name|decimalFormat
operator|.
name|groupingSeparator
argument_list|)
expr_stmt|;
name|idxDecimalSeparator
operator|=
name|formatted
operator|.
name|indexOf
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Rule 11 - Fractional part groupings
annotation|@
name|Nullable
specifier|final
name|int
index|[]
name|fractionalPartGroupingPositions
init|=
name|subPicture
operator|.
name|getFractionalPartGroupingPositions
argument_list|()
decl_stmt|;
if|if
condition|(
name|fractionalPartGroupingPositions
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
index|[]
name|relGroupingOffsets
init|=
operator|new
name|int
index|[
name|fractionalPartGroupingPositions
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fractionalPartGroupingPositions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|fractionalPartGroupingPosition
init|=
name|fractionalPartGroupingPositions
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|groupingIdx
init|=
name|idxDecimalSeparator
operator|+
literal|1
operator|+
name|fractionalPartGroupingPosition
decl_stmt|;
name|relGroupingOffsets
index|[
name|i
index|]
operator|=
name|groupingIdx
expr_stmt|;
block|}
name|formatted
operator|.
name|insert
argument_list|(
name|relGroupingOffsets
argument_list|,
name|decimalFormat
operator|.
name|groupingSeparator
argument_list|)
expr_stmt|;
comment|/*             if (groupingIdx<= formatted.length()) {                     formatted = formatted.substring(0, groupingIdx) + decimalFormat.groupingSeparator + formatted.substring(groupingIdx);                 } else {                     break;                 }              */
name|fractLen
operator|=
name|idxDecimalSeparator
operator|>
operator|-
literal|1
condition|?
name|formatted
operator|.
name|length
argument_list|()
operator|-
operator|(
name|idxDecimalSeparator
operator|+
literal|1
operator|)
else|:
literal|0
expr_stmt|;
block|}
comment|// Rule 12 - strip decimal separator if unneeded
if|if
condition|(
operator|!
name|subPicture
operator|.
name|hasDecimalSeparator
argument_list|()
operator|||
name|fractLen
operator|==
literal|0
condition|)
block|{
name|formatted
operator|.
name|removeFirst
argument_list|(
name|decimalFormat
operator|.
name|decimalSeparator
argument_list|)
expr_stmt|;
block|}
comment|// Rule 13 - add exponent if exists
specifier|final
name|int
name|minimumExponentSize
init|=
name|subPicture
operator|.
name|getMinimumExponentSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|minimumExponentSize
operator|>
literal|0
condition|)
block|{
name|formatted
operator|.
name|append
argument_list|(
name|decimalFormat
operator|.
name|exponentSeparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
block|{
name|formatted
operator|.
name|append
argument_list|(
name|decimalFormat
operator|.
name|minusSign
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CodePointString
name|expStr
init|=
operator|new
name|CodePointString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|expPadLen
init|=
name|subPicture
operator|.
name|getMinimumExponentSize
argument_list|()
operator|-
name|expStr
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|expPadLen
operator|>
literal|0
condition|)
block|{
name|expStr
operator|.
name|leftPad
argument_list|(
name|decimalFormat
operator|.
name|zeroDigit
argument_list|,
name|expPadLen
argument_list|)
expr_stmt|;
block|}
name|formatted
operator|.
name|append
argument_list|(
name|expStr
argument_list|)
expr_stmt|;
block|}
comment|// Rule 14 - concatenate prefix, formatted number, and suffix
specifier|final
name|String
name|result
init|=
name|subPicture
operator|.
name|getPrefixString
argument_list|()
operator|+
name|formatted
operator|.
name|toString
argument_list|()
operator|+
name|subPicture
operator|.
name|getSuffixString
argument_list|()
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Data class for a SubPicture.      *      * See https://www.w3.org/TR/xpath-functions-31/#analyzing-picture-string      */
specifier|private
specifier|static
class|class
name|SubPicture
block|{
specifier|private
name|int
index|[]
name|integerPartGroupingPositions
decl_stmt|;
specifier|private
name|int
name|minimumIntegerPartSize
decl_stmt|;
specifier|private
name|int
name|scalingFactor
decl_stmt|;
specifier|private
name|StringBuilder
name|prefix
decl_stmt|;
specifier|private
name|int
index|[]
name|fractionalPartGroupingPositions
decl_stmt|;
specifier|private
name|int
name|minimumFractionalPartSize
decl_stmt|;
specifier|private
name|int
name|maximumFractionalPartSize
decl_stmt|;
specifier|private
name|int
name|minimumExponentSize
decl_stmt|;
specifier|private
name|StringBuilder
name|suffix
decl_stmt|;
comment|// state needed for adjustment
specifier|private
name|boolean
name|hasIntegerOptionalDigit
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasPercent
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasPerMille
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasDecimalSeparator
init|=
literal|false
decl_stmt|;
specifier|public
name|SubPicture
name|copy
parameter_list|()
block|{
specifier|final
name|SubPicture
name|copy
init|=
operator|new
name|SubPicture
argument_list|()
decl_stmt|;
name|copy
operator|.
name|integerPartGroupingPositions
operator|=
name|integerPartGroupingPositions
operator|==
literal|null
condition|?
literal|null
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|integerPartGroupingPositions
argument_list|,
name|integerPartGroupingPositions
operator|.
name|length
argument_list|)
expr_stmt|;
name|copy
operator|.
name|minimumIntegerPartSize
operator|=
name|minimumIntegerPartSize
expr_stmt|;
name|copy
operator|.
name|scalingFactor
operator|=
name|scalingFactor
expr_stmt|;
name|copy
operator|.
name|prefix
operator|=
name|prefix
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|StringBuilder
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|copy
operator|.
name|fractionalPartGroupingPositions
operator|=
name|fractionalPartGroupingPositions
operator|==
literal|null
condition|?
literal|null
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|fractionalPartGroupingPositions
argument_list|,
name|fractionalPartGroupingPositions
operator|.
name|length
argument_list|)
expr_stmt|;
name|copy
operator|.
name|minimumFractionalPartSize
operator|=
name|minimumFractionalPartSize
expr_stmt|;
name|copy
operator|.
name|maximumFractionalPartSize
operator|=
name|maximumFractionalPartSize
expr_stmt|;
name|copy
operator|.
name|minimumExponentSize
operator|=
name|minimumExponentSize
expr_stmt|;
name|copy
operator|.
name|suffix
operator|=
name|suffix
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|StringBuilder
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|copy
operator|.
name|hasIntegerOptionalDigit
operator|=
name|hasIntegerOptionalDigit
expr_stmt|;
name|copy
operator|.
name|hasPercent
operator|=
name|hasPercent
expr_stmt|;
name|copy
operator|.
name|hasPerMille
operator|=
name|hasPerMille
expr_stmt|;
name|copy
operator|.
name|hasDecimalSeparator
operator|=
name|hasDecimalSeparator
expr_stmt|;
return|return
name|copy
return|;
block|}
specifier|public
name|SubPicture
name|negate
parameter_list|(
specifier|final
name|DecimalFormat
name|decimalFormat
parameter_list|)
block|{
name|this
operator|.
name|prefix
operator|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|appendCodePoint
argument_list|(
name|decimalFormat
operator|.
name|minusSign
argument_list|)
operator|.
name|append
argument_list|(
name|getPrefixString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|void
name|newIntegerPartGroupingPosition
parameter_list|()
block|{
if|if
condition|(
name|integerPartGroupingPositions
operator|==
literal|null
condition|)
block|{
name|integerPartGroupingPositions
operator|=
operator|new
name|int
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|integerPartGroupingPositions
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|integerPartGroupingPositions
argument_list|,
name|integerPartGroupingPositions
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|incrementIntegerPartGroupingPosition
parameter_list|()
block|{
if|if
condition|(
name|integerPartGroupingPositions
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|integerPartGroupingPositions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|integerPartGroupingPositions
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
specifier|public
annotation|@
name|Nullable
name|int
index|[]
name|getIntegerPartGroupingPositions
parameter_list|()
block|{
return|return
name|integerPartGroupingPositions
return|;
block|}
comment|/**          * Determines if the<code>integer-part-grouping-positions</code> are regular.          *          * @return the value of G if regular, or -1 if irregular          */
specifier|public
name|int
name|integerPartGroupingPositionsAreRegular
parameter_list|()
block|{
comment|// There is an least one grouping-separator in the integer part of the sub-picture.
if|if
condition|(
name|integerPartGroupingPositions
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// There is a positive integer G (the grouping size) such that the position of every grouping-separator
comment|// in the integer part of the sub-picture is a positive integer multiple of G.
specifier|final
name|int
name|smallestGroupPosition
init|=
name|integerPartGroupingPositions
index|[
name|integerPartGroupingPositions
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|g
init|=
name|smallestGroupPosition
decl_stmt|;
name|boolean
name|divisible
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
name|g
operator|>
literal|0
condition|;
name|g
operator|--
control|)
block|{
name|divisible
operator|=
literal|false
expr_stmt|;
for|for
control|(
specifier|final
name|int
name|integerPartGroupingPosition
range|:
name|integerPartGroupingPositions
control|)
block|{
name|divisible
operator|=
name|integerPartGroupingPosition
operator|%
name|g
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|divisible
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|divisible
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|divisible
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// Every position in the integer part of the sub-picture that is a positive integer multiple of G is
comment|// occupied by a grouping-separator.
specifier|final
name|int
name|largestGroupPosition
init|=
name|integerPartGroupingPositions
index|[
name|integerPartGroupingPositions
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|m
init|=
literal|2
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
name|g
init|;
name|p
operator|<=
name|largestGroupPosition
condition|;
name|p
operator|=
name|g
operator|*
name|m
operator|++
control|)
block|{
name|boolean
name|isGroupSeparator
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|integerPartGroupingPosition
range|:
name|integerPartGroupingPositions
control|)
block|{
if|if
condition|(
name|integerPartGroupingPosition
operator|==
name|p
condition|)
block|{
name|isGroupSeparator
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isGroupSeparator
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|g
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|public
name|void
name|incrementMinimumIntegerPartSize
parameter_list|()
block|{
name|minimumIntegerPartSize
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|getMinimumIntegerPartSize
parameter_list|()
block|{
return|return
name|minimumIntegerPartSize
return|;
block|}
specifier|public
name|void
name|incrementScalingFactor
parameter_list|()
block|{
name|scalingFactor
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|getScalingFactor
parameter_list|()
block|{
return|return
name|scalingFactor
return|;
block|}
specifier|public
name|void
name|appendPrefix
parameter_list|(
specifier|final
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
literal|null
condition|)
block|{
name|prefix
operator|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
name|prefix
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|getPrefixString
parameter_list|()
block|{
if|if
condition|(
name|prefix
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
return|return
name|prefix
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|public
name|void
name|newFractionalPartGroupingPosition
parameter_list|()
block|{
if|if
condition|(
name|fractionalPartGroupingPositions
operator|==
literal|null
condition|)
block|{
name|fractionalPartGroupingPositions
operator|=
operator|new
name|int
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|fractionalPartGroupingPositions
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|fractionalPartGroupingPositions
argument_list|,
name|fractionalPartGroupingPositions
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|fractionalPartGroupingPositions
index|[
name|fractionalPartGroupingPositions
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|maximumFractionalPartSize
expr_stmt|;
block|}
specifier|public
annotation|@
name|Nullable
name|int
index|[]
name|getFractionalPartGroupingPositions
parameter_list|()
block|{
return|return
name|fractionalPartGroupingPositions
return|;
block|}
specifier|public
name|void
name|incrementMinimumFractionalPartSize
parameter_list|()
block|{
name|minimumFractionalPartSize
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|getMinimumFractionalPartSize
parameter_list|()
block|{
return|return
name|minimumFractionalPartSize
return|;
block|}
specifier|public
name|void
name|incrementMaximumFractionalPartSize
parameter_list|()
block|{
name|maximumFractionalPartSize
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|getMaximumFractionalPartSize
parameter_list|()
block|{
return|return
name|maximumFractionalPartSize
return|;
block|}
specifier|public
name|void
name|incrementMinimumExponentSize
parameter_list|()
block|{
name|minimumExponentSize
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|getMinimumExponentSize
parameter_list|()
block|{
return|return
name|minimumExponentSize
return|;
block|}
specifier|public
name|void
name|appendSuffix
parameter_list|(
specifier|final
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|suffix
operator|==
literal|null
condition|)
block|{
name|suffix
operator|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suffix
operator|=
name|suffix
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|clearSuffix
parameter_list|()
block|{
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|)
block|{
name|suffix
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|getSuffixString
parameter_list|()
block|{
if|if
condition|(
name|suffix
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
return|return
name|suffix
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|public
name|void
name|setHasIntegerOptionalDigit
parameter_list|(
specifier|final
name|boolean
name|hasIntegerOptionalDigit
parameter_list|)
block|{
name|this
operator|.
name|hasIntegerOptionalDigit
operator|=
name|hasIntegerOptionalDigit
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasIntegerOptionalDigit
parameter_list|()
block|{
return|return
name|hasIntegerOptionalDigit
return|;
block|}
specifier|public
name|void
name|setHasPercent
parameter_list|(
specifier|final
name|boolean
name|hasPercent
parameter_list|)
block|{
name|this
operator|.
name|hasPercent
operator|=
name|hasPercent
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasPercent
parameter_list|()
block|{
return|return
name|hasPercent
return|;
block|}
specifier|public
name|void
name|setHasPerMille
parameter_list|(
specifier|final
name|boolean
name|hasPerMille
parameter_list|)
block|{
name|this
operator|.
name|hasPerMille
operator|=
name|hasPerMille
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasPerMille
parameter_list|()
block|{
return|return
name|hasPerMille
return|;
block|}
specifier|public
name|void
name|setHasDecimalSeparator
parameter_list|(
specifier|final
name|boolean
name|hasDecimalSeparator
parameter_list|)
block|{
name|this
operator|.
name|hasDecimalSeparator
operator|=
name|hasDecimalSeparator
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasDecimalSeparator
parameter_list|()
block|{
return|return
name|hasDecimalSeparator
return|;
block|}
specifier|public
name|SubPicture
name|adjust
parameter_list|()
block|{
if|if
condition|(
name|minimumIntegerPartSize
operator|==
literal|0
operator|&&
name|maximumFractionalPartSize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|minimumExponentSize
operator|>
literal|0
condition|)
block|{
name|minimumFractionalPartSize
operator|=
literal|1
expr_stmt|;
name|maximumFractionalPartSize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|minimumIntegerPartSize
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minimumExponentSize
operator|>
literal|0
operator|&&
name|minimumIntegerPartSize
operator|==
literal|0
operator|&&
name|hasIntegerOptionalDigit
condition|)
block|{
name|minimumIntegerPartSize
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|minimumIntegerPartSize
operator|==
literal|0
operator|&&
name|minimumFractionalPartSize
operator|==
literal|0
condition|)
block|{
name|minimumFractionalPartSize
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
block|}
block|}
end_class

end_unit

