begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2007 The eXist team  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software Foundation  *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  *  *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|stax
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|NamespaceContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|StreamFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|CharacterDataImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ElementImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|StoredNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|Signatures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|RawNodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|XMLString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|serializer
operator|.
name|AttrList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|ProcessingInstruction
import|;
end_import

begin_comment
comment|/**  * Lazy implementation of a StAX {@link javax.xml.stream.XMLStreamReader}, which directly reads  * information from the persistent DOM. The class is optimized to support fast scanning of the DOM, where only  * a few selected node properties are requested. Node properties are extracted on demand. For example, the QName of  * an element will not be read unless {@link #getText()} is called.  */
end_comment

begin_class
specifier|public
class|class
name|EmbeddedXMLStreamReader
implements|implements
name|ExtendedXMLStreamReader
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|EmbeddedXMLStreamReader
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|RawNodeIterator
name|iterator
decl_stmt|;
specifier|private
name|Value
name|current
init|=
literal|null
decl_stmt|;
specifier|private
name|Value
name|previous
init|=
literal|null
decl_stmt|;
specifier|private
name|Stack
name|elementStack
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
specifier|private
name|int
name|state
init|=
name|START_DOCUMENT
decl_stmt|;
specifier|private
name|boolean
name|beforeRoot
init|=
literal|false
decl_stmt|;
specifier|private
name|DocumentImpl
name|document
decl_stmt|;
specifier|private
name|NodeId
name|nodeId
decl_stmt|;
specifier|private
name|NodeHandle
name|origin
decl_stmt|;
specifier|private
name|QName
name|qname
init|=
literal|null
decl_stmt|;
specifier|private
name|XMLString
name|text
init|=
operator|new
name|XMLString
argument_list|(
literal|256
argument_list|)
decl_stmt|;
specifier|private
name|List
name|namespaces
init|=
operator|new
name|ArrayList
argument_list|(
literal|6
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|nsRead
init|=
literal|false
decl_stmt|;
specifier|private
name|AttrList
name|attributes
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|reportAttribs
init|=
literal|false
decl_stmt|;
specifier|private
name|DBBroker
name|broker
decl_stmt|;
comment|/**      * Construct an EmbeddedXMLStreamReader.      *      * @param doc the document to which the start node belongs.      * @param iterator a RawNodeIterator positioned on the start node.      * @param origin an optional NodeHandle whose nodeId should match the first node in the stream      *     (or null if no need to check)      * @param reportAttributes if set to true, attributes will be reported as top-level events.      * @throws XMLStreamException      */
specifier|public
name|EmbeddedXMLStreamReader
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|RawNodeIterator
name|iterator
parameter_list|,
name|NodeHandle
name|origin
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|XMLStreamException
block|{
name|this
operator|.
name|broker
operator|=
name|broker
expr_stmt|;
name|this
operator|.
name|document
operator|=
name|doc
expr_stmt|;
name|this
operator|.
name|iterator
operator|=
name|iterator
expr_stmt|;
name|this
operator|.
name|reportAttribs
operator|=
name|reportAttributes
expr_stmt|;
name|this
operator|.
name|origin
operator|=
name|origin
expr_stmt|;
block|}
specifier|public
name|void
name|filter
parameter_list|(
name|StreamFilter
name|filter
parameter_list|)
throws|throws
name|XMLStreamException
block|{
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|filter
operator|.
name|accept
argument_list|(
name|this
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/**      * Reposition the stream reader to another start node, maybe in a different document.      *      * @param node the new start node.      * @param reportAttributes if set to true, attributes will be reported as top-level events.      * @throws IOException      */
specifier|public
name|void
name|reposition
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|broker
operator|=
name|broker
expr_stmt|;
comment|// Seeking to a node with unknown address will reuse this reader, so do it before setting all
comment|// the fields otherwise they could get overwritten.
name|iterator
operator|.
name|seek
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|current
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|previous
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|elementStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|START_DOCUMENT
expr_stmt|;
name|this
operator|.
name|reportAttribs
operator|=
name|reportAttributes
expr_stmt|;
name|this
operator|.
name|document
operator|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
expr_stmt|;
name|this
operator|.
name|origin
operator|=
name|node
expr_stmt|;
block|}
specifier|public
name|short
name|getNodeType
parameter_list|()
block|{
return|return
name|Signatures
operator|.
name|getType
argument_list|(
name|current
operator|.
name|data
argument_list|()
index|[
name|current
operator|.
name|start
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|private
name|void
name|initNode
parameter_list|()
block|{
specifier|final
name|short
name|type
init|=
name|Signatures
operator|.
name|getType
argument_list|(
name|current
operator|.
name|data
argument_list|()
index|[
name|current
operator|.
name|start
argument_list|()
index|]
argument_list|)
decl_stmt|;
comment|// TODO: remove potential NPE
if|if
condition|(
name|state
operator|==
name|START_DOCUMENT
operator|&&
name|type
operator|!=
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|beforeRoot
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|state
operator|=
name|START_ELEMENT
expr_stmt|;
name|elementStack
operator|.
name|push
argument_list|(
operator|new
name|ElementEvent
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|beforeRoot
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|state
operator|=
name|ATTRIBUTE
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|state
operator|=
name|CHARACTERS
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
name|state
operator|=
name|COMMENT
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|CDATA_SECTION_NODE
case|:
name|state
operator|=
name|CDATA
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
name|state
operator|=
name|PROCESSING_INSTRUCTION
expr_stmt|;
break|break;
block|}
name|reset
argument_list|()
expr_stmt|;
name|readNodeId
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|getChildCount
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|START_ELEMENT
condition|)
return|return
operator|(
operator|(
name|ElementEvent
operator|)
name|elementStack
operator|.
name|peek
argument_list|()
operator|)
operator|.
name|getChildCount
argument_list|()
return|;
return|return
literal|0
return|;
block|}
specifier|private
name|void
name|skipAttributes
parameter_list|()
throws|throws
name|XMLStreamException
block|{
if|if
condition|(
name|attributes
operator|==
literal|null
condition|)
block|{
comment|// attributes were not yet read. skip them...
specifier|final
name|ElementEvent
name|parent
init|=
operator|(
name|ElementEvent
operator|)
name|elementStack
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|int
name|attrs
init|=
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrs
condition|;
name|i
operator|++
control|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|parent
operator|.
name|incrementChild
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|readAttributes
parameter_list|()
block|{
if|if
condition|(
name|attributes
operator|==
literal|null
condition|)
block|{
specifier|final
name|ElementEvent
name|parent
init|=
operator|(
name|ElementEvent
operator|)
name|elementStack
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|getAttributeCount
argument_list|()
decl_stmt|;
name|attributes
operator|=
operator|new
name|AttrList
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|Value
name|v
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|AttrImpl
operator|.
name|addToList
argument_list|(
name|broker
argument_list|,
name|v
operator|.
name|data
argument_list|()
argument_list|,
name|v
operator|.
name|start
argument_list|()
argument_list|,
name|v
operator|.
name|getLength
argument_list|()
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|parent
operator|.
name|incrementChild
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|readNodeId
parameter_list|()
block|{
name|int
name|offset
init|=
name|current
operator|.
name|start
argument_list|()
operator|+
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|START_ELEMENT
operator|||
name|state
operator|==
name|END_ELEMENT
condition|)
name|offset
operator|+=
name|ElementImpl
operator|.
name|LENGTH_ELEMENT_CHILD_COUNT
expr_stmt|;
name|int
name|dlnLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|current
operator|.
name|data
argument_list|()
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
expr_stmt|;
name|nodeId
operator|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNodeFactory
argument_list|()
operator|.
name|createFromData
argument_list|(
name|dlnLen
argument_list|,
name|current
operator|.
name|data
argument_list|()
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|next
parameter_list|()
throws|throws
name|XMLStreamException
block|{
if|if
condition|(
name|state
operator|!=
name|END_ELEMENT
condition|)
name|previous
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|START_ELEMENT
operator|&&
operator|!
name|reportAttribs
condition|)
name|skipAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|elementStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ElementEvent
name|parent
init|=
operator|(
name|ElementEvent
operator|)
name|elementStack
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|.
name|getChildCount
argument_list|()
operator|==
name|parent
operator|.
name|getCurrentChild
argument_list|()
condition|)
block|{
name|elementStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|state
operator|=
name|END_ELEMENT
expr_stmt|;
name|current
operator|=
name|parent
operator|.
name|data
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
return|return
name|state
return|;
block|}
else|else
block|{
name|parent
operator|.
name|incrementChild
argument_list|()
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|state
operator|!=
name|START_DOCUMENT
operator|&&
operator|!
name|beforeRoot
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|boolean
name|first
init|=
name|state
operator|==
name|START_DOCUMENT
decl_stmt|;
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|initNode
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|origin
operator|!=
literal|null
condition|)
block|{
name|verifyOriginNodeId
argument_list|()
expr_stmt|;
name|origin
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
specifier|private
name|void
name|verifyOriginNodeId
parameter_list|()
throws|throws
name|XMLStreamException
block|{
if|if
condition|(
operator|!
name|nodeId
operator|.
name|equals
argument_list|(
name|origin
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
comment|// Node got moved, we had the wrong address.  Resync iterator by nodeid.
name|LOG
operator|.
name|warn
argument_list|(
literal|"expected node id "
operator|+
name|origin
operator|.
name|getNodeId
argument_list|()
operator|+
literal|", got "
operator|+
name|nodeId
operator|+
literal|"; resyncing address"
argument_list|)
expr_stmt|;
name|origin
operator|.
name|setInternalAddress
argument_list|(
name|StoredNode
operator|.
name|UNKNOWN_NODE_IMPL_ADDRESS
argument_list|)
expr_stmt|;
name|boolean
name|reportAttribsBackup
init|=
name|reportAttribs
decl_stmt|;
name|DocumentImpl
name|documentBackup
init|=
name|document
decl_stmt|;
try|try
block|{
name|iterator
operator|.
name|seek
argument_list|(
name|origin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XMLStreamException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Seeking the iterator might've reused this reader, so reset all fields.
name|reset
argument_list|()
expr_stmt|;
name|previous
operator|=
literal|null
expr_stmt|;
name|elementStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reportAttribs
operator|=
name|reportAttribsBackup
expr_stmt|;
name|document
operator|=
name|documentBackup
expr_stmt|;
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|initNode
argument_list|()
expr_stmt|;
name|origin
operator|.
name|setInternalAddress
argument_list|(
name|iterator
operator|.
name|currentAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|nodeId
operator|=
literal|null
expr_stmt|;
name|qname
operator|=
literal|null
expr_stmt|;
name|attributes
operator|=
literal|null
expr_stmt|;
name|text
operator|.
name|reuse
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|END_ELEMENT
condition|)
block|{
name|namespaces
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nsRead
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|require
parameter_list|(
name|int
name|i
parameter_list|,
name|String
name|string
parameter_list|,
name|String
name|string1
parameter_list|)
throws|throws
name|XMLStreamException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|String
name|getElementText
parameter_list|()
throws|throws
name|XMLStreamException
block|{
if|if
condition|(
name|getEventType
argument_list|()
operator|!=
name|START_ELEMENT
condition|)
block|{
throw|throw
operator|new
name|XMLStreamException
argument_list|(
literal|"parser must be on START_ELEMENT to read next text"
argument_list|)
throw|;
block|}
name|int
name|eventType
init|=
name|next
argument_list|()
decl_stmt|;
name|StringBuffer
name|content
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|eventType
operator|!=
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|eventType
operator|==
name|CHARACTERS
operator|||
name|eventType
operator|==
name|CDATA
operator|||
name|eventType
operator|==
name|SPACE
operator|||
name|eventType
operator|==
name|ENTITY_REFERENCE
condition|)
block|{
name|content
operator|.
name|append
argument_list|(
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|eventType
operator|==
name|PROCESSING_INSTRUCTION
operator|||
name|eventType
operator|==
name|COMMENT
condition|)
block|{
comment|// skipping
block|}
if|else if
condition|(
name|eventType
operator|==
name|END_DOCUMENT
condition|)
block|{
throw|throw
operator|new
name|XMLStreamException
argument_list|(
literal|"unexpected end of document when reading element text content"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|eventType
operator|==
name|START_ELEMENT
condition|)
block|{
throw|throw
operator|new
name|XMLStreamException
argument_list|(
literal|"element text content may not contain START_ELEMENT"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|XMLStreamException
argument_list|(
literal|"Unexpected event type "
operator|+
name|eventType
argument_list|)
throw|;
block|}
name|eventType
operator|=
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|content
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|Object
name|getProperty
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|string
operator|.
name|equals
argument_list|(
name|PROPERTY_NODE_ID
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodeId
operator|==
literal|null
condition|)
name|readNodeId
argument_list|()
expr_stmt|;
return|return
name|nodeId
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|int
name|nextTag
parameter_list|()
throws|throws
name|XMLStreamException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|XMLStreamException
block|{
return|return
name|state
operator|==
name|START_DOCUMENT
operator|||
name|beforeRoot
operator|||
operator|!
name|elementStack
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|XMLStreamException
block|{
name|iterator
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isStartElement
parameter_list|()
block|{
return|return
name|state
operator|==
name|START_ELEMENT
return|;
block|}
specifier|public
name|boolean
name|isEndElement
parameter_list|()
block|{
return|return
name|state
operator|==
name|END_ELEMENT
return|;
block|}
specifier|public
name|boolean
name|isCharacters
parameter_list|()
block|{
return|return
name|state
operator|==
name|CHARACTERS
return|;
block|}
specifier|public
name|boolean
name|isWhiteSpace
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|String
name|getAttributeValue
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|String
name|localName
parameter_list|)
block|{
name|readAttributes
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
name|qn
init|=
name|attributes
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qn
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|equals
argument_list|(
name|namespaceURI
argument_list|)
operator|&&
name|qn
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|localName
argument_list|)
condition|)
return|return
name|attributes
operator|.
name|getValue
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|int
name|getAttributeCount
parameter_list|()
block|{
name|int
name|offset
init|=
name|current
operator|.
name|start
argument_list|()
operator|+
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
operator|+
name|ElementImpl
operator|.
name|LENGTH_ELEMENT_CHILD_COUNT
operator|+
name|NodeId
operator|.
name|LENGTH_NODE_ID_UNITS
operator|+
name|nodeId
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|current
operator|.
name|data
argument_list|()
argument_list|,
name|offset
argument_list|)
return|;
block|}
specifier|public
name|QName
name|getAttributeName
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
operator|.
name|toJavaQName
argument_list|()
return|;
block|}
specifier|public
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
name|getAttributeQName
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
return|;
block|}
specifier|public
name|String
name|getAttributeNamespace
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
operator|.
name|getNamespaceURI
argument_list|()
return|;
block|}
specifier|public
name|String
name|getAttributeLocalName
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
operator|.
name|getLocalName
argument_list|()
return|;
block|}
specifier|public
name|String
name|getAttributePrefix
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
operator|.
name|getPrefix
argument_list|()
return|;
block|}
specifier|public
name|String
name|getAttributeType
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
specifier|final
name|int
name|type
init|=
name|attributes
operator|.
name|getType
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|AttrImpl
operator|.
name|getAttributeType
argument_list|(
name|type
argument_list|)
return|;
block|}
specifier|public
name|String
name|getAttributeValue
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getValue
argument_list|(
name|i
argument_list|)
return|;
block|}
specifier|public
name|NodeId
name|getAttributeId
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|START_ELEMENT
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at an element"
argument_list|)
throw|;
name|readAttributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|attributes
operator|.
name|getLength
argument_list|()
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"index should be< "
operator|+
name|attributes
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
return|return
name|attributes
operator|.
name|getNodeId
argument_list|(
name|i
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isAttributeSpecified
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|int
name|getNamespaceCount
parameter_list|()
block|{
name|readNamespaceDecls
argument_list|()
expr_stmt|;
return|return
name|namespaces
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|String
name|getNamespacePrefix
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|readNamespaceDecls
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|namespaces
operator|.
name|size
argument_list|()
condition|)
return|return
literal|null
return|;
name|String
index|[]
name|decl
init|=
operator|(
name|String
index|[]
operator|)
name|namespaces
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|decl
index|[
literal|0
index|]
return|;
block|}
specifier|public
name|String
name|getNamespaceURI
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|readNamespaceDecls
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|namespaces
operator|.
name|size
argument_list|()
condition|)
return|return
literal|null
return|;
name|String
index|[]
name|decl
init|=
operator|(
name|String
index|[]
operator|)
name|namespaces
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|decl
index|[
literal|1
index|]
return|;
block|}
specifier|public
name|NamespaceContext
name|getNamespaceContext
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getEventType
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|public
name|XMLString
name|getXMLText
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|CHARACTERS
operator|||
name|state
operator|==
name|COMMENT
operator|||
name|state
operator|==
name|CDATA
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|CharacterDataImpl
operator|.
name|readData
argument_list|(
name|nodeId
argument_list|,
name|current
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
return|return
operator|new
name|XMLString
argument_list|()
return|;
block|}
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|getXMLText
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|char
index|[]
name|getTextCharacters
parameter_list|()
block|{
name|String
name|s
init|=
name|getText
argument_list|()
decl_stmt|;
name|char
index|[]
name|dst
init|=
operator|new
name|char
index|[
name|s
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|s
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|dst
operator|.
name|length
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
block|}
specifier|public
name|int
name|getTextCharacters
parameter_list|(
name|int
name|sourceStart
parameter_list|,
name|char
index|[]
name|chars
parameter_list|,
name|int
name|targetStart
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|XMLStreamException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTextStart
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTextLength
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|CHARACTERS
operator|||
name|state
operator|==
name|COMMENT
operator|||
name|state
operator|==
name|CDATA
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|CharacterDataImpl
operator|.
name|getStringLength
argument_list|(
name|nodeId
argument_list|,
name|current
argument_list|)
return|;
return|return
name|text
operator|.
name|length
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|public
name|String
name|getEncoding
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|hasText
parameter_list|()
block|{
return|return
name|state
operator|==
name|CHARACTERS
operator|||
name|state
operator|==
name|COMMENT
operator|||
name|state
operator|==
name|CDATA
return|;
block|}
specifier|public
name|Location
name|getLocation
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|String
name|getNamespaceURI
parameter_list|(
name|String
name|string
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|QName
name|getName
parameter_list|()
block|{
if|if
condition|(
name|qname
operator|!=
literal|null
condition|)
return|return
name|qname
return|;
if|if
condition|(
name|state
operator|==
name|START_ELEMENT
operator|||
name|state
operator|==
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|nodeId
operator|==
literal|null
condition|)
name|readNodeId
argument_list|()
expr_stmt|;
name|qname
operator|=
name|ElementImpl
operator|.
name|readQName
argument_list|(
name|current
argument_list|,
name|document
argument_list|,
name|nodeId
argument_list|)
operator|.
name|toJavaQName
argument_list|()
expr_stmt|;
block|}
return|return
name|qname
return|;
block|}
specifier|public
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
name|getQName
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|START_ELEMENT
operator|||
name|state
operator|==
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|nodeId
operator|==
literal|null
condition|)
name|readNodeId
argument_list|()
expr_stmt|;
return|return
name|ElementImpl
operator|.
name|readQName
argument_list|(
name|current
argument_list|,
name|document
argument_list|,
name|nodeId
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Read all namespace declarations defined on the current element.      * Cache them in the namespaces map.      */
specifier|private
name|void
name|readNamespaceDecls
parameter_list|()
block|{
if|if
condition|(
name|nsRead
condition|)
return|return;
if|if
condition|(
name|state
operator|==
name|START_ELEMENT
operator|||
name|state
operator|==
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|nodeId
operator|==
literal|null
condition|)
name|readNodeId
argument_list|()
expr_stmt|;
name|ElementImpl
operator|.
name|readNamespaceDecls
argument_list|(
name|namespaces
argument_list|,
name|current
argument_list|,
name|document
argument_list|,
name|nodeId
argument_list|)
expr_stmt|;
block|}
name|nsRead
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|String
name|getPrefix
parameter_list|()
block|{
return|return
name|getName
argument_list|()
operator|.
name|getPrefix
argument_list|()
return|;
block|}
specifier|public
name|String
name|getLocalName
parameter_list|()
block|{
return|return
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
return|;
block|}
specifier|public
name|String
name|getNamespaceURI
parameter_list|()
block|{
return|return
name|getName
argument_list|()
operator|.
name|getNamespaceURI
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|hasName
parameter_list|()
block|{
return|return
operator|(
name|state
operator|==
name|START_ELEMENT
operator|||
name|state
operator|==
name|END_ELEMENT
operator|)
return|;
block|}
comment|/**      * Deserialize the node at the current position of the cursor and return      * it as a {@link org.exist.dom.StoredNode}.      *      * @return the node at the current position.      */
specifier|public
name|StoredNode
name|getNode
parameter_list|()
block|{
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|current
operator|.
name|data
argument_list|()
argument_list|,
name|current
operator|.
name|start
argument_list|()
argument_list|,
name|current
operator|.
name|getLength
argument_list|()
argument_list|,
name|document
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|current
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**      * Returns the last node in document sequence that occurs before the      * current node. Usually used to find the last child before an END_ELEMENT      * event.      *      * @return the last node in document sequence before the current node      */
specifier|public
name|StoredNode
name|getPreviousNode
parameter_list|()
block|{
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|previous
operator|.
name|data
argument_list|()
argument_list|,
name|previous
operator|.
name|start
argument_list|()
argument_list|,
name|previous
operator|.
name|getLength
argument_list|()
argument_list|,
name|document
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|previous
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**      * Returns the (internal) address of the node at the cursor's current      * position.      *       * @return internal address of node      */
specifier|public
name|long
name|getCurrentPosition
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|currentAddress
argument_list|()
return|;
block|}
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
literal|"1.0"
return|;
block|}
specifier|public
name|boolean
name|isStandalone
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|standaloneSet
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|String
name|getCharacterEncodingScheme
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|String
name|getPITarget
parameter_list|()
block|{
name|readPI
argument_list|()
expr_stmt|;
return|return
name|qname
operator|.
name|getLocalPart
argument_list|()
return|;
block|}
specifier|public
name|String
name|getPIData
parameter_list|()
block|{
name|readPI
argument_list|()
expr_stmt|;
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|readPI
parameter_list|()
block|{
if|if
condition|(
name|qname
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|PROCESSING_INSTRUCTION
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cursor is not at a processing instruction"
argument_list|)
throw|;
name|ProcessingInstruction
name|pi
init|=
operator|(
name|ProcessingInstruction
operator|)
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|current
operator|.
name|data
argument_list|()
argument_list|,
name|current
operator|.
name|start
argument_list|()
argument_list|,
name|current
operator|.
name|getLength
argument_list|()
argument_list|,
name|document
argument_list|)
decl_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
literal|""
argument_list|,
name|pi
operator|.
name|getTarget
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|text
operator|.
name|append
argument_list|(
name|pi
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|ElementEvent
block|{
specifier|private
name|Value
name|data
decl_stmt|;
specifier|private
name|int
name|childCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|currentChild
init|=
literal|0
decl_stmt|;
specifier|public
name|ElementEvent
parameter_list|(
name|Value
name|data
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|childCount
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|data
operator|.
name|start
argument_list|()
operator|+
name|StoredNode
operator|.
name|LENGTH_SIGNATURE_LENGTH
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Value
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
specifier|public
name|int
name|getChildCount
parameter_list|()
block|{
return|return
name|childCount
return|;
block|}
specifier|public
name|int
name|getCurrentChild
parameter_list|()
block|{
return|return
name|currentChild
return|;
block|}
specifier|public
name|void
name|setCurrentChild
parameter_list|(
name|int
name|currentChild
parameter_list|)
block|{
name|this
operator|.
name|currentChild
operator|=
name|currentChild
expr_stmt|;
block|}
specifier|public
name|void
name|incrementChild
parameter_list|()
block|{
name|currentChild
operator|++
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

