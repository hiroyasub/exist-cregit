begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 2012, Adam Retter  All rights reserved.   Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions are met:  * Redistributions of source code must retain the above copyright  notice, this list of conditions and the following disclaimer.  * Redistributions in binary form must reproduce the above copyright  notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.  * Neither the name of Adam Retter Consulting nor the  names of its contributors may be used to endorse or promote products  derived from this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL Adam Retter BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_comment
comment|/**  * Implementation of an Input Stream Filter that extends any InputStream with  * mark() and reset() capabilities by caching the read data for later  * re-reading.  *  * NOTE - Only supports reading data up to 2GB as the cache index uses an 'int'  * index  *  * @version 1.1  *  * @author Adam Retter<adam.retter@googlemail.com>  * @author Tobi Krebs<tobi.krebs AT gmail.com>  */
end_comment

begin_class
specifier|public
class|class
name|CachingFilterInputStream
extends|extends
name|FilterInputStream
block|{
comment|//TODO what about if the underlying stream supports marking
comment|//then we could just use its capabilities?
specifier|private
specifier|final
name|FilterInputStreamCache
name|cache
decl_stmt|;
specifier|private
name|int
name|srcOffset
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|mark
init|=
literal|0
decl_stmt|;
comment|/**      * Constructor which uses an existing Cache from a CachingFilterInputStream,      * if inputStream is a CachingFilterInputStream.      *      * @param inputStream      */
specifier|public
name|CachingFilterInputStream
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|InstantiationException
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputStream
operator|instanceof
name|CachingFilterInputStream
condition|)
block|{
name|this
operator|.
name|cache
operator|=
operator|(
operator|(
name|CachingFilterInputStream
operator|)
name|inputStream
operator|)
operator|.
name|getCache
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|InstantiationException
argument_list|(
literal|"Only CachingFilterInputStream are supported as InputStream"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|CachingFilterInputStream
parameter_list|(
specifier|final
name|FilterInputStreamCache
name|cache
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
block|}
comment|/**      * Gets the cache implementation      */
specifier|private
name|FilterInputStreamCache
name|getCache
parameter_list|()
block|{
return|return
name|cache
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getCache
argument_list|()
operator|.
name|available
argument_list|()
operator|-
name|srcOffset
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|mark
parameter_list|(
specifier|final
name|int
name|readLimit
parameter_list|)
block|{
name|mark
operator|=
name|srcOffset
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|srcOffset
operator|=
name|mark
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FilterInputStreamCache
operator|.
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
comment|//Read from cache
if|if
condition|(
name|useCache
argument_list|()
condition|)
block|{
specifier|final
name|int
name|data
init|=
name|getCache
argument_list|()
operator|.
name|get
argument_list|(
name|srcOffset
operator|++
argument_list|)
decl_stmt|;
return|return
name|data
return|;
block|}
else|else
block|{
specifier|final
name|int
name|data
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|()
decl_stmt|;
name|srcOffset
operator|++
expr_stmt|;
return|return
name|data
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|read
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FilterInputStreamCache
operator|.
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|if
condition|(
name|useCache
argument_list|()
condition|)
block|{
comment|//copy data from the cache
name|int
name|actualLen
init|=
operator|(
name|len
operator|>
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
condition|?
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
else|:
name|len
operator|)
decl_stmt|;
name|getCache
argument_list|()
operator|.
name|copyTo
argument_list|(
name|this
operator|.
name|srcOffset
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|actualLen
argument_list|)
expr_stmt|;
name|this
operator|.
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
comment|//if the requested bytes were more than what is present in the cache, then also read from the src
if|if
condition|(
name|actualLen
operator|<
name|len
condition|)
block|{
name|int
name|srcLen
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|actualLen
argument_list|,
name|len
operator|-
name|actualLen
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|srcLen
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
return|return
name|srcLen
return|;
block|}
comment|//increase srcOffset due to the read opertaion above
name|srcOffset
operator|+=
name|srcLen
expr_stmt|;
name|actualLen
operator|+=
name|srcLen
expr_stmt|;
block|}
return|return
name|actualLen
return|;
block|}
else|else
block|{
name|int
name|actualLen
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|actualLen
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to read operation above
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
return|return
name|actualLen
return|;
block|}
block|}
comment|/**      * Closes the src InputStream and empties the cache      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|getCache
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * We cant actually skip as we need to read so that we can cache the data,      * however apart from the potentially increased I/O and Memory, the end      * result is the same      */
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
specifier|final
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getCache
argument_list|()
operator|.
name|isSrcClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FilterInputStreamCache
operator|.
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|else if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|useCache
argument_list|()
condition|)
block|{
comment|//skip data from the cache
name|long
name|actualLen
init|=
operator|(
name|len
operator|>
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
condition|?
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|this
operator|.
name|srcOffset
else|:
name|len
operator|)
decl_stmt|;
comment|//if the requested bytes were more than what is present in the cache, then also read from the src
if|if
condition|(
name|actualLen
operator|<
name|len
condition|)
block|{
specifier|final
name|byte
name|skipped
index|[]
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
operator|(
name|len
operator|-
name|actualLen
operator|)
index|]
decl_stmt|;
name|int
name|srcLen
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|skipped
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|srcLen
operator|==
name|FilterInputStreamCache
operator|.
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to the read operation above
name|srcOffset
operator|+=
name|srcLen
expr_stmt|;
name|actualLen
operator|+=
name|srcLen
expr_stmt|;
block|}
return|return
name|actualLen
return|;
block|}
else|else
block|{
specifier|final
name|byte
name|skipped
index|[]
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|len
index|]
decl_stmt|;
comment|//TODO could overflow
name|int
name|actualLen
init|=
name|getCache
argument_list|()
operator|.
name|read
argument_list|(
name|skipped
argument_list|)
decl_stmt|;
comment|//increase srcOffset due to read operation above
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
return|return
name|actualLen
return|;
block|}
block|}
specifier|private
name|boolean
name|useCache
parameter_list|()
block|{
comment|//If cache hasRead and srcOffset is still in cache useCache
return|return
name|getCache
argument_list|()
operator|.
name|getSrcOffset
argument_list|()
operator|>
literal|0
operator|&&
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|>
name|srcOffset
return|;
block|}
block|}
end_class

end_unit

