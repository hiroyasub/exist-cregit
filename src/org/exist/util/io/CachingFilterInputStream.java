begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2012, Adam Retter All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither the name of Adam Retter Consulting nor the       names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Adam Retter BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_comment
comment|/**  * Implementation of an Input Stream Filter that extends  * any InputStream with mark() and reset() capabilities  * by caching the read data for later re-reading.  *  * NOTE - Only supports reading data up to 2GB as the cache index uses an 'int' index  *  * @version 1.0  *  * @author Adam Retter<adam.retter@googlemail.com>  */
end_comment

begin_class
specifier|public
class|class
name|CachingFilterInputStream
extends|extends
name|FilterInputStream
block|{
specifier|private
specifier|final
specifier|static
name|int
name|END_OF_STREAM
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|INPUTSTREAM_CLOSED
init|=
literal|"The underlying InputStream has been closed"
decl_stmt|;
specifier|private
specifier|final
name|InputStream
name|src
decl_stmt|;
specifier|private
specifier|final
name|FilterInputStreamCache
name|cache
decl_stmt|;
specifier|private
name|boolean
name|srcClosed
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|srcOffset
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|mark
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|useCache
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|cacheOffset
init|=
literal|0
decl_stmt|;
comment|//TODO ensure that FilterInputStreamCache implementations are thread-safe
comment|/**      * @param cache The cache implementation      * @param src The source InputStream to cache reads for      */
specifier|public
name|CachingFilterInputStream
parameter_list|(
specifier|final
name|FilterInputStreamCache
name|cache
parameter_list|,
specifier|final
name|InputStream
name|src
parameter_list|)
block|{
name|super
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
block|}
comment|/**      * Constructor which uses an existing CachingFilterInputStream as its      * underlying InputStream      *      * The position in the stream and any mark is reset to zero      */
specifier|public
name|CachingFilterInputStream
parameter_list|(
specifier|final
name|CachingFilterInputStream
name|cfis
parameter_list|)
block|{
name|this
argument_list|(
name|cfis
operator|.
name|getCache
argument_list|()
argument_list|,
name|cfis
argument_list|)
expr_stmt|;
name|this
operator|.
name|srcClosed
operator|=
name|cfis
operator|.
name|srcClosed
expr_stmt|;
name|this
operator|.
name|srcOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|mark
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|useCache
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|cacheOffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Gets the cache implementation      */
specifier|private
name|FilterInputStreamCache
name|getCache
parameter_list|()
block|{
return|return
name|cache
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|available
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|srcClosed
condition|)
block|{
name|available
operator|=
name|src
operator|.
name|available
argument_list|()
expr_stmt|;
if|if
condition|(
name|useCache
operator|&&
name|cacheOffset
operator|<
name|srcOffset
condition|)
block|{
name|available
operator|+=
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|cacheOffset
expr_stmt|;
block|}
block|}
return|return
name|available
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|mark
parameter_list|(
specifier|final
name|int
name|readLimit
parameter_list|)
block|{
name|mark
operator|=
name|srcOffset
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|useCache
operator|=
literal|true
expr_stmt|;
name|cacheOffset
operator|=
name|mark
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|srcClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|if
condition|(
name|useCache
operator|&&
name|cacheOffset
operator|<
name|srcOffset
condition|)
block|{
specifier|final
name|int
name|data
init|=
name|getCache
argument_list|()
operator|.
name|get
argument_list|(
name|cacheOffset
operator|++
argument_list|)
decl_stmt|;
comment|//are we outside the cache
if|if
condition|(
name|cacheOffset
operator|>=
name|srcOffset
condition|)
block|{
name|useCache
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
else|else
block|{
specifier|final
name|int
name|data
init|=
name|src
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|data
operator|==
name|END_OF_STREAM
condition|)
block|{
return|return
name|END_OF_STREAM
return|;
block|}
comment|//increment srcOffset due to read operation above
name|srcOffset
operator|++
expr_stmt|;
comment|//store data in cache
name|getCache
argument_list|()
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|read
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|srcClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|if
condition|(
name|useCache
operator|&&
name|cacheOffset
operator|<
name|srcOffset
condition|)
block|{
comment|//copy data from the cache
name|int
name|actualLen
init|=
operator|(
name|len
operator|>
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|cacheOffset
condition|?
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|cacheOffset
else|:
name|len
operator|)
decl_stmt|;
name|getCache
argument_list|()
operator|.
name|copyTo
argument_list|(
name|cacheOffset
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|actualLen
argument_list|)
expr_stmt|;
name|cacheOffset
operator|+=
name|actualLen
expr_stmt|;
comment|//if the requested bytes were more than what is present in the cache, then also read from the src
if|if
condition|(
name|actualLen
operator|<
name|len
condition|)
block|{
name|useCache
operator|=
literal|false
expr_stmt|;
name|int
name|srcLen
init|=
name|src
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|actualLen
argument_list|,
name|len
operator|-
name|actualLen
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|srcLen
operator|==
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to the read opertaion above
name|srcOffset
operator|+=
name|srcLen
expr_stmt|;
comment|//store data in cache
name|getCache
argument_list|()
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|actualLen
argument_list|,
name|srcLen
argument_list|)
expr_stmt|;
name|actualLen
operator|+=
name|srcLen
expr_stmt|;
block|}
return|return
name|actualLen
return|;
block|}
else|else
block|{
name|int
name|actualLen
init|=
name|src
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|actualLen
operator|==
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to read operation above
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
comment|//store data in cache
name|getCache
argument_list|()
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|actualLen
argument_list|)
expr_stmt|;
return|return
name|actualLen
return|;
block|}
block|}
comment|/**      * Closes the src InputStream and empties the cache      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|srcClosed
condition|)
block|{
try|try
block|{
name|src
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|srcClosed
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|getCache
argument_list|()
operator|.
name|invalidate
argument_list|()
expr_stmt|;
comment|//empty the cache
block|}
comment|/**      * We cant actually skip as we need to read so that we can cache the data,      * however apart from the potentially increased I/O      * and Memory, the end result is the same      */
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|srcClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|INPUTSTREAM_CLOSED
argument_list|)
throw|;
block|}
if|else if
condition|(
name|n
operator|<
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|useCache
operator|&&
name|cacheOffset
operator|<
name|srcOffset
condition|)
block|{
comment|//skip data from the cache
name|long
name|actualLen
init|=
operator|(
name|n
operator|>
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|cacheOffset
condition|?
name|getCache
argument_list|()
operator|.
name|getLength
argument_list|()
operator|-
name|cacheOffset
else|:
name|n
operator|)
decl_stmt|;
name|cacheOffset
operator|+=
name|actualLen
expr_stmt|;
comment|//if the requested bytes were more than what is present in the cache, then also read from the src
if|if
condition|(
name|actualLen
operator|<
name|n
condition|)
block|{
name|useCache
operator|=
literal|false
expr_stmt|;
specifier|final
name|byte
name|skipped
index|[]
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
operator|(
name|n
operator|-
name|actualLen
operator|)
index|]
decl_stmt|;
name|int
name|srcLen
init|=
name|src
operator|.
name|read
argument_list|(
name|skipped
argument_list|)
decl_stmt|;
comment|//have we reached the end of the stream?
if|if
condition|(
name|srcLen
operator|==
name|END_OF_STREAM
condition|)
block|{
return|return
name|actualLen
return|;
block|}
comment|//increase srcOffset due to the read opertaion above
name|srcOffset
operator|+=
name|srcLen
expr_stmt|;
comment|//store data in cache
name|getCache
argument_list|()
operator|.
name|write
argument_list|(
name|skipped
argument_list|,
literal|0
argument_list|,
name|srcLen
argument_list|)
expr_stmt|;
name|actualLen
operator|+=
name|srcLen
expr_stmt|;
block|}
return|return
name|actualLen
return|;
block|}
else|else
block|{
specifier|final
name|byte
name|skipped
index|[]
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|n
index|]
decl_stmt|;
comment|//TODO could overflow
name|int
name|actualLen
init|=
name|src
operator|.
name|read
argument_list|(
name|skipped
argument_list|)
decl_stmt|;
comment|//increase srcOffset due to read operation above
name|srcOffset
operator|+=
name|actualLen
expr_stmt|;
comment|//store data in the cache
name|getCache
argument_list|()
operator|.
name|write
argument_list|(
name|skipped
argument_list|,
literal|0
argument_list|,
name|actualLen
argument_list|)
expr_stmt|;
return|return
name|actualLen
return|;
block|}
block|}
block|}
end_class

end_unit

