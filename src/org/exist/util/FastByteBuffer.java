begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  The Apache Software License, Version 1.1  *  *  *  Copyright (c) 1999 The Apache Software Foundation.  All rights  *  reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.  *  *  2. Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in  *  the documentation and/or other materials provided with the  *  distribution.  *  *  3. The end-user documentation included with the redistribution,  *  if any, must include the following acknowledgment:  *  "This product includes software developed by the  *  Apache Software Foundation (http://www.apache.org/)."  *  Alternately, this acknowledgment may appear in the software itself,  *  if and wherever such third-party acknowledgments normally appear.  *  *  4. The names "Xalan" and "Apache Software Foundation" must  *  not be used to endorse or promote products derived from this  *  software without prior written permission. For written  *  permission, please contact apache@apache.org.  *  *  5. Products derived from this software may not be called "Apache",  *  nor may "Apache" appear in their name, without prior written  *  permission of the Apache Software Foundation.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *  SUCH DAMAGE.  *  ====================================================================  *  *  This software consists of voluntary contributions made by many  *  individuals on behalf of the Apache Software Foundation and was  *  originally based on software copyright (c) 1999, Lotus  *  Development Corporation., http://www.lotus.com.  For more  *  information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_comment
comment|/**  *  Copied this class from Xalan and adopted it for eXist. Bare-bones, unsafe,  *  fast string buffer. No thread-safety, no parameter range checking, exposed  *  fields. Note that in typical applications, thread-safety of a StringBuffer  *  is a somewhat dubious concept in any case.<p>  *  *  Note that Stree and DTM used a single FastStringBuffer as a string pool, by  *  recording start and length indices within this single buffer. This minimizes  *  heap overhead, but of course requires more work when retrieving the data.  *<p>  *  *  FastStringBuffer operates as a "chunked buffer". Doing so reduces the need  *  to recopy existing information when an append exceeds the space available;  *  we just allocate another chunk and flow across to it. (The array of chunks  *  may need to grow, admittedly, but that's a much smaller object.) Some excess  *  recopying may arise when we extract Strings which cross chunk boundaries;  *  larger chunks make that less frequent.<p>  *  *  The size values are parameterized, to allow tuning this code. In theory,  *  Result Tree Fragments might want to be tuned differently from the main  *  document's text.<p>  *  *  %REVIEW% An experiment in self-tuning is included in the code (using nested  *  FastStringBuffers to achieve variation in chunk sizes), but this  *  implementation has proven to be problematic when data may be being copied  *  from the FSB into itself. We should either re-architect that to make this  *  safe (if possible) or remove that code and clean up for  *  performance/maintainability reasons.<p>  *  */
end_comment

begin_class
specifier|public
class|class
name|FastByteBuffer
implements|implements
name|ByteArray
block|{
comment|// %BUG% %REVIEW% *****PROBLEM SUSPECTED: If data from an FSB is being copied
comment|// back into the same FSB (variable set from previous variable, for example)
comment|// and blocksize changes in mid-copy... there's risk of severe malfunction in
comment|// the read process, due to how the resizing code re-jiggers storage. Arggh.
comment|// If we want to retain the variable-size-block feature, we need to reconsider
comment|// that issue. For now, I have forced us into fixed-size mode.
specifier|static
name|boolean
name|DEBUG_FORCE_FIXED_CHUNKSIZE
init|=
literal|true
decl_stmt|;
comment|// If nonzero, forces the inial chunk size.
comment|/*      *      */
specifier|final
specifier|static
name|int
name|DEBUG_FORCE_INIT_BITS
init|=
literal|0
decl_stmt|;
comment|// =m_chunkSize-1;
comment|/**      *  Field m_array holds the string buffer's text contents, using an      *  array-of-arrays. Note that this array, and the arrays it contains, may      *  be reallocated when necessary in order to allow the buffer to grow;      *  references to them should be considered to be invalidated after any      *  append. However, the only time these arrays are directly exposed is in      *  the sendSAXcharacters call.      */
name|byte
index|[]
index|[]
name|m_array
decl_stmt|;
comment|/**      *  Field m_chunkBits sets our chunking strategy, by saying how many bits of      *  index can be used within a single chunk before flowing over to the next      *  chunk. For example, if m_chunkbits is set to 15, each chunk can contain      *  up to 2^15 (32K) characters      */
name|int
name|m_chunkBits
init|=
literal|15
decl_stmt|;
comment|// =1<<(m_chunkBits-1);
comment|/**      *  Field m_chunkMask is m_chunkSize-1 -- in other words, m_chunkBits worth      *  of low-order '1' bits, useful for shift-and-mask addressing within the      *  chunks.      */
name|int
name|m_chunkMask
decl_stmt|;
comment|/**      *  Field m_chunkSize establishes the maximum size of one chunk of the array      *  as 2**chunkbits characters. (Which may also be the minimum size if we      *  aren't tuning for storage)      */
name|int
name|m_chunkSize
decl_stmt|;
comment|/**      *  Field m_firstFree is an index into m_array[m_lastChunk][], pointing to      *  the first character in the Chunked Array which is not part of the      *  FastStringBuffer's current content. Since m_array[][] is zero-based, the      *  length of that content can be calculated as (m_lastChunk<<m_chunkBits) +      *  m_firstFree      */
name|int
name|m_firstFree
init|=
literal|0
decl_stmt|;
comment|/**      *  Field m_innerFSB, when non-null, is a FastStringBuffer whose total      *  length equals m_chunkSize, and which replaces m_array[0]. This allows      *  building a hierarchy of FastStringBuffers, where early appends use a      *  smaller chunkSize (for less wasted memory overhead) but later ones use a      *  larger chunkSize (for less heap activity overhead).      */
name|FastByteBuffer
name|m_innerFSB
init|=
literal|null
decl_stmt|;
comment|/**      *  Field m_lastChunk is an index into m_array[], pointing to the last chunk      *  of the Chunked Array currently in use. Note that additional chunks may      *  actually be allocated, eg if the FastStringBuffer had previously been      *  truncated or if someone issued an ensureSpace request.<p>      *      *  The insertion point for append operations is addressed by the      *  combination of m_lastChunk and m_firstFree.      */
name|int
name|m_lastChunk
init|=
literal|0
decl_stmt|;
comment|/**      *  Field m_maxChunkBits affects our chunk-growth strategy, by saying what      *  the largest permissible chunk size is in this particular      *  FastStringBuffer hierarchy.      */
name|int
name|m_maxChunkBits
init|=
literal|15
decl_stmt|;
comment|/**      *  Field m_rechunkBits affects our chunk-growth strategy, by saying how      *  many chunks should be allocated at one size before we encapsulate them      *  into the first chunk of the next size up. For example, if m_rechunkBits      *  is set to 3, then after 8 chunks at a given size we will rebundle them      *  as the first element of a FastStringBuffer using a chunk size 8 times      *  larger (chunkBits shifted left three bits).      */
name|int
name|m_rebundleBits
init|=
literal|2
decl_stmt|;
comment|/**      *  Construct a FastStringBuffer, with allocation policy as per parameters.      *<p>      *      *  For coding convenience, I've expressed both allocation sizes in terms of      *  a number of bits. That's needed for the final size of a chunk, to permit      *  fast and efficient shift-and-mask addressing. It's less critical for the      *  inital size, and may be reconsidered.<p>      *      *  An alternative would be to accept integer sizes and round to powers of      *  two; that really doesn't seem to buy us much, if anything.      *      *@param  initChunkBits  Length in characters of the initial allocation of a      *      chunk, expressed in log-base-2. (That is, 10 means allocate 1024      *      characters.) Later chunks will use larger allocation units, to trade      *      off allocation speed of large document against storage efficiency of      *      small ones.      *@param  maxChunkBits   Number of character-offset bits that should be used      *      for addressing within a chunk. Maximum length of a chunk is      *      2^chunkBits characters.      *@param  rebundleBits   Number of character-offset bits that addressing      *      should advance before we attempt to take a step from initChunkBits      *      to maxChunkBits      */
specifier|public
name|FastByteBuffer
parameter_list|(
name|int
name|initChunkBits
parameter_list|,
name|int
name|maxChunkBits
parameter_list|,
name|int
name|rebundleBits
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_FORCE_INIT_BITS
operator|!=
literal|0
condition|)
name|initChunkBits
operator|=
name|DEBUG_FORCE_INIT_BITS
expr_stmt|;
comment|// %REVIEW%
comment|// Should this force to larger value, or smaller? Smaller less efficient, but if
comment|// someone requested variable mode it's because they care about storage space.
comment|// On the other hand, given the other changes I'm making, odds are that we should
comment|// adopt the larger size. Dither, dither, dither... This is just stopgap workaround
comment|// anyway; we need a permanant solution.
comment|//
if|if
condition|(
name|DEBUG_FORCE_FIXED_CHUNKSIZE
condition|)
name|maxChunkBits
operator|=
name|initChunkBits
expr_stmt|;
comment|//if(DEBUG_FORCE_FIXED_CHUNKSIZE) initChunkBits=maxChunkBits;
name|m_array
operator|=
operator|new
name|byte
index|[
literal|16
index|]
index|[]
expr_stmt|;
comment|// Don't bite off more than we're prepared to swallow!
if|if
condition|(
name|initChunkBits
operator|>
name|maxChunkBits
condition|)
name|initChunkBits
operator|=
name|maxChunkBits
expr_stmt|;
name|m_chunkBits
operator|=
name|initChunkBits
expr_stmt|;
name|m_maxChunkBits
operator|=
name|maxChunkBits
expr_stmt|;
name|m_rebundleBits
operator|=
name|rebundleBits
expr_stmt|;
name|m_chunkSize
operator|=
literal|1
operator|<<
operator|(
name|initChunkBits
operator|)
expr_stmt|;
name|m_chunkMask
operator|=
name|m_chunkSize
operator|-
literal|1
expr_stmt|;
name|m_array
index|[
literal|0
index|]
operator|=
operator|new
name|byte
index|[
name|m_chunkSize
index|]
expr_stmt|;
comment|//m_array[0] = ByteArrayPool.getByteArray(m_chunkSize);
block|}
comment|/**      *  Construct a FastStringBuffer, using a default rebundleBits value.      *  NEEDSDOC      *      *@param  initChunkBits  NEEDSDOC      *@param  maxChunkBits      */
specifier|public
name|FastByteBuffer
parameter_list|(
name|int
name|initChunkBits
parameter_list|,
name|int
name|maxChunkBits
parameter_list|)
block|{
name|this
argument_list|(
name|initChunkBits
argument_list|,
name|maxChunkBits
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Construct a FastStringBuffer, using default maxChunkBits and      *  rebundleBits values.<p>      *      *  ISSUE: Should this call assert initial size, or fixed size? Now      *  configured as initial, with a default for fixed.      *      *@param  initChunkBits      */
specifier|public
name|FastByteBuffer
parameter_list|(
name|int
name|initChunkBits
parameter_list|)
block|{
name|this
argument_list|(
name|initChunkBits
argument_list|,
literal|15
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**  Construct a FastStringBuffer, using a default allocation policy. */
specifier|public
name|FastByteBuffer
parameter_list|()
block|{
comment|// 10 bits is 1K. 15 bits is 32K. Remember that these are character
comment|// counts, so actual memory allocation unit is doubled for UTF-16 chars.
comment|//
comment|// For reference: In the original FastStringBuffer, we simply
comment|// overallocated by blocksize (default 1KB) on each buffer-growth.
comment|//this( 10, 15, 2 );
name|this
argument_list|(
literal|6
argument_list|,
literal|10
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Encapsulation c'tor. After this is called, the source FastStringBuffer      *  will be reset to use the new object as its m_innerFSB, and will have had      *  its chunk size reset appropriately. IT SHOULD NEVER BE CALLED EXCEPT      *  WHEN source.length()==1<<(source.m_chunkBits+source.m_rebundleBits)      *  NEEDSDOC      *      *@param  source      */
specifier|private
name|FastByteBuffer
parameter_list|(
name|FastByteBuffer
name|source
parameter_list|)
block|{
comment|// Copy existing information into new encapsulation
name|m_chunkBits
operator|=
name|source
operator|.
name|m_chunkBits
expr_stmt|;
name|m_maxChunkBits
operator|=
name|source
operator|.
name|m_maxChunkBits
expr_stmt|;
name|m_rebundleBits
operator|=
name|source
operator|.
name|m_rebundleBits
expr_stmt|;
name|m_chunkSize
operator|=
name|source
operator|.
name|m_chunkSize
expr_stmt|;
name|m_chunkMask
operator|=
name|source
operator|.
name|m_chunkMask
expr_stmt|;
name|m_array
operator|=
name|source
operator|.
name|m_array
expr_stmt|;
name|m_innerFSB
operator|=
name|source
operator|.
name|m_innerFSB
expr_stmt|;
comment|// These have to be adjusted because we're calling just at the time
comment|// when we would be about to allocate another chunk
name|m_lastChunk
operator|=
name|source
operator|.
name|m_lastChunk
operator|-
literal|1
expr_stmt|;
name|m_firstFree
operator|=
name|source
operator|.
name|m_chunkSize
expr_stmt|;
comment|// Establish capsule as the Inner FSB, reset chunk sizes/addressing
name|source
operator|.
name|m_array
operator|=
operator|new
name|byte
index|[
literal|16
index|]
index|[]
expr_stmt|;
name|source
operator|.
name|m_innerFSB
operator|=
name|this
expr_stmt|;
comment|// Since we encapsulated just as we were about to append another
comment|// chunk, return ready to create the chunk after the innerFSB
comment|// -- 1, not 0.
name|source
operator|.
name|m_lastChunk
operator|=
literal|1
expr_stmt|;
name|source
operator|.
name|m_firstFree
operator|=
literal|0
expr_stmt|;
name|source
operator|.
name|m_chunkBits
operator|+=
name|m_rebundleBits
expr_stmt|;
name|source
operator|.
name|m_chunkSize
operator|=
literal|1
operator|<<
operator|(
name|source
operator|.
name|m_chunkBits
operator|)
expr_stmt|;
name|source
operator|.
name|m_chunkMask
operator|=
name|source
operator|.
name|m_chunkSize
operator|-
literal|1
expr_stmt|;
block|}
comment|/**      *  Append a single character onto the FastStringBuffer, growing the storage      *  if necessary.<p>      *      *  NOTE THAT after calling append(), previously obtained references to      *  m_array[][] may no longer be valid.... though in fact they should be in      *  this instance.      *      *@param  value  character to be appended.      */
specifier|public
specifier|final
name|void
name|append
parameter_list|(
name|byte
name|value
parameter_list|)
block|{
name|byte
index|[]
name|chunk
decl_stmt|;
comment|// We may have preallocated chunks. If so, all but last should
comment|// be at full size.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|boolean
name|lastchunk
init|=
operator|(
name|m_lastChunk
operator|+
literal|1
operator|==
name|m_array
operator|.
name|length
operator|)
decl_stmt|;
if|if
condition|(
name|m_firstFree
operator|<
name|m_chunkSize
condition|)
comment|// Simplified test single-character-fits
name|chunk
operator|=
name|m_array
index|[
name|m_lastChunk
index|]
expr_stmt|;
else|else
block|{
comment|// Extend array?
name|int
name|i
init|=
name|m_array
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|m_lastChunk
operator|+
literal|1
operator|==
name|i
condition|)
block|{
name|byte
index|[]
index|[]
name|newarray
init|=
operator|new
name|byte
index|[
name|i
operator|+
literal|16
index|]
index|[]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
argument_list|,
literal|0
argument_list|,
name|newarray
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m_array
operator|=
name|newarray
expr_stmt|;
block|}
comment|// Advance one chunk
name|chunk
operator|=
name|m_array
index|[
operator|++
name|m_lastChunk
index|]
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
comment|// Hierarchical encapsulation
if|if
condition|(
name|m_lastChunk
operator|==
literal|1
operator|<<
name|m_rebundleBits
operator|&&
name|m_chunkBits
operator|<
name|m_maxChunkBits
condition|)
comment|// Should do all the work of both encapsulating
comment|// existing data and establishing new sizes/offsets
name|m_innerFSB
operator|=
operator|new
name|FastByteBuffer
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Add a chunk.
name|chunk
operator|=
name|m_array
index|[
name|m_lastChunk
index|]
operator|=
operator|new
name|byte
index|[
name|m_chunkSize
index|]
expr_stmt|;
comment|//chunk = m_array[m_lastChunk] = ByteArrayPool.getByteArray(m_chunkSize);
block|}
name|m_firstFree
operator|=
literal|0
expr_stmt|;
block|}
comment|// Space exists in the chunk. Append the character.
name|chunk
index|[
name|m_firstFree
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
comment|/**      *  Append the contents of the array onto the buffer.      *      *@param  chars  Description of the Parameter      */
specifier|public
specifier|final
name|void
name|append
parameter_list|(
name|byte
index|[]
name|chars
parameter_list|)
block|{
name|append
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|chars
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Append part of the contents of a Character Array onto the      *  FastStringBuffer, growing the storage if necessary.<p>      *      *  NOTE THAT after calling append(), previously obtained references to      *  m_array[] may no longer be valid.      *      *@param  chars   character array from which data is to be copied      *@param  start   offset in chars of first character to be copied,      *      zero-based.      *@param  length  number of characters to be copied      */
specifier|public
specifier|final
name|void
name|append
parameter_list|(
name|byte
index|[]
name|chars
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|strlen
init|=
name|length
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|strlen
condition|)
return|return;
name|int
name|copyfrom
init|=
name|start
decl_stmt|;
name|byte
index|[]
name|chunk
init|=
name|m_array
index|[
name|m_lastChunk
index|]
decl_stmt|;
name|int
name|available
init|=
name|m_chunkSize
operator|-
name|m_firstFree
decl_stmt|;
comment|// Repeat while data remains to be copied
while|while
condition|(
name|strlen
operator|>
literal|0
condition|)
block|{
comment|// Copy what fits
if|if
condition|(
name|available
operator|>
name|strlen
condition|)
name|available
operator|=
name|strlen
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|chars
argument_list|,
name|copyfrom
argument_list|,
name|m_array
index|[
name|m_lastChunk
index|]
argument_list|,
name|m_firstFree
argument_list|,
name|available
argument_list|)
expr_stmt|;
name|strlen
operator|-=
name|available
expr_stmt|;
name|copyfrom
operator|+=
name|available
expr_stmt|;
comment|// If there's more left, allocate another chunk and continue
if|if
condition|(
name|strlen
operator|>
literal|0
condition|)
block|{
comment|// Extend array?
name|int
name|i
init|=
name|m_array
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|m_lastChunk
operator|+
literal|1
operator|==
name|i
condition|)
block|{
name|byte
index|[]
index|[]
name|newarray
init|=
operator|new
name|byte
index|[
name|i
operator|+
literal|16
index|]
index|[]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
argument_list|,
literal|0
argument_list|,
name|newarray
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m_array
operator|=
name|newarray
expr_stmt|;
block|}
comment|// Advance one chunk
name|chunk
operator|=
name|m_array
index|[
operator|++
name|m_lastChunk
index|]
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
comment|// Hierarchical encapsulation
if|if
condition|(
name|m_lastChunk
operator|==
literal|1
operator|<<
name|m_rebundleBits
operator|&&
name|m_chunkBits
operator|<
name|m_maxChunkBits
condition|)
comment|// Should do all the work of both encapsulating
comment|// existing data and establishing new sizes/offsets
name|m_innerFSB
operator|=
operator|new
name|FastByteBuffer
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Add a chunk.
name|chunk
operator|=
name|m_array
index|[
name|m_lastChunk
index|]
operator|=
operator|new
name|byte
index|[
name|m_chunkSize
index|]
expr_stmt|;
comment|//chunk = m_array[m_lastChunk] = ByteArrayPool.getByteArray(m_chunkSize);
block|}
name|available
operator|=
name|m_chunkSize
expr_stmt|;
name|m_firstFree
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Adjust the insert point in the last chunk, when we've reached it.
name|m_firstFree
operator|+=
name|available
expr_stmt|;
block|}
comment|/**      *  Append the contents of another FastStringBuffer onto this      *  FastStringBuffer, growing the storage if necessary.<p>      *      *  NOTE THAT after calling append(), previously obtained references to      *  m_array[] may no longer be valid.      *      *@param  value  FastStringBuffer whose contents are to be appended.      */
specifier|public
specifier|final
name|void
name|append
parameter_list|(
name|FastByteBuffer
name|value
parameter_list|)
block|{
comment|// Complicating factor here is that the two buffers may use
comment|// different chunk sizes, and even if they're the same we're
comment|// probably on a different alignment due to previously appended
comment|// data. We have to work through the source in bite-sized chunks.
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return;
name|int
name|strlen
init|=
name|value
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|strlen
condition|)
return|return;
name|int
name|copyfrom
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|chunk
init|=
name|m_array
index|[
name|m_lastChunk
index|]
decl_stmt|;
name|int
name|available
init|=
name|m_chunkSize
operator|-
name|m_firstFree
decl_stmt|;
comment|// Repeat while data remains to be copied
while|while
condition|(
name|strlen
operator|>
literal|0
condition|)
block|{
comment|// Copy what fits
if|if
condition|(
name|available
operator|>
name|strlen
condition|)
name|available
operator|=
name|strlen
expr_stmt|;
name|int
name|sourcechunk
init|=
operator|(
name|copyfrom
operator|+
name|value
operator|.
name|m_chunkSize
operator|-
literal|1
operator|)
operator|>>>
name|value
operator|.
name|m_chunkBits
decl_stmt|;
name|int
name|sourcecolumn
init|=
name|copyfrom
operator|&
name|value
operator|.
name|m_chunkMask
decl_stmt|;
name|int
name|runlength
init|=
name|value
operator|.
name|m_chunkSize
operator|-
name|sourcecolumn
decl_stmt|;
if|if
condition|(
name|runlength
operator|>
name|available
condition|)
name|runlength
operator|=
name|available
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
operator|.
name|m_array
index|[
name|sourcechunk
index|]
argument_list|,
name|sourcecolumn
argument_list|,
name|m_array
index|[
name|m_lastChunk
index|]
argument_list|,
name|m_firstFree
argument_list|,
name|runlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|runlength
operator|!=
name|available
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|value
operator|.
name|m_array
index|[
name|sourcechunk
operator|+
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|m_array
index|[
name|m_lastChunk
index|]
argument_list|,
name|m_firstFree
operator|+
name|runlength
argument_list|,
name|available
operator|-
name|runlength
argument_list|)
expr_stmt|;
name|strlen
operator|-=
name|available
expr_stmt|;
name|copyfrom
operator|+=
name|available
expr_stmt|;
comment|// If there's more left, allocate another chunk and continue
if|if
condition|(
name|strlen
operator|>
literal|0
condition|)
block|{
comment|// Extend array?
name|int
name|i
init|=
name|m_array
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|m_lastChunk
operator|+
literal|1
operator|==
name|i
condition|)
block|{
name|byte
index|[]
index|[]
name|newarray
init|=
operator|new
name|byte
index|[
name|i
operator|+
literal|16
index|]
index|[]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
argument_list|,
literal|0
argument_list|,
name|newarray
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m_array
operator|=
name|newarray
expr_stmt|;
block|}
comment|// Advance one chunk
name|chunk
operator|=
name|m_array
index|[
operator|++
name|m_lastChunk
index|]
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
comment|// Hierarchical encapsulation
if|if
condition|(
name|m_lastChunk
operator|==
literal|1
operator|<<
name|m_rebundleBits
operator|&&
name|m_chunkBits
operator|<
name|m_maxChunkBits
condition|)
comment|// Should do all the work of both encapsulating
comment|// existing data and establishing new sizes/offsets
name|m_innerFSB
operator|=
operator|new
name|FastByteBuffer
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Add a chunk.
name|chunk
operator|=
name|m_array
index|[
name|m_lastChunk
index|]
operator|=
operator|new
name|byte
index|[
name|m_chunkSize
index|]
expr_stmt|;
comment|//chunk = m_array[m_lastChunk] = ByteArrayPool.getByteArray(m_chunkSize);
block|}
name|available
operator|=
name|m_chunkSize
expr_stmt|;
name|m_firstFree
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Adjust the insert point in the last chunk, when we've reached it.
name|m_firstFree
operator|+=
name|available
expr_stmt|;
block|}
specifier|public
name|void
name|copyTo
parameter_list|(
name|byte
index|[]
name|newBuf
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|pos
init|=
name|offset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_lastChunk
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|newBuf
argument_list|,
name|pos
argument_list|)
expr_stmt|;
else|else
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|newBuf
argument_list|,
name|pos
argument_list|,
name|m_chunkSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|m_chunkSize
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
index|[
name|m_lastChunk
index|]
argument_list|,
literal|0
argument_list|,
name|newBuf
argument_list|,
name|pos
argument_list|,
name|m_firstFree
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|copyTo
parameter_list|(
name|ByteArray
name|newBuf
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_lastChunk
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|newBuf
argument_list|)
expr_stmt|;
else|else
name|newBuf
operator|.
name|append
argument_list|(
name|m_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|newBuf
operator|.
name|append
argument_list|(
name|m_array
index|[
name|m_lastChunk
index|]
argument_list|,
literal|0
argument_list|,
name|m_firstFree
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|copyTo
parameter_list|(
name|ByteBuffer
name|newBuf
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_lastChunk
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|newBuf
argument_list|)
expr_stmt|;
else|else
name|newBuf
operator|.
name|put
argument_list|(
name|m_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|newBuf
operator|.
name|put
argument_list|(
name|m_array
index|[
name|m_lastChunk
index|]
argument_list|,
literal|0
argument_list|,
name|m_firstFree
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|copyTo
parameter_list|(
name|int
name|start
parameter_list|,
name|byte
index|[]
name|newBuf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|stop
init|=
name|start
operator|+
name|len
decl_stmt|;
name|int
name|startChunk
init|=
name|start
operator|>>>
name|m_chunkBits
decl_stmt|;
name|int
name|startColumn
init|=
name|start
operator|&
name|m_chunkMask
decl_stmt|;
name|int
name|stopChunk
init|=
name|stop
operator|>>>
name|m_chunkBits
decl_stmt|;
name|int
name|stopColumn
init|=
name|stop
operator|&
name|m_chunkMask
decl_stmt|;
name|int
name|pos
init|=
name|offset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startChunk
init|;
name|i
operator|<
name|stopChunk
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|startColumn
argument_list|,
name|newBuf
argument_list|,
name|offset
argument_list|,
name|m_chunkSize
operator|-
name|startColumn
argument_list|)
expr_stmt|;
else|else
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
index|[
name|i
index|]
argument_list|,
name|startColumn
argument_list|,
name|newBuf
argument_list|,
name|pos
argument_list|,
name|m_chunkSize
operator|-
name|startColumn
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|m_chunkSize
operator|-
name|startColumn
expr_stmt|;
name|startColumn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stopChunk
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|startColumn
argument_list|,
name|newBuf
argument_list|,
name|pos
argument_list|,
name|stopColumn
operator|-
name|startColumn
argument_list|)
expr_stmt|;
if|else if
condition|(
name|stopColumn
operator|>
name|startColumn
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|m_array
index|[
name|stopChunk
index|]
argument_list|,
name|startColumn
argument_list|,
name|newBuf
argument_list|,
name|pos
argument_list|,
name|stopColumn
operator|-
name|startColumn
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|copyTo
parameter_list|(
name|int
name|start
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|stop
init|=
name|start
operator|+
name|len
decl_stmt|;
name|int
name|startChunk
init|=
name|start
operator|>>>
name|m_chunkBits
decl_stmt|;
name|int
name|startColumn
init|=
name|start
operator|&
name|m_chunkMask
decl_stmt|;
name|int
name|stopChunk
init|=
name|stop
operator|>>>
name|m_chunkBits
decl_stmt|;
name|int
name|stopColumn
init|=
name|stop
operator|&
name|m_chunkMask
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startChunk
init|;
name|i
operator|<
name|stopChunk
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|startColumn
argument_list|,
name|buf
argument_list|,
name|m_chunkSize
operator|-
name|startColumn
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|put
argument_list|(
name|m_array
index|[
name|i
index|]
argument_list|,
name|startColumn
argument_list|,
name|m_chunkSize
operator|-
name|startColumn
argument_list|)
expr_stmt|;
name|startColumn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stopChunk
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|copyTo
argument_list|(
name|startColumn
argument_list|,
name|buf
argument_list|,
name|stopColumn
operator|-
name|startColumn
argument_list|)
expr_stmt|;
if|else if
condition|(
name|stopColumn
operator|>
name|startColumn
condition|)
name|buf
operator|.
name|put
argument_list|(
name|m_array
index|[
name|stopChunk
index|]
argument_list|,
name|startColumn
argument_list|,
name|stopColumn
operator|-
name|startColumn
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|position
parameter_list|,
name|byte
name|b
parameter_list|)
block|{
name|int
name|chunk
init|=
name|position
operator|>>>
name|m_chunkBits
decl_stmt|;
name|int
name|column
init|=
name|position
operator|&
name|m_chunkMask
decl_stmt|;
name|m_array
index|[
name|chunk
index|]
index|[
name|column
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|/**      *  Get the length of the list. Synonym for size().      *      *@return    the number of characters in the FastStringBuffer's content.      */
specifier|public
specifier|final
name|int
name|length
parameter_list|()
block|{
return|return
operator|(
name|m_lastChunk
operator|<<
name|m_chunkBits
operator|)
operator|+
name|m_firstFree
return|;
block|}
comment|/**      *  Discard the content of the FastStringBuffer, and most of the memory that      *  was allocated by it, restoring the initial state. Note that this may      *  eventually be different from setLength(0), which see.      */
specifier|public
specifier|final
name|void
name|reset
parameter_list|()
block|{
name|m_lastChunk
operator|=
literal|0
expr_stmt|;
name|m_firstFree
operator|=
literal|0
expr_stmt|;
comment|// Recover the original chunk size
name|FastByteBuffer
name|innermost
init|=
name|this
decl_stmt|;
while|while
condition|(
name|innermost
operator|.
name|m_innerFSB
operator|!=
literal|null
condition|)
name|innermost
operator|=
name|innermost
operator|.
name|m_innerFSB
expr_stmt|;
name|m_chunkBits
operator|=
name|innermost
operator|.
name|m_chunkBits
expr_stmt|;
name|m_chunkSize
operator|=
name|innermost
operator|.
name|m_chunkSize
expr_stmt|;
name|m_chunkMask
operator|=
name|innermost
operator|.
name|m_chunkMask
expr_stmt|;
comment|// Discard the hierarchy
name|m_innerFSB
operator|=
literal|null
expr_stmt|;
name|m_array
operator|=
operator|new
name|byte
index|[
literal|16
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m_array
index|[
literal|0
index|]
operator|=
operator|new
name|byte
index|[
name|m_chunkSize
index|]
expr_stmt|;
block|}
comment|/**      *  Directly set how much of the FastStringBuffer's storage is to be      *  considered part of its content. This is a fast but hazardous operation.      *  It is not protected against negative values, or values greater than the      *  amount of storage currently available... and even if additional storage      *  does exist, its contents are unpredictable. The only safe use for our      *  setLength() is to truncate the FastStringBuffer to a shorter string.      *      *@param  l  New length. If l<0 or l>=getLength(), this operation will not      *      report an error but future operations will almost certainly fail.      */
specifier|public
specifier|final
name|void
name|setLength
parameter_list|(
name|int
name|l
parameter_list|)
block|{
name|m_lastChunk
operator|=
name|l
operator|>>>
name|m_chunkBits
expr_stmt|;
if|if
condition|(
name|m_lastChunk
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
comment|// Replace this FSB with the appropriate inner FSB, truncated
name|m_innerFSB
operator|.
name|setLength
argument_list|(
name|l
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
block|{
name|m_firstFree
operator|=
name|l
operator|&
name|m_chunkMask
expr_stmt|;
comment|// There's an edge case if l is an exact multiple of m_chunkBits, which risks leaving
comment|// us pointing at the start of a chunk which has not yet been allocated. Rather than
comment|// pay the cost of dealing with that in the append loops (more scattered and more
comment|// inner-loop), we correct it here by moving to the safe side of that
comment|// line -- as we would have left the indexes had we appended up to that point.
if|if
condition|(
name|m_firstFree
operator|==
literal|0
operator|&&
name|m_lastChunk
operator|>
literal|0
condition|)
block|{
operator|--
name|m_lastChunk
expr_stmt|;
name|m_firstFree
operator|=
name|m_chunkSize
expr_stmt|;
block|}
block|}
block|}
comment|/**      *  Subroutine for the public setLength() method. Deals with the fact that      *  truncation may require restoring one of the innerFSBs NEEDSDOC      *      *@param  l        NEEDSDOC      *@param  rootFSB      */
specifier|private
specifier|final
name|void
name|setLength
parameter_list|(
name|int
name|l
parameter_list|,
name|FastByteBuffer
name|rootFSB
parameter_list|)
block|{
name|m_lastChunk
operator|=
name|l
operator|>>>
name|m_chunkBits
expr_stmt|;
if|if
condition|(
name|m_lastChunk
operator|==
literal|0
operator|&&
name|m_innerFSB
operator|!=
literal|null
condition|)
name|m_innerFSB
operator|.
name|setLength
argument_list|(
name|l
argument_list|,
name|rootFSB
argument_list|)
expr_stmt|;
else|else
block|{
comment|// Undo encapsulation -- pop the innerFSB data back up to root.
comment|// Inefficient, but attempts to keep the code simple.
name|rootFSB
operator|.
name|m_chunkBits
operator|=
name|m_chunkBits
expr_stmt|;
name|rootFSB
operator|.
name|m_maxChunkBits
operator|=
name|m_maxChunkBits
expr_stmt|;
name|rootFSB
operator|.
name|m_rebundleBits
operator|=
name|m_rebundleBits
expr_stmt|;
name|rootFSB
operator|.
name|m_chunkSize
operator|=
name|m_chunkSize
expr_stmt|;
name|rootFSB
operator|.
name|m_chunkMask
operator|=
name|m_chunkMask
expr_stmt|;
name|rootFSB
operator|.
name|m_array
operator|=
name|m_array
expr_stmt|;
name|rootFSB
operator|.
name|m_innerFSB
operator|=
name|m_innerFSB
expr_stmt|;
name|rootFSB
operator|.
name|m_lastChunk
operator|=
name|m_lastChunk
expr_stmt|;
comment|// Finally, truncate this sucker.
name|rootFSB
operator|.
name|m_firstFree
operator|=
name|l
operator|&
name|m_chunkMask
expr_stmt|;
block|}
block|}
comment|/**      *  Get the length of the list. Synonym for length().      *      *@return    the number of characters in the FastStringBuffer's content.      */
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
operator|(
name|m_lastChunk
operator|<<
name|m_chunkBits
operator|)
operator|+
name|m_firstFree
return|;
block|}
block|}
end_class

end_unit

