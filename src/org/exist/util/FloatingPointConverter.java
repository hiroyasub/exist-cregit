begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_comment
comment|/**  * This is a utility class that handles formatting of numbers as strings.  *<p>  * The algorithm for converting a floating point number to a string is taken from Guy L. Steele and  * Jon L. White,<i>How to Print Floating-Point Numbers Accurately</i>, ACM SIGPLAN 1990. It is algorithm  * (FPP)<sup>2</sup> from that paper. There are three separate implementations of the algorithm:  *<ul>  *<li>One using long arithmetic and generating non-exponential output representations  *<li>One using BigInteger arithmetic and generating non-exponential output representation  *<li>One using BigInteger arithmetic and generating exponential output representations  *</ul>  *<p>  * The choice of method depends on the value of the number being formatted.  *<p>  * The module contains some residual code (mainly the routine for formatting integers) from the class  * AppenderHelper by Jack Shirazi in the O'Reilly book<i>Java Performance Tuning</i>. The floating point routines  * in that module were found to be unsuitable, since they used floating point arithmetic which introduces  * rounding errors.  *<p>  * There are several reasons for doing this conversion within Saxon, rather than leaving it all to Java.  * Firstly, there are differences in the required output format, notably the absence of ".0" when formatting  * whole numbers, and the different rules for the range of numbers where exponential notation is used.  * Secondly, there are bugs in some Java implementations, for example JDK outputs 0.001 as 0.0010, and  * IKVM/GNU gets things very wrong sometimes. Finally, this implementation is faster for "everyday" numbers,  * though it is slower for more extreme numbers. It would probably be reasonable to hand over formatting  * to the Java platform (at least when running the Sun JDK) for exponents outside the range -7 to +7.  */
end_comment

begin_class
specifier|public
class|class
name|FloatingPointConverter
block|{
specifier|public
specifier|static
name|FloatingPointConverter
name|THE_INSTANCE
init|=
operator|new
name|FloatingPointConverter
argument_list|()
decl_stmt|;
specifier|private
name|FloatingPointConverter
parameter_list|()
block|{
block|}
comment|/**      * char array holding the characters for the string "-Infinity".      */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|NEGATIVE_INFINITY
init|=
block|{
literal|'-'
block|,
literal|'I'
block|,
literal|'N'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/**      * char array holding the characters for the string "Infinity".      */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|POSITIVE_INFINITY
init|=
block|{
literal|'I'
block|,
literal|'N'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/**      * char array holding the characters for the string "NaN".      */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|NaN
init|=
block|{
literal|'N'
block|,
literal|'a'
block|,
literal|'N'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|charForDigit
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|doubleSignMask
init|=
literal|0x8000000000000000L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|doubleExpMask
init|=
literal|0x7ff0000000000000L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|doubleExpShift
init|=
literal|52
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|doubleExpBias
init|=
literal|1023
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|doubleFractMask
init|=
literal|0xfffffffffffffL
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|floatSignMask
init|=
literal|0x80000000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|floatExpMask
init|=
literal|0x7f800000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|floatExpShift
init|=
literal|23
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|floatExpBias
init|=
literal|127
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|floatFractMask
init|=
literal|0x7fffff
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|TEN
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|10
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigInteger
name|NINE
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|9
argument_list|)
decl_stmt|;
comment|/**      * Format an integer, appending the string representation of the integer to a string buffer      * @param s the string buffer      * @param i the integer to be formatted      * @return the supplied string buffer, containing the appended integer      */
specifier|public
specifier|static
name|FastStringBuffer
name|appendInt
parameter_list|(
name|FastStringBuffer
name|s
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
comment|//cannot make this positive due to integer overflow
name|s
operator|.
name|append
argument_list|(
literal|"-2147483648"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|int
name|c
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|10
condition|)
block|{
comment|//one digit
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|100
condition|)
block|{
comment|//two digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|1000
condition|)
block|{
comment|//three digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|10000
condition|)
block|{
comment|//four digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|100000
condition|)
block|{
comment|//five digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|10000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|10000
operator|)
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|1000000
condition|)
block|{
comment|//six digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|100000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|100000
operator|)
operator|/
literal|10000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000
operator|)
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|10000000
condition|)
block|{
comment|//seven digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|1000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|1000000
operator|)
operator|/
literal|100000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100000
operator|)
operator|/
literal|10000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000
operator|)
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|100000000
condition|)
block|{
comment|//eight digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|10000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|10000000
operator|)
operator|/
literal|1000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000000
operator|)
operator|/
literal|100000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100000
operator|)
operator|/
literal|10000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000
operator|)
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|else if
condition|(
name|i
operator|<
literal|1000000000
condition|)
block|{
comment|//nine digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|100000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|100000000
operator|)
operator|/
literal|10000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000000
operator|)
operator|/
literal|1000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000000
operator|)
operator|/
literal|100000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100000
operator|)
operator|/
literal|10000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000
operator|)
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
comment|//ten digits
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|i
operator|/
literal|1000000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|=
name|i
operator|%
literal|1000000000
operator|)
operator|/
literal|100000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100000000
operator|)
operator|/
literal|10000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000000
operator|)
operator|/
literal|1000000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000000
operator|)
operator|/
literal|100000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100000
operator|)
operator|/
literal|10000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|10000
operator|)
operator|/
literal|1000
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|1000
operator|)
operator|/
literal|100
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
operator|(
name|c
operator|%=
literal|100
operator|)
operator|/
literal|10
index|]
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|c
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
comment|/**      * Implementation of the (FPP)2 algorithm from Steele and White, for doubles in the range      * 0.01 to 1000000, and floats in the range 0.000001 to 1000000.      * In this range (a) XPath requires that the output should not be in exponential      * notation, and (b) the arithmetic can be handled using longs rather than BigIntegers      * @param sb the string buffer to which the formatted result is to be appended      * @param e the exponent of the floating point number      * @param f the fraction part of the floating point number, such that the "real" value of the      * number is f * 2^(e-p), with p>=0 and 0 lt f lt 2^p      * @param p the precision      */
specifier|private
specifier|static
name|void
name|fppfpp
parameter_list|(
name|FastStringBuffer
name|sb
parameter_list|,
name|int
name|e
parameter_list|,
name|long
name|f
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|long
name|R
init|=
name|f
operator|<<
name|Math
operator|.
name|max
argument_list|(
name|e
operator|-
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|long
name|S
init|=
literal|1L
operator|<<
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
operator|-
operator|(
name|e
operator|-
name|p
operator|)
argument_list|)
decl_stmt|;
name|long
name|Mminus
init|=
literal|1L
operator|<<
name|Math
operator|.
name|max
argument_list|(
name|e
operator|-
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|long
name|Mplus
init|=
name|Mminus
decl_stmt|;
name|boolean
name|initial
init|=
literal|true
decl_stmt|;
comment|// simpleFixup
if|if
condition|(
name|f
operator|==
literal|1L
operator|<<
operator|(
name|p
operator|-
literal|1
operator|)
condition|)
block|{
name|Mplus
operator|=
name|Mplus
operator|<<
literal|1
expr_stmt|;
name|R
operator|=
name|R
operator|<<
literal|1
expr_stmt|;
name|S
operator|=
name|S
operator|<<
literal|1
expr_stmt|;
block|}
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|R
operator|<
operator|(
name|S
operator|+
literal|9
operator|)
operator|/
literal|10
condition|)
block|{
comment|// (S+9)/10 == ceiling(S/10)
name|k
operator|--
expr_stmt|;
name|R
operator|=
name|R
operator|*
literal|10
expr_stmt|;
name|Mminus
operator|=
name|Mminus
operator|*
literal|10
expr_stmt|;
name|Mplus
operator|=
name|Mplus
operator|*
literal|10
expr_stmt|;
block|}
while|while
condition|(
literal|2
operator|*
name|R
operator|+
name|Mplus
operator|>=
literal|2
operator|*
name|S
condition|)
block|{
name|S
operator|=
name|S
operator|*
literal|10
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|z
init|=
name|k
init|;
name|z
operator|<
literal|0
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"0."
argument_list|)
expr_stmt|;
block|}
name|initial
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
comment|// end simpleFixup
comment|//int H = k-1;
name|boolean
name|low
decl_stmt|;
name|boolean
name|high
decl_stmt|;
name|int
name|U
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|U
operator|=
operator|(
name|int
operator|)
operator|(
name|R
operator|*
literal|10
operator|/
name|S
operator|)
expr_stmt|;
name|R
operator|=
name|R
operator|*
literal|10
operator|%
name|S
expr_stmt|;
name|Mminus
operator|=
name|Mminus
operator|*
literal|10
expr_stmt|;
name|Mplus
operator|=
name|Mplus
operator|*
literal|10
expr_stmt|;
name|low
operator|=
literal|2
operator|*
name|R
operator|<
name|Mminus
expr_stmt|;
name|high
operator|=
literal|2
operator|*
name|R
operator|>
literal|2
operator|*
name|S
operator|-
name|Mplus
expr_stmt|;
if|if
condition|(
name|low
operator|||
name|high
condition|)
break|break;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|U
index|]
argument_list|)
expr_stmt|;
name|initial
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|&&
operator|(
operator|!
name|low
operator|||
literal|2
operator|*
name|R
operator|>
name|S
operator|)
condition|)
block|{
name|U
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|U
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|z
init|=
literal|0
init|;
name|z
operator|<
name|k
condition|;
name|z
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Implementation of the (FPP)2 algorithm from Steele and White, for doubles in the range      * 0.000001 to 0.01. In this range XPath requires that the output should not be in exponential      * notation, but the scale factors are large enough to exceed the capacity of long arithmetic.      * @param sb the string buffer to which the formatted result is to be appended      * @param e the exponent of the floating point number      * @param f the fraction part of the floating point number, such that the "real" value of the      * number is f * 2^(e-p), with p>=0 and 0 lt f lt 2^p      * @param p the precision      */
specifier|private
specifier|static
name|void
name|fppfppBig
parameter_list|(
name|FastStringBuffer
name|sb
parameter_list|,
name|int
name|e
parameter_list|,
name|long
name|f
parameter_list|,
name|int
name|p
parameter_list|)
block|{
comment|//long R = f<< Math.max(e-p, 0);
name|BigInteger
name|R
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|f
argument_list|)
operator|.
name|shiftLeft
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|e
operator|-
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|//long S = 1L<< Math.max(0, -(e-p));
name|BigInteger
name|S
init|=
name|BigInteger
operator|.
name|ONE
operator|.
name|shiftLeft
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
operator|-
operator|(
name|e
operator|-
name|p
operator|)
argument_list|)
argument_list|)
decl_stmt|;
comment|//long Mminus = 1<< Math.max(e-p, 0);
name|BigInteger
name|Mminus
init|=
name|BigInteger
operator|.
name|ONE
operator|.
name|shiftLeft
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|e
operator|-
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|//long Mplus = Mminus;
name|BigInteger
name|Mplus
init|=
name|Mminus
decl_stmt|;
name|boolean
name|initial
init|=
literal|true
decl_stmt|;
comment|// simpleFixup
if|if
condition|(
name|f
operator|==
literal|1L
operator|<<
operator|(
name|p
operator|-
literal|1
operator|)
condition|)
block|{
name|Mplus
operator|=
name|Mplus
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|R
operator|=
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|S
operator|=
name|S
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|R
operator|.
name|compareTo
argument_list|(
name|S
operator|.
name|add
argument_list|(
name|NINE
argument_list|)
operator|.
name|divide
argument_list|(
name|TEN
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// (S+9)/10 == ceiling(S/10)
name|k
operator|--
expr_stmt|;
name|R
operator|=
name|R
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|Mminus
operator|=
name|Mminus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|Mplus
operator|=
name|Mplus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|Mplus
argument_list|)
operator|.
name|compareTo
argument_list|(
name|S
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|S
operator|=
name|S
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|z
init|=
name|k
init|;
name|z
operator|<
literal|0
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"0."
argument_list|)
expr_stmt|;
block|}
name|initial
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
comment|// end simpleFixup
comment|//int H = k-1;
name|boolean
name|low
decl_stmt|;
name|boolean
name|high
decl_stmt|;
name|int
name|U
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|BigInteger
name|R10
init|=
name|R
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
decl_stmt|;
name|U
operator|=
name|R10
operator|.
name|divide
argument_list|(
name|S
argument_list|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|R
operator|=
name|R10
operator|.
name|mod
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|Mminus
operator|=
name|Mminus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|Mplus
operator|=
name|Mplus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|BigInteger
name|R2
init|=
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|low
operator|=
name|R2
operator|.
name|compareTo
argument_list|(
name|Mminus
argument_list|)
operator|<
literal|0
expr_stmt|;
name|high
operator|=
name|R2
operator|.
name|compareTo
argument_list|(
name|S
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
operator|.
name|subtract
argument_list|(
name|Mplus
argument_list|)
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|low
operator|||
name|high
condition|)
break|break;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|U
index|]
argument_list|)
expr_stmt|;
name|initial
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|&&
operator|(
operator|!
name|low
operator|||
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
operator|.
name|compareTo
argument_list|(
name|S
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|U
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|U
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|z
init|=
literal|0
init|;
name|z
operator|<
name|k
condition|;
name|z
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Implementation of the (FPP)2 algorithm from Steele and White, for numbers outside the range      * 0.000001 to 1000000. In this range XPath requires that the output should be in exponential      * notation      * @param sb the string buffer to which the formatted result is to be appended      * @param e the exponent of the floating point number      * @param f the fraction part of the floating point number, such that the "real" value of the      * number is f * 2^(e-p), with p>=0 and 0 lt f lt 2^p      * @param p the precision      */
specifier|private
specifier|static
name|void
name|fppfppExponential
parameter_list|(
name|FastStringBuffer
name|sb
parameter_list|,
name|int
name|e
parameter_list|,
name|long
name|f
parameter_list|,
name|int
name|p
parameter_list|)
block|{
comment|//long R = f<< Math.max(e-p, 0);
name|BigInteger
name|R
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|f
argument_list|)
operator|.
name|shiftLeft
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|e
operator|-
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|//long S = 1L<< Math.max(0, -(e-p));
name|BigInteger
name|S
init|=
name|BigInteger
operator|.
name|ONE
operator|.
name|shiftLeft
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
operator|-
operator|(
name|e
operator|-
name|p
operator|)
argument_list|)
argument_list|)
decl_stmt|;
comment|//long Mminus = 1<< Math.max(e-p, 0);
name|BigInteger
name|Mminus
init|=
name|BigInteger
operator|.
name|ONE
operator|.
name|shiftLeft
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|e
operator|-
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|//long Mplus = Mminus;
name|BigInteger
name|Mplus
init|=
name|Mminus
decl_stmt|;
name|boolean
name|initial
init|=
literal|true
decl_stmt|;
name|boolean
name|doneDot
init|=
literal|false
decl_stmt|;
comment|// simpleFixup
if|if
condition|(
name|f
operator|==
literal|1L
operator|<<
operator|(
name|p
operator|-
literal|1
operator|)
condition|)
block|{
name|Mplus
operator|=
name|Mplus
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|R
operator|=
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|S
operator|=
name|S
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|R
operator|.
name|compareTo
argument_list|(
name|S
operator|.
name|add
argument_list|(
name|NINE
argument_list|)
operator|.
name|divide
argument_list|(
name|TEN
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// (S+9)/10 == ceiling(S/10)
name|k
operator|--
expr_stmt|;
name|R
operator|=
name|R
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|Mminus
operator|=
name|Mminus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|Mplus
operator|=
name|Mplus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|Mplus
argument_list|)
operator|.
name|compareTo
argument_list|(
name|S
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|S
operator|=
name|S
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
comment|// end simpleFixup
name|int
name|H
init|=
name|k
operator|-
literal|1
decl_stmt|;
name|boolean
name|low
decl_stmt|;
name|boolean
name|high
decl_stmt|;
name|int
name|U
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|BigInteger
name|R10
init|=
name|R
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
decl_stmt|;
name|U
operator|=
name|R10
operator|.
name|divide
argument_list|(
name|S
argument_list|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|R
operator|=
name|R10
operator|.
name|mod
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|Mminus
operator|=
name|Mminus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|Mplus
operator|=
name|Mplus
operator|.
name|multiply
argument_list|(
name|TEN
argument_list|)
expr_stmt|;
name|BigInteger
name|R2
init|=
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|low
operator|=
name|R2
operator|.
name|compareTo
argument_list|(
name|Mminus
argument_list|)
operator|<
literal|0
expr_stmt|;
name|high
operator|=
name|R2
operator|.
name|compareTo
argument_list|(
name|S
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
operator|.
name|subtract
argument_list|(
name|Mplus
argument_list|)
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|low
operator|||
name|high
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|U
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|doneDot
operator|=
literal|true
expr_stmt|;
block|}
name|initial
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|&&
operator|(
operator|!
name|low
operator|||
name|R
operator|.
name|shiftLeft
argument_list|(
literal|1
argument_list|)
operator|.
name|compareTo
argument_list|(
name|S
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|U
operator|++
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|charForDigit
index|[
name|U
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doneDot
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".0"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|appendInt
argument_list|(
name|sb
argument_list|,
name|H
argument_list|)
expr_stmt|;
block|}
comment|/**      * Append a string representation of a double value to a string buffer      * @param s the string buffer to which the result will be appended      * @param value the double to be formatted      * @return the original string buffer, now containing the string representation of the supplied double      */
specifier|public
specifier|static
name|FastStringBuffer
name|appendDouble
parameter_list|(
name|FastStringBuffer
name|s
parameter_list|,
name|double
name|value
parameter_list|)
block|{
name|double
name|d
init|=
name|value
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|Double
operator|.
name|NEGATIVE_INFINITY
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|NEGATIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|==
name|Double
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|!=
name|d
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|NaN
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|d
argument_list|)
operator|&
name|doubleSignMask
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|==
name|Double
operator|.
name|MAX_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"1.7976931348623157E308"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|==
operator|-
name|Double
operator|.
name|MAX_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"-1.7976931348623157E308"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|==
name|Double
operator|.
name|MIN_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"4.9E-324"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|d
operator|==
operator|-
name|Double
operator|.
name|MIN_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"-4.9E-324"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|d
operator|=
operator|-
name|d
expr_stmt|;
block|}
name|boolean
name|exponential
init|=
operator|(
name|d
operator|>=
literal|1000000
operator|||
name|d
operator|<
literal|0.000001
operator|)
decl_stmt|;
name|long
name|bits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|long
name|fraction
init|=
operator|(
literal|1L
operator|<<
literal|52
operator|)
operator||
operator|(
name|bits
operator|&
name|doubleFractMask
operator|)
decl_stmt|;
name|long
name|rawExp
init|=
operator|(
name|bits
operator|&
name|doubleExpMask
operator|)
operator|>>
name|doubleExpShift
decl_stmt|;
name|int
name|exp
init|=
operator|(
name|int
operator|)
name|rawExp
operator|-
name|doubleExpBias
decl_stmt|;
if|if
condition|(
name|rawExp
operator|==
literal|0
condition|)
block|{
comment|// don't know how to handle this currently: hand it over to Java to deal with
name|s
operator|.
name|append
argument_list|(
name|Double
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|exponential
condition|)
block|{
name|fppfppExponential
argument_list|(
name|s
argument_list|,
name|exp
argument_list|,
name|fraction
argument_list|,
literal|52
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|<=
literal|0.01
condition|)
block|{
name|fppfppBig
argument_list|(
name|s
argument_list|,
name|exp
argument_list|,
name|fraction
argument_list|,
literal|52
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fppfpp
argument_list|(
name|s
argument_list|,
name|exp
argument_list|,
name|fraction
argument_list|,
literal|52
argument_list|)
expr_stmt|;
block|}
block|}
comment|// test code
comment|//            try {
comment|//                if (Double.parseDouble(s.toString()) != value) {
comment|//                    System.err.println("*** Round-trip failed: input " + value +
comment|//                            '(' + Double.doubleToLongBits(value) + ')' +
comment|//                            " != output " + s.toString() +
comment|//                            '(' + Double.doubleToLongBits(Double.parseDouble(s.toString())) + ')' );
comment|//                }
comment|//            } catch (NumberFormatException e) {
comment|//                System.err.println("*** Bad float " + s.toString() + " for input " + value);
comment|//            }
block|}
return|return
name|s
return|;
block|}
comment|/**      * Append a string representation of a float value to a string buffer      * @param s the string buffer to which the result will be appended      * @param value the float to be formatted      * @return the original string buffer, now containing the string representation of the supplied float      */
specifier|public
specifier|static
name|FastStringBuffer
name|appendFloat
parameter_list|(
name|FastStringBuffer
name|s
parameter_list|,
name|float
name|value
parameter_list|)
block|{
name|float
name|f
init|=
name|value
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|Float
operator|.
name|NEGATIVE_INFINITY
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|NEGATIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|==
name|Float
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|!=
name|f
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|NaN
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|f
argument_list|)
operator|&
name|floatSignMask
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|==
name|Float
operator|.
name|MAX_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"3.4028235E38"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|==
operator|-
name|Float
operator|.
name|MAX_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"-3.4028235E38"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|==
name|Float
operator|.
name|MIN_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"1.4E-45"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|f
operator|==
operator|-
name|Float
operator|.
name|MIN_VALUE
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"-1.4E-45"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|f
operator|=
operator|-
name|f
expr_stmt|;
block|}
name|boolean
name|exponential
init|=
operator|(
name|f
operator|>=
literal|1000000
operator|||
name|f
operator|<
literal|0.000001F
operator|)
decl_stmt|;
name|int
name|bits
init|=
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|int
name|fraction
init|=
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
operator|(
name|bits
operator|&
name|floatFractMask
operator|)
decl_stmt|;
name|int
name|rawExp
init|=
operator|(
operator|(
name|bits
operator|&
name|floatExpMask
operator|)
operator|>>
name|floatExpShift
operator|)
decl_stmt|;
name|int
name|exp
init|=
name|rawExp
operator|-
name|floatExpBias
decl_stmt|;
name|int
name|precision
init|=
literal|23
decl_stmt|;
if|if
condition|(
name|rawExp
operator|==
literal|0
condition|)
block|{
comment|// don't know how to handle this currently: hand it over to Java to deal with
name|s
operator|.
name|append
argument_list|(
name|Float
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|exponential
condition|)
block|{
name|fppfppExponential
argument_list|(
name|s
argument_list|,
name|exp
argument_list|,
name|fraction
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fppfpp
argument_list|(
name|s
argument_list|,
name|exp
argument_list|,
name|fraction
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
comment|// test code
comment|//            try {
comment|//                if (Float.parseFloat(s.toString()) != value) {
comment|//                    System.err.println("*** Round-trip failed: input " + value +
comment|//                            '(' + Float.floatToIntBits(value) + ')' +
comment|//                            " != output " + s.toString() +
comment|//                            '(' + Float.floatToIntBits(Float.parseFloat(s.toString())) + ')' );
comment|//                }
comment|//            } catch (NumberFormatException e) {
comment|//                System.err.println("*** Bad float " + s.toString() + " for input " + value);
comment|//            }
block|}
return|return
name|s
return|;
block|}
comment|//    public static void main(String[] args) {
comment|//        if (args.length> 0&& args[0].equals("F")) {
comment|//            if (args.length == 2) {
comment|//                StringTokenizer tok = new StringTokenizer(args[1], ",");
comment|//                while (tok.hasMoreElements()) {
comment|//                    String input = tok.nextToken();
comment|//                    float f = Float.parseFloat(input);
comment|//                    FastStringBuffer sb = new FastStringBuffer(20);
comment|//                    appendFloat(sb, f);
comment|//                    System.err.println("input: " + input + " output: " + sb.toString() + " java: " + f);
comment|//                }
comment|//            } else {
comment|//                Random gen = new Random();
comment|//                for (int i=1; i<1000; i++) {
comment|//                    int p=gen.nextInt(999*i*i);
comment|//                    int q=gen.nextInt(999*i*i);
comment|//                    String input = (p + "." + q);
comment|//                    float f = Float.parseFloat(input);
comment|//                    FastStringBuffer sb = new FastStringBuffer(20);
comment|//                    appendFloat(sb, f);
comment|//                    System.err.println("input: " + input + " output: " + sb.toString() + " java: " + f);
comment|//                }
comment|//            }
comment|//        } else {
comment|//            if (args.length == 2) {
comment|//                StringTokenizer tok = new StringTokenizer(args[1], ",");
comment|//                while (tok.hasMoreElements()) {
comment|//                    String input = tok.nextToken();
comment|//                    double f = Double.parseDouble(input);
comment|//                    FastStringBuffer sb = new FastStringBuffer(20);
comment|//                    appendDouble(sb, f);
comment|//                    System.err.println("input: " + input + " output: " + sb.toString() + " java: " + f);
comment|//                }
comment|//            } else {
comment|//                long start = System.currentTimeMillis();
comment|//                Random gen = new Random();
comment|//                for (int i=1; i<100000; i++) {
comment|//                    //int p=gen.nextInt(999*i*i);
comment|//                    int q=gen.nextInt(999*i);
comment|//                    //String input = (p + "." + q);
comment|//                    String input = "0.000" + q;
comment|//                    double f = Double.parseDouble(input);
comment|//                    FastStringBuffer sb = new FastStringBuffer(20);
comment|//                    appendDouble(sb, f);
comment|//                    //System.err.println("input: " + input + " output: " + sb.toString() + " java: " + f);
comment|//                }
comment|//                System.err.println("** elapsed time " + (System.currentTimeMillis() - start));
comment|//            }
comment|//        }
comment|//    }
block|}
end_class

begin_comment
comment|//
end_comment

begin_comment
comment|// The contents of this file are subject to the Mozilla Public License Version 1.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License. You may obtain a copy of the
end_comment

begin_comment
comment|// License at http://www.mozilla.org/MPL/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Software distributed under the License is distributed on an "AS IS" basis,
end_comment

begin_comment
comment|// WITHOUT WARRANTY OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing rights and limitations under the License.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Original Code is: all this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Initial Developer of the Original Code is Michael H. Kay, based on a published algorithm by
end_comment

begin_comment
comment|// Guy L. Steele and Jon L. White.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Contributor(s): the appendInt routine, and some of the constant declarations (and some of the ideas) are
end_comment

begin_comment
comment|// from the class AppenderHelper by Jack Shirazi in the O'Reilly book Java Performance Tuning..
end_comment

begin_comment
comment|//
end_comment

end_unit

