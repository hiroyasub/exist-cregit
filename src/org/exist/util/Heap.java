begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*   File: Heap.java    Originally written by Doug Lea and released into the public domain.   This may be used for any purposes whatsoever without acknowledgment.   Thanks for the assistance and support of Sun Microsystems Labs,   and everyone contributing, testing, and using this code.    History:   Date       Who                What   29Aug1998  dl               Refactored from BoundedPriorityQueue   08dec2001  dl               Null out slots of removed items   03feb2002  dl               Also null out in clear */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_comment
comment|/**  * A heap-based priority queue, without any concurrency control  * (i.e., no blocking on empty/full states).  * This class provides the data structure mechanics for BoundedPriorityQueue.  *<p>  * The class currently uses a standard array-based heap, as described  * in, for example, Sedgewick's Algorithms text. All methods  * are fully synchronized. In the future,  * it may instead use structures permitting finer-grained locking.  *<p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package.</a>]  **/
end_comment

begin_class
specifier|public
class|class
name|Heap
block|{
specifier|protected
name|Object
index|[]
name|nodes_
decl_stmt|;
comment|// the tree nodes, packed into an array
specifier|protected
name|int
name|count_
init|=
literal|0
decl_stmt|;
comment|// number of used slots
specifier|protected
specifier|final
name|Comparator
name|cmp_
decl_stmt|;
comment|// for ordering
comment|/**    * Create a Heap with the given initial capacity and comparator    * @exception IllegalArgumentException if capacity less or equal to zero    **/
specifier|public
name|Heap
parameter_list|(
name|int
name|capacity
parameter_list|,
name|Comparator
name|cmp
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|capacity
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|nodes_
operator|=
operator|new
name|Object
index|[
name|capacity
index|]
expr_stmt|;
name|cmp_
operator|=
name|cmp
expr_stmt|;
block|}
comment|/**    * Create a Heap with the given capacity,    * and relying on natural ordering.    **/
specifier|public
name|Heap
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|this
argument_list|(
name|capacity
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** perform element comaprisons using comparator or natural ordering **/
specifier|protected
name|int
name|compare
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
if|if
condition|(
name|cmp_
operator|==
literal|null
condition|)
block|{
return|return
operator|(
operator|(
name|Comparable
operator|)
name|a
operator|)
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|cmp_
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
comment|// indexes of heap parents and children
specifier|protected
specifier|final
name|int
name|parent
parameter_list|(
name|int
name|k
parameter_list|)
block|{
return|return
operator|(
name|k
operator|-
literal|1
operator|)
operator|/
literal|2
return|;
block|}
specifier|protected
specifier|final
name|int
name|left
parameter_list|(
name|int
name|k
parameter_list|)
block|{
return|return
literal|2
operator|*
name|k
operator|+
literal|1
return|;
block|}
specifier|protected
specifier|final
name|int
name|right
parameter_list|(
name|int
name|k
parameter_list|)
block|{
return|return
literal|2
operator|*
operator|(
name|k
operator|+
literal|1
operator|)
return|;
block|}
comment|/**    * insert an element, resize if necessary    **/
specifier|public
specifier|synchronized
name|void
name|insert
parameter_list|(
name|Object
name|x
parameter_list|)
block|{
if|if
condition|(
name|count_
operator|>=
name|nodes_
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newcap
init|=
literal|3
operator|*
name|nodes_
operator|.
name|length
operator|/
literal|2
operator|+
literal|1
decl_stmt|;
name|Object
index|[]
name|newnodes
init|=
operator|new
name|Object
index|[
name|newcap
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|nodes_
argument_list|,
literal|0
argument_list|,
name|newnodes
argument_list|,
literal|0
argument_list|,
name|nodes_
operator|.
name|length
argument_list|)
expr_stmt|;
name|nodes_
operator|=
name|newnodes
expr_stmt|;
block|}
name|int
name|k
init|=
name|count_
decl_stmt|;
operator|++
name|count_
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|int
name|par
init|=
name|parent
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|x
argument_list|,
name|nodes_
index|[
name|par
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nodes_
index|[
name|k
index|]
operator|=
name|nodes_
index|[
name|par
index|]
expr_stmt|;
name|k
operator|=
name|par
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|nodes_
index|[
name|k
index|]
operator|=
name|x
expr_stmt|;
block|}
comment|/**    * Return and remove least element, or null if empty    **/
specifier|public
specifier|synchronized
name|Object
name|extract
parameter_list|()
block|{
if|if
condition|(
name|count_
operator|<
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|k
init|=
literal|0
decl_stmt|;
comment|// take element at root;
specifier|final
name|Object
name|least
init|=
name|nodes_
index|[
name|k
index|]
decl_stmt|;
operator|--
name|count_
expr_stmt|;
name|Object
name|x
init|=
name|nodes_
index|[
name|count_
index|]
decl_stmt|;
name|nodes_
index|[
name|count_
index|]
operator|=
literal|null
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|int
name|l
init|=
name|left
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|>=
name|count_
condition|)
block|{
break|break;
block|}
else|else
block|{
specifier|final
name|int
name|r
init|=
name|right
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|int
name|child
init|=
operator|(
name|r
operator|>=
name|count_
operator|||
name|compare
argument_list|(
name|nodes_
index|[
name|l
index|]
argument_list|,
name|nodes_
index|[
name|r
index|]
argument_list|)
operator|<
literal|0
operator|)
condition|?
name|l
else|:
name|r
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|x
argument_list|,
name|nodes_
index|[
name|child
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|nodes_
index|[
name|k
index|]
operator|=
name|nodes_
index|[
name|child
index|]
expr_stmt|;
name|k
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
name|nodes_
index|[
name|k
index|]
operator|=
name|x
expr_stmt|;
return|return
name|least
return|;
block|}
comment|/** Return least element without removing it, or null if empty **/
specifier|public
specifier|synchronized
name|Object
name|peek
parameter_list|()
block|{
if|if
condition|(
name|count_
operator|>
literal|0
condition|)
block|{
return|return
name|nodes_
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Return number of elements **/
specifier|public
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
return|return
name|count_
return|;
block|}
comment|/** remove all elements **/
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count_
condition|;
operator|++
name|i
control|)
name|nodes_
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|count_
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_class

end_unit

