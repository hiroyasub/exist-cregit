begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-2006 The eXist team  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software Foundation  *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  *  *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|http
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|output
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletOutputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParserFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|OutputKeys
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Transformer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|DOMSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|sax
operator|.
name|SAXTransformerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|sax
operator|.
name|TemplatesHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|sax
operator|.
name|TransformerHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|stream
operator|.
name|StreamResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Namespaces
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|BinaryDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|http
operator|.
name|servlets
operator|.
name|HttpRequestWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|http
operator|.
name|servlets
operator|.
name|HttpResponseWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|http
operator|.
name|servlets
operator|.
name|RequestWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|http
operator|.
name|servlets
operator|.
name|ResponseWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentBuilderReceiver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|MemTreeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|SAXAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|xacml
operator|.
name|AccessContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|source
operator|.
name|Source
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|source
operator|.
name|StringSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|XQueryPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|WSDLFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|MimeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Cardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|CompiledXQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|FunctionSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Module
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQueryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|request
operator|.
name|RequestModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|response
operator|.
name|ResponseModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|functions
operator|.
name|session
operator|.
name|SessionModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|SequenceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|XMLReader
import|;
end_import

begin_comment
comment|/**  * @author Adam Retter<adam.retter@devon.gov.uk>  * @author Jose Maria Fernandez  *   * @serial 20070531T12:18:00  *   * The SOAPServer allows Web Services to be written in XQuery; it translates a   * SOAP Request to an XQuery function call and then translates the result of the  * XQuery function to a SOAP Response.  *   * This is done by managing an internal representation of an XQWS (XQuery Web Service),  * through this it is able to provide enough information to an XSLT proccessor to  * generate WSDL and human readable descriptions of the web service and individual  * functions.  *   * XSLT's are provided for both document literal and RPC style Web Service's and are  * located in $EXIST_HOME/tools/SOAPServer  */
end_comment

begin_class
specifier|public
class|class
name|SOAPServer
block|{
specifier|private
name|String
name|formEncoding
decl_stmt|;
comment|//TODO: we may be able to remove this eventually, in favour of HttpServletRequestWrapper being setup in EXistServlet, currently used for doPost() but perhaps could be used for other Request Methods? - deliriumsky
specifier|private
name|String
name|containerEncoding
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|ENCODING
init|=
literal|"UTF-8"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|SEPERATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|XSLT_WEBSERVICE_WSDL
init|=
literal|"/db/system/webservice/wsdl.xslt"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|XSLT_WEBSERVICE_HUMAN_DESCRIPTION
init|=
literal|"/db/system/webservice/human.description.xslt"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|XSLT_WEBSERVICE_FUNCTION_DESCRIPTION
init|=
literal|"/db/system/webservice/function.description.xslt"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|XSLT_WEBSERVICE_SOAP_RESPONSE
init|=
literal|"/db/system/webservice/soap.response.xslt"
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|WEBSERVICE_MODULE_EXTENSION
init|=
literal|".xqws"
decl_stmt|;
specifier|private
name|HashMap
name|XQWSDescriptionsCache
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|//TODO: SHARE THIS FUNCTION WITH RESTServer (copied at the moment)
specifier|private
specifier|final
specifier|static
name|String
name|QUERY_ERROR_HEAD
init|=
literal|"<html>"
operator|+
literal|"<head>"
operator|+
literal|"<title>Query Error</title>"
operator|+
literal|"<style type=\"text/css\">"
operator|+
literal|".errmsg {"
operator|+
literal|"  border: 1px solid black;"
operator|+
literal|"  padding: 15px;"
operator|+
literal|"  margin-left: 20px;"
operator|+
literal|"  margin-right: 20px;"
operator|+
literal|"}"
operator|+
literal|"h1 { color: #C0C0C0; }"
operator|+
literal|".path {"
operator|+
literal|"  padding-bottom: 10px;"
operator|+
literal|"}"
operator|+
literal|".high { "
operator|+
literal|"  color: #666699; "
operator|+
literal|"  font-weight: bold;"
operator|+
literal|"}"
operator|+
literal|"</style>"
operator|+
literal|"</head>"
operator|+
literal|"<body>"
operator|+
literal|"<h1>XQuery Error</h1>"
decl_stmt|;
comment|/** 	 * Constructor 	 *  	 * @param formEncoding	The character encoding method to be used for form data 	 * @param containerEncoding	The character encoding method to be used for the container   	 */
specifier|public
name|SOAPServer
parameter_list|(
name|String
name|formEncoding
parameter_list|,
name|String
name|containerEncoding
parameter_list|)
block|{
name|this
operator|.
name|formEncoding
operator|=
name|formEncoding
expr_stmt|;
name|this
operator|.
name|containerEncoding
operator|=
name|containerEncoding
expr_stmt|;
block|}
comment|/**      * Compiles an XQuery or returns a cached version if one exists      *       * @param broker	The Database Broker to use      * @param xqSource	The XQuery source      * @param staticallyKnownDocuments	An array of XmldbURI's for documents that should be considered statically known by the XQuery      * @param xqwsCollectionUri	The XmldbUri of the collection where the XQWS resides      * @param request	The HttpServletRequest for the XQWS      * @param response	The HttpServletResponse for the XQWS      *       * @return The compiled XQuery      */
specifier|private
name|CompiledXQuery
name|compileXQuery
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Source
name|xqSource
parameter_list|,
name|XmldbURI
index|[]
name|staticallyKnownDocuments
parameter_list|,
name|XmldbURI
name|xqwsCollectionUri
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|XPathException
block|{
comment|//Get the xquery service
name|XQuery
name|xquery
init|=
name|broker
operator|.
name|getXQueryService
argument_list|()
decl_stmt|;
name|XQueryPool
name|pool
init|=
name|xquery
operator|.
name|getXQueryPool
argument_list|()
decl_stmt|;
name|XQueryContext
name|context
decl_stmt|;
comment|//try and get pre-compiled XQuery from the cache
name|CompiledXQuery
name|compiled
init|=
name|pool
operator|.
name|borrowCompiledXQuery
argument_list|(
name|broker
argument_list|,
name|xqSource
argument_list|)
decl_stmt|;
comment|//Create the context and set a header to indicate cache status
if|if
condition|(
name|compiled
operator|==
literal|null
condition|)
block|{
name|context
operator|=
name|xquery
operator|.
name|newContext
argument_list|(
name|AccessContext
operator|.
name|REST
argument_list|)
expr_stmt|;
comment|//response.setHeader("X-XQuery-Cached", "false");
block|}
else|else
block|{
name|context
operator|=
name|compiled
operator|.
name|getContext
argument_list|()
expr_stmt|;
comment|//response.setHeader("X-XQuery-Cached", "true");
block|}
comment|//Setup the context
name|declareVariables
argument_list|(
name|context
argument_list|,
name|request
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|context
operator|.
name|setModuleLoadPath
argument_list|(
name|XmldbURI
operator|.
name|EMBEDDED_SERVER_URI
operator|.
name|append
argument_list|(
name|xqwsCollectionUri
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|setStaticallyKnownDocuments
argument_list|(
name|staticallyKnownDocuments
argument_list|)
expr_stmt|;
comment|//no pre-compiled XQuery, so compile, it
if|if
condition|(
name|compiled
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|compiled
operator|=
name|xquery
operator|.
name|compile
argument_list|(
name|context
argument_list|,
name|xqSource
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"Failed to compile query: "
operator|+
name|xqSource
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|//store the compiled xqws for use later
name|pool
operator|.
name|returnCompiledXQuery
argument_list|(
name|xqSource
argument_list|,
name|compiled
argument_list|)
expr_stmt|;
return|return
name|compiled
return|;
block|}
comment|/**      * Creates an XQuery to call an XQWS function from a SOAP Request      *       * @param broker	The Database Broker to use      * @param xqwsFileUri	The XmldbURI of the XQWS file      * @param xqwsNamespace	The namespace of the xqws      * @param xqwsCollectionUri	The XmldbUri of the collection where the XQWS resides      * @param xqwsSOAPFunction	The Node from the SOAP request for the Function call from the Http Request      * @param xqwsDescription	The internal description of the XQWS      * @param request	The Http Servlet Request      * @param response The Http Servlet Response      *       * @return The compiled XQuery      */
specifier|private
name|CompiledXQuery
name|XQueryExecuteXQWSFunction
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Node
name|xqwsSOAPFunction
parameter_list|,
name|XQWSDescription
name|xqwsDescription
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|XPathException
block|{
name|StringBuffer
name|query
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|"xquery version \"1.0\";"
operator|+
name|SEPERATOR
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|SEPERATOR
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|"import module namespace "
operator|+
name|xqwsDescription
operator|.
name|getNamespace
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"=\""
operator|+
name|xqwsDescription
operator|.
name|getNamespace
argument_list|()
operator|.
name|getNamespaceURI
argument_list|()
operator|+
literal|"\" at \""
operator|+
name|xqwsDescription
operator|.
name|getFileURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"\";"
operator|+
name|SEPERATOR
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
name|SEPERATOR
argument_list|)
expr_stmt|;
comment|//add the function call to the xquery
name|String
name|functionName
init|=
name|xqwsSOAPFunction
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|functionName
operator|==
literal|null
condition|)
block|{
name|functionName
operator|=
name|xqwsSOAPFunction
operator|.
name|getNodeName
argument_list|()
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
name|xqwsDescription
operator|.
name|getNamespace
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|+
literal|":"
operator|+
name|functionName
operator|+
literal|"("
argument_list|)
expr_stmt|;
comment|//add the arguments for the function call if any
name|NodeList
name|xqwsSOAPFunctionParams
init|=
name|xqwsSOAPFunction
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|Node
name|nInternalFunction
init|=
name|xqwsDescription
operator|.
name|getFunction
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
name|NodeList
name|nlInternalFunctionParams
init|=
name|xqwsDescription
operator|.
name|getFunctionParameters
argument_list|(
name|nInternalFunction
argument_list|)
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xqwsSOAPFunctionParams
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|nSOAPFunctionParam
init|=
name|xqwsSOAPFunctionParams
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nSOAPFunctionParam
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
comment|// Did we reached the length?
if|if
condition|(
name|j
operator|==
name|nlInternalFunctionParams
operator|.
name|getLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"Too many input parameters for "
operator|+
name|functionName
operator|+
literal|": expected="
operator|+
name|xqwsSOAPFunctionParams
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
block|}
name|query
operator|.
name|append
argument_list|(
name|writeXQueryFunctionParameter
argument_list|(
name|xqwsDescription
operator|.
name|getFunctionParameterType
argument_list|(
name|nlInternalFunctionParams
operator|.
name|item
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|,
name|xqwsDescription
operator|.
name|getFunctionParameterCardinality
argument_list|(
name|nlInternalFunctionParams
operator|.
name|item
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|,
name|nSOAPFunctionParam
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
comment|//add function seperator
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|!=
name|xqwsSOAPFunctionParams
operator|.
name|getLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"Input parameters number mismatch for "
operator|+
name|functionName
operator|+
literal|": expected="
operator|+
name|xqwsSOAPFunctionParams
operator|.
name|getLength
argument_list|()
operator|+
literal|" got="
operator|+
name|j
argument_list|)
throw|;
block|}
comment|//remove last superflurous seperator
if|if
condition|(
name|query
operator|.
name|charAt
argument_list|(
name|query
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|','
condition|)
block|{
name|query
operator|.
name|deleteCharAt
argument_list|(
name|query
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|//compile the query
return|return
name|compileXQuery
argument_list|(
name|broker
argument_list|,
operator|new
name|StringSource
argument_list|(
name|query
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|XmldbURI
index|[]
block|{
name|xqwsDescription
operator|.
name|getCollectionURI
argument_list|()
block|}
argument_list|,
name|xqwsDescription
operator|.
name|getCollectionURI
argument_list|()
argument_list|,
name|request
argument_list|,
name|response
argument_list|)
return|;
block|}
comment|/**      * Writes the value of a parameter for an XQuery function call      *       * @param param	This StringBuffer contains the serialization of the value for XQuery      * @param nParamSeqItem	The parameter value node from the SOAP Message      * @param prefix	The prefix for the value (casting syntax)      * @param postfix	The postfix for the value (casting syntax)      * @param isAtomic	Whether the value of this type should be atomic or not (or even both)      */
specifier|private
name|void
name|processParameterValue
parameter_list|(
name|StringBuffer
name|param
parameter_list|,
name|Node
name|nParamSeqItem
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|postfix
parameter_list|,
name|int
name|isAtomic
parameter_list|)
throws|throws
name|XPathException
block|{
name|boolean
name|justOnce
init|=
literal|false
decl_stmt|;
name|StringBuffer
name|whiteContent
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|Transformer
name|tr
init|=
name|TransformerFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newTransformer
argument_list|()
decl_stmt|;
name|tr
operator|.
name|setOutputProperty
argument_list|(
name|OutputKeys
operator|.
name|OMIT_XML_DECLARATION
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
name|Node
name|n
init|=
name|nParamSeqItem
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|StreamResult
name|result
init|=
operator|new
name|StreamResult
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|StringBuffer
name|psw
init|=
name|sw
operator|.
name|getBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|n
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
if|if
condition|(
name|isAtomic
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Content of "
operator|+
name|nParamSeqItem
operator|.
name|getNodeName
argument_list|()
operator|+
literal|" must be an atomic value"
argument_list|)
throw|;
block|}
name|isAtomic
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|justOnce
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
name|nParamSeqItem
operator|.
name|getNodeName
argument_list|()
operator|+
literal|" must have ONLY ONE element child"
argument_list|)
throw|;
block|}
name|DOMSource
name|source
init|=
operator|new
name|DOMSource
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|tr
operator|.
name|transform
argument_list|(
name|source
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|// Only once!
name|justOnce
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
case|case
name|Node
operator|.
name|CDATA_SECTION_NODE
case|:
name|String
name|nodeValue
init|=
name|n
operator|.
name|getNodeValue
argument_list|()
decl_stmt|;
name|boolean
name|isNotWhite
init|=
operator|!
name|nodeValue
operator|.
name|matches
argument_list|(
literal|"[ \n\r\t]+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAtomic
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isNotWhite
operator|||
name|isAtomic
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isAtomic
operator|==
literal|0
condition|)
block|{
name|isAtomic
operator|=
literal|1
expr_stmt|;
block|}
name|psw
operator|.
name|append
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|isAtomic
operator|==
literal|0
condition|)
block|{
name|whiteContent
operator|.
name|append
argument_list|(
name|nodeValue
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|isNotWhite
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
name|nParamSeqItem
operator|.
name|getNodeName
argument_list|()
operator|+
literal|" has mixed content, but it must have only one element child"
argument_list|)
throw|;
block|}
break|break;
block|}
name|n
operator|=
name|n
operator|.
name|getNextSibling
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isAtomic
operator|>=
literal|0
condition|)
block|{
name|param
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isAtomic
operator|==
literal|0
condition|)
block|{
name|param
operator|.
name|append
argument_list|(
name|whiteContent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|param
operator|.
name|append
argument_list|(
name|psw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isAtomic
operator|>=
literal|0
condition|)
block|{
name|param
operator|.
name|append
argument_list|(
name|postfix
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Writes a parameter for an XQuery function call      *       * @param paramType	The type of the Parameter (from the internal description of the XQWS)      * @param paramCardinality The cardinality of the Parameter (from the internal description of the XQWS)      * @param SOAPParam	The Node from the SOAP request for the Paremeter of the Function call from the Http Request       *       * @return A String representation of the parameter, suitable for use in the function call       */
specifier|private
name|StringBuffer
name|writeXQueryFunctionParameter
parameter_list|(
name|String
name|paramType
parameter_list|,
name|int
name|paramCardinality
parameter_list|,
name|Node
name|nSOAPParam
parameter_list|)
throws|throws
name|XPathException
block|{
name|String
name|prefix
init|=
operator|new
name|String
argument_list|()
decl_stmt|;
name|String
name|postfix
init|=
name|prefix
decl_stmt|;
comment|//determine the type of the parameter
name|int
name|type
init|=
name|Type
operator|.
name|getType
argument_list|(
name|paramType
argument_list|)
decl_stmt|;
name|int
name|isAtomic
init|=
operator|(
name|Type
operator|.
name|subTypeOf
argument_list|(
name|type
argument_list|,
name|Type
operator|.
name|ATOMIC
argument_list|)
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|Type
operator|.
name|subTypeOf
argument_list|(
name|type
argument_list|,
name|Type
operator|.
name|NODE
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|isAtomic
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isAtomic
operator|>
literal|0
operator|&&
name|type
operator|!=
name|Type
operator|.
name|STRING
condition|)
block|{
name|String
name|typeName
init|=
name|Type
operator|.
name|getTypeName
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeName
operator|!=
literal|null
condition|)
block|{
name|prefix
operator|=
name|typeName
operator|+
literal|"(\""
expr_stmt|;
name|postfix
operator|=
literal|"\")"
expr_stmt|;
block|}
block|}
else|else
block|{
name|prefix
operator|=
literal|"\""
expr_stmt|;
name|postfix
operator|=
name|prefix
expr_stmt|;
block|}
block|}
name|StringBuffer
name|param
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|//determine the cardinality of the parameter
if|if
condition|(
name|paramCardinality
operator|>=
name|Cardinality
operator|.
name|MANY
condition|)
block|{
comment|//sequence
name|param
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|NodeList
name|nlParamSequenceItems
init|=
name|nSOAPParam
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlParamSequenceItems
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|nParamSeqItem
init|=
name|nlParamSequenceItems
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nParamSeqItem
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|processParameterValue
argument_list|(
name|param
argument_list|,
name|nParamSeqItem
argument_list|,
name|prefix
argument_list|,
name|postfix
argument_list|,
name|isAtomic
argument_list|)
expr_stmt|;
name|param
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
comment|//seperator for next item in sequence
block|}
block|}
comment|//remove last superflurous seperator
if|if
condition|(
name|param
operator|.
name|charAt
argument_list|(
name|param
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|','
condition|)
block|{
name|param
operator|.
name|deleteCharAt
argument_list|(
name|param
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|param
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processParameterValue
argument_list|(
name|param
argument_list|,
name|nSOAPParam
argument_list|,
name|prefix
argument_list|,
name|postfix
argument_list|,
name|isAtomic
argument_list|)
expr_stmt|;
block|}
return|return
name|param
return|;
block|}
comment|/**      * Get's an XQWS Description from the cache.      * If the description in the cache is out of date it will be refreshed.      * If there is no cached description a new one is created and added      * to the cache.      *       * @param broker	The Database Broker to use      * @param path	The path of the http request      * @param request	The HttpServletRequest for the XQWS      *       * @return An object describing the XQWS      */
specifier|private
name|XQWSDescription
name|getXQWSDescription
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|String
name|path
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|XPathException
throws|,
name|SAXException
throws|,
name|NotFoundException
block|{
name|XQWSDescription
name|description
decl_stmt|;
comment|//is there a description for this path
if|if
condition|(
name|XQWSDescriptionsCache
operator|.
name|containsKey
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|//get the description from the cache
name|description
operator|=
operator|(
name|XQWSDescription
operator|)
name|XQWSDescriptionsCache
operator|.
name|get
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|//is the description is invalid, refresh it
if|if
condition|(
operator|!
name|description
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|description
operator|.
name|refresh
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//create a new description
name|description
operator|=
operator|new
name|XQWSDescription
argument_list|(
name|broker
argument_list|,
name|path
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
comment|//store description in the cache
name|XQWSDescriptionsCache
operator|.
name|put
argument_list|(
name|path
argument_list|,
name|description
argument_list|)
expr_stmt|;
comment|//return the description
return|return
name|description
return|;
block|}
comment|/** 	 * HTTP GET 	 * Processes requests for description documents - WSDL, Human Readable and Human Readable for a specific function 	 *  	 * TODO: I think simple webservices can also be called using GET, so we may need to cater for that as well 	 * but first it would be best to write the doPost() method, split the code out into functions and also use it for this. 	 */
specifier|public
name|void
name|doGet
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|BadRequestException
throws|,
name|PermissionDeniedException
throws|,
name|NotFoundException
throws|,
name|IOException
block|{
comment|//set the encoding
if|if
condition|(
name|request
operator|.
name|getCharacterEncoding
argument_list|()
operator|==
literal|null
condition|)
name|request
operator|.
name|setCharacterEncoding
argument_list|(
name|formEncoding
argument_list|)
expr_stmt|;
comment|/* Process the request */
try|try
block|{
comment|//Get a Description of the XQWS
name|XQWSDescription
name|description
init|=
name|getXQWSDescription
argument_list|(
name|broker
argument_list|,
name|path
argument_list|,
name|request
argument_list|)
decl_stmt|;
comment|//Get the approriate description for the user
name|byte
index|[]
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|getParameter
argument_list|(
literal|"WSDL"
argument_list|)
operator|!=
literal|null
operator|||
name|request
operator|.
name|getParameter
argument_list|(
literal|"wsdl"
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//WSDL document literal
name|result
operator|=
name|description
operator|.
name|getWSDL
argument_list|()
expr_stmt|;
comment|//set output content type for wsdl
name|response
operator|.
name|setContentType
argument_list|(
name|MimeType
operator|.
name|XML_TYPE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|request
operator|.
name|getParameter
argument_list|(
literal|"WSDLRPC"
argument_list|)
operator|!=
literal|null
operator|||
name|request
operator|.
name|getParameter
argument_list|(
literal|"wsdlrpc"
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//WSDL RPC
name|result
operator|=
name|description
operator|.
name|getWSDL
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//set output content type for wsdl
name|response
operator|.
name|setContentType
argument_list|(
name|MimeType
operator|.
name|XML_TYPE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|request
operator|.
name|getParameter
argument_list|(
literal|"function"
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//Specific Function Description
name|result
operator|=
name|description
operator|.
name|getFunctionDescription
argument_list|(
name|request
operator|.
name|getParameter
argument_list|(
literal|"function"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Human Readable Description
name|result
operator|=
name|description
operator|.
name|getHumanDescription
argument_list|()
expr_stmt|;
block|}
comment|//send the description to the http servlet response
name|ServletOutputStream
name|os
init|=
name|response
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|BufferedOutputStream
name|bos
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|bos
operator|.
name|write
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|bos
operator|.
name|close
argument_list|()
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|xpe
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
name|xpe
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|saxe
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
operator|new
name|XPathException
argument_list|(
literal|null
argument_list|,
literal|"SAX exception while transforming node: "
operator|+
name|saxe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|saxe
argument_list|)
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransformerConfigurationException
name|tce
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
operator|new
name|XPathException
argument_list|(
literal|null
argument_list|,
literal|"SAX exception while transforming node: "
operator|+
name|tce
operator|.
name|getMessage
argument_list|()
argument_list|,
name|tce
argument_list|)
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
block|}
block|}
comment|//process incomoing SOAP requests
specifier|public
name|void
name|doPost
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|BadRequestException
throws|,
name|PermissionDeniedException
throws|,
name|NotFoundException
throws|,
name|IOException
block|{
comment|/* 		 * Example incoming SOAP Request 		 *<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"><SOAP-ENV:Header/><SOAP-ENV:Body><echo xmlns="http://localhost:8080/exist/servlet/db/echo.xqws"><arg1>adam</arg1></echo></SOAP-ENV:Body></SOAP-ENV:Envelope> 		 */
comment|// 1) Read the incoming SOAP request
name|InputStream
name|is
init|=
name|request
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|request
operator|.
name|getContentLength
argument_list|()
index|]
decl_stmt|;
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
literal|4096
decl_stmt|;
while|while
condition|(
operator|(
name|bytes
operator|=
name|is
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|max
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|offset
operator|+=
name|bytes
expr_stmt|;
block|}
comment|// 2) Create an XML Document from the SOAP Request
name|Document
name|soapRequest
init|=
literal|null
decl_stmt|;
try|try
block|{
name|soapRequest
operator|=
name|BuildXMLDocument
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
operator|new
name|XPathException
argument_list|(
literal|null
argument_list|,
literal|"Unable to construct an XML document from the SOAP Request, probably an invalid request: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// 3) Validate the SOAP Request
comment|//TODO: validate the SOAP Request
comment|// 4) Extract the function call from the SOAP Request
name|NodeList
name|nlBody
init|=
name|soapRequest
operator|.
name|getDocumentElement
argument_list|()
operator|.
name|getElementsByTagNameNS
argument_list|(
name|Namespaces
operator|.
name|SOAP_ENVELOPE
argument_list|,
literal|"Body"
argument_list|)
decl_stmt|;
name|Node
name|nSOAPBody
init|=
name|nlBody
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|nlBodyChildren
init|=
name|nSOAPBody
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|Node
name|nSOAPFunction
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlBodyChildren
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|bodyChild
init|=
name|nlBodyChildren
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bodyChild
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|nSOAPFunction
operator|=
name|bodyChild
expr_stmt|;
break|break;
block|}
block|}
comment|// Check the namespace for the function in the SOAP document is the same as the request path?
name|String
name|funcNamespace
init|=
name|nSOAPFunction
operator|.
name|getNamespaceURI
argument_list|()
decl_stmt|;
if|if
condition|(
name|funcNamespace
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|funcNamespace
operator|.
name|equals
argument_list|(
name|request
operator|.
name|getRequestURL
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
comment|//function in SOAP request has an invalid namespace
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
literal|"SOAP Function call has invalid namespace, got: "
operator|+
name|funcNamespace
operator|+
literal|" but expected: "
operator|+
name|request
operator|.
name|getRequestURL
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|//function in SOAP request has no namespace
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
literal|"SOAP Function call has no namespace, expected: "
operator|+
name|request
operator|.
name|getRequestURL
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// 4.5) Detemine encoding style
name|String
name|encodingStyle
init|=
operator|(
operator|(
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
operator|)
name|nSOAPFunction
operator|)
operator|.
name|getAttributeNS
argument_list|(
name|Namespaces
operator|.
name|SOAP_ENVELOPE
argument_list|,
literal|"encodingStyle"
argument_list|)
decl_stmt|;
name|boolean
name|isRpcEncoded
init|=
operator|(
name|encodingStyle
operator|!=
literal|null
operator|&&
name|encodingStyle
operator|.
name|equals
argument_list|(
literal|"http://schemas.xmlsoap.org/soap/encoding/"
argument_list|)
operator|)
decl_stmt|;
comment|// As this detection is a "quirk" which is not always available, let's use a better one...
if|if
condition|(
operator|!
name|isRpcEncoded
condition|)
block|{
name|NodeList
name|nlSOAPFunction
init|=
name|nSOAPFunction
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlSOAPFunction
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|functionChild
init|=
name|nlSOAPFunction
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionChild
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
operator|)
name|functionChild
operator|)
operator|.
name|hasAttributeNS
argument_list|(
name|Namespaces
operator|.
name|SCHEMA_INSTANCE_NS
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
name|isRpcEncoded
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// 5) Execute the XQWS function indicated by the SOAP request
try|try
block|{
comment|//Get the internal description for the function requested by SOAP (should be in the cache)
name|XQWSDescription
name|description
init|=
name|getXQWSDescription
argument_list|(
name|broker
argument_list|,
name|path
argument_list|,
name|request
argument_list|)
decl_stmt|;
comment|//Create an XQuery to call the XQWS function
name|CompiledXQuery
name|xqCallXQWS
init|=
name|XQueryExecuteXQWSFunction
argument_list|(
name|broker
argument_list|,
name|nSOAPFunction
argument_list|,
name|description
argument_list|,
name|request
argument_list|,
name|response
argument_list|)
decl_stmt|;
comment|//xqCallXQWS
name|XQuery
name|xqueryService
init|=
name|broker
operator|.
name|getXQueryService
argument_list|()
decl_stmt|;
name|Sequence
name|xqwsResult
init|=
name|xqueryService
operator|.
name|execute
argument_list|(
name|xqCallXQWS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// 6) Create a SOAP Response describing the Result
name|String
name|funcName
init|=
name|nSOAPFunction
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|funcName
operator|==
literal|null
condition|)
block|{
name|funcName
operator|=
name|nSOAPFunction
operator|.
name|getNodeName
argument_list|()
expr_stmt|;
block|}
name|byte
index|[]
name|result
init|=
name|description
operator|.
name|getSOAPResponse
argument_list|(
name|funcName
argument_list|,
name|xqwsResult
argument_list|,
name|request
argument_list|,
name|isRpcEncoded
argument_list|)
decl_stmt|;
comment|// 7) Send the SOAP Response to the http servlet response
name|response
operator|.
name|setContentType
argument_list|(
name|MimeType
operator|.
name|XML_TYPE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|ServletOutputStream
name|os
init|=
name|response
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|BufferedOutputStream
name|bos
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|bos
operator|.
name|write
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|bos
operator|.
name|close
argument_list|()
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathException
name|xpe
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
name|xpe
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|saxe
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
operator|new
name|XPathException
argument_list|(
literal|null
argument_list|,
literal|"SAX exception while transforming node: "
operator|+
name|saxe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|saxe
argument_list|)
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransformerConfigurationException
name|tce
parameter_list|)
block|{
name|response
operator|.
name|setStatus
argument_list|(
name|HttpServletResponse
operator|.
name|SC_BAD_REQUEST
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|response
argument_list|,
name|formatXPathException
argument_list|(
literal|null
argument_list|,
name|path
argument_list|,
operator|new
name|XPathException
argument_list|(
literal|null
argument_list|,
literal|"SAX exception while transforming node: "
operator|+
name|tce
operator|.
name|getMessage
argument_list|()
argument_list|,
name|tce
argument_list|)
argument_list|)
argument_list|,
literal|"text/html"
argument_list|,
name|ENCODING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Builds an XML Document from a string representation 	 *  	 * @param buf	The XML Document content 	 *  	 * @return	DOM XML Document 	 */
specifier|private
name|Document
name|BuildXMLDocument
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|SAXException
throws|,
name|ParserConfigurationException
throws|,
name|IOException
block|{
comment|//try and construct xml document from input stream, we use eXist's in-memory DOM implementation
name|SAXParserFactory
name|factory
init|=
name|SAXParserFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|factory
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//TODO we should be able to cope with context.getBaseURI()
name|InputSource
name|src
init|=
operator|new
name|InputSource
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|SAXParser
name|parser
init|=
name|factory
operator|.
name|newSAXParser
argument_list|()
decl_stmt|;
name|XMLReader
name|reader
init|=
name|parser
operator|.
name|getXMLReader
argument_list|()
decl_stmt|;
name|SAXAdapter
name|adapter
init|=
operator|new
name|SAXAdapter
argument_list|()
decl_stmt|;
name|reader
operator|.
name|setContentHandler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|reader
operator|.
name|setContentHandler
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|reader
operator|.
name|parse
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|//return receiver.getDocument();
return|return
name|adapter
operator|.
name|getDocument
argument_list|()
return|;
block|}
comment|/**      * Pass the request, response and session objects to the XQuery      * context.      *      * @param context      * @param request      * @param response      * @throws XPathException      */
specifier|private
name|void
name|declareVariables
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|request
operator|!=
literal|null
condition|)
block|{
name|RequestWrapper
name|reqw
init|=
operator|new
name|HttpRequestWrapper
argument_list|(
name|request
argument_list|,
name|formEncoding
argument_list|,
name|containerEncoding
argument_list|)
decl_stmt|;
name|context
operator|.
name|declareVariable
argument_list|(
name|RequestModule
operator|.
name|PREFIX
operator|+
literal|":request"
argument_list|,
name|reqw
argument_list|)
expr_stmt|;
name|context
operator|.
name|declareVariable
argument_list|(
name|SessionModule
operator|.
name|PREFIX
operator|+
literal|":session"
argument_list|,
name|reqw
operator|.
name|getSession
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|!=
literal|null
condition|)
block|{
name|ResponseWrapper
name|respw
init|=
operator|new
name|HttpResponseWrapper
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|context
operator|.
name|declareVariable
argument_list|(
name|ResponseModule
operator|.
name|PREFIX
operator|+
literal|":response"
argument_list|,
name|respw
argument_list|)
expr_stmt|;
block|}
block|}
comment|//TODO: SHARE THIS FUNCTION WITH RESTServer (copied at the moment)
comment|/**      * @param query      * @param e      */
specifier|private
name|String
name|formatXPathException
parameter_list|(
name|String
name|query
parameter_list|,
name|String
name|path
parameter_list|,
name|XPathException
name|e
parameter_list|)
block|{
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|QUERY_ERROR_HEAD
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"<p class=\"path\"><span class=\"high\">Path</span>: "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"<a href=\""
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"</a></p>"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"<p class=\"errmsg\">"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"<p><span class=\"high\">Query</span>:</p><pre>"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"</pre>"
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|"</body></html>"
argument_list|)
expr_stmt|;
return|return
name|writer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//TODO: SHARE THIS FUNCTION WITH RESTServer (copied at the moment)
specifier|private
name|void
name|writeResponse
parameter_list|(
name|HttpServletResponse
name|response
parameter_list|,
name|String
name|data
parameter_list|,
name|String
name|contentType
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
comment|// possible format contentType: text/xml; charset=UTF-8
if|if
condition|(
name|contentType
operator|!=
literal|null
operator|&&
operator|!
name|response
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
name|int
name|semicolon
init|=
name|contentType
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
if|if
condition|(
name|semicolon
operator|!=
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
block|{
name|contentType
operator|=
name|contentType
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|semicolon
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|setContentType
argument_list|(
name|contentType
operator|+
literal|"; charset="
operator|+
name|encoding
argument_list|)
expr_stmt|;
block|}
name|OutputStream
name|is
init|=
name|response
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|is
operator|.
name|write
argument_list|(
literal|"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|is
operator|.
name|write
argument_list|(
name|data
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|XQWSDescription
block|{
comment|/**     	 * Class describes an XQWS using an Internal XML Representation     	 *      	 * @author Adam Retter<adam.retter@devon.gov.uk>     	 * @serial 20061023T19:23:00     	 */
specifier|private
name|DBBroker
name|broker
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|HttpServletRequestURL
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|XQWSPath
init|=
literal|null
decl_stmt|;
specifier|private
name|XmldbURI
name|xqwsFileURI
init|=
literal|null
decl_stmt|;
specifier|private
name|XmldbURI
name|xqwsCollectionURI
init|=
literal|null
decl_stmt|;
specifier|private
name|QName
name|xqwsNamespace
init|=
literal|null
decl_stmt|;
comment|//cache for internal Description of an XQWS
specifier|private
name|long
name|lastModifiedXQWS
init|=
literal|0
decl_stmt|;
specifier|private
name|Module
name|modXQWS
init|=
literal|null
decl_stmt|;
specifier|private
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|docXQWSDescription
init|=
literal|null
decl_stmt|;
comment|//cache for XQWS WSDL
specifier|private
name|long
name|lastModifiedWSDL
init|=
literal|0
decl_stmt|;
specifier|private
name|byte
index|[]
index|[]
name|descriptionWSDL
init|=
block|{
literal|null
block|,
literal|null
block|}
decl_stmt|;
comment|//cache for XQWS Human Readable description
specifier|private
name|long
name|lastModifiedHuman
init|=
literal|0
decl_stmt|;
specifier|private
name|byte
index|[]
name|descriptionHuman
init|=
literal|null
decl_stmt|;
comment|//Cache for XQWS (Human Readable) Function description
specifier|private
name|long
name|lastModifiedFunction
init|=
literal|0
decl_stmt|;
specifier|private
name|HashMap
name|descriptionFunction
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|//key: functionName as String, value: byte[]
comment|/**     	 * Constructor     	 *      	 * @param broker	The Database Broker to use     	 * @param XQWSPath	The path to the XQWS     	 * @param request	The Http Request for the XQWS     	 */
specifier|public
name|XQWSDescription
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|String
name|XQWSPath
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|)
throws|throws
name|XPathException
throws|,
name|SAXException
throws|,
name|PermissionDeniedException
throws|,
name|NotFoundException
block|{
name|this
operator|.
name|broker
operator|=
name|broker
expr_stmt|;
name|this
operator|.
name|HttpServletRequestURL
operator|=
name|request
operator|.
name|getRequestURL
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|XQWSPath
operator|=
name|XQWSPath
expr_stmt|;
comment|//create an initial description of the XQWS
name|createInternalDescription
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
comment|/**     	 * Returns the URI of the XQWS file     	 *      	 * @return The XmldbURI of the XQWS file     	 */
specifier|public
name|XmldbURI
name|getFileURI
parameter_list|()
block|{
return|return
name|xqwsFileURI
return|;
block|}
comment|/**     	 * Returns the URI of the Collection containing the XQWS file     	 *      	 * @return The XmldbURI of the Collection containing the XQWS file     	 */
specifier|public
name|XmldbURI
name|getCollectionURI
parameter_list|()
block|{
return|return
name|xqwsCollectionURI
return|;
block|}
comment|/**     	 * Returns the Namespace of the XQWS     	 *      	 * @return The QName for the Namespace of the XQWS     	 */
specifier|public
name|QName
name|getNamespace
parameter_list|()
block|{
return|return
name|xqwsNamespace
return|;
block|}
comment|/**     	 * Determines if this description of the XQWS is valid     	 *      	 * @return true if the description is valid, false otherwise     	 */
specifier|public
name|boolean
name|isValid
parameter_list|()
block|{
name|BinaryDocument
name|docXQWS
init|=
literal|null
decl_stmt|;
try|try
block|{
name|docXQWS
operator|=
name|getXQWS
argument_list|(
name|broker
argument_list|,
name|XQWSPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|docXQWS
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
operator|==
name|lastModifiedXQWS
operator|)
return|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
comment|//TODO: log message
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|docXQWS
operator|!=
literal|null
condition|)
block|{
name|docXQWS
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     	 * Refreshes an XQWS Description by re-reading the XQWS     	 * Should be called if isValid() returns false and an XQWS description is needed further      	 *      	 * @param request	The HttpServletRequest to update for     	 */
specifier|public
name|void
name|refresh
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|)
throws|throws
name|XPathException
throws|,
name|SAXException
throws|,
name|PermissionDeniedException
throws|,
name|NotFoundException
block|{
name|createInternalDescription
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
comment|/**     	 * Returns the WSDL for the XQWS Description     	 * Caches the result, however the cache is regenerated if     	 * the StyleSheet used for the transformation changes     	 *      	 * @return byte array containing the WSDL     	 */
specifier|public
name|byte
index|[]
name|getWSDL
parameter_list|()
throws|throws
name|PermissionDeniedException
throws|,
name|TransformerConfigurationException
throws|,
name|SAXException
block|{
return|return
name|getWSDL
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**     	 * Returns the WSDL for the XQWS Description     	 * Caches the result, however the cache is regenerated if     	 * the StyleSheet used for the transformation changes     	 *      	 * @return byte array containing the WSDL     	 */
specifier|public
name|byte
index|[]
name|getWSDL
parameter_list|(
name|boolean
name|isDocumentLiteral
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|TransformerConfigurationException
throws|,
name|SAXException
block|{
name|DocumentImpl
name|docStyleSheet
init|=
literal|null
decl_stmt|;
name|int
name|wsdlIndex
init|=
name|isDocumentLiteral
condition|?
literal|0
else|:
literal|1
decl_stmt|;
try|try
block|{
comment|//get the WSDL StyleSheet
name|docStyleSheet
operator|=
name|broker
operator|.
name|getXMLResource
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|XSLT_WEBSERVICE_WSDL
argument_list|)
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|//has the stylesheet changed, or is this the first call for this version
if|if
condition|(
name|docStyleSheet
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
operator|!=
name|lastModifiedWSDL
operator|||
name|descriptionWSDL
index|[
name|wsdlIndex
index|]
operator|==
literal|null
condition|)
block|{
comment|//TODO: validate the WSDL
name|Properties
name|params
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"isDocumentLiteral"
argument_list|,
name|isDocumentLiteral
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
comment|//yes, so re-run the transformation
name|descriptionWSDL
index|[
name|wsdlIndex
index|]
operator|=
name|Transform
argument_list|(
name|docXQWSDescription
argument_list|,
name|docStyleSheet
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|lastModifiedWSDL
operator|=
name|docStyleSheet
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
expr_stmt|;
block|}
comment|//return the result of the transformation
return|return
name|descriptionWSDL
index|[
name|wsdlIndex
index|]
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|docStyleSheet
operator|!=
literal|null
condition|)
block|{
comment|//close the Stylesheet Document and release the read lock
name|docStyleSheet
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     	 * Returns the Human Readable description for the XQWS Description     	 * Caches the result, however the cache is regenerated if     	 * the StyleSheet used for the transformation changes     	 *      	 * @return byte array containing the WSDL     	 */
specifier|public
name|byte
index|[]
name|getHumanDescription
parameter_list|()
throws|throws
name|PermissionDeniedException
throws|,
name|TransformerConfigurationException
throws|,
name|SAXException
block|{
name|DocumentImpl
name|docStyleSheet
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//get the Human Description StyleSheet
name|docStyleSheet
operator|=
name|broker
operator|.
name|getXMLResource
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|XSLT_WEBSERVICE_HUMAN_DESCRIPTION
argument_list|)
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|//has the stylesheet changed, or is this the first call for this version
if|if
condition|(
name|docStyleSheet
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
operator|!=
name|lastModifiedHuman
operator|||
name|descriptionHuman
operator|==
literal|null
condition|)
block|{
comment|//yes, so re-run the transformation
name|descriptionHuman
operator|=
name|Transform
argument_list|(
name|docXQWSDescription
argument_list|,
name|docStyleSheet
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|lastModifiedHuman
operator|=
name|docStyleSheet
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
expr_stmt|;
block|}
comment|//return the result of the transformation
return|return
name|descriptionHuman
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|docStyleSheet
operator|!=
literal|null
condition|)
block|{
comment|//close the Stylesheet Document and release the read lock
name|docStyleSheet
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     	 * Returns the (Human Readable) description of a Function for the XQWS Description     	 * Caches the result, however the cache is regenerated if     	 * the StyleSheet used for the transformation changes     	 *      	 * @param functionName The name of the function to describe     	 *      	 * @return byte array containing the Function Description     	 */
specifier|public
name|byte
index|[]
name|getFunctionDescription
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|TransformerConfigurationException
throws|,
name|SAXException
block|{
name|DocumentImpl
name|docStyleSheet
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//get the Function Description StyleSheet
name|docStyleSheet
operator|=
name|broker
operator|.
name|getXMLResource
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|XSLT_WEBSERVICE_FUNCTION_DESCRIPTION
argument_list|)
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|//has the stylesheet changed?
if|if
condition|(
name|docStyleSheet
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
operator|!=
name|lastModifiedFunction
condition|)
block|{
comment|//yes, so empty the cache
name|descriptionFunction
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//change the last modified date
name|lastModifiedFunction
operator|=
name|docStyleSheet
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
expr_stmt|;
block|}
comment|//if there is not a pre-trasformed description in the cache
if|if
condition|(
operator|!
name|descriptionFunction
operator|.
name|containsKey
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
comment|//do the transformation and store in the cache
name|Properties
name|params
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"function"
argument_list|,
name|functionName
argument_list|)
expr_stmt|;
name|descriptionFunction
operator|.
name|put
argument_list|(
name|functionName
argument_list|,
name|Transform
argument_list|(
name|docXQWSDescription
argument_list|,
name|docStyleSheet
argument_list|,
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//return the result of the transformation from the cache
return|return
operator|(
name|byte
index|[]
operator|)
name|descriptionFunction
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|docStyleSheet
operator|!=
literal|null
condition|)
block|{
comment|//close the Stylesheet Document and release the read lock
name|docStyleSheet
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     	 * Returns the function node from the internal description     	 *      	 * @param functionName	The name of the function to return     	 *      	 * @return the node from the internal description     	 */
specifier|public
name|Node
name|getFunction
parameter_list|(
name|String
name|functionName
parameter_list|)
block|{
comment|//iterate through all the function nodes
name|NodeList
name|nlFunctions
init|=
name|docXQWSDescription
operator|.
name|getElementsByTagName
argument_list|(
literal|"function"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlFunctions
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|//get the function node
name|Node
name|nFunction
init|=
name|nlFunctions
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//iterate through children of function, get value of<name> element
name|NodeList
name|nlFunctionChildren
init|=
name|nFunction
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nlFunctionChildren
operator|.
name|getLength
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|Node
name|nFunctionChild
init|=
name|nlFunctionChildren
operator|.
name|item
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|nFunctionChild
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
comment|//is this the function node we are looking for?
if|if
condition|(
name|nFunctionChild
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"name"
argument_list|)
operator|&&
name|nFunctionChild
operator|.
name|getFirstChild
argument_list|()
operator|.
name|getNodeValue
argument_list|()
operator|.
name|equals
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
comment|//yes so return it
return|return
name|nFunction
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**     	 * Returns the parameters for a function from the internal description     	 *      	 * @param functionName	The name of the function to return parameters for     	 *      	 * @return NodeList of parameter's     	 */
specifier|public
name|NodeList
name|getFunctionParameters
parameter_list|(
name|String
name|functionName
parameter_list|)
block|{
name|Node
name|internalFunction
init|=
name|getFunction
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalFunction
operator|!=
literal|null
condition|)
block|{
return|return
name|getFunctionParameters
argument_list|(
name|internalFunction
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**     	 * Returns the parameters for a function from the internal description     	 *      	 * @param internalFunction The internal function to return parameters for     	 *      	 * @return NodeList of parameter's     	 */
specifier|public
name|NodeList
name|getFunctionParameters
parameter_list|(
name|Node
name|internalFunction
parameter_list|)
block|{
name|NodeList
name|nlChildren
init|=
name|internalFunction
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlChildren
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|child
init|=
name|nlChildren
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"parameters"
argument_list|)
condition|)
block|{
return|return
name|child
operator|.
name|getChildNodes
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**     	 * Returns the Name for the function parameter     	 *      	 * @param internalFunctionParameter The internal function parameter to return the Name for     	 *      	 * @return The Name of the parameter     	 */
specifier|public
name|String
name|getFunctionParameterName
parameter_list|(
name|Node
name|internalFunctionParameter
parameter_list|)
block|{
comment|//first element child of<parameter> is<name>
name|NodeList
name|nlParamArgs
init|=
name|internalFunctionParameter
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlParamArgs
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|nArg
init|=
name|nlParamArgs
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nArg
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
name|nArg
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"name"
argument_list|)
condition|)
block|{
return|return
name|nArg
operator|.
name|getFirstChild
argument_list|()
operator|.
name|getNodeValue
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**     	 * Returns the Type for the function parameter     	 *      	 * @param internalFunctionParameter The internal function parameter to return the Type for     	 *      	 * @return The Type of the parameter     	 */
specifier|public
name|String
name|getFunctionParameterType
parameter_list|(
name|Node
name|internalFunctionParameter
parameter_list|)
block|{
comment|//second element child of<parameter> is<type>
name|NodeList
name|nlParamArgs
init|=
name|internalFunctionParameter
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlParamArgs
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|nArg
init|=
name|nlParamArgs
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nArg
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
name|nArg
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"type"
argument_list|)
condition|)
block|{
return|return
name|nArg
operator|.
name|getFirstChild
argument_list|()
operator|.
name|getNodeValue
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**     	 * Returns the Cardinality for the function parameter     	 *      	 * @param internalFunctionParameter The internal function parameter to return the Cardinality for     	 *      	 * @return The Cardinality as defined by org.exist.xquery.Cardinality     	 */
specifier|public
name|int
name|getFunctionParameterCardinality
parameter_list|(
name|Node
name|internalFunctionParameter
parameter_list|)
block|{
comment|//third element child of<parameter> is<cardinality>
name|NodeList
name|nlParamArgs
init|=
name|internalFunctionParameter
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nlParamArgs
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|nArg
init|=
name|nlParamArgs
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nArg
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
name|nArg
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"cardinality"
argument_list|)
condition|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|nArg
operator|.
name|getFirstChild
argument_list|()
operator|.
name|getNodeValue
argument_list|()
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
block|}
comment|//default cardinality
return|return
name|Cardinality
operator|.
name|EXACTLY_ONE
return|;
block|}
comment|/**     	 * Returns the SOAP Response for the XQWS Function     	 * named with the result provided.     	 *      	 * @param functionName	The name of the XQWS function that was called     	 * @param functionResult	The Result of the XQWS function that was called     	 * @param request	The Http Request for the XQWS     	 *      	 * @return byte array containing the SOAP Response     	 */
specifier|public
name|byte
index|[]
name|getSOAPResponse
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Sequence
name|functionResult
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|boolean
name|isRpcEncoded
parameter_list|)
throws|throws
name|XPathException
throws|,
name|PermissionDeniedException
throws|,
name|TransformerConfigurationException
throws|,
name|SAXException
block|{
comment|//get the Result StyleSheet for the SOAP Response
name|DocumentImpl
name|docStyleSheet
init|=
name|broker
operator|.
name|getXMLResource
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|XSLT_WEBSERVICE_SOAP_RESPONSE
argument_list|)
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
decl_stmt|;
comment|//Get an internal description, containg just a single function with its result
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|docResult
init|=
name|describeWebService
argument_list|(
name|modXQWS
argument_list|,
name|xqwsFileURI
argument_list|,
name|request
argument_list|,
name|XQWSPath
argument_list|,
name|functionName
argument_list|,
name|functionResult
argument_list|)
decl_stmt|;
comment|//return the SOAP Response
name|Properties
name|params
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"isDocumentLiteral"
argument_list|,
name|isRpcEncoded
condition|?
literal|"false"
else|:
literal|"true"
argument_list|)
expr_stmt|;
return|return
name|Transform
argument_list|(
name|docResult
argument_list|,
name|docStyleSheet
argument_list|,
name|params
argument_list|)
return|;
block|}
comment|/**     	 * Creates the internal Description of the XQWS     	 *      	 * @param request The HttpServletRequest for which the description should be created     	 */
specifier|private
name|void
name|createInternalDescription
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|)
throws|throws
name|XPathException
throws|,
name|SAXException
throws|,
name|PermissionDeniedException
throws|,
name|NotFoundException
block|{
comment|// 1) Get the XQWS
name|BinaryDocument
name|docXQWS
init|=
name|getXQWS
argument_list|(
name|broker
argument_list|,
name|XQWSPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|docXQWS
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
literal|"Resource "
operator|+
name|request
operator|.
name|getRequestURL
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
name|xqwsFileURI
operator|=
name|docXQWS
operator|.
name|getFileURI
argument_list|()
expr_stmt|;
name|xqwsCollectionURI
operator|=
name|docXQWS
operator|.
name|getCollection
argument_list|()
operator|.
name|getURI
argument_list|()
expr_stmt|;
name|byte
index|[]
name|xqwsData
init|=
name|getXQWSData
argument_list|(
name|broker
argument_list|,
name|docXQWS
argument_list|)
decl_stmt|;
comment|// 2) Store last modified date
name|lastModifiedXQWS
operator|=
name|docXQWS
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
expr_stmt|;
comment|// 3) Get the XQWS Namespace
name|xqwsNamespace
operator|=
name|getXQWSNamespace
argument_list|(
name|xqwsData
argument_list|)
expr_stmt|;
comment|// 4) Compile a Simple XQuery to access the module
name|CompiledXQuery
name|compiled
init|=
name|XQueryIncludeXQWS
argument_list|(
name|broker
argument_list|,
name|docXQWS
operator|.
name|getFileURI
argument_list|()
argument_list|,
name|xqwsNamespace
argument_list|,
name|docXQWS
operator|.
name|getCollection
argument_list|()
operator|.
name|getURI
argument_list|()
argument_list|)
decl_stmt|;
comment|// 5) Inspect the XQWS and its function signatures and create a small XML document to represent it
name|modXQWS
operator|=
name|compiled
operator|.
name|getContext
argument_list|()
operator|.
name|getModule
argument_list|(
name|xqwsNamespace
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
expr_stmt|;
name|docXQWSDescription
operator|=
name|describeWebService
argument_list|(
name|modXQWS
argument_list|,
name|xqwsFileURI
argument_list|,
name|request
argument_list|,
name|XQWSPath
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**          * Gets XQWS file from the db          *           * @param broker 	The Database Broker to use          * @param path		The Path to the XQWS          *           * @return	The XQWS BinaryDocument          */
specifier|private
name|BinaryDocument
name|getXQWS
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|BinaryDocument
name|docXQWS
init|=
literal|null
decl_stmt|;
try|try
block|{
name|XmldbURI
name|pathUri
init|=
name|XmldbURI
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|docXQWS
operator|=
operator|(
name|BinaryDocument
operator|)
name|broker
operator|.
name|getXMLResource
argument_list|(
name|pathUri
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
return|return
name|docXQWS
return|;
block|}
finally|finally
block|{
comment|//close the XQWS Document and release the read lock
if|if
condition|(
name|docXQWS
operator|!=
literal|null
condition|)
block|{
name|docXQWS
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Gets the data from an XQWS Binary Document          *           * @param broker	The Database Broker to use          * @param docXQWS	The XQWS Binary Document          *           * @return	byte array containing the content of the XQWS Binary document          */
specifier|private
name|byte
index|[]
name|getXQWSData
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|BinaryDocument
name|docXQWS
parameter_list|)
block|{
try|try
block|{
name|InputStream
name|is
init|=
name|broker
operator|.
name|getBinaryResource
argument_list|(
name|docXQWS
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|broker
operator|.
name|getBinaryResourceSize
argument_list|(
name|docXQWS
argument_list|)
index|]
decl_stmt|;
name|is
operator|.
name|read
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|data
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// TODO: where should this go?
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Get's the namespace of the XQWS form the content of an XQWS          *          * @param xqwsData	The content of an XQWS file          *           * @return The namespace QName          */
specifier|private
name|QName
name|getXQWSNamespace
parameter_list|(
name|byte
index|[]
name|xqwsData
parameter_list|)
block|{
comment|//move through the xqws char by char checking if a line contains the module namespace declaration
name|StringBuffer
name|sbNamespace
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|ByteArrayInputStream
name|bis
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|xqwsData
argument_list|)
decl_stmt|;
while|while
condition|(
name|bis
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|char
name|c
init|=
operator|(
name|char
operator|)
name|bis
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//TODO: do we need encoding here?
name|sbNamespace
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SEPERATOR
operator|.
name|charAt
argument_list|(
name|SEPERATOR
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|sbNamespace
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"module namespace"
argument_list|)
condition|)
block|{
comment|//break out of the while loop, sbNamespace should now contain our namespace
break|break;
block|}
else|else
block|{
comment|//empty the namespace buffer
name|sbNamespace
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
name|sbNamespace
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//seperate the name and url
name|String
name|namespaceName
init|=
name|sbNamespace
operator|.
name|substring
argument_list|(
literal|"module namespace"
operator|.
name|length
argument_list|()
argument_list|,
name|sbNamespace
operator|.
name|indexOf
argument_list|(
literal|"="
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|namespaceURL
init|=
name|sbNamespace
operator|.
name|substring
argument_list|(
name|sbNamespace
operator|.
name|indexOf
argument_list|(
literal|"\""
argument_list|)
operator|+
literal|1
argument_list|,
name|sbNamespace
operator|.
name|lastIndexOf
argument_list|(
literal|"\""
argument_list|)
argument_list|)
decl_stmt|;
comment|//return the XQWS namespace
return|return
operator|new
name|QName
argument_list|(
name|namespaceName
argument_list|,
name|namespaceURL
argument_list|)
return|;
block|}
comment|/**          * Creates a simple XQuery to include an XQWS          *           * @param broker	The Database Broker to use          * @param xqwsFileUri	The XmldbURI of the XQWS file          * @param xqwsNamespace	The namespace of the xqws          * @param xqwsCollectionUri	The XmldbUri of the collection where the XQWS resides          *           * @return The compiled XQuery          */
specifier|private
name|CompiledXQuery
name|XQueryIncludeXQWS
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|xqwsFileUri
parameter_list|,
name|QName
name|xqwsNamespace
parameter_list|,
name|XmldbURI
name|xqwsCollectionUri
parameter_list|)
throws|throws
name|XPathException
block|{
comment|//Create a simple XQuery wrapper to access the module
name|String
name|query
init|=
literal|"xquery version \"1.0\";"
operator|+
name|SEPERATOR
decl_stmt|;
name|query
operator|+=
name|SEPERATOR
expr_stmt|;
name|query
operator|+=
literal|"import module namespace "
operator|+
name|xqwsNamespace
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"=\""
operator|+
name|xqwsNamespace
operator|.
name|getNamespaceURI
argument_list|()
operator|+
literal|"\" at \""
operator|+
name|xqwsFileUri
operator|.
name|toString
argument_list|()
operator|+
literal|"\";"
operator|+
name|SEPERATOR
expr_stmt|;
name|query
operator|+=
name|SEPERATOR
expr_stmt|;
name|query
operator|+=
literal|"()"
expr_stmt|;
comment|//compile the query
return|return
name|compileXQuery
argument_list|(
name|broker
argument_list|,
operator|new
name|StringSource
argument_list|(
name|query
argument_list|)
argument_list|,
operator|new
name|XmldbURI
index|[]
block|{
name|xqwsCollectionUri
block|}
argument_list|,
name|xqwsCollectionUri
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**     	 * Describes an XQWS by building an XML node representation of the XQWS module     	 *      	 *<webservice>     	 *<name/>     	 *<description/>     	 *<host/>     	 *<path/>     	 *<URL/>     	 *<functions>     	 *<function/> { unbounded } { @see org.exist.http.SOAPServer#describeWebServiceFunction(org.exist.xquery.FunctionSignature, org.exist.memtree.MemTreeBuilder) }     	 *</functions>     	 *</webservice>     	 *     	 * @param modXQWS	The XQWS XQuery module     	 * @param xqwsFileUri	The File URI of the XQWS     	 * @param request	The Http Servlet request for this webservice     	 * @param path	The request path     	 * @param functionName	Used when only a single function should be described, linked to functionResult     	 * @param functionResult For writting out the results of a function call, should be used with functionName      	 * @return	An in-memory document describing the webservice     	 */
specifier|private
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|describeWebService
parameter_list|(
name|Module
name|modXQWS
parameter_list|,
name|XmldbURI
name|xqwsFileUri
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|String
name|path
parameter_list|,
name|String
name|functionName
parameter_list|,
name|Sequence
name|functionResult
parameter_list|)
throws|throws
name|XPathException
throws|,
name|SAXException
block|{
name|FunctionSignature
index|[]
name|xqwsFunctions
init|=
name|modXQWS
operator|.
name|listFunctions
argument_list|()
decl_stmt|;
name|MemTreeBuilder
name|builderWebserviceDoc
init|=
operator|new
name|MemTreeBuilder
argument_list|(
name|broker
operator|.
name|getXQueryService
argument_list|()
operator|.
name|newContext
argument_list|(
name|AccessContext
operator|.
name|REST
argument_list|)
argument_list|)
decl_stmt|;
name|builderWebserviceDoc
operator|.
name|startDocument
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"webservice"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"name"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|characters
argument_list|(
name|xqwsFileUri
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|xqwsFileUri
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
name|WEBSERVICE_MODULE_EXTENSION
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"description"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|characters
argument_list|(
name|modXQWS
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"host"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|characters
argument_list|(
name|request
operator|.
name|getServerName
argument_list|()
operator|+
literal|":"
operator|+
name|request
operator|.
name|getServerPort
argument_list|()
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"path"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|characters
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"URL"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|characters
argument_list|(
name|request
operator|.
name|getRequestURL
argument_list|()
argument_list|)
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"functions"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|xqwsFunctions
operator|.
name|length
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|functionName
operator|==
literal|null
condition|)
block|{
comment|//All Function Descriptions
name|describeWebServiceFunction
argument_list|(
name|xqwsFunctions
index|[
name|f
index|]
argument_list|,
name|builderWebserviceDoc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Only a Single Function Description for showing function call results
if|if
condition|(
name|xqwsFunctions
index|[
name|f
index|]
operator|.
name|getName
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|describeWebServiceFunction
argument_list|(
name|xqwsFunctions
index|[
name|f
index|]
argument_list|,
name|builderWebserviceDoc
argument_list|,
name|functionResult
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderWebserviceDoc
operator|.
name|endDocument
argument_list|()
expr_stmt|;
return|return
name|builderWebserviceDoc
operator|.
name|getDocument
argument_list|()
return|;
block|}
comment|/**     	 * Describes an XQWS function by building an XML node representation of the function signature     	 *      	 *<function>     	 *<name/>     	 *<description/>     	 *<parameters>     	 *<parameter>	{ unbounded }     	 *<name/>     	 *<type/>     	 *<cardinality/>     	 *</parameter>     	 *</parameters>     	 *<return>     	 *<type/>     	 *<cardinality/>     	 *<result>		{ Only displayed if this is after the function has been executed }     	 * 				either {     	 *<value/> or     	 *<sequence>     	 *<value/> { unbounded }     	 *</sequence>     	 * 				}     	 *</result>     	 *</return>     	 *</function>     	 *      	 * @param signature	The function signature to describe     	 * @param builderFunction	The MemTreeBuilder to write the description to     	 * @param functionResult	A Sequence containing the function results or null if the function has not yet been executed     	 */
specifier|private
name|void
name|describeWebServiceFunction
parameter_list|(
name|FunctionSignature
name|signature
parameter_list|,
name|MemTreeBuilder
name|builderFunction
parameter_list|,
name|Sequence
name|functionResult
parameter_list|)
throws|throws
name|XPathException
throws|,
name|SAXException
block|{
comment|//Generate an XML snippet for each function
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"function"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"name"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|characters
argument_list|(
name|signature
operator|.
name|getName
argument_list|()
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
if|if
condition|(
name|signature
operator|.
name|getDescription
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"description"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|characters
argument_list|(
name|signature
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
name|SequenceType
index|[]
name|xqwsArguments
init|=
name|signature
operator|.
name|getArgumentTypes
argument_list|()
decl_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"parameters"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|xqwsArguments
operator|.
name|length
condition|;
name|a
operator|++
control|)
block|{
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"parameter"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"name"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//builderFunction.characters(xqwsArguments[a].getNodeName().getLocalName()); //TODO: how to get parameter name?
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"type"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|characters
argument_list|(
name|Type
operator|.
name|getTypeName
argument_list|(
name|xqwsArguments
index|[
name|a
index|]
operator|.
name|getPrimaryType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"cardinality"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|characters
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|xqwsArguments
index|[
name|a
index|]
operator|.
name|getCardinality
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"return"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"type"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|characters
argument_list|(
name|Type
operator|.
name|getTypeName
argument_list|(
name|signature
operator|.
name|getReturnType
argument_list|()
operator|.
name|getPrimaryType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|int
name|iReturnCardinality
init|=
name|signature
operator|.
name|getReturnType
argument_list|()
operator|.
name|getCardinality
argument_list|()
decl_stmt|;
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"cardinality"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|characters
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|iReturnCardinality
argument_list|)
argument_list|)
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
if|if
condition|(
name|functionResult
operator|!=
literal|null
condition|)
block|{
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"result"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//determine result cardinality
name|DocumentBuilderReceiver
name|receiver
init|=
operator|new
name|DocumentBuilderReceiver
argument_list|(
name|builderFunction
argument_list|)
decl_stmt|;
if|if
condition|(
name|iReturnCardinality
operator|>=
name|Cardinality
operator|.
name|MANY
condition|)
block|{
comment|//sequence of values
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"sequence"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|functionResult
operator|.
name|getItemCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"value"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|functionResult
operator|.
name|itemAt
argument_list|(
name|i
argument_list|)
operator|.
name|copyTo
argument_list|(
name|broker
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
comment|//builderFunction.characters(functionResult.itemAt(i).getStringValue());
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//atomic value
name|builderFunction
operator|.
name|startElement
argument_list|(
operator|new
name|QName
argument_list|(
literal|"value"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|functionResult
operator|.
name|itemAt
argument_list|(
literal|0
argument_list|)
operator|.
name|copyTo
argument_list|(
name|broker
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
comment|//builderFunction.characters(functionResult.itemAt(0).getStringValue());
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
name|builderFunction
operator|.
name|endElement
argument_list|()
expr_stmt|;
block|}
comment|/**          * Transforms a document with a stylesheet          *           * @param docStyleSheet	A stylesheet document from the db          * @param parameters	Any parameters to be passed to the stylesheet          *           * @return byte array containing the result of the transformation          */
specifier|private
name|byte
index|[]
name|Transform
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|srcDoc
parameter_list|,
name|DocumentImpl
name|docStyleSheet
parameter_list|,
name|Properties
name|parameters
parameter_list|)
throws|throws
name|TransformerConfigurationException
throws|,
name|SAXException
block|{
comment|//Transform docXQWSDescription with the stylesheet
comment|/*         	 * TODO: the code in this try statement (apart from the WSDLFilter use) was mostly extracted from         	 * transform:stream-transform(), it would be better to be able to share that code somehow         	 */
name|SAXTransformerFactory
name|factory
init|=
operator|(
name|SAXTransformerFactory
operator|)
name|SAXTransformerFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|TemplatesHandler
name|templatesHandler
init|=
name|factory
operator|.
name|newTemplatesHandler
argument_list|()
decl_stmt|;
name|templatesHandler
operator|.
name|startDocument
argument_list|()
expr_stmt|;
name|Serializer
name|serializer
init|=
name|broker
operator|.
name|getSerializer
argument_list|()
decl_stmt|;
name|serializer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|WSDLFilter
name|wsdlfilter
init|=
operator|new
name|WSDLFilter
argument_list|(
name|templatesHandler
argument_list|,
name|HttpServletRequestURL
argument_list|)
decl_stmt|;
name|serializer
operator|.
name|setSAXHandlers
argument_list|(
name|wsdlfilter
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|serializer
operator|.
name|toSAX
argument_list|(
name|docStyleSheet
argument_list|)
expr_stmt|;
name|templatesHandler
operator|.
name|endDocument
argument_list|()
expr_stmt|;
name|TransformerHandler
name|handler
init|=
name|factory
operator|.
name|newTransformerHandler
argument_list|(
name|templatesHandler
operator|.
name|getTemplates
argument_list|()
argument_list|)
decl_stmt|;
comment|//set parameters, if any
if|if
condition|(
name|parameters
operator|!=
literal|null
condition|)
block|{
name|Transformer
name|transformer
init|=
name|handler
operator|.
name|getTransformer
argument_list|()
decl_stmt|;
name|Enumeration
name|parameterKeys
init|=
name|parameters
operator|.
name|keys
argument_list|()
decl_stmt|;
while|while
condition|(
name|parameterKeys
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|paramName
init|=
operator|(
name|String
operator|)
name|parameterKeys
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Object
name|paramValue
init|=
name|parameters
operator|.
name|get
argument_list|(
name|paramName
argument_list|)
decl_stmt|;
name|transformer
operator|.
name|setParameter
argument_list|(
name|paramName
argument_list|,
name|paramValue
argument_list|)
expr_stmt|;
block|}
block|}
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|StreamResult
name|result
init|=
operator|new
name|StreamResult
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|handler
operator|.
name|setResult
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|handler
operator|.
name|startDocument
argument_list|()
expr_stmt|;
name|srcDoc
operator|.
name|toSAX
argument_list|(
name|broker
argument_list|,
name|handler
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|handler
operator|.
name|endDocument
argument_list|()
expr_stmt|;
return|return
name|os
operator|.
name|toByteArray
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

