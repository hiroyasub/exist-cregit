begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-06 The eXist Project  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  *   *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|collections
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Indexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|DocumentTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|Trigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|BinaryDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Group
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|SecurityManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|XMLSecurityManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DBBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|FulltextIndexSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|GeneralRangeIndexSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|IndexSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|NodePath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|QNameRangeIndexSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|UpdateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cacheable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|LockedDocumentMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|hashtable
operator|.
name|ObjectHashSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|serializer
operator|.
name|DOMStreamer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|XMLReader
import|;
end_import

begin_comment
comment|/**  * This class represents a collection in the database. A collection maintains a list of  * sub-collections and documents, and provides the methods to store/remove resources.  *  * Collections are shared between {@link org.exist.storage.DBBroker} instances. The caller  * is responsible to lock/unlock the collection. Call {@link DBBroker#openCollection(XmldbURI, int)}  * to get a collection with a read or write lock and {@link #release(int)} to release the lock.  *  * @author wolf  */
end_comment

begin_class
specifier|public
class|class
name|Collection
extends|extends
name|Observable
implements|implements
name|Comparable
implements|,
name|Cacheable
block|{
specifier|public
specifier|static
name|int
name|LENGTH_COLLECTION_ID
init|=
literal|4
decl_stmt|;
comment|//sizeof int
specifier|public
specifier|static
specifier|final
name|int
name|POOL_PARSER_THRESHOLD
init|=
literal|500
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|SHALLOW_SIZE
init|=
literal|550
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DOCUMENT_SIZE
init|=
literal|450
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|Collection
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//private final static int VALIDATION_ENABLED = 0;
comment|//private final static int VALIDATION_AUTO = 1;
comment|//private final static int VALIDATION_DISABLED = 2;
specifier|public
specifier|final
specifier|static
name|int
name|UNKNOWN_COLLECTION_ID
init|=
operator|-
literal|1
decl_stmt|;
comment|// Internal id
specifier|private
name|int
name|collectionId
init|=
name|UNKNOWN_COLLECTION_ID
decl_stmt|;
comment|// the documents contained in this collection
specifier|private
name|Map
name|documents
init|=
operator|new
name|TreeMap
argument_list|()
decl_stmt|;
comment|// the path of this collection
specifier|private
name|XmldbURI
name|path
decl_stmt|;
comment|// the permissions assigned to this collection
specifier|private
name|Permission
name|permissions
init|=
name|PermissionFactory
operator|.
name|getPermission
argument_list|(
literal|0775
argument_list|)
decl_stmt|;
comment|// stores child-collections with their storage address
specifier|private
name|ObjectHashSet
name|subcollections
init|=
operator|new
name|ObjectHashSet
argument_list|(
literal|19
argument_list|)
decl_stmt|;
comment|// Storage address of the collection in the BFile
specifier|private
name|long
name|address
init|=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
decl_stmt|;
comment|// creation time
specifier|private
name|long
name|created
init|=
literal|0
decl_stmt|;
specifier|private
name|Observer
index|[]
name|observers
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|collectionConfEnabled
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|triggersEnabled
init|=
literal|true
decl_stmt|;
comment|// fields required by the collections cache
specifier|private
name|int
name|refCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|timestamp
init|=
literal|0
decl_stmt|;
specifier|private
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
comment|/** user-defined Reader */
specifier|private
name|XMLReader
name|userReader
init|=
literal|null
decl_stmt|;
comment|/** is this a temporary collection? */
specifier|private
name|boolean
name|isTempCollection
init|=
literal|false
decl_stmt|;
specifier|public
name|Collection
parameter_list|()
block|{
block|}
specifier|public
name|Collection
parameter_list|(
name|XmldbURI
name|path
parameter_list|)
block|{
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setPath
parameter_list|(
name|XmldbURI
name|path
parameter_list|)
block|{
name|path
operator|=
name|path
operator|.
name|toCollectionPathURI
argument_list|()
expr_stmt|;
comment|//TODO : see if the URI resolves against DBBroker.TEMP_COLLECTION
name|isTempCollection
operator|=
name|path
operator|.
name|getRawCollectionPath
argument_list|()
operator|.
name|equals
argument_list|(
name|DBBroker
operator|.
name|TEMP_COLLECTION
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
block|}
specifier|public
name|Lock
name|getLock
parameter_list|()
block|{
return|return
name|lock
return|;
block|}
comment|/**      *  Add a new sub-collection to the collection.      *      */
specifier|public
name|void
name|addCollection
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Collection
name|child
parameter_list|,
name|boolean
name|isNew
parameter_list|)
block|{
name|XmldbURI
name|childName
init|=
name|child
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|subcollections
operator|.
name|contains
argument_list|(
name|childName
argument_list|)
condition|)
name|subcollections
operator|.
name|add
argument_list|(
name|childName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNew
condition|)
block|{
name|CollectionConfiguration
name|config
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
name|child
operator|.
name|permissions
operator|.
name|setPermissions
argument_list|(
name|config
operator|.
name|getDefCollPermissions
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|hasChildCollection
parameter_list|(
name|XmldbURI
name|path
parameter_list|)
block|{
return|return
name|subcollections
operator|.
name|contains
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**      * Returns true if this is a temporary collection. By default,      * the temporary collection is in /db/system/temp.      *      * @return A boolean where true means the collection is temporary.      */
specifier|public
name|boolean
name|isTempCollection
parameter_list|()
block|{
return|return
name|isTempCollection
return|;
block|}
comment|/**      * Closes the collection, i.e. releases the lock held by      * the current thread. This is a shortcut for getLock().release().      */
specifier|public
name|void
name|release
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/**      * Update the specified child-collection.      *      * @param child      */
specifier|public
name|void
name|update
parameter_list|(
name|Collection
name|child
parameter_list|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|child
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
name|subcollections
operator|.
name|remove
argument_list|(
name|childName
argument_list|)
expr_stmt|;
name|subcollections
operator|.
name|add
argument_list|(
name|childName
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Add a document to the collection.      *      *@param  doc      */
specifier|public
name|void
name|addDocument
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
condition|)
name|doc
operator|.
name|setDocId
argument_list|(
name|broker
operator|.
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|documents
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the document from the internal list of resources, but      * doesn't delete the document object itself.      *      * @param doc      */
specifier|public
name|void
name|unlinkDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|documents
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Return an iterator over all subcollections.      *      * The list of subcollections is copied first, so modifications      * via the iterator have no affect.      *      *@return    Description of the Return Value      */
specifier|public
name|Iterator
name|collectionIterator
parameter_list|()
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
return|return
name|subcollections
operator|.
name|stableIterator
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Load all collections below this collections      * and return them in a List.      *      * @return List      */
specifier|public
name|List
name|getDescendants
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|User
name|user
parameter_list|)
block|{
specifier|final
name|ArrayList
name|cl
init|=
operator|new
name|ArrayList
argument_list|(
name|subcollections
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|Collection
name|child
decl_stmt|;
name|XmldbURI
name|childName
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|subcollections
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childName
operator|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
comment|//TODO : resolve URI !
name|child
operator|=
name|broker
operator|.
name|getCollection
argument_list|(
name|path
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|permissions
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|cl
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCollectionCount
argument_list|()
operator|>
literal|0
condition|)
name|cl
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getDescendants
argument_list|(
name|broker
argument_list|,
name|user
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|cl
return|;
block|}
specifier|public
name|DocumentSet
name|allDocs
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|checkPermissions
parameter_list|)
block|{
return|return
name|allDocs
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|recursive
argument_list|,
name|checkPermissions
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Retrieve all documents contained in this collections.      *      * If recursive is true, documents from sub-collections are      * included.      *      * @param broker      * @param docs      * @param recursive      * @param checkPermissions      * @return The set of documents.      */
specifier|public
name|DocumentSet
name|allDocs
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|checkPermissions
parameter_list|,
name|LockedDocumentMap
name|protectedDocs
parameter_list|)
block|{
if|if
condition|(
name|permissions
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|List
name|subColls
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// acquire a lock on the collection
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|// add all docs in this collection to the returned set
name|getDocuments
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|checkPermissions
argument_list|)
expr_stmt|;
comment|// get a list of subcollection URIs. We will process them after unlocking this collection.
comment|// otherwise we may deadlock ourselves
name|subColls
operator|=
name|subcollections
operator|.
name|keys
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recursive
operator|&&
name|subColls
operator|!=
literal|null
condition|)
block|{
comment|// process the child collections
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subColls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|XmldbURI
name|childName
init|=
operator|(
name|XmldbURI
operator|)
name|subColls
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//TODO : resolve URI !
name|Collection
name|child
init|=
name|broker
operator|.
name|openCollection
argument_list|(
name|path
operator|.
name|appendInternal
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
decl_stmt|;
comment|// a collection may have been removed in the meantime, so check first
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
name|child
operator|.
name|allDocs
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|recursive
argument_list|,
name|checkPermissions
argument_list|,
name|protectedDocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|docs
return|;
block|}
specifier|public
name|DocumentSet
name|allDocs
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|LockedDocumentMap
name|lockMap
parameter_list|,
name|int
name|lockType
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
name|permissions
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|List
name|subColls
init|=
literal|null
decl_stmt|;
name|XmldbURI
name|uris
index|[]
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// acquire a lock on the collection
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|// add all docs in this collection to the returned set
name|getDocuments
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|lockMap
argument_list|,
name|lockType
argument_list|)
expr_stmt|;
comment|// get a list of subcollection URIs. We will process them after unlocking this collection.
comment|// otherwise we may deadlock ourselves
name|subColls
operator|=
name|subcollections
operator|.
name|keys
argument_list|()
expr_stmt|;
if|if
condition|(
name|subColls
operator|!=
literal|null
condition|)
block|{
name|uris
operator|=
operator|new
name|XmldbURI
index|[
name|subColls
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subColls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|XmldbURI
name|childName
init|=
operator|(
name|XmldbURI
operator|)
name|subColls
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uris
index|[
name|i
index|]
operator|=
name|path
operator|.
name|appendInternal
argument_list|(
name|childName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recursive
operator|&&
name|uris
operator|!=
literal|null
condition|)
block|{
comment|// process the child collections
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uris
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|//TODO : resolve URI !
name|Collection
name|child
init|=
name|broker
operator|.
name|openCollection
argument_list|(
name|uris
index|[
name|i
index|]
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
decl_stmt|;
comment|// a collection may have been removed in the meantime, so check first
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
name|child
operator|.
name|allDocs
argument_list|(
name|broker
argument_list|,
name|docs
argument_list|,
name|recursive
argument_list|,
name|lockMap
argument_list|,
name|lockType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|docs
return|;
block|}
comment|/**      * Add all documents to the specified document set.      *      * @param docs      */
specifier|public
name|DocumentSet
name|getDocuments
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|boolean
name|checkPermissions
parameter_list|)
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|docs
operator|.
name|addCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|docs
operator|.
name|addAll
argument_list|(
name|broker
argument_list|,
name|this
argument_list|,
name|getDocumentPaths
argument_list|()
argument_list|,
name|checkPermissions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
specifier|public
name|DocumentSet
name|getDocuments
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|LockedDocumentMap
name|lockMap
parameter_list|,
name|int
name|lockType
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|docs
operator|.
name|addCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|docs
operator|.
name|addAll
argument_list|(
name|broker
argument_list|,
name|this
argument_list|,
name|getDocumentPaths
argument_list|()
argument_list|,
name|lockMap
argument_list|,
name|lockType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
specifier|private
name|String
index|[]
name|getDocumentPaths
parameter_list|()
block|{
name|String
name|paths
index|[]
init|=
operator|new
name|String
index|[
name|documents
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|documents
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
operator|(
name|String
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
comment|/**      * Check if this collection may be safely removed from the      * cache. Returns false if there are ongoing write operations,      * i.e. one or more of the documents is locked for      * write.      *      * @return A boolean value where true indicates it may be unloaded.      */
specifier|public
name|boolean
name|allowUnload
parameter_list|()
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|documents
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|isLockedForWrite
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
comment|//		try {
comment|//			lock.acquire(Lock.WRITE_LOCK);
comment|//			for (Iterator i = documents.values().iterator(); i.hasNext(); ) {
comment|//				DocumentImpl doc = (DocumentImpl) i.next();
comment|//				if (doc.isLockedForWrite())
comment|//					return false;
comment|//			}
comment|//			return true;
comment|//		} catch (LockException e) {
comment|//			LOG.warn("Failed to acquire lock on collection: " + getName(), e);
comment|//		} finally {
comment|//			lock.release();
comment|//		}
comment|//		return false;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|Collection
name|other
init|=
operator|(
name|Collection
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|collectionId
operator|==
name|other
operator|.
name|collectionId
condition|)
return|return
name|Constants
operator|.
name|EQUAL
return|;
if|else if
condition|(
name|collectionId
operator|<
name|other
operator|.
name|collectionId
condition|)
return|return
name|Constants
operator|.
name|INFERIOR
return|;
else|else
return|return
name|Constants
operator|.
name|SUPERIOR
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Collection
operator|)
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|(
name|Collection
operator|)
name|obj
operator|)
operator|.
name|collectionId
operator|==
name|collectionId
return|;
block|}
comment|/**      * Returns the estimated amount of memory used by this collection      * and its documents. This information is required by the      * {@link org.exist.storage.CollectionCacheManager} to be able      * to resize the caches.      *      * @return estimated amount of memory in bytes      */
specifier|public
name|int
name|getMemorySize
parameter_list|()
block|{
return|return
name|SHALLOW_SIZE
operator|+
name|documents
operator|.
name|size
argument_list|()
operator|*
name|DOCUMENT_SIZE
return|;
block|}
comment|/**      *  Return the number of child-collections managed by this      * collection.      *      *@return    The childCollectionCount value      */
specifier|public
name|int
name|getChildCollectionCount
parameter_list|()
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
return|return
name|subcollections
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *  Get a child resource as identified by path. This method doesn't put      * a lock on the document nor does it recognize locks held by other threads.      * There's no guarantee that the document still exists when accessing it.      *      *@param  broker      *@param  path  The name of the document (without collection path)      *@return   the document      */
specifier|public
name|DocumentImpl
name|getDocument
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|path
parameter_list|)
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|documents
operator|.
name|get
argument_list|(
name|path
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Document "
operator|+
name|path
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Retrieve a child resource after putting a read lock on it. With this method,      * access to the received document object is safe.      *      * @deprecated Use other method      * @param broker      * @param name      * @return The document that was locked.      * @throws LockException      */
specifier|public
name|DocumentImpl
name|getDocumentWithLock
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|getDocumentWithLock
argument_list|(
name|broker
argument_list|,
name|name
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
return|;
block|}
comment|/**      * Retrieve a child resource after putting a read lock on it. With this method,      * access to the received document object is safe.      *      * @param broker      * @param uri      * @param lockMode      * @return The document that was locked.      * @throws LockException      */
specifier|public
name|DocumentImpl
name|getDocumentWithLock
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|uri
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|documents
operator|.
name|get
argument_list|(
name|uri
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|DocumentImpl
name|getDocumentNoLock
parameter_list|(
name|String
name|rawPath
parameter_list|)
block|{
return|return
operator|(
name|DocumentImpl
operator|)
name|documents
operator|.
name|get
argument_list|(
name|rawPath
argument_list|)
return|;
block|}
comment|/**      * Release any locks held on the document.      * @deprecated Use other method      * @param doc      */
specifier|public
name|void
name|releaseDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Release any locks held on the document.      *      * @param doc      */
specifier|public
name|void
name|releaseDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *  Returns the number of documents in this collection.      *      *@return    The documentCount value      */
specifier|public
name|int
name|getDocumentCount
parameter_list|()
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
return|return
name|documents
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *  Get the internal id.      *      *@return    The id value      */
specifier|public
name|int
name|getId
parameter_list|()
block|{
return|return
name|collectionId
return|;
block|}
comment|/**      *  Get the name of this collection.      *      *@return    The name value      */
specifier|public
name|XmldbURI
name|getURI
parameter_list|()
block|{
return|return
name|path
return|;
block|}
comment|/**      *  Returns the parent-collection.      *      *@return    The parent-collection or null if this      *is the root collection.      */
specifier|public
name|XmldbURI
name|getParentURI
parameter_list|()
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|)
return|return
literal|null
return|;
comment|//TODO : resolve URI against ".." !
return|return
name|path
operator|.
name|removeLastSegment
argument_list|()
return|;
block|}
comment|/**      *  Gets the permissions attribute of the Collection object      *      *@return    The permissions value      */
specifier|public
name|Permission
name|getPermissions
parameter_list|()
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
return|return
name|permissions
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|permissions
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Permission
name|getPermissionsNoLock
parameter_list|()
block|{
return|return
name|permissions
return|;
block|}
comment|/**      *  Check if the collection has a child document.      *      *@param  uri  the name (without path) of the document      *@return A value of true when the collection has the document identified.      */
specifier|public
name|boolean
name|hasDocument
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
block|{
return|return
name|documents
operator|.
name|containsKey
argument_list|(
name|uri
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
return|;
block|}
comment|/**      *  Check if the collection has a sub-collection.      *      *@param  name  the name of the subcollection (without path).      *@return A value of true when the subcollection exists.      */
specifier|public
name|boolean
name|hasSubcollection
parameter_list|(
name|XmldbURI
name|name
parameter_list|)
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
return|return
name|subcollections
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : ouch ! -pb
return|return
name|subcollections
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|hasSubcollectionNoLock
parameter_list|(
name|XmldbURI
name|name
parameter_list|)
block|{
return|return
name|subcollections
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      *  Returns an iterator on the child-documents in this collection.      *      *@return A iterator of all the documents in the collection.      */
specifier|public
name|Iterator
name|iterator
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
return|return
name|getDocuments
argument_list|(
name|broker
argument_list|,
operator|new
name|DocumentSet
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * Read collection contents from the stream.      *      * @param istream      * @throws IOException      */
specifier|public
name|void
name|read
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|VariableByteInput
name|istream
parameter_list|)
throws|throws
name|IOException
block|{
name|collectionId
operator|=
name|istream
operator|.
name|readInt
argument_list|()
expr_stmt|;
specifier|final
name|int
name|collLen
init|=
name|istream
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|subcollections
operator|=
operator|new
name|ObjectHashSet
argument_list|(
name|collLen
operator|==
literal|0
condition|?
literal|19
else|:
name|collLen
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collLen
condition|;
name|i
operator|++
control|)
name|subcollections
operator|.
name|add
argument_list|(
name|XmldbURI
operator|.
name|create
argument_list|(
name|istream
operator|.
name|readUTF
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|uid
init|=
name|istream
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|gid
init|=
name|istream
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|perm
init|=
name|istream
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|created
operator|=
name|istream
operator|.
name|readLong
argument_list|()
expr_stmt|;
specifier|final
name|SecurityManager
name|secman
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|secman
operator|==
literal|null
condition|)
block|{
comment|//TODO : load default permissions ? -pb
name|permissions
operator|.
name|setOwner
argument_list|(
name|SecurityManager
operator|.
name|DBA_USER
argument_list|)
expr_stmt|;
name|permissions
operator|.
name|setGroup
argument_list|(
name|SecurityManager
operator|.
name|DBA_GROUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|permissions
operator|.
name|setOwner
argument_list|(
name|secman
operator|.
name|getUser
argument_list|(
name|uid
argument_list|)
argument_list|)
expr_stmt|;
name|Group
name|group
init|=
name|secman
operator|.
name|getGroup
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|group
operator|!=
literal|null
condition|)
name|permissions
operator|.
name|setGroup
argument_list|(
name|group
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|///TODO : why this mask ? -pb
name|permissions
operator|.
name|setPermissions
argument_list|(
name|perm
operator|&
literal|0777
argument_list|)
expr_stmt|;
name|broker
operator|.
name|getCollectionResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Remove the specified sub-collection.      *      *@param  name  Description of the Parameter      */
specifier|public
name|void
name|removeCollection
parameter_list|(
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|subcollections
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *  Remove the specified document from the collection.      *      *@param  transaction      *@param  broker      *@param  docUri      */
specifier|public
name|void
name|removeXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|LockException
block|{
name|DocumentImpl
name|doc
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//Doh ! READ lock ?
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|documents
operator|.
name|get
argument_list|(
name|docUri
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
return|return;
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Write access to collection denied; user="
operator|+
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission to remove document denied"
argument_list|)
throw|;
name|DocumentTrigger
name|trigger
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE_URI
operator|.
name|equals
argument_list|(
name|docUri
argument_list|)
condition|)
block|{
if|if
condition|(
name|triggersEnabled
condition|)
block|{
name|CollectionConfiguration
name|config
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
try|try
block|{
name|trigger
operator|=
operator|(
name|DocumentTrigger
operator|)
name|config
operator|.
name|newTrigger
argument_list|(
name|Trigger
operator|.
name|REMOVE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"An error occurred while initializing a trigger for collection "
operator|+
name|getURI
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// we remove a collection.xconf configuration file: tell the configuration manager to
comment|// reload the configuration.
name|CollectionConfigurationManager
name|confMgr
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
name|confMgr
operator|.
name|invalidateAll
argument_list|(
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trigger
operator|!=
literal|null
condition|)
block|{
name|trigger
operator|.
name|prepare
argument_list|(
name|Trigger
operator|.
name|REMOVE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|transaction
argument_list|,
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|docUri
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|broker
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|documents
operator|.
name|remove
argument_list|(
name|docUri
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|!=
literal|null
condition|)
block|{
name|trigger
operator|.
name|finish
argument_list|(
name|Trigger
operator|.
name|REMOVE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|transaction
argument_list|,
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|docUri
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyUpdate
argument_list|(
name|doc
argument_list|,
name|UpdateListener
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
name|doc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|//Doh ! A READ lock ?
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|uri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|DocumentImpl
name|doc
init|=
name|getDocument
argument_list|(
name|broker
argument_list|,
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|isLockedForWrite
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" is locked for write"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"write access to collection denied; user="
operator|+
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission to remove document denied"
argument_list|)
throw|;
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|!=
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" is not a binary object"
argument_list|)
throw|;
if|if
condition|(
name|doc
operator|.
name|isLockedForWrite
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" is locked for write"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"write access to collection denied; user="
operator|+
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission to remove document denied"
argument_list|)
throw|;
name|DocumentTrigger
name|trigger
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|triggersEnabled
condition|)
block|{
name|CollectionConfiguration
name|config
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|trigger
operator|=
operator|(
name|DocumentTrigger
operator|)
name|config
operator|.
name|newTrigger
argument_list|(
name|Trigger
operator|.
name|REMOVE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"An error occurred while initializing a trigger for collection "
operator|+
name|getURI
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|trigger
operator|!=
literal|null
condition|)
name|trigger
operator|.
name|prepare
argument_list|(
name|Trigger
operator|.
name|REMOVE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|transaction
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|broker
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
name|documents
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|!=
literal|null
condition|)
block|{
name|trigger
operator|.
name|finish
argument_list|(
name|Trigger
operator|.
name|REMOVE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|transaction
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stores an XML document in the database. {@link #validateXMLResourceInternal(org.exist.storage.txn.Txn,      * org.exist.storage.DBBroker, org.exist.xmldb.XmldbURI, CollectionConfiguration, org.exist.collections.Collection.ValidateBlock)}       * should have been called previously in order to acquire a write lock for the document. Launches the finish trigger.      * @param transaction      * @param broker      * @param info      * @param source      * @param privileged      * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|public
name|void
name|store
parameter_list|(
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|,
name|boolean
name|privileged
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
name|storeXMLInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|privileged
argument_list|,
operator|new
name|StoreBlock
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|EXistException
throws|,
name|SAXException
block|{
try|try
block|{
specifier|final
name|InputStream
name|is
init|=
name|source
operator|.
name|getByteStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
name|is
operator|.
name|reset
argument_list|()
expr_stmt|;
else|else
block|{
specifier|final
name|Reader
name|cs
init|=
name|source
operator|.
name|getCharacterStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
name|cs
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not reset input source"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|XMLReader
name|reader
init|=
name|getReader
argument_list|(
name|broker
argument_list|,
name|info
operator|.
name|getCollectionConfig
argument_list|()
argument_list|)
decl_stmt|;
name|info
operator|.
name|setReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|reader
operator|.
name|parse
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|releaseReader
argument_list|(
name|broker
argument_list|,
name|info
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Stores an XML document in the database. {@link #validateXMLResourceInternal(org.exist.storage.txn.Txn,      * org.exist.storage.DBBroker, org.exist.xmldb.XmldbURI, CollectionConfiguration, org.exist.collections.Collection.ValidateBlock)}       * should have been called previously in order to acquire a write lock for the document. Launches the finish trigger.      * @param transaction      * @param broker      * @param info      * @param data      * @param privileged      * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|public
name|void
name|store
parameter_list|(
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|String
name|data
parameter_list|,
name|boolean
name|privileged
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
name|storeXMLInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|privileged
argument_list|,
operator|new
name|StoreBlock
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|SAXException
throws|,
name|EXistException
block|{
name|CollectionConfiguration
name|colconf
init|=
name|info
operator|.
name|getDocument
argument_list|()
operator|.
name|getCollection
argument_list|()
operator|.
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
name|XMLReader
name|reader
init|=
name|getReader
argument_list|(
name|broker
argument_list|,
name|colconf
argument_list|)
decl_stmt|;
name|info
operator|.
name|setReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|reader
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|releaseReader
argument_list|(
name|broker
argument_list|,
name|info
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Stores an XML document in the database. {@link #validateXMLResourceInternal(org.exist.storage.txn.Txn,      * org.exist.storage.DBBroker, org.exist.xmldb.XmldbURI, CollectionConfiguration, org.exist.collections.Collection.ValidateBlock)}       * should have been called previously in order to acquire a write lock for the document. Launches the finish trigger.      * @param transaction      * @param broker      * @param info      * @param node      * @param privileged      * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|public
name|void
name|store
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
specifier|final
name|IndexInfo
name|info
parameter_list|,
specifier|final
name|Node
name|node
parameter_list|,
name|boolean
name|privileged
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
block|{
name|storeXMLInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|info
argument_list|,
name|privileged
argument_list|,
operator|new
name|StoreBlock
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|EXistException
throws|,
name|SAXException
block|{
name|info
operator|.
name|getDOMStreamer
argument_list|()
operator|.
name|serialize
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
interface|interface
name|StoreBlock
block|{
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|EXistException
throws|,
name|SAXException
function_decl|;
block|}
comment|/** Stores an XML document in the database. {@link #validateXMLResourceInternal(org.exist.storage.txn.Txn,      * org.exist.storage.DBBroker, org.exist.xmldb.XmldbURI, CollectionConfiguration, org.exist.collections.Collection.ValidateBlock)}       * should have been called previously in order to acquire a write lock for the document. Launches the finish trigger.      * @param transaction      * @param broker      * @param info      * @param privileged      * @param doParse      * @throws EXistException      * @throws SAXException      */
specifier|private
name|void
name|storeXMLInternal
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|IndexInfo
name|info
parameter_list|,
name|boolean
name|privileged
parameter_list|,
name|StoreBlock
name|doParse
parameter_list|)
throws|throws
name|EXistException
throws|,
name|SAXException
block|{
name|DocumentImpl
name|document
init|=
name|info
operator|.
name|getIndexer
argument_list|()
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"storing document "
operator|+
name|document
operator|.
name|getDocId
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
comment|//Sanity check
if|if
condition|(
operator|!
name|document
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|isLockedForWrite
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"document is not locked for write !"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|doParse
operator|.
name|run
argument_list|()
expr_stmt|;
name|broker
operator|.
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
name|broker
operator|.
name|flush
argument_list|()
expr_stmt|;
name|broker
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
comment|//			broker.checkTree(document);
name|LOG
operator|.
name|debug
argument_list|(
literal|"document stored."
argument_list|)
expr_stmt|;
comment|// if we are running in privileged mode (e.g. backup/restore), notify the SecurityManager about changes
if|if
condition|(
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|SYSTEM_COLLECTION_URI
argument_list|)
operator|&&
name|document
operator|.
name|getFileURI
argument_list|()
operator|.
name|equals
argument_list|(
name|XMLSecurityManager
operator|.
name|ACL_FILE_URI
argument_list|)
operator|&&
name|privileged
operator|==
literal|false
condition|)
block|{
comment|// inform the security manager that system data has changed
name|LOG
operator|.
name|debug
argument_list|(
literal|"users.xml changed"
argument_list|)
expr_stmt|;
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|reloadSecurityManager
argument_list|(
name|broker
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|//This lock has been acquired in validateXMLResourceInternal()
name|document
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|collectionConfEnabled
operator|=
literal|true
expr_stmt|;
name|broker
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
name|info
operator|.
name|finishTrigger
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|document
operator|.
name|getURI
argument_list|()
argument_list|,
name|document
argument_list|)
expr_stmt|;
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyUpdate
argument_list|(
name|document
argument_list|,
operator|(
name|info
operator|.
name|getEvent
argument_list|()
operator|==
name|Trigger
operator|.
name|UPDATE_DOCUMENT_EVENT
condition|?
name|UpdateListener
operator|.
name|UPDATE
else|:
name|UpdateListener
operator|.
name|ADD
operator|)
argument_list|)
expr_stmt|;
comment|//Is it a collection configuration file ?
name|XmldbURI
name|docName
init|=
name|document
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
comment|//WARNING : there is no reason to lock the collection since setPath() is normally called in a safe way
comment|//TODO: *resolve* URI against CollectionConfigurationManager.CONFIG_COLLECTION_URI
if|if
condition|(
name|getURI
argument_list|()
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|CONFIG_COLLECTION_URI
argument_list|)
operator|&&
name|docName
operator|.
name|endsWith
argument_list|(
name|CollectionConfiguration
operator|.
name|COLLECTION_CONFIG_SUFFIX_URI
argument_list|)
condition|)
block|{
name|broker
operator|.
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR_SYNC
argument_list|)
expr_stmt|;
name|CollectionConfigurationManager
name|manager
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|manager
operator|.
name|invalidateAll
argument_list|(
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|loadConfiguration
argument_list|(
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
comment|// DIZ: should this exception really been thrown? bugid=1807744
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Error while reading new collection configuration: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
interface|interface
name|ValidateBlock
block|{
specifier|public
name|void
name|run
parameter_list|(
name|IndexInfo
name|info
parameter_list|)
throws|throws
name|SAXException
throws|,
name|EXistException
function_decl|;
block|}
comment|/** Validates an XML document et prepares it for further storage. Launches prepare and postValidate triggers.      * Since the process is dependant from the collection configuration, the collection acquires a write lock during the process.      * @param transaction      * @param broker      * @param docUri         * @param data        * @return An {@link IndexInfo} with a write lock on the document.       * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
return|return
name|validateXMLResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|,
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Validates an XML document et prepares it for further storage. Launches prepare and postValidate triggers.      * Since the process is dependant from the collection configuration, the collection acquires a write lock during the process.      * @param transaction      * @param broker      * @param docUri      * @param source      * @return An {@link IndexInfo} with a write lock on the document.       * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
specifier|final
name|InputSource
name|source
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
specifier|final
name|CollectionConfiguration
name|colconf
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
name|validateXMLResourceInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|,
name|colconf
argument_list|,
operator|new
name|ValidateBlock
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|(
name|IndexInfo
name|info
parameter_list|)
throws|throws
name|SAXException
throws|,
name|EXistException
block|{
name|XMLReader
name|reader
init|=
name|getReader
argument_list|(
name|broker
argument_list|,
name|colconf
argument_list|)
decl_stmt|;
name|info
operator|.
name|setReader
argument_list|(
name|reader
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|reader
operator|.
name|parse
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|releaseReader
argument_list|(
name|broker
argument_list|,
name|info
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Validates an XML document et prepares it for further storage. Launches prepare and postValidate triggers.      * Since the process is dependant from the collection configuration, the collection acquires a write lock during the process.      * @param transaction      * @param broker      * @param docUri      * @param node      * @return An {@link IndexInfo} with a write lock on the document.       * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|public
name|IndexInfo
name|validateXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
specifier|final
name|Node
name|node
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
return|return
name|validateXMLResourceInternal
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|,
name|getConfiguration
argument_list|(
name|broker
argument_list|)
argument_list|,
operator|new
name|ValidateBlock
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|(
name|IndexInfo
name|info
parameter_list|)
throws|throws
name|SAXException
block|{
name|info
operator|.
name|setDOMStreamer
argument_list|(
operator|new
name|DOMStreamer
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|getDOMStreamer
argument_list|()
operator|.
name|serialize
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Validates an XML document et prepares it for further storage. Launches prepare and postValidate triggers.      * Since the process is dependant from the collection configuration, the collection acquires a write lock during the process.      * @param transaction      * @param broker      * @param docUri      * @param doValidate      * @return An {@link IndexInfo} with a write lock on the document.       * @throws EXistException      * @throws PermissionDeniedException      * @throws TriggerException      * @throws SAXException      * @throws LockException      */
specifier|private
name|IndexInfo
name|validateXMLResourceInternal
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|CollectionConfiguration
name|config
parameter_list|,
name|ValidateBlock
name|doValidate
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|TriggerException
throws|,
name|SAXException
throws|,
name|LockException
throws|,
name|IOException
block|{
comment|//Make the necessary operations if we process a collection configuration document
name|checkConfigurationDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|broker
operator|.
name|isReadOnly
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Database is read-only"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
literal|null
decl_stmt|;
name|boolean
name|oldDocLocked
init|=
literal|false
decl_stmt|;
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|DocumentImpl
name|document
init|=
operator|new
name|DocumentImpl
argument_list|(
name|broker
argument_list|,
name|this
argument_list|,
name|docUri
argument_list|)
decl_stmt|;
name|oldDoc
operator|=
operator|(
name|DocumentImpl
operator|)
name|documents
operator|.
name|get
argument_list|(
name|docUri
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|setPermissions
argument_list|(
name|config
operator|.
name|getDefResPermissions
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|document
operator|.
name|setPermissions
argument_list|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
name|checkPermissions
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|manageDocumentInformation
argument_list|(
name|broker
argument_list|,
name|oldDoc
argument_list|,
name|document
argument_list|)
expr_stmt|;
name|Indexer
name|indexer
init|=
operator|new
name|Indexer
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|)
decl_stmt|;
name|IndexInfo
name|info
init|=
operator|new
name|IndexInfo
argument_list|(
name|indexer
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|indexer
operator|.
name|setDocument
argument_list|(
name|document
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|addObserversToIndexer
argument_list|(
name|broker
argument_list|,
name|indexer
argument_list|)
expr_stmt|;
name|indexer
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// if !triggersEnabled, setupTriggers will return null anyway, so no need to check
name|info
operator|.
name|setTrigger
argument_list|(
name|setupTriggers
argument_list|(
name|broker
argument_list|,
name|docUri
argument_list|,
name|oldDoc
operator|!=
literal|null
argument_list|,
name|config
argument_list|)
argument_list|,
name|oldDoc
operator|==
literal|null
condition|?
name|Trigger
operator|.
name|STORE_DOCUMENT_EVENT
else|:
name|Trigger
operator|.
name|UPDATE_DOCUMENT_EVENT
argument_list|)
expr_stmt|;
name|info
operator|.
name|prepareTrigger
argument_list|(
name|broker
argument_list|,
name|transaction
argument_list|,
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|docUri
argument_list|)
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning document "
operator|+
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|docUri
argument_list|)
argument_list|)
expr_stmt|;
name|doValidate
operator|.
name|run
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// new document is valid: remove old document
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|oldDoc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|oldDocLocked
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
comment|//TODO : use a more elaborated method ? No triggers...
name|broker
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|oldDoc
argument_list|)
expr_stmt|;
name|documents
operator|.
name|remove
argument_list|(
name|oldDoc
operator|.
name|getFileURI
argument_list|()
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
comment|//This lock is released in storeXMLInternal()
comment|//TODO : check that we go until there to ensure the lock is released
name|document
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|document
operator|.
name|setDocId
argument_list|(
name|broker
operator|.
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//TODO : use a more elaborated method ? No triggers...
name|broker
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|oldDoc
operator|.
name|copyOf
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|indexer
operator|.
name|setDocumentObject
argument_list|(
name|oldDoc
argument_list|)
expr_stmt|;
comment|//old has become new at this point
name|document
operator|=
name|oldDoc
expr_stmt|;
name|oldDocLocked
operator|=
literal|false
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"removed old document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//This lock is released in storeXMLInternal()
comment|//TODO : check that we go until there to ensure the lock is released
name|document
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|document
operator|.
name|setDocId
argument_list|(
name|broker
operator|.
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|indexer
operator|.
name|setValidating
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|info
operator|.
name|postValidateTrigger
argument_list|()
expr_stmt|;
return|return
name|info
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|oldDocLocked
condition|)
name|oldDoc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkConfigurationDocument
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|IOException
block|{
comment|//Is it a collection configuration file ?
comment|//TODO : use XmldbURI.resolve() !
if|if
condition|(
operator|!
name|getURI
argument_list|()
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|CONFIG_COLLECTION_URI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|docUri
operator|.
name|endsWith
argument_list|(
name|CollectionConfiguration
operator|.
name|COLLECTION_CONFIG_SUFFIX_URI
argument_list|)
condition|)
return|return;
comment|//Allow just one configuration document per collection
comment|//TODO : do not throw the exception if a system property allows several ones -pb
for|for
control|(
name|Iterator
name|i
init|=
name|iterator
argument_list|(
name|broker
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|confDoc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|XmldbURI
name|currentConfDocName
init|=
name|confDoc
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentConfDocName
operator|!=
literal|null
operator|&&
operator|!
name|currentConfDocName
operator|.
name|equals
argument_list|(
name|docUri
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Could not store configuration '"
operator|+
name|docUri
operator|+
literal|"': A configuration document with a different name ("
operator|+
name|currentConfDocName
operator|+
literal|") already exists in this collection ("
operator|+
name|getURI
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|//        broker.saveCollection(transaction, this);
comment|//        CollectionConfigurationManager confMgr = broker.getBrokerPool().getConfigurationManager();
comment|//        if(confMgr != null)
comment|//            try {
comment|//                confMgr.reload(broker, this);
comment|//            } catch (CollectionConfigurationException e) {
comment|//                throw new EXistException("An error occurred while reloading the updated collection configuration: " + e.getMessage(), e);
comment|//            }
block|}
comment|/** add observers to the indexer      * @param broker      * @param indexer      */
specifier|private
name|void
name|addObserversToIndexer
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Indexer
name|indexer
parameter_list|)
block|{
name|broker
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|observers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|indexer
operator|.
name|addObserver
argument_list|(
name|observers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|broker
operator|.
name|addObserver
argument_list|(
name|observers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** If an old document exists, keep information  about  the document.      * @param broker      * @param document      */
specifier|private
name|void
name|manageDocumentInformation
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|DocumentImpl
name|oldDoc
parameter_list|,
name|DocumentImpl
name|document
parameter_list|)
block|{
name|DocumentMetadata
name|metadata
init|=
operator|new
name|DocumentMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|=
name|oldDoc
operator|.
name|getMetadata
argument_list|()
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|oldDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getCreated
argument_list|()
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setLastModified
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|document
operator|.
name|setPermissions
argument_list|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|.
name|setCreated
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|document
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|document
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|document
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check Permissions about user and document, and throw exceptions if necessary.      *      * @param broker      * @param oldDoc old Document existing in database prior to adding a new one with same name.      * @throws LockException      * @throws PermissionDeniedException      */
specifier|private
name|void
name|checkPermissions
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|DocumentImpl
name|oldDoc
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found old doc "
operator|+
name|oldDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if the document is locked by another user
name|User
name|lockUser
init|=
name|oldDoc
operator|.
name|getUserLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lockUser
operator|!=
literal|null
operator|&&
operator|!
name|lockUser
operator|.
name|equals
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"The document is locked by user "
operator|+
name|lockUser
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
comment|// do we have permissions for update?
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Document exists and update is not allowed"
argument_list|)
throw|;
if|if
condition|(
operator|!
operator|(
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
operator|||
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
operator|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Document exists and update is not allowed for the collection"
argument_list|)
throw|;
comment|// do we have write permissions?
block|}
if|else if
condition|(
operator|!
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"User '"
operator|+
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to write to collection '"
operator|+
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
specifier|private
name|DocumentTrigger
name|setupTriggers
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|boolean
name|update
parameter_list|,
name|CollectionConfiguration
name|config
parameter_list|)
block|{
comment|//TODO : is this the right place for such a task ? -pb
if|if
condition|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE_URI
operator|.
name|equals
argument_list|(
name|docUri
argument_list|)
condition|)
block|{
comment|// we are updating collection.xconf. Notify configuration manager
comment|//            CollectionConfigurationManager confMgr = broker.getBrokerPool().getConfigurationManager();
comment|//            confMgr.invalidateAll(getURI());
name|collectionConfEnabled
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|triggersEnabled
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|config
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DocumentTrigger
name|trigger
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|update
condition|)
name|trigger
operator|=
operator|(
name|DocumentTrigger
operator|)
name|config
operator|.
name|newTrigger
argument_list|(
name|Trigger
operator|.
name|UPDATE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
name|trigger
operator|=
operator|(
name|DocumentTrigger
operator|)
name|config
operator|.
name|newTrigger
argument_list|(
name|Trigger
operator|.
name|STORE_DOCUMENT_EVENT
argument_list|,
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"An error occurred while initializing a trigger for collection "
operator|+
name|getURI
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trigger
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|update
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using update trigger '"
operator|+
name|trigger
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using store trigger '"
operator|+
name|trigger
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return
name|trigger
return|;
block|}
comment|// Blob
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|String
name|mimeType
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|,
name|data
argument_list|,
name|mimeType
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// Blob
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|String
name|mimeType
parameter_list|,
name|Date
name|created
parameter_list|,
name|Date
name|modified
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
argument_list|,
name|mimeType
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|created
argument_list|,
name|modified
argument_list|)
return|;
block|}
comment|// Streaming
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|InputStream
name|is
parameter_list|,
name|String
name|mimeType
parameter_list|,
name|int
name|size
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
return|return
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|docUri
argument_list|,
name|is
argument_list|,
name|mimeType
argument_list|,
name|size
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// Streaming
specifier|public
name|BinaryDocument
name|addBinaryResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|XmldbURI
name|docUri
parameter_list|,
name|InputStream
name|is
parameter_list|,
name|String
name|mimeType
parameter_list|,
name|int
name|size
parameter_list|,
name|Date
name|created
parameter_list|,
name|Date
name|modified
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|broker
operator|.
name|isReadOnly
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Database is read-only"
argument_list|)
throw|;
name|BinaryDocument
name|blob
init|=
operator|new
name|BinaryDocument
argument_list|(
name|broker
argument_list|,
name|this
argument_list|,
name|docUri
argument_list|)
decl_stmt|;
comment|//TODO : move later, i.e. after the collection lock is acquired ?
name|DocumentImpl
name|oldDoc
init|=
name|getDocument
argument_list|(
name|broker
argument_list|,
name|docUri
argument_list|)
decl_stmt|;
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|checkPermissions
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|DocumentTrigger
name|trigger
init|=
literal|null
decl_stmt|;
name|int
name|event
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|triggersEnabled
condition|)
block|{
name|CollectionConfiguration
name|config
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
name|event
operator|=
name|oldDoc
operator|!=
literal|null
condition|?
name|Trigger
operator|.
name|UPDATE_DOCUMENT_EVENT
else|:
name|Trigger
operator|.
name|STORE_DOCUMENT_EVENT
expr_stmt|;
try|try
block|{
name|trigger
operator|=
operator|(
name|DocumentTrigger
operator|)
name|config
operator|.
name|newTrigger
argument_list|(
name|event
argument_list|,
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"An error occurred while initializing a trigger for collection "
operator|+
name|getURI
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trigger
operator|!=
literal|null
condition|)
block|{
name|trigger
operator|.
name|prepare
argument_list|(
name|event
argument_list|,
name|broker
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|manageDocumentInformation
argument_list|(
name|broker
argument_list|,
name|oldDoc
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|DocumentMetadata
name|metadata
init|=
name|blob
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setMimeType
argument_list|(
name|mimeType
operator|==
literal|null
condition|?
name|MimeType
operator|.
name|BINARY_TYPE
operator|.
name|getName
argument_list|()
else|:
name|mimeType
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|instanceof
name|BinaryDocument
condition|)
name|broker
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
operator|(
name|BinaryDocument
operator|)
name|oldDoc
argument_list|)
expr_stmt|;
else|else
name|broker
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|created
operator|!=
literal|null
condition|)
name|metadata
operator|.
name|setCreated
argument_list|(
name|created
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
operator|!=
literal|null
condition|)
name|metadata
operator|.
name|setLastModified
argument_list|(
name|modified
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|blob
operator|.
name|setContentLength
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|broker
operator|.
name|storeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|broker
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|broker
operator|.
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|broker
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
if|if
condition|(
name|trigger
operator|!=
literal|null
condition|)
block|{
name|trigger
operator|.
name|finish
argument_list|(
name|event
argument_list|,
name|broker
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
return|return
name|blob
return|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|this
operator|.
name|collectionId
operator|=
name|id
expr_stmt|;
block|}
specifier|public
name|void
name|setPermissions
parameter_list|(
name|int
name|mode
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|permissions
operator|.
name|setPermissions
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setPermissions
parameter_list|(
name|String
name|mode
parameter_list|)
throws|throws
name|SyntaxException
throws|,
name|LockException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|permissions
operator|.
name|setPermissions
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set permissions for the collection.      *      * @param permissions      */
specifier|public
name|void
name|setPermissions
parameter_list|(
name|Permission
name|permissions
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|this
operator|.
name|permissions
operator|=
name|permissions
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write collection contents to stream.      *      * @param ostream      * @throws IOException      */
specifier|public
name|void
name|write
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|VariableByteOutputStream
name|ostream
parameter_list|)
throws|throws
name|IOException
block|{
name|ostream
operator|.
name|writeInt
argument_list|(
name|collectionId
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|writeInt
argument_list|(
name|subcollections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|XmldbURI
name|childColl
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|subcollections
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childColl
operator|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|ostream
operator|.
name|writeUTF
argument_list|(
name|childColl
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SecurityManager
name|secman
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|secman
operator|==
literal|null
condition|)
block|{
name|ostream
operator|.
name|writeInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|writeInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|User
name|user
init|=
name|secman
operator|.
name|getUser
argument_list|(
name|permissions
operator|.
name|getOwner
argument_list|()
argument_list|)
decl_stmt|;
name|Group
name|group
init|=
name|secman
operator|.
name|getGroup
argument_list|(
name|permissions
operator|.
name|getOwnerGroup
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The user "
operator|+
name|permissions
operator|.
name|getOwner
argument_list|()
operator|+
literal|" for the collection cannot be found."
argument_list|)
throw|;
block|}
if|if
condition|(
name|group
operator|==
literal|null
condition|)
name|group
operator|=
name|secman
operator|.
name|getGroup
argument_list|(
name|SecurityManager
operator|.
name|GUEST_GROUP
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|writeInt
argument_list|(
name|user
operator|.
name|getUID
argument_list|()
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|writeInt
argument_list|(
name|group
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ostream
operator|.
name|writeInt
argument_list|(
name|permissions
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|writeLong
argument_list|(
name|created
argument_list|)
expr_stmt|;
block|}
specifier|public
name|CollectionConfiguration
name|getConfiguration
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|collectionConfEnabled
condition|)
return|return
literal|null
return|;
comment|//System collection has no configuration
if|if
condition|(
name|DBBroker
operator|.
name|SYSTEM_COLLECTION
operator|.
name|equals
argument_list|(
name|getURI
argument_list|()
operator|.
name|getRawCollectionPath
argument_list|()
argument_list|)
condition|)
return|return
literal|null
return|;
name|CollectionConfigurationManager
name|manager
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|//Attempt to get configuration
name|CollectionConfiguration
name|configuration
init|=
literal|null
decl_stmt|;
name|collectionConfEnabled
operator|=
literal|false
expr_stmt|;
try|try
block|{
comment|//TODO: AR: if a Trigger throws CollectionConfigurationException from its configure() method, is the rest of the collection configurartion (indexes etc.) ignored even though they might be fine?
name|configuration
operator|=
name|manager
operator|.
name|getConfiguration
argument_list|(
name|broker
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|collectionConfEnabled
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CollectionConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to load collection configuration for '"
operator|+
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//        LOG.debug("Loaded configuration for collection:  " + getURI());
return|return
name|configuration
return|;
block|}
comment|/**      * Should the collection configuration document be enabled      * for this collection? Called by {@link org.exist.storage.NativeBroker}      * before doing a reindex.      *      * @param enabled      */
specifier|public
name|void
name|setConfigEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|collectionConfEnabled
operator|=
name|enabled
expr_stmt|;
block|}
comment|/**      * Set the internal storage address of the collection data.      *      * @param addr      */
specifier|public
name|void
name|setAddress
parameter_list|(
name|long
name|addr
parameter_list|)
block|{
name|this
operator|.
name|address
operator|=
name|addr
expr_stmt|;
block|}
specifier|public
name|long
name|getAddress
parameter_list|()
block|{
return|return
name|this
operator|.
name|address
return|;
block|}
specifier|public
name|void
name|setCreationTime
parameter_list|(
name|long
name|ms
parameter_list|)
block|{
name|created
operator|=
name|ms
expr_stmt|;
block|}
specifier|public
name|long
name|getCreationTime
parameter_list|()
block|{
return|return
name|created
return|;
block|}
specifier|public
name|void
name|setTriggersEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
try|try
block|{
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|this
operator|.
name|triggersEnabled
operator|=
name|enabled
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//Ouch ! -pb
name|this
operator|.
name|triggersEnabled
operator|=
name|enabled
expr_stmt|;
block|}
finally|finally
block|{
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** set user-defined Reader */
specifier|public
name|void
name|setReader
parameter_list|(
name|XMLReader
name|reader
parameter_list|)
block|{
name|userReader
operator|=
name|reader
expr_stmt|;
block|}
comment|//    /**
comment|//     * If user-defined Reader is set, return it; otherwise return JAXP
comment|//     * default XMLReader configured by eXist.
comment|//     */
comment|//    private XMLReader getReader(DBBroker broker) throws EXistException,
comment|//            SAXException {
comment|//
comment|//        if(userReader != null){
comment|//            return userReader;
comment|//        }
comment|//
comment|//        return broker.getBrokerPool().getParserPool().borrowXMLReader();
comment|//    }
comment|/**       * Get xml reader from readerpool and setup validation when needed.      */
specifier|private
name|XMLReader
name|getReader
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|CollectionConfiguration
name|colconfig
parameter_list|)
throws|throws
name|EXistException
throws|,
name|SAXException
block|{
comment|// If user-defined Reader is set, return it;
if|if
condition|(
name|userReader
operator|!=
literal|null
condition|)
block|{
return|return
name|userReader
return|;
block|}
comment|// Get reader from readerpool.
name|XMLReader
name|reader
init|=
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getParserPool
argument_list|()
operator|.
name|borrowXMLReader
argument_list|()
decl_stmt|;
comment|// If Collection configuration exists (try to) get validation mode
comment|// and setup reader with this information.
if|if
condition|(
name|colconfig
operator|!=
literal|null
condition|)
block|{
name|int
name|mode
init|=
name|colconfig
operator|.
name|getValidationMode
argument_list|()
decl_stmt|;
name|XMLReaderObjectFactory
operator|.
name|setReaderValidationMode
argument_list|(
name|mode
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
comment|// Return configured reader.
return|return
name|reader
return|;
block|}
comment|/**      * Reset validation mode of reader and return reader to reader pool.      */
specifier|private
name|void
name|releaseReader
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|IndexInfo
name|info
parameter_list|,
name|XMLReader
name|reader
parameter_list|)
block|{
if|if
condition|(
name|userReader
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|info
operator|.
name|getIndexer
argument_list|()
operator|.
name|getDocSize
argument_list|()
operator|>
name|POOL_PARSER_THRESHOLD
condition|)
return|return;
comment|// Get validation mode from static configuration
name|Configuration
name|config
init|=
name|broker
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|String
name|optionValue
init|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|XMLReaderObjectFactory
operator|.
name|PROPERTY_VALIDATION_MODE
argument_list|)
decl_stmt|;
name|int
name|validationMode
init|=
name|XMLReaderObjectFactory
operator|.
name|convertValidationMode
argument_list|(
name|optionValue
argument_list|)
decl_stmt|;
comment|// Restore default validation mode
name|XMLReaderObjectFactory
operator|.
name|setReaderValidationMode
argument_list|(
name|validationMode
argument_list|,
name|reader
argument_list|)
expr_stmt|;
comment|// Return reader
name|broker
operator|.
name|getBrokerPool
argument_list|()
operator|.
name|getParserPool
argument_list|()
operator|.
name|returnXMLReader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see java.util.Observable#addObserver(java.util.Observer)      */
specifier|public
name|void
name|addObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
if|if
condition|(
name|hasObserver
argument_list|(
name|o
argument_list|)
condition|)
return|return;
if|if
condition|(
name|observers
operator|==
literal|null
condition|)
block|{
name|observers
operator|=
operator|new
name|Observer
index|[
literal|1
index|]
expr_stmt|;
name|observers
index|[
literal|0
index|]
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
name|Observer
name|n
index|[]
init|=
operator|new
name|Observer
index|[
name|observers
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|observers
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
name|observers
operator|.
name|length
argument_list|)
expr_stmt|;
name|n
index|[
name|observers
operator|.
name|length
index|]
operator|=
name|o
expr_stmt|;
name|observers
operator|=
name|n
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|hasObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|observers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|observers
index|[
name|i
index|]
operator|==
name|o
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* (non-Javadoc)          * @see java.util.Observable#deleteObservers()          */
specifier|public
name|void
name|deleteObservers
parameter_list|()
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
name|observers
operator|=
literal|null
expr_stmt|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#getKey()          */
specifier|public
name|long
name|getKey
parameter_list|()
block|{
return|return
name|collectionId
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#getReferenceCount()          */
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#incReferenceCount()          */
specifier|public
name|int
name|incReferenceCount
parameter_list|()
block|{
return|return
operator|++
name|refCount
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#decReferenceCount()          */
specifier|public
name|int
name|decReferenceCount
parameter_list|()
block|{
return|return
name|refCount
operator|>
literal|0
condition|?
operator|--
name|refCount
else|:
literal|0
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#setReferenceCount(int)          */
specifier|public
name|void
name|setReferenceCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|refCount
operator|=
name|count
expr_stmt|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#setTimestamp(int)          */
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|int
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#getTimestamp()          */
specifier|public
name|int
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.cache.Cacheable#release()          */
specifier|public
name|boolean
name|sync
parameter_list|(
name|boolean
name|syncJournal
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/* (non-Javadoc)      * @see org.exist.storage.cache.Cacheable#isDirty()      */
specifier|public
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|documents
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @deprecated Make private ASAP      * @param broker      */
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
name|CollectionConfiguration
name|conf
init|=
name|getConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
comment|//If the collection has its own config...
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
return|return
name|broker
operator|.
name|getIndexConfiguration
argument_list|()
return|;
comment|//... otherwise return the general config (the broker's one)
block|}
else|else
block|{
return|return
name|conf
operator|.
name|getIndexConfiguration
argument_list|()
return|;
block|}
block|}
specifier|public
name|GeneralRangeIndexSpec
name|getIndexByPathConfiguration
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|NodePath
name|path
parameter_list|)
block|{
name|IndexSpec
name|idxSpec
init|=
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
operator|(
name|idxSpec
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|path
argument_list|)
return|;
block|}
specifier|public
name|QNameRangeIndexSpec
name|getIndexByQNameConfiguration
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|QName
name|qname
parameter_list|)
block|{
name|IndexSpec
name|idxSpec
init|=
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
operator|(
name|idxSpec
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|qname
argument_list|)
return|;
block|}
specifier|public
name|FulltextIndexSpec
name|getFulltextIndexConfiguration
parameter_list|(
name|DBBroker
name|broker
parameter_list|)
block|{
name|IndexSpec
name|idxSpec
init|=
name|getIndexConfiguration
argument_list|(
name|broker
argument_list|)
decl_stmt|;
return|return
operator|(
name|idxSpec
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
return|;
block|}
block|}
end_class

end_unit

