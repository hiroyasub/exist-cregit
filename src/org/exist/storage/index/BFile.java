begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database Copyright (C) 2001-06 Wolfgang M. Meier  * wolfgang@exist-db.org http://exist.sourceforge.net  *   * This program is free software; you can redistribute it and/or modify it under  * the terms of the GNU Lesser General Public License as published by the Free  * Software Foundation; either version 2 of the License, or (at your option) any  * later version.  *   * This program is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more  * details.  *   * You should have received a copy of the GNU Lesser General Public License  * along with this program; if not, write to the Free Software Foundation, Inc.,  * 675 Mass Ave, Cambridge, MA 02139, USA.  *   * $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BufferStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|CacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DefaultCacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|NativeBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|StorageAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cacheable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|LRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteArrayInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|LogEntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Loggable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Lsn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|FixedByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|IndexCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|sanity
operator|.
name|SanityCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|external
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|output
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * Data store for variable size values.  *   * This class maps keys to values of variable size. Keys are stored in the  * b+-tree. B+-tree values are pointers to the logical storage address of the  * value in the data section. The pointer consists of the page number and a  * logical tuple identifier.  *   * If a value is larger than the internal page size (4K), it is split into  * overflow pages. Appending data to a overflow page is very fast. Only the  * first and the last data page are loaded.  *   * Data pages are buffered.  *   * @author Wolfgang Meier<wolfgang@exist-db.org>  */
end_comment

begin_class
specifier|public
class|class
name|BFile
extends|extends
name|BTree
block|{
specifier|protected
specifier|final
specifier|static
name|Logger
name|LOGSTATS
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NativeBroker
operator|.
name|EXIST_STATISTICS_LOGGER
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|short
name|FILE_FORMAT_VERSION_ID
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|UNKNOWN_ADDRESS
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|DATA_SYNC_PERIOD
init|=
literal|15000
decl_stmt|;
comment|// minimum free space a page should have to be
comment|// considered for reusing
specifier|public
specifier|final
specifier|static
name|int
name|PAGE_MIN_FREE
init|=
literal|64
decl_stmt|;
comment|// page signatures
specifier|public
specifier|final
specifier|static
name|byte
name|RECORD
init|=
literal|20
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOB
init|=
literal|21
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|FREE_LIST
init|=
literal|22
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|MULTI_PAGE
init|=
literal|23
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_RECORDS_COUNT
init|=
literal|2
decl_stmt|;
comment|//sizeof short
specifier|public
specifier|static
specifier|final
name|int
name|LENGTH_NEXT_TID
init|=
literal|2
decl_stmt|;
comment|//sizeof short
comment|/*      * Byte ids for the records written to the log file.      */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_CREATE_PAGE
init|=
literal|0x30
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_STORE_VALUE
init|=
literal|0x31
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_VALUE
init|=
literal|0x32
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_PAGE
init|=
literal|0x33
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_OVERFLOW_APPEND
init|=
literal|0x34
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_OVERFLOW_STORE
init|=
literal|0x35
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_OVERFLOW_CREATE
init|=
literal|0x36
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_OVERFLOW_MODIFIED
init|=
literal|0x37
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_OVERFLOW_CREATE_PAGE
init|=
literal|0x38
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_OVERFLOW_REMOVE
init|=
literal|0x39
decl_stmt|;
static|static
block|{
comment|// register log entry types for this db file
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_CREATE_PAGE
argument_list|,
name|CreatePageLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_STORE_VALUE
argument_list|,
name|StoreValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_VALUE
argument_list|,
name|RemoveValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_PAGE
argument_list|,
name|RemoveEmptyPageLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_OVERFLOW_APPEND
argument_list|,
name|OverflowAppendLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_OVERFLOW_STORE
argument_list|,
name|OverflowStoreLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_OVERFLOW_CREATE
argument_list|,
name|OverflowCreateLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_OVERFLOW_MODIFIED
argument_list|,
name|OverflowModifiedLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_OVERFLOW_CREATE_PAGE
argument_list|,
name|OverflowCreatePageLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_OVERFLOW_REMOVE
argument_list|,
name|OverflowRemoveLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|BFileHeader
name|fileHeader
decl_stmt|;
specifier|protected
name|int
name|minFree
decl_stmt|;
specifier|protected
name|Cache
name|dataCache
init|=
literal|null
decl_stmt|;
specifier|protected
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
specifier|public
name|int
name|fixedKeyLen
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|int
name|maxValueSize
decl_stmt|;
specifier|public
name|BFile
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|byte
name|fileId
parameter_list|,
name|boolean
name|transactional
parameter_list|,
name|File
name|file
parameter_list|,
name|DefaultCacheManager
name|cacheManager
parameter_list|,
name|double
name|cacheGrowth
parameter_list|,
name|double
name|thresholdBTree
parameter_list|,
name|double
name|thresholdData
parameter_list|)
throws|throws
name|DBException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|fileId
argument_list|,
name|transactional
argument_list|,
name|cacheManager
argument_list|,
name|file
argument_list|,
name|thresholdBTree
argument_list|)
expr_stmt|;
name|fileHeader
operator|=
operator|(
name|BFileHeader
operator|)
name|getFileHeader
argument_list|()
expr_stmt|;
name|dataCache
operator|=
operator|new
name|LRUCache
argument_list|(
literal|64
argument_list|,
name|cacheGrowth
argument_list|,
name|thresholdData
argument_list|,
name|CacheManager
operator|.
name|DATA_CACHE
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|setFileName
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|cacheManager
operator|.
name|registerCache
argument_list|(
name|dataCache
argument_list|)
expr_stmt|;
name|minFree
operator|=
name|PAGE_MIN_FREE
expr_stmt|;
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|maxValueSize
operator|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|exists
argument_list|()
condition|)
block|{
name|open
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating data file: "
operator|+
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|create
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @return file version      */
annotation|@
name|Override
specifier|public
name|short
name|getFileVersion
parameter_list|()
block|{
return|return
name|FILE_FORMAT_VERSION_ID
return|;
block|}
comment|/**      * Returns the Lock object responsible for this BFile.      *       * @return Lock      */
specifier|public
name|Lock
name|getLock
parameter_list|()
block|{
return|return
name|lock
return|;
block|}
specifier|protected
name|long
name|getDataSyncPeriod
parameter_list|()
block|{
return|return
name|DATA_SYNC_PERIOD
return|;
block|}
comment|/**      * Append the given data fragment to the value associated      * with the key. A new entry is created if the key does not      * yet exist in the database.      *       * @param key      * @param value      * @throws ReadOnlyException      * @throws IOException      */
specifier|public
name|long
name|append
parameter_list|(
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
throws|,
name|IOException
block|{
return|return
name|append
argument_list|(
literal|null
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|public
name|long
name|append
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"key is null"
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
if|if
condition|(
name|key
operator|.
name|getLength
argument_list|()
operator|>
name|fileHeader
operator|.
name|getMaxKeySize
argument_list|()
condition|)
block|{
comment|//TODO : throw an exception ? -pb
name|LOG
operator|.
name|warn
argument_list|(
literal|"Key length exceeds page size! Skipping key ..."
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
try|try
block|{
comment|// check if key exists already
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
comment|// key does not exist:
name|p
operator|=
name|storeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|addValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|// key exists: get old data
specifier|final
name|long
name|pnum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|final
name|short
name|tid
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|final
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|instanceof
name|OverflowPage
condition|)
operator|(
operator|(
name|OverflowPage
operator|)
name|page
operator|)
operator|.
name|append
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
specifier|final
name|int
name|valueLen
init|=
name|value
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|getData
argument_list|()
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"tid "
operator|+
name|tid
operator|+
literal|" not found on page "
operator|+
name|pnum
argument_list|)
throw|;
if|if
condition|(
name|offset
operator|+
literal|4
operator|>
name|data
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"found invalid pointer in file "
operator|+
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" for page"
operator|+
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|" : "
operator|+
literal|"tid = "
operator|+
name|tid
operator|+
literal|"; offset = "
operator|+
name|offset
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
specifier|final
name|int
name|l
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
decl_stmt|;
comment|//TOUNDERSTAND : unless l can be negative, we should never get there -pb
if|if
condition|(
name|offset
operator|+
literal|4
operator|+
name|l
operator|>
name|data
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"found invalid data record in file "
operator|+
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" for page"
operator|+
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|" : "
operator|+
literal|"length = "
operator|+
name|data
operator|.
name|length
operator|+
literal|"; required = "
operator|+
operator|(
name|offset
operator|+
literal|4
operator|+
name|l
operator|)
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
specifier|final
name|byte
index|[]
name|newData
init|=
operator|new
name|byte
index|[
name|l
operator|+
name|valueLen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|newData
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|value
operator|.
name|copyTo
argument_list|(
name|newData
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|=
name|update
argument_list|(
name|transaction
argument_list|,
name|p
argument_list|,
name|page
argument_list|,
name|key
argument_list|,
operator|new
name|FixedByteArray
argument_list|(
name|newData
argument_list|,
literal|0
argument_list|,
name|newData
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree exception while appending value"
argument_list|,
name|bte
argument_list|)
expr_stmt|;
block|}
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
comment|/**      * Close the BFile.      *       * @throws DBException      * @return always true      */
annotation|@
name|Override
specifier|public
name|boolean
name|close
parameter_list|()
throws|throws
name|DBException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Check, if key is contained in BFile.      *       * @param key key to look for      * @return true, if key exists      */
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Value
name|key
parameter_list|)
block|{
try|try
block|{
return|return
name|findValue
argument_list|(
name|key
argument_list|)
operator|!=
name|KEY_NOT_FOUND
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|create
parameter_list|()
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|create
argument_list|(
operator|(
name|short
operator|)
name|fixedKeyLen
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closeAndRemove
parameter_list|()
block|{
name|super
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|deregisterCache
argument_list|(
name|dataCache
argument_list|)
expr_stmt|;
block|}
specifier|private
name|SinglePage
name|createDataPage
parameter_list|()
block|{
try|try
block|{
name|SinglePage
name|page
init|=
operator|new
name|SinglePage
argument_list|()
decl_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|int
name|pageSize
parameter_list|)
block|{
return|return
operator|new
name|BFileHeader
argument_list|(
name|pageSize
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PageHeader
name|createPageHeader
parameter_list|()
block|{
return|return
operator|new
name|BFilePageHeader
argument_list|()
return|;
block|}
comment|/**      * Remove all entries matching the given query.      *       * @param query      * @throws IOException      * @throws BTreeException      */
specifier|public
name|void
name|removeAll
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
comment|// first collect the values to remove, then sort them by their page number
comment|// and remove them.
try|try
block|{
name|RemoveCallback
name|cb
init|=
operator|new
name|RemoveCallback
argument_list|()
decl_stmt|;
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|cb
operator|.
name|count
operator|+
literal|" items to remove."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|count
operator|==
literal|0
condition|)
return|return;
name|Arrays
operator|.
name|sort
argument_list|(
name|cb
operator|.
name|pointers
argument_list|,
literal|0
argument_list|,
name|cb
operator|.
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cb
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|remove
argument_list|(
name|transaction
argument_list|,
name|cb
operator|.
name|pointers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
comment|// Should never happen during remove
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeAll() - method has been terminated."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|RemoveCallback
implements|implements
name|BTreeCallback
block|{
name|long
index|[]
name|pointers
init|=
operator|new
name|long
index|[
literal|128
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
if|if
condition|(
name|count
operator|==
name|pointers
operator|.
name|length
condition|)
block|{
name|long
index|[]
name|np
init|=
operator|new
name|long
index|[
name|count
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pointers
argument_list|,
literal|0
argument_list|,
name|np
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pointers
operator|=
name|np
expr_stmt|;
block|}
name|pointers
index|[
name|count
operator|++
index|]
operator|=
name|pointer
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
specifier|public
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|findEntries
parameter_list|(
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|BOTH
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|findKeys
parameter_list|(
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|KEYS
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
specifier|public
name|void
name|find
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|IndexCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|callback
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
comment|/* Flushes {@link org.exist.storage.btree.Paged#flush()dirty data} to the disk and cleans up the cache.       * @return<code>true</code> if something has actually been cleaned      */
annotation|@
name|Override
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|DBException
block|{
name|boolean
name|flushed
init|=
literal|false
decl_stmt|;
comment|//TODO : consider log operation as a flush ?
if|if
condition|(
name|isTransactional
condition|)
name|logManager
operator|.
name|flushToLog
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|flushed
operator|=
name|flushed
operator||
name|dataCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|flushed
operator|=
name|flushed
operator||
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|flushed
return|;
block|}
specifier|public
name|BufferStats
name|getDataBufferStats
parameter_list|()
block|{
if|if
condition|(
name|dataCache
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|BufferStats
argument_list|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getHits
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getFails
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
name|super
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getPercentInstance
argument_list|()
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" DATA "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Buffers occupation : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
operator|==
literal|0
operator|&&
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
name|nf
operator|.
name|format
argument_list|(
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
operator|/
operator|(
name|float
operator|)
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" ("
operator|+
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
operator|+
literal|" out of "
operator|+
name|dataCache
operator|.
name|getBuffers
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|//buf.append(dataCache.getBuffers()).append(" / ");
comment|//buf.append(dataCache.getUsedBuffers()).append(" / ");
name|buf
operator|.
name|append
argument_list|(
literal|" Cache efficiency : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataCache
operator|.
name|getHits
argument_list|()
operator|==
literal|0
operator|&&
name|dataCache
operator|.
name|getFails
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
name|nf
operator|.
name|format
argument_list|(
name|dataCache
operator|.
name|getHits
argument_list|()
operator|/
operator|(
name|float
operator|)
operator|(
name|dataCache
operator|.
name|getHits
argument_list|()
operator|+
name|dataCache
operator|.
name|getFails
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//buf.append(dataCache.getHits()).append(" / ");
comment|//buf.append(dataCache.getFails());
name|LOGSTATS
operator|.
name|info
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the value data associated with the specified key      * or null if the key could not be found.      *       * @param key      */
specifier|public
name|Value
name|get
parameter_list|(
name|Value
name|key
parameter_list|)
block|{
try|try
block|{
specifier|final
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
literal|null
return|;
specifier|final
name|long
name|pnum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|final
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
return|return
name|get
argument_list|(
name|page
argument_list|,
name|p
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An exception occurred while trying to retrieve key "
operator|+
name|key
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get the value data for the given key as a variable byte      * encoded input stream.      *       * @param key      * @throws IOException      */
specifier|public
name|VariableByteInput
name|getAsStream
parameter_list|(
name|Value
name|key
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
literal|null
return|;
specifier|final
name|long
name|pnum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|final
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|MULTI_PAGE
case|:
return|return
operator|(
operator|(
name|OverflowPage
operator|)
name|page
operator|)
operator|.
name|getDataStream
argument_list|(
name|p
argument_list|)
return|;
default|default:
return|return
name|getAsStream
argument_list|(
name|page
argument_list|,
name|p
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An exception occurred while trying to retrieve key "
operator|+
name|key
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get the value located at the specified address as a      * variable byte encoded input stream.      *       * @param pointer      * @throws IOException      */
specifier|public
name|VariableByteInput
name|getAsStream
parameter_list|(
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|pointer
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|MULTI_PAGE
case|:
return|return
operator|(
operator|(
name|OverflowPage
operator|)
name|page
operator|)
operator|.
name|getDataStream
argument_list|(
name|pointer
argument_list|)
return|;
default|default:
return|return
name|getAsStream
argument_list|(
name|page
argument_list|,
name|pointer
argument_list|)
return|;
block|}
block|}
specifier|private
name|VariableByteInput
name|getAsStream
parameter_list|(
name|DataPage
name|page
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
block|{
name|dataCache
operator|.
name|add
argument_list|(
name|page
operator|.
name|getFirstPage
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
specifier|final
name|short
name|tid
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"no data found at tid "
operator|+
name|tid
operator|+
literal|"; page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
throw|;
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|getData
argument_list|()
decl_stmt|;
specifier|final
name|int
name|l
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|SimplePageInput
name|input
init|=
operator|new
name|SimplePageInput
argument_list|(
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|l
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
return|return
name|input
return|;
block|}
comment|/**      * Returns the value located at the specified address.      *       * @param p      * @return value located at the specified address      */
specifier|public
name|Value
name|get
parameter_list|(
name|long
name|p
parameter_list|)
block|{
try|try
block|{
name|long
name|pnum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
return|return
name|get
argument_list|(
name|page
argument_list|,
name|p
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Retrieve value at logical address p from page      */
specifier|protected
name|Value
name|get
parameter_list|(
name|DataPage
name|page
parameter_list|,
name|long
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|short
name|tid
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|data
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"wrong pointer (tid: "
operator|+
name|tid
operator|+
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|") in file "
operator|+
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"; offset = "
operator|+
name|offset
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|l
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|+
literal|6
operator|>
name|data
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" wrong data length in page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": expected="
operator|+
operator|(
name|l
operator|+
literal|6
operator|)
operator|+
literal|"; found="
operator|+
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|dataCache
operator|.
name|add
argument_list|(
name|page
operator|.
name|getFirstPage
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|v
init|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|v
operator|.
name|setAddress
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
specifier|private
name|DataPage
name|getDataPage
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getDataPage
argument_list|(
name|pos
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
name|DataPage
name|getDataPage
parameter_list|(
name|long
name|pos
parameter_list|,
name|boolean
name|initialize
parameter_list|)
throws|throws
name|IOException
block|{
name|DataPage
name|wp
init|=
operator|(
name|DataPage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"page "
operator|+
name|pos
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|MULTI_PAGE
condition|)
return|return
operator|new
name|OverflowPage
argument_list|(
name|page
argument_list|,
name|data
argument_list|)
return|;
return|return
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
name|initialize
argument_list|)
return|;
block|}
if|else if
condition|(
name|wp
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|MULTI_PAGE
condition|)
return|return
operator|new
name|OverflowPage
argument_list|(
name|wp
argument_list|)
return|;
else|else
return|return
name|wp
return|;
block|}
specifier|private
name|SinglePage
name|getSinglePage
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
name|SinglePage
name|wp
init|=
operator|(
name|SinglePage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"page "
operator|+
name|pos
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
return|return
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
name|wp
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|getEntries
parameter_list|()
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|ANY
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|BOTH
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|getKeys
parameter_list|()
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|ANY
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|KEYS
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|getValues
parameter_list|()
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|ANY
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|VALUES
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|open
parameter_list|()
throws|throws
name|DBException
block|{
return|return
name|super
operator|.
name|open
argument_list|(
name|FILE_FORMAT_VERSION_ID
argument_list|)
return|;
block|}
comment|/**      * Put data under given key.      *       * @return on success the address of the stored value, else UNKNOWN_ADDRESS      * @see BFile#put(Value,byte[],boolean)      * @param key       * @param data the data (value) to update      * @param overwrite overwrite if set to true, value will be overwritten if it already exists      * @throws ReadOnlyException       */
specifier|public
name|long
name|put
parameter_list|(
name|Value
name|key
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
return|return
name|put
argument_list|(
literal|null
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|overwrite
argument_list|)
return|;
block|}
specifier|public
name|long
name|put
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|key
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
comment|/* throws ReadOnlyException */
block|{
name|SanityCheck
operator|.
name|THROW_ASSERT
argument_list|(
name|key
operator|.
name|getLength
argument_list|()
operator|<=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
argument_list|,
literal|"Key length exceeds page size!"
argument_list|)
expr_stmt|;
name|FixedByteArray
name|buf
init|=
operator|new
name|FixedByteArray
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
decl_stmt|;
return|return
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|buf
argument_list|,
name|overwrite
argument_list|)
return|;
block|}
comment|/**      * Convenience method for {@link BFile#put(Value, byte[], boolean)}, overwrite is true.      *       * @param key with which the data is updated      * @param value value to update      * @return on success the address of the stored value, else UNKNOWN_ADDRESS      * @throws ReadOnlyException      */
specifier|public
name|long
name|put
parameter_list|(
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
return|return
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Put a value under given key. The difference of this      * method and {@link BFile#append(Value, ByteArray)} is,      * that the value gets updated and not stored.      *       * @param key with which the data is updated      * @param value value to update      * @param overwrite if set to true, value will be overwritten if it already exists      * @return on success the address of the stored value, else UNKNOWN_ADDRESS      * @throws ReadOnlyException      */
specifier|public
name|long
name|put
parameter_list|(
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
return|return
name|put
argument_list|(
literal|null
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|overwrite
argument_list|)
return|;
block|}
specifier|public
name|long
name|put
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"key is null"
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
if|if
condition|(
name|key
operator|.
name|getLength
argument_list|()
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|//TODO : exception ? -pb
name|LOG
operator|.
name|warn
argument_list|(
literal|"Key length exceeds page size! Skipping key ..."
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
try|try
block|{
try|try
block|{
comment|// check if key exists already
comment|//TODO : rely on a KEY_NOT_FOUND (or maybe VALUE_NOT_FOUND) result ! -pb
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
comment|// key does not exist:
name|p
operator|=
name|storeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|addValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|// if exists, update value
if|if
condition|(
name|overwrite
condition|)
block|{
return|return
name|update
argument_list|(
name|transaction
argument_list|,
name|p
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|//TODO : throw an exception ? -pb
return|return
name|UNKNOWN_ADDRESS
return|;
comment|//TODO : why catch an exception here ??? It costs too much ! -pb
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
comment|// key does not exist:
name|long
name|p
init|=
name|storeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|addValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|bte
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|bte
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Value
name|key
parameter_list|)
block|{
name|remove
argument_list|(
literal|null
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|key
parameter_list|)
block|{
try|try
block|{
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return;
name|long
name|pos
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|remove
argument_list|(
name|transaction
argument_list|,
name|page
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|long
name|p
parameter_list|)
block|{
try|try
block|{
name|long
name|pos
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|DataPage
name|page
init|=
name|getDataPage
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|remove
argument_list|(
name|transaction
argument_list|,
name|page
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"io problem"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DataPage
name|page
parameter_list|,
name|long
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|MULTI_PAGE
condition|)
block|{
comment|// overflow page: simply delete the whole page
operator|(
operator|(
name|OverflowPage
operator|)
name|page
operator|)
operator|.
name|delete
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
return|return;
block|}
name|short
name|tid
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|data
operator|.
name|length
operator|||
name|offset
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"wrong pointer (tid: "
operator|+
name|tid
operator|+
literal|", "
operator|+
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|l
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|,
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|offset
operator|+
literal|4
operator|+
name|l
decl_stmt|;
name|int
name|len
init|=
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// remove old value
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|end
argument_list|,
name|data
argument_list|,
name|offset
operator|-
literal|2
argument_list|,
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ph
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|len
operator|=
name|len
operator|-
name|l
operator|-
literal|6
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// if this page is empty, remove it
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|RemoveEmptyPageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|fileHeader
operator|.
name|removeFreeSpace
argument_list|(
name|fileHeader
operator|.
name|getFreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|page
operator|.
name|removeTID
argument_list|(
name|tid
argument_list|,
name|l
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|// adjust free space data
specifier|final
name|int
name|newFree
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|newFree
operator|>
name|minFree
condition|)
block|{
name|FreeSpace
name|free
init|=
name|fileHeader
operator|.
name|getFreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|free
operator|==
literal|null
condition|)
block|{
name|free
operator|=
operator|new
name|FreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newFree
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|addFreeSpace
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
operator|.
name|setFree
argument_list|(
name|newFree
argument_list|)
expr_stmt|;
block|}
block|}
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|void
name|saveFreeSpace
parameter_list|(
name|FreeSpace
name|space
parameter_list|,
name|DataPage
name|page
parameter_list|)
block|{
name|int
name|free
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
name|space
operator|.
name|setFree
argument_list|(
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|<
name|minFree
condition|)
name|fileHeader
operator|.
name|removeFreeSpace
argument_list|(
name|space
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setLocation
parameter_list|(
name|String
name|location
parameter_list|)
throws|throws
name|DBException
block|{
name|setFile
argument_list|(
operator|new
name|File
argument_list|(
name|location
operator|+
literal|".dbx"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|storeValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|ByteArray
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|vlen
init|=
name|value
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// does value fit into a single page?
if|if
condition|(
literal|6
operator|+
name|vlen
operator|>
name|maxValueSize
condition|)
block|{
name|OverflowPage
name|page
init|=
operator|new
name|OverflowPage
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|vlen
operator|+
literal|6
index|]
decl_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|vlen
operator|+
literal|6
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|vlen
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|//System.arraycopy(value, 0, data, 6, vlen);
name|value
operator|.
name|copyTo
argument_list|(
name|data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|page
operator|.
name|setData
argument_list|(
name|transaction
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//dataCache.add(page);
return|return
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
return|;
block|}
name|DataPage
name|page
init|=
literal|null
decl_stmt|;
name|short
name|tid
init|=
operator|-
literal|1
decl_stmt|;
name|FreeSpace
name|free
init|=
literal|null
decl_stmt|;
name|int
name|realSpace
init|=
literal|0
decl_stmt|;
comment|// check for available tid
while|while
condition|(
name|tid
operator|<
literal|0
condition|)
block|{
name|free
operator|=
name|fileHeader
operator|.
name|findFreeSpace
argument_list|(
name|vlen
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|==
literal|null
condition|)
block|{
name|page
operator|=
name|createDataPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|page
operator|.
name|setData
argument_list|(
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|free
operator|=
operator|new
name|FreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|addFreeSpace
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|page
operator|=
name|getDataPage
argument_list|(
name|free
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if this is really a data page
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|!=
name|BFile
operator|.
name|RECORD
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" is not a data page; removing it"
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|removeFreeSpace
argument_list|(
name|free
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// check if the information about free space is really correct
name|realSpace
operator|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|realSpace
operator|<
literal|6
operator|+
name|vlen
condition|)
block|{
comment|// not correct: adjust and continue
name|LOG
operator|.
name|warn
argument_list|(
literal|"Wrong data length in list of free pages: adjusting to "
operator|+
name|realSpace
argument_list|)
expr_stmt|;
name|free
operator|.
name|setFree
argument_list|(
name|realSpace
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|tid
operator|=
name|page
operator|.
name|getNextTID
argument_list|()
expr_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"removing page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" from free pages"
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|removeFreeSpace
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|StoreValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|int
name|len
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|getData
argument_list|()
decl_stmt|;
comment|// save tid
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tid
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
name|page
operator|.
name|setOffset
argument_list|(
name|tid
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// save data length
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|vlen
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
comment|// save data
name|value
operator|.
name|copyTo
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|vlen
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|saveFreeSpace
argument_list|(
name|free
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
comment|// return pointer from pageNum and offset into page
return|return
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
return|;
block|}
comment|/**      * Update a key/value pair.      *       * @param key      *                   Description of the Parameter      * @param value      *                   Description of the Parameter      * @return Description of the Return Value      */
specifier|public
name|long
name|update
parameter_list|(
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
block|{
try|try
block|{
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
name|UNKNOWN_ADDRESS
return|;
return|return
name|update
argument_list|(
name|p
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
comment|/**      * Update the key/value pair found at the logical address p.      *       * @param p      *                   Description of the Parameter      * @param key      *                   Description of the Parameter      * @param value      *                   Description of the Parameter      * @return Description of the Return Value      */
specifier|public
name|long
name|update
parameter_list|(
name|long
name|p
parameter_list|,
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
block|{
return|return
name|update
argument_list|(
literal|null
argument_list|,
name|p
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|public
name|long
name|update
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|long
name|p
parameter_list|,
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
block|{
try|try
block|{
return|return
name|update
argument_list|(
name|transaction
argument_list|,
name|p
argument_list|,
name|getDataPage
argument_list|(
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_ADDRESS
return|;
block|}
block|}
comment|/**      * Update the key/value pair with logical address p and stored in page.      *       * @param p      *                   Description of the Parameter      * @param page      *                   Description of the Parameter      * @param key      *                   Description of the Parameter      * @param value      *                   Description of the Parameter      * @exception BTreeException      *                        Description of the Exception      * @exception IOException      *                        Description of the Exception      */
specifier|protected
name|long
name|update
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|long
name|p
parameter_list|,
name|DataPage
name|page
parameter_list|,
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
throws|throws
name|BTreeException
throws|,
name|IOException
block|{
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|MULTI_PAGE
condition|)
block|{
specifier|final
name|int
name|valueLen
init|=
name|value
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// does value fit into a single page?
if|if
condition|(
name|valueLen
operator|+
literal|6
operator|<
name|maxValueSize
condition|)
block|{
comment|// yes: remove the overflow page
name|remove
argument_list|(
name|transaction
argument_list|,
name|page
argument_list|,
name|p
argument_list|)
expr_stmt|;
specifier|final
name|long
name|np
init|=
name|storeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|addValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
name|np
return|;
block|}
comment|// this is an overflow page: simply replace the value
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|valueLen
operator|+
literal|6
index|]
decl_stmt|;
comment|// save tid
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// save length
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|valueLen
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// save data
name|value
operator|.
name|copyTo
argument_list|(
name|data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
operator|(
operator|(
name|OverflowPage
operator|)
name|page
operator|)
operator|.
name|setData
argument_list|(
name|transaction
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|remove
argument_list|(
name|transaction
argument_list|,
name|page
argument_list|,
name|p
argument_list|)
expr_stmt|;
specifier|final
name|long
name|np
init|=
name|storeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|addValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
name|np
return|;
block|}
specifier|public
name|void
name|debugFreeList
parameter_list|()
block|{
name|fileHeader
operator|.
name|debugFreeList
argument_list|()
expr_stmt|;
block|}
comment|/* ---------------------------------------------------------------------------------      * Methods used by recovery and transaction management      * --------------------------------------------------------------------------------- */
comment|/**      * Write loggable to the journal and update the LSN in the page header.      */
specifier|private
name|void
name|writeToLog
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|DataPage
name|page
parameter_list|)
block|{
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|SinglePage
name|getSinglePageForRedo
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
name|SinglePage
name|wp
init|=
operator|(
name|SinglePage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|pos
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|<
name|RECORD
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|loggable
operator|!=
literal|null
operator|&&
name|isUptodate
argument_list|(
name|page
argument_list|,
name|loggable
argument_list|)
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
return|;
block|}
return|return
name|wp
return|;
block|}
specifier|private
name|boolean
name|isUptodate
parameter_list|(
name|Page
name|page
parameter_list|,
name|Loggable
name|loggable
parameter_list|)
block|{
return|return
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|>=
name|loggable
operator|.
name|getLsn
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|requiresRedo
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|DataPage
name|page
parameter_list|)
block|{
return|return
name|loggable
operator|.
name|getLsn
argument_list|()
operator|>
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
return|;
block|}
specifier|protected
name|void
name|redoStoreValue
parameter_list|(
name|StoreValueLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePageForRedo
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|storeValueHelper
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|tid
argument_list|,
name|loggable
operator|.
name|value
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoStoreValue
parameter_list|(
name|StoreValueLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
name|removeValueHelper
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|tid
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoCreatePage
parameter_list|(
name|CreatePageLoggable
name|loggable
parameter_list|)
block|{
name|createPageHelper
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|newPage
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|undoCreatePage
parameter_list|(
name|CreatePageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|loggable
operator|.
name|newPage
argument_list|)
decl_stmt|;
name|fileHeader
operator|.
name|removeFreeSpace
argument_list|(
name|fileHeader
operator|.
name|getFreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoRemoveValue
parameter_list|(
name|RemoveValueLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|wp
init|=
operator|(
name|SinglePage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page "
operator|+
name|loggable
operator|.
name|page
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|<
name|RECORD
operator|||
name|isUptodate
argument_list|(
name|page
argument_list|,
name|loggable
argument_list|)
condition|)
block|{
comment|// page is obviously deleted later
return|return;
block|}
name|wp
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wp
operator|.
name|ph
operator|.
name|getLsn
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|wp
argument_list|)
condition|)
block|{
name|removeValueHelper
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|tid
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemoveValue
parameter_list|(
name|RemoveValueLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
name|FixedByteArray
name|data
init|=
operator|new
name|FixedByteArray
argument_list|(
name|loggable
operator|.
name|oldData
argument_list|)
decl_stmt|;
name|storeValueHelper
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|tid
argument_list|,
name|data
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoRemovePage
parameter_list|(
name|RemoveEmptyPageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|wp
init|=
operator|(
name|SinglePage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page "
operator|+
name|loggable
operator|.
name|page
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|<
name|RECORD
operator|||
name|isUptodate
argument_list|(
name|page
argument_list|,
name|loggable
argument_list|)
condition|)
block|{
return|return;
block|}
name|wp
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wp
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|==
name|Lsn
operator|.
name|LSN_INVALID
operator|||
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|wp
argument_list|)
condition|)
block|{
name|fileHeader
operator|.
name|removeFreeSpace
argument_list|(
name|fileHeader
operator|.
name|getFreeSpace
argument_list|(
name|wp
operator|.
name|getPageNum
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemovePage
parameter_list|(
name|RemoveEmptyPageLoggable
name|loggable
parameter_list|)
block|{
name|createPageHelper
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|redoCreateOverflow
parameter_list|(
name|OverflowCreateLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|DataPage
name|firstPage
init|=
operator|(
name|DataPage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstPage
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|==
name|Lsn
operator|.
name|LSN_INVALID
operator|||
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|reuseDeleted
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|BFilePageHeader
name|ph
init|=
operator|(
name|BFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setStatus
argument_list|(
name|MULTI_PAGE
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLastInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|nextTID
operator|=
literal|32
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|firstPage
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|firstPage
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|firstPage
argument_list|)
condition|)
block|{
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|dataCache
operator|.
name|add
argument_list|(
name|firstPage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoCreateOverflow
parameter_list|(
name|OverflowCreateLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoCreateOverflowPage
parameter_list|(
name|OverflowCreatePageLoggable
name|loggable
parameter_list|)
block|{
name|createPageHelper
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|newPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|prevPage
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePageForRedo
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|prevPage
argument_list|)
decl_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|page
operator|!=
literal|null
argument_list|,
literal|"Previous page is null"
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
name|loggable
operator|.
name|newPage
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|void
name|undoCreateOverflowPage
parameter_list|(
name|OverflowCreatePageLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|newPage
argument_list|)
decl_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|prevPage
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
try|try
block|{
name|page
operator|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|prevPage
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|page
operator|!=
literal|null
argument_list|,
literal|"Previous page is null"
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoAppendOverflow
parameter_list|(
name|OverflowAppendLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePageForRedo
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|loggable
operator|.
name|data
operator|.
name|copyTo
argument_list|(
literal|0
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
name|ph
operator|.
name|getDataLength
argument_list|()
argument_list|,
name|loggable
operator|.
name|chunkSize
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|ph
operator|.
name|getDataLength
argument_list|()
operator|+
name|loggable
operator|.
name|chunkSize
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoAppendOverflow
parameter_list|(
name|OverflowAppendLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|ph
operator|.
name|getDataLength
argument_list|()
operator|-
name|loggable
operator|.
name|chunkSize
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoStoreOverflow
parameter_list|(
name|OverflowStoreLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePageForRedo
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|loggable
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|loggable
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|loggable
operator|.
name|data
operator|.
name|length
operator|+
literal|"; "
operator|+
name|page
operator|.
name|getData
argument_list|()
operator|.
name|length
operator|+
literal|"; "
operator|+
name|ph
operator|.
name|getDataLength
argument_list|()
operator|+
literal|"; "
operator|+
name|loggable
operator|.
name|size
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|ph
operator|.
name|setDataLength
argument_list|(
name|loggable
operator|.
name|size
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextInChain
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|.
name|prevPage
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|page
operator|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|prevPage
argument_list|)
expr_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|page
operator|!=
literal|null
argument_list|,
literal|"Previous page is null"
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoModifiedOverflow
parameter_list|(
name|OverflowModifiedLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePageForRedo
argument_list|(
name|loggable
argument_list|,
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|loggable
operator|.
name|length
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLastInChain
argument_list|(
name|loggable
operator|.
name|lastInChain
argument_list|)
expr_stmt|;
comment|// adjust length field in first page
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|ph
operator|.
name|getDataLength
argument_list|()
operator|-
literal|6
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// keep the first page in cache
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoModifiedOverflow
parameter_list|(
name|OverflowModifiedLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|page
init|=
name|getSinglePage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|loggable
operator|.
name|oldLength
argument_list|)
expr_stmt|;
comment|// adjust length field in first page
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|ph
operator|.
name|getDataLength
argument_list|()
operator|-
literal|6
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during undo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoRemoveOverflow
parameter_list|(
name|OverflowRemoveLoggable
name|loggable
parameter_list|)
block|{
try|try
block|{
name|SinglePage
name|wp
init|=
operator|(
name|SinglePage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page "
operator|+
name|loggable
operator|.
name|pageNum
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|<
name|RECORD
operator|||
name|isUptodate
argument_list|(
name|page
argument_list|,
name|loggable
argument_list|)
condition|)
return|return;
name|wp
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|wp
argument_list|)
condition|)
block|{
name|wp
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemoveOverflow
parameter_list|(
name|OverflowRemoveLoggable
name|loggable
parameter_list|)
block|{
name|DataPage
name|page
init|=
name|createPageHelper
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|BFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setStatus
argument_list|(
name|loggable
operator|.
name|status
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|loggable
operator|.
name|length
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextInChain
argument_list|(
name|loggable
operator|.
name|nextInChain
argument_list|)
expr_stmt|;
name|page
operator|.
name|setData
argument_list|(
name|loggable
operator|.
name|data
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|storeValueHelper
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|short
name|tid
parameter_list|,
name|ByteArray
name|value
parameter_list|,
name|SinglePage
name|page
parameter_list|)
block|{
name|int
name|len
init|=
name|page
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// save tid
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tid
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
name|page
operator|.
name|adjustTID
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|page
operator|.
name|setOffset
argument_list|(
name|tid
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// save data length
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
comment|// save data
try|try
block|{
name|value
operator|.
name|copyTo
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": storage error in page: "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; len: "
operator|+
name|len
operator|+
literal|" ; value: "
operator|+
name|value
operator|.
name|size
argument_list|()
operator|+
literal|"; max: "
operator|+
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|+
literal|"; status: "
operator|+
name|page
operator|.
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|page
operator|.
name|printContents
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|len
operator|+=
name|value
operator|.
name|size
argument_list|()
expr_stmt|;
name|page
operator|.
name|ph
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|ph
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|loggable
operator|!=
literal|null
condition|)
name|page
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|FreeSpace
name|free
init|=
name|fileHeader
operator|.
name|getFreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|free
operator|==
literal|null
condition|)
name|free
operator|=
operator|new
name|FreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|len
argument_list|)
expr_stmt|;
name|saveFreeSpace
argument_list|(
name|free
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|removeValueHelper
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|short
name|tid
parameter_list|,
name|SinglePage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"TID: "
operator|+
name|tid
operator|+
literal|" not found on page: "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|l
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|offset
operator|+
literal|4
operator|+
name|l
decl_stmt|;
name|int
name|len
init|=
name|page
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// remove old value
name|System
operator|.
name|arraycopy
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|offset
operator|-
literal|2
argument_list|,
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|page
operator|.
name|ph
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|page
operator|.
name|ph
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
name|len
operator|=
name|len
operator|-
name|l
operator|-
literal|6
expr_stmt|;
name|page
operator|.
name|ph
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggable
operator|!=
literal|null
condition|)
name|page
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|page
operator|.
name|removeTID
argument_list|(
name|tid
argument_list|,
name|l
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|// adjust free space data
specifier|final
name|int
name|newFree
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|newFree
operator|>
name|minFree
condition|)
block|{
name|FreeSpace
name|free
init|=
name|fileHeader
operator|.
name|getFreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|free
operator|==
literal|null
condition|)
block|{
name|free
operator|=
operator|new
name|FreeSpace
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|newFree
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|addFreeSpace
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
operator|.
name|setFree
argument_list|(
name|newFree
argument_list|)
expr_stmt|;
block|}
block|}
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|DataPage
name|createPageHelper
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|long
name|newPage
parameter_list|)
block|{
try|try
block|{
name|DataPage
name|dp
init|=
operator|(
name|DataPage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|newPage
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|null
condition|)
block|{
specifier|final
name|Page
name|page
init|=
name|getPage
argument_list|(
name|newPage
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|==
name|Lsn
operator|.
name|LSN_INVALID
operator|||
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
condition|)
block|{
name|reuseDeleted
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|BFilePageHeader
name|ph
init|=
operator|(
name|BFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLen
argument_list|(
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|ph
operator|.
name|nextTID
operator|=
literal|32
expr_stmt|;
name|dp
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
operator|new
name|SinglePage
argument_list|(
name|page
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|//if ((dp.getPageHeader().getLsn() != Page.NO_PAGE&& requiresRedo(loggable, dp))&& loggable != null)
name|dp
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|dp
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An IOException occurred during redo: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * The file header. Most important, the file header stores the list of      * data pages containing unused space.      *       * @author wolf      */
specifier|private
specifier|final
class|class
name|BFileHeader
extends|extends
name|BTreeFileHeader
block|{
specifier|private
name|FreeList
name|freeList
init|=
operator|new
name|FreeList
argument_list|()
decl_stmt|;
comment|//public final static int MAX_FREE_LIST_LEN = 128;
specifier|public
name|BFileHeader
parameter_list|(
name|int
name|pageSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addFreeSpace
parameter_list|(
name|FreeSpace
name|freeSpace
parameter_list|)
block|{
name|freeList
operator|.
name|add
argument_list|(
name|freeSpace
argument_list|)
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|FreeSpace
name|findFreeSpace
parameter_list|(
name|int
name|needed
parameter_list|)
block|{
return|return
name|freeList
operator|.
name|find
argument_list|(
name|needed
argument_list|)
return|;
block|}
specifier|public
name|FreeSpace
name|getFreeSpace
parameter_list|(
name|long
name|page
parameter_list|)
block|{
return|return
name|freeList
operator|.
name|retrieve
argument_list|(
name|page
argument_list|)
return|;
block|}
specifier|public
name|void
name|removeFreeSpace
parameter_list|(
name|FreeSpace
name|space
parameter_list|)
block|{
if|if
condition|(
name|space
operator|==
literal|null
condition|)
return|return;
name|freeList
operator|.
name|remove
argument_list|(
name|space
argument_list|)
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|debugFreeList
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|freeList
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|super
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
return|return
name|freeList
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|super
operator|.
name|write
argument_list|(
name|buf
argument_list|)
decl_stmt|;
return|return
name|freeList
operator|.
name|write
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|BFilePageHeader
extends|extends
name|BTreePageHeader
block|{
specifier|private
name|int
name|dataLen
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|lastInChain
init|=
operator|-
literal|1L
decl_stmt|;
specifier|private
name|long
name|nextInChain
init|=
operator|-
literal|1L
decl_stmt|;
comment|// tuple identifier: used to identify distinct
comment|// values inside a page
specifier|private
name|short
name|nextTID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|short
name|records
init|=
literal|0
decl_stmt|;
specifier|public
name|BFilePageHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BFilePageHeader
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|decRecordCount
parameter_list|()
block|{
name|records
operator|--
expr_stmt|;
block|}
specifier|public
name|int
name|getDataLength
parameter_list|()
block|{
return|return
name|dataLen
return|;
block|}
specifier|public
name|long
name|getLastInChain
parameter_list|()
block|{
return|return
name|lastInChain
return|;
block|}
specifier|public
name|long
name|getNextInChain
parameter_list|()
block|{
return|return
name|nextInChain
return|;
block|}
specifier|public
name|short
name|getNextTID
parameter_list|()
block|{
if|if
condition|(
name|nextTID
operator|==
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"tid limit reached"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|++
name|nextTID
return|;
block|}
specifier|public
name|short
name|getCurrentTID
parameter_list|()
block|{
if|if
condition|(
name|nextTID
operator|==
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|nextTID
return|;
block|}
specifier|public
name|short
name|getRecordCount
parameter_list|()
block|{
return|return
name|records
return|;
block|}
specifier|public
name|void
name|incRecordCount
parameter_list|()
block|{
name|records
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|records
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_RECORDS_COUNT
expr_stmt|;
name|dataLen
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|nextTID
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_NEXT_TID
expr_stmt|;
name|nextInChain
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|lastInChain
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|8
return|;
block|}
specifier|public
name|void
name|setDataLength
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|dataLen
operator|=
name|len
expr_stmt|;
block|}
specifier|public
name|void
name|setLastInChain
parameter_list|(
name|long
name|p
parameter_list|)
block|{
name|lastInChain
operator|=
name|p
expr_stmt|;
block|}
specifier|public
name|void
name|setNextInChain
parameter_list|(
name|long
name|b
parameter_list|)
block|{
name|nextInChain
operator|=
name|b
expr_stmt|;
block|}
specifier|public
name|void
name|setRecordCount
parameter_list|(
name|short
name|recs
parameter_list|)
block|{
name|records
operator|=
name|recs
expr_stmt|;
block|}
specifier|public
name|void
name|setTID
parameter_list|(
name|short
name|tid
parameter_list|)
block|{
name|this
operator|.
name|nextTID
operator|=
name|tid
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|records
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_RECORDS_COUNT
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|dataLen
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|nextTID
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|LENGTH_NEXT_TID
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|nextInChain
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|lastInChain
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|8
return|;
block|}
block|}
specifier|private
specifier|abstract
class|class
name|DataPage
implements|implements
name|Comparable
implements|,
name|Cacheable
block|{
name|int
name|refCount
init|=
literal|0
decl_stmt|;
name|int
name|timestamp
init|=
literal|0
decl_stmt|;
name|boolean
name|saved
init|=
literal|true
decl_stmt|;
specifier|public
specifier|abstract
name|void
name|delete
parameter_list|()
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|byte
index|[]
name|getData
parameter_list|()
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|BFilePageHeader
name|getPageHeader
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|String
name|getPageInfo
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|long
name|getPageNum
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|int
name|findValuePosition
parameter_list|(
name|short
name|tid
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|short
name|getNextTID
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|void
name|removeTID
parameter_list|(
name|short
name|tid
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
specifier|abstract
name|void
name|setOffset
parameter_list|(
name|short
name|tid
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
specifier|public
name|long
name|getKey
parameter_list|()
block|{
return|return
name|getPageNum
argument_list|()
return|;
block|}
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
specifier|public
name|int
name|incReferenceCount
parameter_list|()
block|{
if|if
condition|(
name|refCount
operator|<
name|Cacheable
operator|.
name|MAX_REF
condition|)
operator|++
name|refCount
expr_stmt|;
return|return
name|refCount
return|;
block|}
specifier|public
name|int
name|decReferenceCount
parameter_list|()
block|{
return|return
name|refCount
operator|>
literal|0
condition|?
operator|--
name|refCount
else|:
literal|0
return|;
block|}
specifier|public
name|void
name|setReferenceCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|refCount
operator|=
name|count
expr_stmt|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#setTimestamp(int)          */
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|int
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#getTimestamp()          */
specifier|public
name|int
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#release()          */
specifier|public
name|boolean
name|sync
parameter_list|(
name|boolean
name|syncJournal
parameter_list|)
block|{
if|if
condition|(
name|isDirty
argument_list|()
condition|)
block|{
try|try
block|{
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|syncJournal
operator|&&
name|logManager
operator|.
name|lastWrittenLsn
argument_list|()
operator|<
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
condition|)
name|logManager
operator|.
name|flushToLog
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IO exception occurred while saving page "
operator|+
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
operator|!
name|saved
return|;
block|}
specifier|public
name|boolean
name|allowUnload
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
specifier|abstract
name|void
name|setData
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|SinglePage
name|getFirstPage
parameter_list|()
function_decl|;
specifier|public
name|void
name|setDirty
parameter_list|(
name|boolean
name|dirty
parameter_list|)
block|{
name|saved
operator|=
operator|!
name|dirty
expr_stmt|;
name|getPageHeader
argument_list|()
operator|.
name|setDirty
argument_list|(
name|dirty
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|void
name|write
parameter_list|()
throws|throws
name|IOException
function_decl|;
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|getPageNum
argument_list|()
operator|==
operator|(
operator|(
name|DataPage
operator|)
name|other
operator|)
operator|.
name|getPageNum
argument_list|()
condition|)
return|return
name|Constants
operator|.
name|EQUAL
return|;
if|else if
condition|(
name|getPageNum
argument_list|()
operator|>
operator|(
operator|(
name|DataPage
operator|)
name|other
operator|)
operator|.
name|getPageNum
argument_list|()
condition|)
return|return
name|Constants
operator|.
name|SUPERIOR
return|;
else|else
return|return
name|Constants
operator|.
name|INFERIOR
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|FilterCallback
implements|implements
name|BTreeCallback
block|{
name|BFileCallback
name|callback
decl_stmt|;
specifier|public
name|FilterCallback
parameter_list|(
name|BFileCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
try|try
block|{
name|long
name|pos
decl_stmt|;
name|short
name|tid
decl_stmt|;
name|DataPage
name|page
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|l
decl_stmt|;
name|Value
name|v
decl_stmt|;
name|pos
operator|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|tid
operator|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|page
operator|=
name|getDataPage
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|offset
operator|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|getData
argument_list|()
decl_stmt|;
name|l
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|v
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|callback
operator|.
name|info
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
specifier|private
specifier|final
class|class
name|FindCallback
implements|implements
name|BTreeCallback
block|{
specifier|public
specifier|final
specifier|static
name|int
name|BOTH
init|=
literal|2
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|KEYS
init|=
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|VALUES
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|mode
init|=
name|VALUES
decl_stmt|;
specifier|private
name|IndexCallback
name|callback
init|=
literal|null
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|values
init|=
literal|null
decl_stmt|;
specifier|public
name|FindCallback
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|values
operator|=
operator|new
name|ArrayList
argument_list|<
name|Value
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
name|FindCallback
parameter_list|(
name|IndexCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|BOTH
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|Value
argument_list|>
name|getValues
parameter_list|()
block|{
return|return
name|values
return|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|long
name|pos
decl_stmt|;
name|short
name|tid
decl_stmt|;
name|DataPage
name|page
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|l
decl_stmt|;
name|Value
name|v
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
try|try
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VALUES
case|:
name|pos
operator|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|tid
operator|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|page
operator|=
name|getDataPage
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
operator|.
name|getFirstPage
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|data
operator|=
name|page
operator|.
name|getData
argument_list|()
expr_stmt|;
name|l
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|v
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|v
operator|.
name|setAddress
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback
operator|==
literal|null
condition|)
name|values
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
else|else
return|return
name|callback
operator|.
name|indexInfo
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
return|;
return|return
literal|true
return|;
case|case
name|KEYS
case|:
name|value
operator|.
name|setAddress
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback
operator|==
literal|null
condition|)
name|values
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
return|return
name|callback
operator|.
name|indexInfo
argument_list|(
name|value
argument_list|,
literal|null
argument_list|)
return|;
return|return
literal|true
return|;
case|case
name|BOTH
case|:
name|Value
index|[]
name|entry
init|=
operator|new
name|Value
index|[
literal|2
index|]
decl_stmt|;
name|entry
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
name|pos
operator|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|tid
operator|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|page
operator|=
name|getDataPage
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|MULTI_PAGE
condition|)
block|{
name|data
operator|=
name|page
operator|.
name|getData
argument_list|()
expr_stmt|;
block|}
name|dataCache
operator|.
name|add
argument_list|(
name|page
operator|.
name|getFirstPage
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|=
name|page
operator|.
name|findValuePosition
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|data
operator|=
name|page
operator|.
name|getData
argument_list|()
expr_stmt|;
name|l
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|v
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|v
operator|.
name|setAddress
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|entry
index|[
literal|1
index|]
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|callback
operator|==
literal|null
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|entry
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|entry
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|callback
operator|.
name|indexInfo
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
return|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|OverflowPage
extends|extends
name|DataPage
block|{
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
name|SinglePage
name|firstPage
decl_stmt|;
specifier|public
name|OverflowPage
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
block|{
name|firstPage
operator|=
operator|new
name|SinglePage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|OverflowCreateLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|firstPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|firstPage
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BFilePageHeader
name|ph
init|=
name|firstPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setStatus
argument_list|(
name|MULTI_PAGE
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLastInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|setData
argument_list|(
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|firstPage
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
specifier|public
name|OverflowPage
parameter_list|(
name|DataPage
name|page
parameter_list|)
block|{
name|firstPage
operator|=
operator|(
name|SinglePage
operator|)
name|page
expr_stmt|;
block|}
specifier|public
name|OverflowPage
parameter_list|(
name|Page
name|p
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|firstPage
operator|=
operator|new
name|SinglePage
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setStatus
argument_list|(
name|MULTI_PAGE
argument_list|)
expr_stmt|;
block|}
comment|/**          * Append a new chunk of data to the page          *           * @param chunk          *                   chunk of data to append          */
specifier|public
name|void
name|append
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|ByteArray
name|chunk
parameter_list|)
throws|throws
name|IOException
block|{
name|SinglePage
name|nextPage
decl_stmt|;
name|BFilePageHeader
name|ph
init|=
name|firstPage
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|int
name|newLen
init|=
name|ph
operator|.
name|getDataLength
argument_list|()
operator|+
name|chunk
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// get the last page and fill it
name|long
name|next
init|=
name|ph
operator|.
name|getLastInChain
argument_list|()
decl_stmt|;
name|DataPage
name|page
decl_stmt|;
if|if
condition|(
name|next
operator|>
literal|0
condition|)
name|page
operator|=
name|getDataPage
argument_list|(
name|next
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|page
operator|=
name|firstPage
expr_stmt|;
name|ph
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
name|int
name|chunkSize
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
operator|-
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
specifier|final
name|int
name|chunkLen
init|=
name|chunk
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|chunkLen
operator|<
name|chunkSize
condition|)
name|chunkSize
operator|=
name|chunkLen
expr_stmt|;
comment|// fill last page
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|OverflowAppendLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|chunk
argument_list|,
literal|0
argument_list|,
name|chunkSize
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|chunk
operator|.
name|copyTo
argument_list|(
literal|0
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
name|ph
operator|.
name|getDataLength
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|firstPage
condition|)
name|ph
operator|.
name|setDataLength
argument_list|(
name|ph
operator|.
name|getDataLength
argument_list|()
operator|+
name|chunkSize
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// write the remaining chunks to new pages
name|int
name|remaining
init|=
name|chunkLen
operator|-
name|chunkSize
decl_stmt|;
name|int
name|current
init|=
name|chunkSize
decl_stmt|;
name|chunkSize
operator|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
comment|// walk through chain of pages
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|remaining
operator|<
name|chunkSize
condition|)
name|chunkSize
operator|=
name|remaining
expr_stmt|;
comment|// add a new page to the chain
name|nextPage
operator|=
name|createDataPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|OverflowCreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextPage
argument_list|)
expr_stmt|;
name|loggable
operator|=
operator|new
name|OverflowAppendLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|chunk
argument_list|,
name|current
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|nextPage
operator|.
name|setData
argument_list|(
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|=
name|nextPage
expr_stmt|;
comment|// copy next chunk of data to the page
name|chunk
operator|.
name|copyTo
argument_list|(
name|current
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|firstPage
condition|)
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|chunkSize
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|remaining
operator|-
name|chunkSize
expr_stmt|;
name|current
operator|+=
name|chunkSize
expr_stmt|;
block|}
block|}
name|ph
operator|=
name|firstPage
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|OverflowModifiedLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|firstPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|ph
operator|.
name|getDataLength
argument_list|()
operator|+
name|chunkLen
argument_list|,
name|ph
operator|.
name|getDataLength
argument_list|()
argument_list|,
name|page
operator|==
name|firstPage
condition|?
literal|0
else|:
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|!=
name|firstPage
condition|)
block|{
comment|// add link to last page
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLastInChain
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|ph
operator|.
name|setLastInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
comment|// adjust length field in first page
name|ph
operator|.
name|setDataLength
argument_list|(
name|newLen
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
operator|-
literal|6
argument_list|,
name|firstPage
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// keep the first page in cache
name|dataCache
operator|.
name|add
argument_list|(
name|firstPage
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|()
throws|throws
name|IOException
block|{
name|delete
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|delete
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|next
init|=
name|firstPage
operator|.
name|getPageNum
argument_list|()
decl_stmt|;
name|SinglePage
name|page
init|=
name|firstPage
decl_stmt|;
do|do
block|{
name|next
operator|=
name|page
operator|.
name|ph
operator|.
name|getNextInChain
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|int
name|dataLen
init|=
name|page
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataLen
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
name|dataLen
operator|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
expr_stmt|;
name|Loggable
name|loggable
init|=
operator|new
name|OverflowRemoveLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|page
operator|.
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
name|dataLen
argument_list|,
name|page
operator|.
name|ph
operator|.
name|getNextInChain
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
operator|>
literal|0
condition|)
name|page
operator|=
name|getSinglePage
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|>
literal|0
condition|)
do|;
block|}
specifier|public
name|VariableByteInput
name|getDataStream
parameter_list|(
name|long
name|pointer
parameter_list|)
block|{
name|MultiPageInput
name|input
init|=
operator|new
name|MultiPageInput
argument_list|(
name|firstPage
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
return|return
name|input
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
return|return
name|data
return|;
name|SinglePage
name|page
init|=
name|firstPage
decl_stmt|;
name|long
name|next
decl_stmt|;
name|byte
index|[]
name|temp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
argument_list|)
decl_stmt|;
do|do
block|{
name|temp
operator|=
name|page
operator|.
name|getData
argument_list|()
expr_stmt|;
name|next
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
expr_stmt|;
name|len
operator|=
name|next
operator|>
literal|0
condition|?
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
else|:
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>
literal|0
condition|)
block|{
name|page
operator|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|next
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next
operator|>
literal|0
condition|)
do|;
name|data
operator|=
name|os
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|!=
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" read="
operator|+
name|data
operator|.
name|length
operator|+
literal|"; expected="
operator|+
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
annotation|@
name|Override
specifier|public
name|SinglePage
name|getFirstPage
parameter_list|()
block|{
return|return
name|firstPage
return|;
block|}
annotation|@
name|Override
specifier|public
name|BFilePageHeader
name|getPageHeader
parameter_list|()
block|{
return|return
name|firstPage
operator|.
name|getPageHeader
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getPageInfo
parameter_list|()
block|{
return|return
literal|"MULTI_PAGE: "
operator|+
name|firstPage
operator|.
name|getPageInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|firstPage
operator|.
name|getPageNum
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setData
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
name|setData
argument_list|(
literal|null
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setData
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
try|try
block|{
name|write
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|()
throws|throws
name|IOException
block|{
name|write
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return;
name|int
name|chunkSize
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
decl_stmt|;
name|int
name|remaining
init|=
name|data
operator|.
name|length
decl_stmt|;
name|int
name|current
init|=
literal|0
decl_stmt|;
name|long
name|next
init|=
literal|0L
decl_stmt|;
name|SinglePage
name|page
init|=
name|firstPage
decl_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|remaining
argument_list|)
expr_stmt|;
name|SinglePage
name|nextPage
decl_stmt|;
name|long
name|prevPageNum
init|=
name|Page
operator|.
name|NO_PAGE
decl_stmt|;
comment|// walk through chain of pages
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|remaining
operator|<
name|chunkSize
condition|)
name|chunkSize
operator|=
name|remaining
expr_stmt|;
name|page
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// copy next chunk of data to the page
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|OverflowStoreLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|prevPageNum
argument_list|,
name|data
argument_list|,
name|current
argument_list|,
name|chunkSize
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|current
argument_list|,
name|page
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|firstPage
condition|)
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|chunkSize
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|chunkSize
expr_stmt|;
name|current
operator|+=
name|chunkSize
expr_stmt|;
name|next
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|>
literal|0
condition|)
block|{
comment|// load next page in chain
name|nextPage
operator|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|next
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|prevPageNum
operator|=
name|page
operator|.
name|getPageNum
argument_list|()
expr_stmt|;
name|page
operator|=
name|nextPage
expr_stmt|;
block|}
else|else
block|{
comment|// add a new page to the chain
name|nextPage
operator|=
name|createDataPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|nextPage
operator|.
name|setData
argument_list|(
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|prevPageNum
operator|=
name|page
operator|.
name|getPageNum
argument_list|()
expr_stmt|;
name|page
operator|=
name|nextPage
expr_stmt|;
block|}
block|}
else|else
block|{
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|firstPage
condition|)
block|{
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLastInChain
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLastInChain
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|firstPage
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next
operator|>
literal|0
condition|)
block|{
comment|// there are more pages in the chain:
comment|// remove them
while|while
condition|(
name|next
operator|>
literal|0
condition|)
block|{
name|nextPage
operator|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|next
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|next
operator|=
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|OverflowRemoveLoggable
argument_list|(
name|fileId
argument_list|,
name|transaction
argument_list|,
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getData
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
argument_list|,
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|nextPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|delete
argument_list|()
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
block|}
name|firstPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|firstPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|firstPage
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|//            LOG.debug(firstPage.getPageNum() + " data length: " + firstPage.ph.getDataLength());
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.store.BFile.DataPage#findValuePosition(short)          */
annotation|@
name|Override
specifier|public
name|int
name|findValuePosition
parameter_list|(
name|short
name|tid
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|2
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.store.BFile.DataPage#getNextTID()          */
annotation|@
name|Override
specifier|public
name|short
name|getNextTID
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.store.BFile.DataPage#removeTID(short)          */
annotation|@
name|Override
specifier|public
name|void
name|removeTID
parameter_list|(
name|short
name|tid
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|//
block|}
comment|/* (non-Javadoc)          * @see org.exist.storage.store.BFile.DataPage#setOffset(short, int)          */
annotation|@
name|Override
specifier|public
name|void
name|setOffset
parameter_list|(
name|short
name|tid
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|//
block|}
block|}
specifier|public
interface|interface
name|PageInputStream
block|{
specifier|public
name|long
name|getAddress
parameter_list|()
function_decl|;
specifier|public
name|long
name|position
parameter_list|()
function_decl|;
specifier|public
name|void
name|seek
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**      * Variable byte input stream to read data from a single page.      *       * @author wolf      */
specifier|private
specifier|final
class|class
name|SimplePageInput
extends|extends
name|VariableByteArrayInput
implements|implements
name|PageInputStream
block|{
specifier|private
name|long
name|address
init|=
literal|0L
decl_stmt|;
specifier|public
name|SimplePageInput
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|,
name|long
name|address
parameter_list|)
block|{
name|super
argument_list|(
name|data
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|this
operator|.
name|address
operator|=
name|address
expr_stmt|;
block|}
specifier|public
name|long
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
specifier|public
name|long
name|position
parameter_list|()
block|{
return|return
name|position
return|;
block|}
specifier|public
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|position
operator|=
operator|(
name|int
operator|)
name|pos
expr_stmt|;
block|}
block|}
comment|/**      * Variable byte input stream to read a multi-page sequences.      *       * @author wolf      */
specifier|private
specifier|final
class|class
name|MultiPageInput
implements|implements
name|VariableByteInput
implements|,
name|PageInputStream
block|{
specifier|private
name|SinglePage
name|nextPage
decl_stmt|;
specifier|private
name|int
name|pageLen
decl_stmt|;
specifier|private
name|short
name|offset
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|address
init|=
literal|0L
decl_stmt|;
specifier|public
name|MultiPageInput
parameter_list|(
name|SinglePage
name|first
parameter_list|,
name|long
name|address
parameter_list|)
block|{
name|nextPage
operator|=
name|first
expr_stmt|;
name|offset
operator|=
literal|6
expr_stmt|;
name|pageLen
operator|=
name|first
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|pageLen
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
name|pageLen
operator|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|first
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|this
operator|.
name|address
operator|=
name|address
expr_stmt|;
block|}
specifier|public
name|long
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see java.io.InputStream#read()          */
specifier|public
specifier|final
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xFF
operator|)
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.util.VariableInputStream#readByte()          */
specifier|public
specifier|final
name|byte
name|readByte
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|)
return|;
block|}
specifier|public
specifier|final
name|short
name|readShort
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|byte
name|b
init|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
name|short
name|i
init|=
operator|(
name|short
operator|)
operator|(
name|b
operator|&
literal|0177
operator|)
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|7
init|;
operator|(
name|b
operator|&
literal|0200
operator|)
operator|!=
literal|0
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|b
operator|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|i
operator||=
operator|(
name|b
operator|&
literal|0177
operator|)
operator|<<
name|shift
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
specifier|public
specifier|final
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|byte
name|b
init|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
name|int
name|i
init|=
name|b
operator|&
literal|0177
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|7
init|;
operator|(
name|b
operator|&
literal|0200
operator|)
operator|!=
literal|0
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|b
operator|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|i
operator||=
operator|(
name|b
operator|&
literal|0177
operator|)
operator|<<
name|shift
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
specifier|public
name|int
name|readFixedInt
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
comment|// do we have to read across a page boundary?
if|if
condition|(
name|offset
operator|+
literal|4
operator|<
name|pageLen
condition|)
block|{
return|return
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
return|;
block|}
name|int
name|r
init|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|shift
init|=
literal|8
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|r
operator||=
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0xff
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
specifier|public
specifier|final
name|long
name|readLong
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|byte
name|b
init|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
decl_stmt|;
name|long
name|i
init|=
name|b
operator|&
literal|0177
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|7
init|;
operator|(
name|b
operator|&
literal|0200
operator|)
operator|!=
literal|0
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|b
operator|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|i
operator||=
operator|(
name|b
operator|&
literal|0177L
operator|)
operator|<<
name|shift
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
specifier|public
specifier|final
name|void
name|skip
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
operator|&
literal|0200
operator|)
operator|>
literal|0
condition|)
do|;
block|}
block|}
specifier|public
specifier|final
name|void
name|skipBytes
parameter_list|(
name|long
name|count
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|void
name|advance
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|next
init|=
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|<
literal|1
condition|)
block|{
name|pageLen
operator|=
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|nextPage
operator|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|next
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pageLen
operator|=
name|nextPage
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to acquire a read lock on "
operator|+
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * (non-Javadoc)          *           * @see java.io.InputStream#available()          */
specifier|public
specifier|final
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pageLen
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|int
name|inPage
init|=
name|pageLen
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|inPage
operator|==
literal|0
condition|)
name|inPage
operator|=
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|inPage
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.io.VariableByteInput#read(byte[])          */
specifier|public
specifier|final
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|read
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see java.io.InputStream#read(byte[], int, int)          */
specifier|public
specifier|final
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pageLen
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
block|{
specifier|final
name|long
name|next
init|=
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextInChain
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|<
literal|1
condition|)
block|{
name|pageLen
operator|=
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
name|nextPage
operator|=
operator|(
name|SinglePage
operator|)
name|getDataPage
argument_list|(
name|next
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pageLen
operator|=
name|nextPage
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
name|b
index|[
name|off
operator|+
name|i
index|]
operator|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.io.VariableByteInput#readUTF()          */
specifier|public
specifier|final
name|String
name|readUTF
parameter_list|()
throws|throws
name|IOException
throws|,
name|EOFException
block|{
name|int
name|len
init|=
name|readInt
argument_list|()
decl_stmt|;
name|byte
name|data
index|[]
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|read
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|String
name|s
decl_stmt|;
try|try
block|{
name|s
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|s
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.io.VariableByteInput#copyTo(org.exist.storage.io.VariableByteOutputStream)          */
specifier|public
specifier|final
name|void
name|copyTo
parameter_list|(
name|VariableByteOutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
name|more
decl_stmt|;
do|do
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|more
operator|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|more
argument_list|)
expr_stmt|;
name|more
operator|&=
literal|0200
expr_stmt|;
block|}
do|while
condition|(
name|more
operator|>
literal|0
condition|)
do|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.io.VariableByteInput#copyTo(org.exist.storage.io.VariableByteOutputStream,          *           int)          */
specifier|public
specifier|final
name|void
name|copyTo
parameter_list|(
name|VariableByteOutputStream
name|os
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
name|more
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|more
operator|=
name|nextPage
operator|.
name|data
index|[
name|offset
operator|++
index|]
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|more
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|more
operator|&
literal|0x200
operator|)
operator|>
literal|0
condition|)
do|;
block|}
block|}
specifier|public
name|void
name|copyRaw
parameter_list|(
name|VariableByteOutputStream
name|os
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|count
init|;
name|i
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|pageLen
condition|)
name|advance
argument_list|()
expr_stmt|;
name|int
name|avail
init|=
name|pageLen
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|avail
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|nextPage
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|i
operator|-=
name|avail
expr_stmt|;
name|offset
operator|=
operator|(
name|short
operator|)
name|pageLen
expr_stmt|;
block|}
else|else
block|{
name|os
operator|.
name|write
argument_list|(
name|nextPage
operator|.
name|data
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|i
expr_stmt|;
break|break;
block|}
comment|//os.writeByte(nextPage.data[offset++]);
block|}
block|}
specifier|public
name|long
name|position
parameter_list|()
block|{
return|return
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|nextPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|offset
argument_list|)
return|;
block|}
specifier|public
name|void
name|seek
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|newPage
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|short
name|newOffset
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|position
argument_list|)
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|nextPage
operator|=
name|getSinglePage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|pageLen
operator|=
name|nextPage
operator|.
name|ph
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|pageLen
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
name|pageLen
operator|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
expr_stmt|;
name|offset
operator|=
name|newOffset
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to acquire a read lock on "
operator|+
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Represents a single data page (as opposed to a overflow page).      *       * @author Wolfgang Meier<wolfgang@exist-db.org>      */
specifier|private
specifier|final
class|class
name|SinglePage
extends|extends
name|DataPage
block|{
comment|// the raw working data of this page (without page header)
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
comment|// the low-level page
name|Page
name|page
decl_stmt|;
comment|// the page header
name|BFilePageHeader
name|ph
decl_stmt|;
comment|// table mapping record ids (tids) to offsets
name|short
index|[]
name|offsets
init|=
literal|null
decl_stmt|;
specifier|public
name|SinglePage
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SinglePage
parameter_list|(
name|boolean
name|compress
parameter_list|)
throws|throws
name|IOException
block|{
name|page
operator|=
name|getFreePage
argument_list|()
expr_stmt|;
name|ph
operator|=
operator|(
name|BFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
name|ph
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|//ph.setNextChunk( -1 );
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|offsets
operator|=
operator|new
name|short
index|[
literal|32
index|]
expr_stmt|;
name|ph
operator|.
name|nextTID
operator|=
literal|32
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|offsets
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SinglePage
parameter_list|(
name|Page
name|p
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|boolean
name|initialize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"illegal page"
argument_list|)
throw|;
if|if
condition|(
operator|!
operator|(
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|RECORD
operator|||
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|MULTI_PAGE
operator|)
condition|)
block|{
name|IOException
name|e
init|=
operator|new
name|IOException
argument_list|(
literal|"not a data-page: "
operator|+
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"not a data-page: "
operator|+
name|p
operator|.
name|getPageInfo
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|page
operator|=
name|p
expr_stmt|;
name|ph
operator|=
operator|(
name|BFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|initialize
condition|)
block|{
name|offsets
operator|=
operator|new
name|short
index|[
name|ph
operator|.
name|nextTID
index|]
expr_stmt|;
name|readOffsets
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|findValuePosition
parameter_list|(
name|short
name|tid
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|offsets
index|[
name|tid
index|]
return|;
block|}
specifier|private
name|void
name|readOffsets
parameter_list|()
block|{
comment|//if(offsets.length> 256)
comment|//LOG.warn("TID size: " + ph.nextTID);
name|Arrays
operator|.
name|fill
argument_list|(
name|offsets
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|int
name|dlen
init|=
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
for|for
control|(
name|short
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dlen
condition|;
control|)
block|{
name|short
name|tid
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid tid found: "
operator|+
name|tid
operator|+
literal|"; ignoring rest of page ..."
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tid
operator|>=
name|offsets
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Problematic tid found: "
operator|+
name|tid
operator|+
literal|"; trying to recover ..."
argument_list|)
expr_stmt|;
name|short
index|[]
name|t
init|=
operator|new
name|short
index|[
name|tid
operator|+
literal|1
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|offsets
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|offsets
operator|.
name|length
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|t
expr_stmt|;
name|ph
operator|.
name|nextTID
operator|=
operator|(
name|short
operator|)
operator|(
name|tid
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|offsets
index|[
name|tid
index|]
operator|=
operator|(
name|short
operator|)
operator|(
name|pos
operator|+
literal|2
operator|)
expr_stmt|;
name|pos
operator|+=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
operator|+
literal|6
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|short
name|getNextTID
parameter_list|()
block|{
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offsets
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
name|short
name|tid
init|=
operator|(
name|short
operator|)
name|offsets
operator|.
name|length
decl_stmt|;
name|short
name|next
init|=
operator|(
name|short
operator|)
operator|(
name|ph
operator|.
name|nextTID
operator|*
literal|2
operator|)
decl_stmt|;
if|if
condition|(
name|next
operator|<
literal|0
operator|||
name|next
operator|<
name|ph
operator|.
name|nextTID
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|short
index|[]
name|t
init|=
operator|new
name|short
index|[
name|next
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|offsets
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|offsets
operator|.
name|length
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|t
expr_stmt|;
name|ph
operator|.
name|nextTID
operator|=
name|next
expr_stmt|;
return|return
name|tid
return|;
block|}
specifier|public
name|void
name|adjustTID
parameter_list|(
name|short
name|tid
parameter_list|)
block|{
if|if
condition|(
name|tid
operator|>=
name|ph
operator|.
name|nextTID
condition|)
block|{
name|short
name|next
init|=
operator|(
name|short
operator|)
operator|(
name|tid
operator|*
literal|2
operator|)
decl_stmt|;
name|short
index|[]
name|t
init|=
operator|new
name|short
index|[
name|next
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|offsets
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|offsets
operator|.
name|length
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|t
expr_stmt|;
name|ph
operator|.
name|nextTID
operator|=
name|next
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|data
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|printContents
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offsets
index|[
name|i
index|]
operator|>
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|short
name|len
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|len
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setOffset
parameter_list|(
name|short
name|tid
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|offsets
index|[
name|tid
index|]
operator|=
operator|(
name|short
operator|)
name|offset
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeTID
parameter_list|(
name|short
name|tid
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|offsets
index|[
name|tid
index|]
operator|-
literal|2
decl_stmt|;
name|offsets
index|[
name|tid
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offsets
index|[
name|i
index|]
operator|>
name|offset
condition|)
name|offsets
index|[
name|i
index|]
operator|-=
name|length
expr_stmt|;
block|}
comment|//readOffsets(start);
block|}
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|()
throws|throws
name|IOException
block|{
comment|// reset page header fields
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextInChain
argument_list|(
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setLastInChain
argument_list|(
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setTID
argument_list|(
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|setReferenceCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SinglePage
name|getFirstPage
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
annotation|@
name|Override
specifier|public
name|BFilePageHeader
name|getPageHeader
parameter_list|()
block|{
return|return
name|ph
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getPageInfo
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setData
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
name|data
operator|=
name|buf
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|()
throws|throws
name|IOException
block|{
comment|//LOG.debug(getFile().getName() + " writing page " + getPageNum());
name|writeValue
argument_list|(
name|page
argument_list|,
operator|new
name|Value
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

