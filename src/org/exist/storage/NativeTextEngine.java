begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-04 Wolfgang M. Meier  *  wolfgang@exist-db.org  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *   *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ElementImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ExtArrayNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|Match
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|TextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|analysis
operator|.
name|TextToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteArrayInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Occurrences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ProgressIndicator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|UTF8
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|XMLString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XQueryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|/**  * This class is responsible for fulltext-indexing. Text-nodes are handed over  * to this class to be fulltext-indexed. Method storeText() is called by  * RelationalBroker whenever it finds a TextNode. Method getNodeIDsContaining()  * is used by the XPath-engine to process queries where a fulltext-operator is  * involved. The class keeps two database tables: table words stores the words  * found with their unique id. Table inv_idx contains the word occurrences for  * every word-id per document.  *   * TODO: store node type (attribute or text) with each entry  *   * @author Wolfgang Meier  */
end_comment

begin_class
specifier|public
class|class
name|NativeTextEngine
extends|extends
name|TextSearchEngine
implements|implements
name|ContentLoadingObserver
block|{
specifier|public
specifier|final
specifier|static
name|byte
name|ATTRIBUTE_SECTION
init|=
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|TEXT_SECTION
init|=
literal|0
decl_stmt|;
comment|/**    * Limit the length of the words to be indexed.    * Default is 512 characters for words in attributes and elements.     */
specifier|public
specifier|final
specifier|static
name|int
name|MAX_WORD_LENGTH
init|=
literal|2048
decl_stmt|;
specifier|protected
name|BFile
name|dbWords
decl_stmt|;
specifier|protected
name|InvertedIndex
name|invIdx
decl_stmt|;
specifier|public
name|NativeTextEngine
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Configuration
name|config
parameter_list|,
name|BFile
name|db
parameter_list|)
block|{
name|super
argument_list|(
name|broker
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|dbWords
operator|=
name|db
expr_stmt|;
name|this
operator|.
name|invIdx
operator|=
operator|new
name|InvertedIndex
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * check if string contains non-letters (maybe it's a regular expression? 	 *  	 * @param str 	 *                Description of the Parameter 	 * @return Description of the Return Value 	 */
specifier|public
specifier|final
specifier|static
name|boolean
name|containsWildcards
parameter_list|(
name|String
name|str
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|final
specifier|static
name|boolean
name|startsWithWildcard
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'['
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|dbWords
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|getTrackMatches
parameter_list|()
block|{
return|return
name|trackMatches
return|;
block|}
specifier|public
name|void
name|setTrackMatches
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|trackMatches
operator|=
name|flags
expr_stmt|;
block|}
comment|/** 	 * Collect all words in a document to be removed 	 *  	 * @param words 	 *                Description of the Parameter 	 * @param domIterator 	 *                Description of the Parameter 	 */
specifier|protected
name|void
name|collect
parameter_list|(
name|Set
name|words
parameter_list|,
name|Iterator
name|domIterator
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
operator|(
operator|(
name|Value
operator|)
name|domIterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getData
argument_list|()
decl_stmt|;
name|short
name|type
init|=
name|Signatures
operator|.
name|getType
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|word
decl_stmt|;
name|TextToken
name|token
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|int
name|children
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
name|collect
argument_list|(
name|words
argument_list|,
name|domIterator
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|String
name|s
decl_stmt|;
try|try
block|{
name|s
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|s
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|tokenizer
operator|.
name|setText
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
name|words
operator|.
name|add
argument_list|(
name|word
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|byte
name|idSizeType
init|=
operator|(
name|byte
operator|)
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x3
operator|)
decl_stmt|;
name|String
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
operator|+
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
operator|-
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|val
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
operator|+
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
operator|-
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tokenizer
operator|.
name|setText
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
name|words
operator|.
name|add
argument_list|(
name|word
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|invIdx
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|DocumentImpl
name|oldDoc
parameter_list|,
name|NodeImpl
name|node
parameter_list|)
block|{
name|invIdx
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|invIdx
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
specifier|public
name|NodeSet
name|getNodesContaining
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|String
name|expr
parameter_list|,
name|int
name|type
parameter_list|)
throws|throws
name|TerminatedException
block|{
if|if
condition|(
name|type
operator|==
name|DBBroker
operator|.
name|MATCH_EXACT
operator|&&
name|containsWildcards
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|type
operator|=
name|DBBroker
operator|.
name|MATCH_WILDCARDS
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DBBroker
operator|.
name|MATCH_EXACT
case|:
return|return
name|getNodesExact
argument_list|(
name|context
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|expr
argument_list|)
return|;
default|default :
return|return
name|getNodesRegexp
argument_list|(
name|context
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
comment|/** 	 * Get all nodes whose content exactly matches the terms passed in expr. 	 * Called by method getNodesContaining. 	 *  	 * @param the 	 *                input document set 	 * @param array 	 *                of regular expression search terms 	 * @return array containing a NodeSet for each of the search terms 	 */
specifier|public
name|NodeSet
name|getNodesExact
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|String
name|expr
parameter_list|)
throws|throws
name|TerminatedException
block|{
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|null
return|;
comment|//				long start = System.currentTimeMillis();
name|DocumentImpl
name|doc
decl_stmt|;
name|Value
name|ref
decl_stmt|;
comment|//		byte[] data;
name|long
name|gid
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|section
decl_stmt|;
name|int
name|sizeHint
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|last
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|NodeProxy
name|parent
decl_stmt|,
name|current
init|=
operator|new
name|NodeProxy
argument_list|()
decl_stmt|;
name|Match
name|match
decl_stmt|;
name|NodeSet
name|result
init|=
operator|new
name|ExtArrayNodeSet
argument_list|(
name|docs
operator|.
name|getLength
argument_list|()
argument_list|,
literal|250
argument_list|)
decl_stmt|;
name|String
name|term
init|=
operator|(
name|stem
operator|)
condition|?
name|stemmer
operator|.
name|stem
argument_list|(
name|expr
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|expr
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|collection
operator|=
operator|(
name|Collection
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|collection
operator|.
name|getId
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|is
operator|=
name|dbWords
operator|.
name|getAsStream
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|section
operator|=
name|is
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
operator|)
operator|==
literal|null
operator|||
operator|(
name|contextSet
operator|!=
literal|null
operator|&&
operator|!
name|contextSet
operator|.
name|containsDoc
argument_list|(
name|doc
argument_list|)
operator|)
condition|)
block|{
name|is
operator|.
name|skip
argument_list|(
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
name|sizeHint
operator|=
name|contextSet
operator|.
name|getSizeHint
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|gid
operator|=
name|last
operator|+
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|freq
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|last
operator|=
name|gid
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|current
operator|=
operator|(
name|section
operator|==
name|TEXT_SECTION
condition|?
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|TEXT_NODE
argument_list|)
else|:
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|ATTRIBUTE_NODE
argument_list|)
operator|)
expr_stmt|;
comment|// if a context set is specified, we can directly check if the
comment|// matching text node is a descendant of one of the nodes
comment|// in the context set.
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|section
operator|==
name|TEXT_SECTION
condition|)
name|parent
operator|=
name|contextSet
operator|.
name|parentWithChild
argument_list|(
name|current
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|parent
operator|=
name|contextSet
operator|.
name|get
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|match
operator|=
operator|new
name|Match
argument_list|(
name|term
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|match
operator|.
name|setFrequency
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|parent
argument_list|,
name|sizeHint
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackMatches
operator|!=
name|Serializer
operator|.
name|TAG_NONE
condition|)
name|parent
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
comment|// otherwise, we add all text nodes without check
block|}
else|else
block|{
name|result
operator|.
name|add
argument_list|(
name|current
argument_list|,
name|sizeHint
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|proceed
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while reading words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
operator|(
operator|(
name|ExtArrayNodeSet
operator|)
name|result
operator|)
operator|.
name|sort
argument_list|()
expr_stmt|;
comment|//				LOG.debug(
comment|//					"found "
comment|//						+ expr
comment|//						+ ": "
comment|//						+ result.getLength()
comment|//						+ " ("
comment|//						+ count
comment|//						+ ") "
comment|//						+ " in "
comment|//						+ (System.currentTimeMillis() - start)
comment|//						+ "ms.");
return|return
name|result
return|;
block|}
specifier|private
name|NodeSet
name|getNodesRegexp
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|String
name|expr
parameter_list|,
name|int
name|type
parameter_list|)
throws|throws
name|TerminatedException
block|{
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|null
return|;
name|expr
operator|=
name|expr
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|StringBuffer
name|term
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|expr
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|expr
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|term
operator|.
name|append
argument_list|(
name|expr
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
try|try
block|{
name|TermMatcher
name|comparator
init|=
operator|new
name|RegexMatcher
argument_list|(
name|expr
argument_list|,
name|type
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
operator||
name|Pattern
operator|.
name|UNICODE_CASE
argument_list|)
decl_stmt|;
return|return
name|getNodes
argument_list|(
name|context
argument_list|,
name|docs
argument_list|,
name|contextSet
argument_list|,
name|comparator
argument_list|,
name|term
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** 	 * Return all nodes whose content matches any of the search terms in expr. 	 * This method interprets the search terms as regular expressions and 	 * matches them against all indexed words. 	 *  	 * @param the 	 *                input document set 	 * @param array 	 *                of regular expression search terms 	 * @return array containing a NodeSet for each of the search terms 	 */
specifier|public
name|NodeSet
name|getNodes
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|TermMatcher
name|matcher
parameter_list|,
name|CharSequence
name|startTerm
parameter_list|)
throws|throws
name|TerminatedException
block|{
comment|//		long start = System.currentTimeMillis();
name|NodeSet
name|result
init|=
operator|new
name|ExtArrayNodeSet
argument_list|()
decl_stmt|;
name|Value
name|ref
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
name|SearchCallback
name|cb
init|=
operator|new
name|SearchCallback
argument_list|(
name|context
argument_list|,
name|matcher
argument_list|,
name|result
argument_list|,
name|contextSet
argument_list|,
name|docs
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|collection
operator|=
operator|(
name|Collection
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|collection
operator|.
name|getId
argument_list|()
expr_stmt|;
if|if
condition|(
name|startTerm
operator|!=
literal|null
operator|&&
name|startTerm
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|startTerm
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|)
expr_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|//		LOG.debug("regexp found: " + result.getLength() + " in "
comment|//				+ (System.currentTimeMillis() - start) + "ms.");
return|return
name|result
return|;
block|}
specifier|public
name|String
index|[]
name|getIndexTerms
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|TermMatcher
name|matcher
parameter_list|)
block|{
comment|//		long start = System.currentTimeMillis();
name|Value
name|ref
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
name|IndexCallback
name|cb
init|=
operator|new
name|IndexCallback
argument_list|(
literal|null
argument_list|,
name|matcher
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|collection
operator|=
operator|(
name|Collection
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|collection
operator|.
name|getId
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|)
expr_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|cb
operator|.
name|getMatches
argument_list|()
return|;
block|}
specifier|public
name|Occurrences
index|[]
name|scanIndexTerms
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|end
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|long
name|t0
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|Collection
name|current
decl_stmt|;
name|IndexQuery
name|query
decl_stmt|;
name|IndexScanCallback
name|cb
init|=
operator|new
name|IndexScanCallback
argument_list|(
name|docs
argument_list|,
name|contextSet
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|current
operator|=
operator|(
name|Collection
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|current
operator|.
name|getId
argument_list|()
expr_stmt|;
if|if
condition|(
name|end
operator|==
literal|null
condition|)
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|BW
argument_list|,
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|start
argument_list|)
argument_list|,
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|dbWords
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"cannot get lock on words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while reading words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while reading words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Map
name|map
init|=
name|cb
operator|.
name|map
decl_stmt|;
name|Occurrences
index|[]
name|result
init|=
operator|new
name|Occurrences
index|[
name|map
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|result
operator|.
name|length
operator|+
literal|" in "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t0
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Occurrences
index|[]
operator|)
name|map
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/** 	 * Remove indexed words for entire collection 	 *  	 * @param collection 	 *                Description of the Parameter 	 */
specifier|public
name|void
name|dropIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing fulltext index ..."
argument_list|)
expr_stmt|;
name|WordRef
name|ref
init|=
operator|new
name|WordRef
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|dbWords
operator|.
name|flush
argument_list|()
expr_stmt|;
name|dbWords
operator|.
name|removeAll
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on collections.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Remove all index entries for the specified document 	 *  	 * @param doc 	 *                The document 	 */
specifier|public
name|void
name|dropIndex
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
try|try
block|{
name|TreeSet
name|words
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
name|NodeList
name|children
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
operator|(
name|NodeImpl
operator|)
name|children
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Iterator
name|j
init|=
name|broker
operator|.
name|getDOMIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|collect
argument_list|(
name|words
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|String
name|word
decl_stmt|;
comment|//			Value val;
name|WordRef
name|ref
decl_stmt|;
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|VariableByteOutputStream
name|os
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|docId
decl_stmt|;
comment|//			long delta;
name|byte
name|section
decl_stmt|;
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|boolean
name|changed
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|words
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|word
operator|=
operator|(
name|String
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|is
operator|=
name|dbWords
operator|.
name|getAsStream
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|os
operator|=
operator|new
name|VariableByteOutputStream
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|false
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|section
operator|=
name|is
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|docId
operator|!=
name|doc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
comment|// copy data to new buffer
name|os
operator|.
name|writeInt
argument_list|(
name|docId
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|is
operator|.
name|copyTo
argument_list|(
name|os
argument_list|,
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changed
operator|=
literal|true
expr_stmt|;
comment|// skip
name|is
operator|.
name|skip
argument_list|(
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|//				    LOG.debug(e.getMessage(), e);
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//				    LOG.debug(e.getMessage(), e);
block|}
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|os
operator|.
name|data
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dbWords
operator|.
name|remove
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dbWords
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
operator|<
literal|0
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - "
operator|+
literal|"could not remove index for "
operator|+
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeDocument(DocumentImpl) - "
operator|+
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|is
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"removeDocument(DocumentImpl) - "
operator|+
literal|"io error while reading words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|is
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - "
operator|+
name|words
operator|.
name|size
argument_list|()
operator|+
literal|" words updated."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeDocument(DocumentImpl) - "
operator|+
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Index an attribute value 	 *  	 * @param attr 	 *                the attribute to be indexed 	 */
specifier|public
name|void
name|storeAttribute
parameter_list|(
name|FulltextIndexSpec
name|idx
parameter_list|,
name|AttrImpl
name|attr
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|attr
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|tokenizer
operator|.
name|setText
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|word
decl_stmt|;
name|TextToken
name|token
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|attr
operator|.
name|getGID
argument_list|()
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
literal|null
operator|&&
name|idx
operator|.
name|getIncludeAlphaNum
argument_list|()
operator|==
literal|false
operator|&&
name|token
operator|.
name|getType
argument_list|()
operator|==
name|TextToken
operator|.
name|ALPHANUM
condition|)
block|{
continue|continue;
block|}
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
operator|||
name|word
operator|.
name|length
argument_list|()
operator|>
name|MAX_WORD_LENGTH
condition|)
block|{
continue|continue;
block|}
name|invIdx
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|invIdx
operator|.
name|addAttribute
argument_list|(
name|word
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Index a text node 	 *  	 * @param idx 	 *                IndexPaths object passed in by the broker 	 * @param text 	 *                the text node to be indexed 	 * @param onetoken 	 *                if true, given text is indexed as a whole 	 *                if false, it is indexed token by token 	 * @return boolean indicates if all of the text content has been added to 	 *            the index 	 */
specifier|public
name|void
name|storeText
parameter_list|(
name|FulltextIndexSpec
name|idx
parameter_list|,
name|TextImpl
name|text
parameter_list|,
name|boolean
name|onetoken
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|text
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|tokenizer
operator|.
name|setText
argument_list|(
name|text
operator|.
name|getXMLString
argument_list|()
operator|.
name|transformToLower
argument_list|()
argument_list|)
expr_stmt|;
name|TextToken
name|token
decl_stmt|;
name|CharSequence
name|word
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|text
operator|.
name|getGID
argument_list|()
decl_stmt|;
if|if
condition|(
name|onetoken
condition|)
block|{
name|invIdx
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|String
name|sal
init|=
name|text
operator|.
name|getXMLString
argument_list|()
operator|.
name|transformToLower
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|invIdx
operator|.
name|addText
argument_list|(
name|sal
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
literal|null
operator|&&
name|idx
operator|.
name|getIncludeAlphaNum
argument_list|()
operator|==
literal|false
operator|&&
name|token
operator|.
name|isAlpha
argument_list|()
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
name|word
operator|=
name|token
operator|.
name|getCharSequence
argument_list|()
expr_stmt|;
comment|//			word = token.getText();
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
operator|||
name|word
operator|.
name|length
argument_list|()
operator|>
name|MAX_WORD_LENGTH
condition|)
block|{
continue|continue;
block|}
name|invIdx
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|invIdx
operator|.
name|addText
argument_list|(
name|word
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|sync
parameter_list|()
block|{
comment|// uncomment this to get statistics about page buffer usage
name|dbWords
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * This inner class is responsible for actually storing the list of 	 * occurrences. 	 *  	 * @author Wolfgang Meier<meier@ifs.tu-darmstadt.de> 	 */
specifier|final
class|class
name|InvertedIndex
block|{
specifier|private
name|DocumentImpl
name|doc
init|=
literal|null
decl_stmt|;
specifier|private
name|Map
name|words
index|[]
init|=
operator|new
name|TreeMap
index|[
literal|2
index|]
decl_stmt|;
specifier|private
name|VariableByteOutputStream
name|os
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|7
argument_list|)
decl_stmt|;
specifier|public
name|InvertedIndex
parameter_list|()
block|{
comment|// To distinguish between attribute values and text, we use
comment|// two maps: words[0] collects text, words[1] stores attribute
comment|// values.
name|words
index|[
literal|0
index|]
operator|=
operator|new
name|TreeMap
argument_list|()
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
operator|new
name|TreeMap
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|addText
parameter_list|(
name|CharSequence
name|word
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|TermFrequencyList
name|buf
init|=
operator|(
name|TermFrequencyList
operator|)
name|words
index|[
literal|0
index|]
operator|.
name|get
argument_list|(
name|word
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
name|buf
operator|=
operator|new
name|TermFrequencyList
argument_list|()
expr_stmt|;
name|buf
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|words
index|[
literal|0
index|]
operator|.
name|put
argument_list|(
name|word
operator|.
name|toString
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|buf
operator|.
name|getLast
argument_list|()
operator|==
name|gid
condition|)
block|{
name|buf
operator|.
name|incLastTerm
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addAttribute
parameter_list|(
name|String
name|word
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|TermFrequencyList
name|buf
init|=
operator|(
name|TermFrequencyList
operator|)
name|words
index|[
literal|1
index|]
operator|.
name|get
argument_list|(
name|word
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
name|buf
operator|=
operator|new
name|TermFrequencyList
argument_list|()
expr_stmt|;
name|buf
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|.
name|put
argument_list|(
name|word
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|buf
operator|.
name|getLast
argument_list|()
operator|==
name|gid
condition|)
block|{
name|buf
operator|.
name|incLastTerm
argument_list|()
expr_stmt|;
block|}
else|else
name|buf
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Remove the entries in the current list from the index. 		 */
specifier|public
name|void
name|remove
parameter_list|()
block|{
comment|// TODO: use VariableInputStream
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
return|return;
specifier|final
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|len
decl_stmt|,
name|docId
decl_stmt|;
name|Map
operator|.
name|Entry
name|entry
decl_stmt|;
name|String
name|word
decl_stmt|;
name|TermFrequencyList
name|idList
decl_stmt|;
name|TermFrequencyList
operator|.
name|TermFreq
index|[]
name|ids
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|long
name|last
decl_stmt|;
comment|// , gid;
name|long
name|delta
decl_stmt|;
name|byte
name|section
decl_stmt|;
comment|//			NodeProxy p;
name|WordRef
name|ref
decl_stmt|;
name|TermFrequencyList
name|newList
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
name|Value
name|val
init|=
literal|null
decl_stmt|;
name|VariableByteArrayInput
name|is
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|words
index|[
name|k
index|]
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|entry
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|word
operator|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|idList
operator|=
operator|(
name|TermFrequencyList
operator|)
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|val
operator|=
name|dbWords
operator|.
name|get
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|os
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// new output list containing nodes from the
comment|// document that should not be removed
name|newList
operator|=
operator|new
name|TermFrequencyList
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
comment|// add old entries to the new list
name|data
operator|=
name|val
operator|.
name|getData
argument_list|()
expr_stmt|;
comment|//					        LOG.debug("old size: " + data.length);
name|is
operator|=
operator|new
name|VariableByteArrayInput
argument_list|(
name|data
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|section
operator|=
name|is
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|docId
operator|==
name|doc
operator|.
name|getDocId
argument_list|()
operator|&&
name|section
operator|==
name|k
condition|)
block|{
comment|// copy data to new output list; skip
comment|// removed nodes
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|last
operator|=
name|last
operator|+
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|freq
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// add the node to the new output list if it is not found
comment|// in the list of removed nodes
if|if
condition|(
operator|!
name|idList
operator|.
name|contains
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|newList
operator|.
name|setLastTermFreq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// section belongs to another document:
comment|// copy data to new buffer
name|os
operator|.
name|writeInt
argument_list|(
name|docId
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|is
operator|.
name|copyTo
argument_list|(
name|os
argument_list|,
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"end-of-file while reading index entry for "
operator|+
name|word
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io-error while reading index entry for "
operator|+
name|word
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newList
operator|.
name|getSize
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// save the nodes remaining in the output list for the document
name|ids
operator|=
name|newList
operator|.
name|toArray
argument_list|()
expr_stmt|;
comment|//i.remove();
name|Arrays
operator|.
name|sort
argument_list|(
name|ids
argument_list|)
expr_stmt|;
name|len
operator|=
name|ids
operator|.
name|length
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|k
operator|==
literal|0
condition|?
name|TEXT_SECTION
else|:
name|ATTRIBUTE_SECTION
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|ids
index|[
name|j
index|]
operator|.
name|l
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"neg. delta: "
operator|+
name|delta
operator|+
literal|" for "
operator|+
name|word
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"id = "
operator|+
name|ids
index|[
name|j
index|]
operator|+
literal|"; prev = "
operator|+
name|last
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|os
operator|.
name|writeInt
argument_list|(
name|ids
index|[
name|j
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|last
operator|=
name|ids
index|[
name|j
index|]
operator|.
name|l
expr_stmt|;
block|}
block|}
name|ByteArray
name|ndata
init|=
name|os
operator|.
name|data
argument_list|()
decl_stmt|;
comment|//					    LOG.debug("new size: " + ndata.size());
if|if
condition|(
name|ndata
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|dbWords
operator|.
name|remove
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while removing fulltext entry: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
name|dbWords
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|dbWords
operator|.
name|update
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|,
name|ref
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
block|}
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|words
index|[
name|k
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|DocumentImpl
name|oldDoc
parameter_list|,
name|NodeImpl
name|node
parameter_list|)
block|{
specifier|final
name|short
name|collectionId
init|=
name|oldDoc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|len
decl_stmt|,
name|docId
decl_stmt|;
name|Map
operator|.
name|Entry
name|entry
decl_stmt|;
name|String
name|word
decl_stmt|;
name|TermFrequencyList
name|idList
decl_stmt|;
name|TermFrequencyList
operator|.
name|TermFreq
index|[]
name|ids
decl_stmt|;
name|long
name|last
decl_stmt|,
name|gid
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
name|byte
name|section
decl_stmt|;
comment|//		    NodeProxy p;
name|WordRef
name|ref
decl_stmt|;
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|words
index|[
name|k
index|]
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|entry
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|word
operator|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|idList
operator|=
operator|(
name|TermFrequencyList
operator|)
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|is
operator|=
name|dbWords
operator|.
name|getAsStream
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|os
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
comment|// add old entries to the new list
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|section
operator|=
name|is
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|docId
operator|!=
name|oldDoc
operator|.
name|getDocId
argument_list|()
operator|||
name|section
operator|!=
name|k
condition|)
block|{
comment|// section belongs to another document:
comment|// copy data to new buffer
name|os
operator|.
name|writeInt
argument_list|(
name|docId
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|is
operator|.
name|copyTo
argument_list|(
name|os
argument_list|,
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// copy nodes to new list
name|gid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|gid
operator|+=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|freq
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|&&
name|oldDoc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|<
name|oldDoc
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
name|idList
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|idList
operator|.
name|setLastTermFreq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|XMLUtil
operator|.
name|isDescendantOrSelf
argument_list|(
name|oldDoc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|gid
argument_list|)
operator|)
condition|)
block|{
name|idList
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|idList
operator|.
name|setLastTermFreq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|//LOG.error("end-of-file while reading index entry
comment|// for " + word, e);
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io-error while reading index entry for "
operator|+
name|word
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|ids
operator|=
name|idList
operator|.
name|toArray
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|ids
argument_list|)
expr_stmt|;
name|len
operator|=
name|ids
operator|.
name|length
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|oldDoc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|k
operator|==
literal|0
condition|?
name|TEXT_SECTION
else|:
name|ATTRIBUTE_SECTION
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|ids
index|[
name|j
index|]
operator|.
name|l
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"neg. delta: "
operator|+
name|delta
operator|+
literal|" for "
operator|+
name|word
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"id = "
operator|+
name|ids
index|[
name|j
index|]
operator|+
literal|"; prev = "
operator|+
name|last
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|os
operator|.
name|writeInt
argument_list|(
name|ids
index|[
name|j
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|last
operator|=
name|ids
index|[
name|j
index|]
operator|.
name|l
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|is
operator|==
literal|null
condition|)
name|dbWords
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|dbWords
operator|.
name|update
argument_list|(
operator|(
operator|(
name|BFile
operator|.
name|PageInputStream
operator|)
name|is
operator|)
operator|.
name|getAddress
argument_list|()
argument_list|,
name|ref
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"could not acquire lock on index for '"
operator|+
name|word
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|is
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while reindexing word '"
operator|+
name|word
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|is
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
name|words
index|[
name|k
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
specifier|final
name|int
name|wordsCount
init|=
name|words
index|[
literal|0
index|]
operator|.
name|size
argument_list|()
operator|+
name|words
index|[
literal|1
index|]
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
operator|||
name|wordsCount
operator|==
literal|0
condition|)
return|return;
specifier|final
name|ProgressIndicator
name|progress
init|=
operator|new
name|ProgressIndicator
argument_list|(
name|wordsCount
argument_list|,
literal|100
argument_list|)
decl_stmt|;
specifier|final
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|len
decl_stmt|;
name|Map
operator|.
name|Entry
name|entry
decl_stmt|;
name|String
name|word
decl_stmt|;
name|TermFrequencyList
name|idList
decl_stmt|;
comment|//			TermFrequencyList.TermFreq id;
name|TermFrequencyList
operator|.
name|TermFreq
index|[]
name|ids
decl_stmt|;
comment|//			byte[] data;
name|long
name|prevId
decl_stmt|;
name|long
name|delta
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|words
index|[
name|k
index|]
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|entry
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|word
operator|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|idList
operator|=
operator|(
name|TermFrequencyList
operator|)
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|os
operator|.
name|clear
argument_list|()
expr_stmt|;
name|len
operator|=
name|idList
operator|.
name|getSize
argument_list|()
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|k
operator|==
literal|0
condition|?
name|TEXT_SECTION
else|:
name|ATTRIBUTE_SECTION
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|prevId
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
name|idList
operator|.
name|toArray
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|ids
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|len
condition|;
name|m
operator|++
control|)
block|{
name|delta
operator|=
name|ids
index|[
name|m
index|]
operator|.
name|l
operator|-
name|prevId
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"neg. delta: "
operator|+
name|delta
operator|+
literal|" for "
operator|+
name|word
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"id = "
operator|+
name|ids
index|[
name|m
index|]
operator|+
literal|"; prev = "
operator|+
name|prevId
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|os
operator|.
name|writeInt
argument_list|(
name|ids
index|[
name|m
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|prevId
operator|=
name|ids
index|[
name|m
index|]
operator|.
name|l
expr_stmt|;
block|}
name|flushWord
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|progress
operator|.
name|setValue
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress
operator|.
name|changed
argument_list|()
condition|)
block|{
name|setChanged
argument_list|()
expr_stmt|;
name|notifyObservers
argument_list|(
name|progress
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wordsCount
operator|>
literal|100
condition|)
block|{
name|progress
operator|.
name|finish
argument_list|()
expr_stmt|;
name|setChanged
argument_list|()
expr_stmt|;
name|notifyObservers
argument_list|(
name|progress
argument_list|)
expr_stmt|;
block|}
name|words
index|[
name|k
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|//			dbWords.debugFreeList();
block|}
specifier|private
name|void
name|flushWord
parameter_list|(
name|short
name|collectionId
parameter_list|,
name|String
name|word
parameter_list|,
name|ByteArray
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|append
argument_list|(
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while writing '"
operator|+
name|word
operator|+
literal|"'"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|doc
operator|!=
literal|null
operator|&&
name|this
operator|.
name|doc
operator|.
name|getDocId
argument_list|()
operator|!=
name|doc
operator|.
name|getDocId
argument_list|()
condition|)
name|flush
argument_list|()
expr_stmt|;
name|this
operator|.
name|doc
operator|=
name|doc
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|IndexCallback
implements|implements
name|BTreeCallback
block|{
name|List
name|matches
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|TermMatcher
name|matcher
decl_stmt|;
name|XQueryContext
name|context
decl_stmt|;
specifier|public
name|IndexCallback
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|TermMatcher
name|matcher
parameter_list|)
block|{
name|this
operator|.
name|matcher
operator|=
name|matcher
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
specifier|public
name|String
index|[]
name|getMatches
parameter_list|()
block|{
name|String
index|[]
name|a
init|=
operator|new
name|String
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|(
name|String
index|[]
operator|)
name|matches
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/* (non-Javadoc) 		 * @see org.dbxml.core.filer.BTreeCallback#indexInfo(org.dbxml.core.data.Value, long) 		 */
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
name|context
operator|.
name|proceed
argument_list|()
expr_stmt|;
name|String
name|word
decl_stmt|;
try|try
block|{
name|word
operator|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|word
operator|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|word
argument_list|)
condition|)
name|matches
operator|.
name|add
argument_list|(
name|word
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|SearchCallback
implements|implements
name|BTreeCallback
block|{
name|DocumentSet
name|docs
decl_stmt|;
name|TermMatcher
name|matcher
decl_stmt|;
name|NodeSet
name|result
decl_stmt|;
name|NodeSet
name|contextSet
decl_stmt|;
name|XQueryContext
name|context
decl_stmt|;
name|XMLString
name|word
init|=
operator|new
name|XMLString
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|public
name|SearchCallback
parameter_list|(
name|XQueryContext
name|context
parameter_list|,
name|TermMatcher
name|comparator
parameter_list|,
name|NodeSet
name|result
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|,
name|DocumentSet
name|docs
parameter_list|)
block|{
name|this
operator|.
name|matcher
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|this
operator|.
name|docs
operator|=
name|docs
expr_stmt|;
name|this
operator|.
name|contextSet
operator|=
name|contextSet
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|word
operator|.
name|reuse
argument_list|()
expr_stmt|;
name|word
operator|=
name|UTF8
operator|.
name|decode
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|word
argument_list|)
condition|)
block|{
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|dbWords
operator|.
name|getAsStream
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
return|return
literal|true
return|;
comment|//				int k = 0;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
name|long
name|gid
decl_stmt|;
name|long
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
name|int
name|sizeHint
init|=
operator|-
literal|1
decl_stmt|;
name|byte
name|section
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|NodeProxy
name|parent
decl_stmt|,
name|proxy
decl_stmt|;
name|Match
name|match
decl_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
name|context
operator|.
name|proceed
argument_list|()
expr_stmt|;
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|section
operator|=
name|is
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|is
operator|.
name|skip
argument_list|(
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
name|sizeHint
operator|=
name|contextSet
operator|.
name|getSizeHint
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|gid
operator|=
name|last
operator|+
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|freq
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|last
operator|=
name|gid
expr_stmt|;
name|proxy
operator|=
operator|(
name|section
operator|==
name|TEXT_SECTION
condition|?
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|TEXT_NODE
argument_list|)
else|:
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|ATTRIBUTE_NODE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|section
operator|==
name|TEXT_SECTION
condition|)
name|parent
operator|=
name|contextSet
operator|.
name|parentWithChild
argument_list|(
name|proxy
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|parent
operator|=
name|contextSet
operator|.
name|get
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|parent
argument_list|,
name|sizeHint
argument_list|)
expr_stmt|;
name|match
operator|=
operator|new
name|Match
argument_list|(
name|word
operator|.
name|toString
argument_list|()
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|match
operator|.
name|setFrequency
argument_list|(
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackMatches
operator|!=
name|Serializer
operator|.
name|TAG_NONE
condition|)
name|parent
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|result
operator|.
name|add
argument_list|(
name|proxy
argument_list|,
name|sizeHint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|// EOFExceptions are normal
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while reading index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
operator|(
operator|(
name|ExtArrayNodeSet
operator|)
name|result
operator|)
operator|.
name|sort
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|IndexScanCallback
implements|implements
name|BTreeCallback
block|{
specifier|private
name|DocumentSet
name|docs
decl_stmt|;
specifier|private
name|NodeSet
name|contextSet
decl_stmt|;
specifier|private
name|Map
name|map
init|=
operator|new
name|TreeMap
argument_list|()
decl_stmt|;
name|IndexScanCallback
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|NodeSet
name|contextSet
parameter_list|)
block|{
name|this
operator|.
name|docs
operator|=
name|docs
expr_stmt|;
name|this
operator|.
name|contextSet
operator|=
name|contextSet
expr_stmt|;
block|}
comment|/* (non-Javadoc) 		 * @see org.dbxml.core.filer.BTreeCallback#indexInfo(org.dbxml.core.data.Value, long) 		 */
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|String
name|term
decl_stmt|;
try|try
block|{
name|term
operator|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|term
operator|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|Occurrences
name|oc
init|=
operator|(
name|Occurrences
operator|)
name|map
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|dbWords
operator|.
name|getAsStream
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
return|return
literal|true
return|;
try|try
block|{
name|int
name|docId
decl_stmt|;
comment|//				byte section;
name|int
name|len
decl_stmt|;
name|int
name|freq
init|=
literal|1
decl_stmt|;
name|long
name|gid
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|boolean
name|include
init|=
literal|true
decl_stmt|;
name|boolean
name|docAdded
decl_stmt|;
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|//					section =
name|is
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|is
operator|.
name|skip
argument_list|(
name|termFreq
condition|?
name|len
operator|*
literal|2
else|:
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|docAdded
operator|=
literal|false
expr_stmt|;
name|gid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|gid
operator|+=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termFreq
condition|)
name|freq
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|contextSet
operator|!=
literal|null
condition|)
block|{
name|include
operator|=
name|contextSet
operator|.
name|parentWithChild
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
operator|!=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|include
condition|)
block|{
if|if
condition|(
name|oc
operator|==
literal|null
condition|)
block|{
name|oc
operator|=
operator|new
name|Occurrences
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|docAdded
condition|)
block|{
name|oc
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|docAdded
operator|=
literal|true
expr_stmt|;
block|}
name|oc
operator|.
name|addOccurrences
argument_list|(
name|freq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while scanning index: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TermFrequencyList
block|{
specifier|protected
specifier|static
class|class
name|TermFreq
implements|implements
name|Comparable
block|{
name|long
name|l
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|TermFreq
name|next
init|=
literal|null
decl_stmt|;
specifier|public
name|TermFreq
parameter_list|(
name|long
name|l
parameter_list|)
block|{
name|this
operator|.
name|l
operator|=
name|l
expr_stmt|;
block|}
specifier|public
name|void
name|increment
parameter_list|()
block|{
operator|++
name|count
expr_stmt|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|TermFreq
name|other
init|=
operator|(
name|TermFreq
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|other
operator|.
name|l
condition|)
return|return
literal|0
return|;
else|else
return|return
name|l
operator|>
name|other
operator|.
name|l
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
block|}
specifier|private
name|TermFreq
name|first
init|=
literal|null
decl_stmt|;
specifier|private
name|TermFreq
name|last
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|add
parameter_list|(
name|long
name|l
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
operator|new
name|TermFreq
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
name|TermFreq
name|next
init|=
operator|new
name|TermFreq
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|last
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|last
operator|=
name|next
expr_stmt|;
block|}
operator|++
name|count
expr_stmt|;
block|}
specifier|public
name|void
name|incLastTerm
parameter_list|()
block|{
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
operator|(
operator|(
name|TermFreq
operator|)
name|last
operator|)
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setLastTermFreq
parameter_list|(
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
operator|(
operator|(
name|TermFreq
operator|)
name|last
operator|)
operator|.
name|count
operator|=
name|freq
expr_stmt|;
block|}
specifier|public
name|long
name|getLast
parameter_list|()
block|{
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
return|return
name|last
operator|.
name|l
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|long
name|l
parameter_list|)
block|{
name|TermFreq
name|next
init|=
name|first
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|next
operator|.
name|l
operator|==
name|l
condition|)
return|return
literal|true
return|;
name|next
operator|=
name|next
operator|.
name|next
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|count
return|;
block|}
specifier|public
name|TermFreq
index|[]
name|toArray
parameter_list|()
block|{
name|TermFreq
index|[]
name|data
init|=
operator|new
name|TermFreq
index|[
name|count
index|]
decl_stmt|;
name|TermFreq
name|next
init|=
name|first
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|data
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|TermFreq
operator|)
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|.
name|next
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
block|}
specifier|private
specifier|final
specifier|static
class|class
name|WordRef
extends|extends
name|Value
block|{
specifier|public
name|WordRef
parameter_list|(
name|short
name|collectionId
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|2
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|collectionId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
block|}
specifier|public
name|WordRef
parameter_list|(
name|short
name|collectionId
parameter_list|,
name|String
name|word
parameter_list|)
block|{
name|len
operator|=
name|UTF8
operator|.
name|encoded
argument_list|(
name|word
argument_list|)
operator|+
literal|2
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|collectionId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UTF8
operator|.
name|encode
argument_list|(
name|word
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * @see java.lang.Object#toString() 		 */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
operator|+
operator|new
name|String
argument_list|(
name|data
argument_list|,
name|pos
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|storeAttribute
parameter_list|(
name|RangeIndexSpec
name|spec
parameter_list|,
name|AttrImpl
name|node
parameter_list|)
block|{
comment|// TODO Auto-generated method stu
block|}
specifier|public
name|void
name|setDocument
parameter_list|(
name|DocumentImpl
name|document
parameter_list|)
block|{
block|}
specifier|public
name|void
name|storeAttribute
parameter_list|(
name|AttrImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|fullTextIndexSwitch
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
specifier|public
name|void
name|storeText
parameter_list|(
name|TextImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|fullTextIndexSwitch
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
specifier|public
name|void
name|startElement
parameter_list|(
name|ElementImpl
name|impl
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
specifier|public
name|void
name|endElement
parameter_list|(
name|int
name|xpathType
parameter_list|,
name|ElementImpl
name|node
parameter_list|,
name|String
name|content
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
specifier|public
name|void
name|removeElement
parameter_list|(
name|ElementImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
block|}
end_class

end_unit

