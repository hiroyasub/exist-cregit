begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001/2002 Wolfgang M. Meier  *  meier@ifs.tu-darmstadt.de  *  http://exist.sourceforge.net  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *   *  $Id:  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|it
operator|.
name|unimi
operator|.
name|dsi
operator|.
name|fastutil
operator|.
name|Object2ObjectAVLTreeMap
import|;
end_import

begin_import
import|import
name|it
operator|.
name|unimi
operator|.
name|dsi
operator|.
name|fastutil
operator|.
name|Object2ObjectRBTreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|GlobCompiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|MalformedPatternException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|PatternCompiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|PatternMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Perl5Compiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Perl5Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|data
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|indexer
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ArraySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|Match
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|TextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|analysis
operator|.
name|TextToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LongLinkedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Occurrences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|OrderedLongLinkedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ProgressIndicator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|VariableByteInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|/**  *  This class is responsible for fulltext-indexing. Text-nodes are handed over  *  to this class to be fulltext-indexed. Method storeText() is called by  *  RelationalBroker whenever it finds a TextNode. Method getNodeIDsContaining()  *  is used by the XPath-engine to process queries where a fulltext-operator is  *  involved. The class keeps two database tables: table words stores the words  *  found with their unique id. Table inv_idx contains the word occurrences for  *  every word-id per document.  *  *@author     Wolfgang Meier  *@created    25. Mai 2002  */
end_comment

begin_class
specifier|public
class|class
name|NativeTextEngine
extends|extends
name|TextSearchEngine
block|{
specifier|private
specifier|static
name|Category
name|LOG
init|=
name|Category
operator|.
name|getInstance
argument_list|(
name|NativeTextEngine
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|BFile
name|dbWords
decl_stmt|;
specifier|protected
name|InvertedIndex
name|invIdx
decl_stmt|;
specifier|protected
name|boolean
name|useCompression
init|=
literal|false
decl_stmt|;
specifier|protected
name|PatternCompiler
name|regexCompiler
init|=
operator|new
name|Perl5Compiler
argument_list|()
decl_stmt|;
specifier|protected
name|PatternCompiler
name|globCompiler
init|=
operator|new
name|GlobCompiler
argument_list|()
decl_stmt|;
specifier|protected
name|PatternMatcher
name|matcher
init|=
operator|new
name|Perl5Matcher
argument_list|()
decl_stmt|;
specifier|public
name|NativeTextEngine
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Configuration
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|broker
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|String
name|dataDir
decl_stmt|;
name|String
name|temp
decl_stmt|;
name|int
name|buffers
decl_stmt|;
name|boolean
name|compress
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|dataDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.data-dir"
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|dataDir
operator|=
literal|"data"
expr_stmt|;
if|if
condition|(
operator|(
name|buffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.words.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|buffers
operator|=
literal|1024
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.compress"
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|compress
operator|=
name|temp
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
name|String
name|pathSep
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|dbWords
operator|=
operator|(
name|BFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.words"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|dbWords
operator|=
operator|new
name|BFile
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"words.dbx"
argument_list|)
argument_list|,
name|buffers
operator|/
literal|2
argument_list|,
name|buffers
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"words index buffer size: "
operator|+
name|buffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbWords
operator|.
name|exists
argument_list|()
condition|)
name|dbWords
operator|.
name|create
argument_list|()
expr_stmt|;
else|else
name|dbWords
operator|.
name|open
argument_list|()
expr_stmt|;
name|dbWords
operator|.
name|setCompression
argument_list|(
name|compress
argument_list|)
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.words"
argument_list|,
name|dbWords
argument_list|)
expr_stmt|;
block|}
name|invIdx
operator|=
operator|new
name|InvertedIndex
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  check if string contains non-letters (maybe it's a regular expression? 	 * 	 *@param  str  Description of the Parameter 	 *@return      Description of the Return Value 	 */
specifier|public
specifier|final
specifier|static
name|boolean
name|containsWildcards
parameter_list|(
name|String
name|str
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|final
specifier|static
name|boolean
name|startsWithWildcard
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'['
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
name|dbWords
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  Collect all words in a document to be removed 	 * 	 *@param  words        Description of the Parameter 	 *@param  domIterator  Description of the Parameter 	 */
specifier|protected
name|void
name|collect
parameter_list|(
name|HashSet
name|words
parameter_list|,
name|Iterator
name|domIterator
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
operator|(
operator|(
name|Value
operator|)
name|domIterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getData
argument_list|()
decl_stmt|;
name|short
name|type
init|=
name|Signatures
operator|.
name|getType
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|word
decl_stmt|;
name|TextToken
name|token
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|int
name|children
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
name|collect
argument_list|(
name|words
argument_list|,
name|domIterator
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|String
name|s
decl_stmt|;
try|try
block|{
name|s
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|s
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|tokenizer
operator|.
name|setText
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
name|words
operator|.
name|add
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|byte
name|idSizeType
init|=
operator|(
name|byte
operator|)
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x3
operator|)
decl_stmt|;
name|String
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
operator|+
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
operator|-
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|val
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|1
operator|+
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|,
name|data
operator|.
name|length
operator|-
literal|1
operator|-
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tokenizer
operator|.
name|setText
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
name|words
operator|.
name|add
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|invIdx
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|DocumentImpl
name|oldDoc
parameter_list|)
block|{
name|invIdx
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|)
expr_stmt|;
block|}
comment|/** 	 *  Find    all the nodes containing the search terms given by the array 	 * expr from the fulltext-index. 	 * 	 * @param the input document set 	 * @param array of regular expression search terms 	 * @return array containing a NodeSet for each of the search terms 	 * 	 */
specifier|public
name|NodeSet
index|[]
name|getNodesContaining
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|String
index|[]
name|expr
parameter_list|)
block|{
return|return
name|getNodesContaining
argument_list|(
name|docs
argument_list|,
name|expr
argument_list|,
name|DBBroker
operator|.
name|MATCH_EXACT
argument_list|)
return|;
block|}
comment|/** 	 *  Get   all  the nodes containing the search terms given by the array expr 	 * using the fulltext-index. 	 * 	 * @param docs the input document set 	 * @param expr array of search terms 	 * @param type either MATCH_EXACT or MATCH_REGEX 	 * @return array containing a NodeSet for each of the search terms 	 */
specifier|public
name|NodeSet
index|[]
name|getNodesContaining
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|String
index|[]
name|expr
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|DBBroker
operator|.
name|MATCH_EXACT
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expr
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|containsWildcards
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|type
operator|=
name|DBBroker
operator|.
name|MATCH_WILDCARDS
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DBBroker
operator|.
name|MATCH_EXACT
case|:
return|return
name|getNodesExact
argument_list|(
name|docs
argument_list|,
name|expr
argument_list|)
return|;
default|default :
return|return
name|getNodesRegexp
argument_list|(
name|docs
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
comment|/** 	 *  Get all nodes whose content exactly matches the terms passed 	 * in expr. Called by method getNodesContaining. 	 * 	 * @param the input document set 	 * @param array of regular expression search terms 	 * @return array containing a NodeSet for each of the search terms 	 */
specifier|public
name|NodeSet
index|[]
name|getNodesExact
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|String
index|[]
name|expr
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ArraySet
index|[]
name|result
init|=
operator|new
name|ArraySet
index|[
name|expr
operator|.
name|length
index|]
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|Value
name|ref
decl_stmt|;
name|Value
name|value
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|long
name|gid
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
name|long
name|last
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|String
name|term
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|VariableByteInputStream
name|is
decl_stmt|;
name|NodeProxy
name|p
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|expr
index|[
name|i
index|]
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|term
operator|=
operator|(
name|stem
operator|)
condition|?
name|stemmer
operator|.
name|stem
argument_list|(
name|expr
index|[
name|i
index|]
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|expr
index|[
name|i
index|]
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|new
name|ArraySet
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|collection
operator|=
operator|(
name|Collection
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|collection
operator|.
name|getId
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|term
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|value
operator|=
name|dbWords
operator|.
name|get
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|value
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|data
operator|=
name|value
operator|.
name|getData
argument_list|()
expr_stmt|;
name|is
operator|=
operator|new
name|VariableByteInputStream
argument_list|(
name|data
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|is
operator|.
name|skip
argument_list|(
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|gid
operator|=
name|last
operator|+
name|delta
expr_stmt|;
name|last
operator|=
name|gid
expr_stmt|;
name|p
operator|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|TEXT_NODE
argument_list|)
expr_stmt|;
name|p
operator|.
name|addMatch
argument_list|(
operator|new
name|Match
argument_list|(
name|term
argument_list|,
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
block|}
comment|//( (ArraySet) result[i] ).setIsSorted( true );
name|LOG
operator|.
name|debug
argument_list|(
literal|"found: "
operator|+
name|result
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
operator|+
literal|" in "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** 	 * Return all nodes whose content matches any of the search terms 	 * in expr. This method interprets the search terms as regular  	 * expressions and matches them against all indexed words. 	 *  	 * @param the input document set 	 * @param array of regular expression search terms 	 * @return array containing a NodeSet for each of the search terms 	 */
specifier|private
name|NodeSet
index|[]
name|getNodesRegexp
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|String
index|[]
name|expr
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ArraySet
index|[]
name|result
init|=
operator|new
name|ArraySet
index|[
name|expr
operator|.
name|length
index|]
decl_stmt|;
name|Value
name|ref
decl_stmt|;
name|StringBuffer
name|term
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|Pattern
name|regexp
decl_stmt|;
name|WordsCallback
name|cb
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|expr
index|[
name|i
index|]
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|expr
index|[
name|i
index|]
operator|=
name|expr
index|[
name|i
index|]
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|new
name|ArraySet
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
try|try
block|{
name|regexp
operator|=
operator|(
name|type
operator|==
name|DBBroker
operator|.
name|MATCH_REGEXP
condition|?
name|regexCompiler
operator|.
name|compile
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|,
name|Perl5Compiler
operator|.
name|CASE_INSENSITIVE_MASK
argument_list|)
else|:
name|globCompiler
operator|.
name|compile
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|,
name|GlobCompiler
operator|.
name|CASE_INSENSITIVE_MASK
operator||
name|GlobCompiler
operator|.
name|QUESTION_MATCHES_ZERO_OR_ONE_MASK
argument_list|)
operator|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedPatternException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|term
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|expr
index|[
name|i
index|]
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|expr
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|term
operator|.
name|append
argument_list|(
name|expr
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
name|cb
operator|=
operator|new
name|WordsCallback
argument_list|(
name|regexp
argument_list|,
name|result
index|[
name|i
index|]
argument_list|,
name|docs
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|collection
operator|=
operator|(
name|Collection
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|collection
operator|.
name|getId
argument_list|()
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|term
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|)
expr_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
literal|null
argument_list|,
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"regexp found: "
operator|+
name|result
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
operator|+
literal|" in "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|Occurrences
index|[]
name|scanIndexTerms
parameter_list|(
name|User
name|user
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|end
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission denied"
argument_list|)
throw|;
name|List
name|collections
init|=
name|inclusive
condition|?
name|collection
operator|.
name|getDescendants
argument_list|(
name|user
argument_list|)
else|:
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|collections
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|Collection
name|current
decl_stmt|;
name|IndexQuery
name|query
decl_stmt|;
name|ArrayList
name|values
decl_stmt|;
name|Value
index|[]
name|val
decl_stmt|;
name|String
name|term
decl_stmt|;
name|Object2ObjectAVLTreeMap
name|map
init|=
operator|new
name|Object2ObjectAVLTreeMap
argument_list|()
decl_stmt|;
name|Occurrences
name|oc
decl_stmt|;
name|VariableByteInputStream
name|is
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collections
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|current
operator|=
operator|(
name|Collection
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|current
operator|.
name|getId
argument_list|()
expr_stmt|;
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
literal|null
argument_list|,
name|IndexQuery
operator|.
name|BW
argument_list|,
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|start
argument_list|)
argument_list|,
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|values
operator|=
name|dbWords
operator|.
name|findEntries
argument_list|(
name|query
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|values
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|val
operator|=
operator|(
name|Value
index|[]
operator|)
name|j
operator|.
name|next
argument_list|()
expr_stmt|;
name|term
operator|=
operator|new
name|String
argument_list|(
name|val
index|[
literal|0
index|]
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|val
index|[
literal|0
index|]
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|oc
operator|=
operator|(
name|Occurrences
operator|)
name|map
operator|.
name|get
argument_list|(
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|==
literal|null
condition|)
block|{
name|oc
operator|=
operator|new
name|Occurrences
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|is
operator|=
operator|new
name|VariableByteInputStream
argument_list|(
name|val
index|[
literal|1
index|]
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|is
operator|.
name|skip
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|oc
operator|.
name|addOccurrences
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"cannot get lock on words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while reading words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while reading words"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|Occurrences
index|[]
name|result
init|=
operator|new
name|Occurrences
index|[
name|map
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|(
name|Occurrences
index|[]
operator|)
name|map
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/** 	 *  Remove indexed words for entire collection 	 * 	 *@param  collection  Description of the Parameter 	 */
specifier|public
name|void
name|removeCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|dbWords
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing words ..."
argument_list|)
expr_stmt|;
name|WordRef
name|ref
init|=
operator|new
name|WordRef
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
literal|null
argument_list|,
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|ArrayList
name|entries
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|entries
operator|=
name|dbWords
operator|.
name|findKeys
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|entries
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entries
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"could not remove collection"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"found "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" words."
argument_list|)
expr_stmt|;
name|Value
name|val
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|entries
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|val
operator|=
operator|(
name|Value
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|//dbWords.remove(val);
name|dbWords
operator|.
name|remove
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|dbWords
operator|.
name|removeValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"removed words index"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  Remove all index entries for the specified document 	 * 	 *@param  doc  The document 	 */
specifier|public
name|void
name|removeDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing text index ..."
argument_list|)
expr_stmt|;
try|try
block|{
name|HashSet
name|words
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|NodeList
name|children
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
operator|(
name|NodeImpl
operator|)
name|children
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Iterator
name|j
init|=
name|broker
operator|.
name|getDOMIterator
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
name|collect
argument_list|(
name|words
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|String
name|word
decl_stmt|;
name|Value
name|val
decl_stmt|;
name|WordRef
name|ref
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|byte
index|[]
name|ndata
decl_stmt|;
name|VariableByteInputStream
name|is
decl_stmt|;
name|VariableByteOutputStream
name|os
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|boolean
name|changed
decl_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|words
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|word
operator|=
operator|(
name|String
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|val
operator|=
name|dbWords
operator|.
name|get
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|val
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
continue|continue;
name|data
operator|=
name|val
operator|.
name|getData
argument_list|()
expr_stmt|;
name|is
operator|=
operator|new
name|VariableByteInputStream
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|os
operator|=
operator|new
name|VariableByteOutputStream
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|false
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|docId
operator|!=
name|doc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
comment|// copy data to new buffer
name|os
operator|.
name|writeInt
argument_list|(
name|docId
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|changed
operator|=
literal|true
expr_stmt|;
comment|// skip
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
name|delta
operator|=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
if|if
condition|(
name|changed
condition|)
block|{
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ndata
operator|=
name|os
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
if|if
condition|(
name|ndata
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|dbWords
operator|.
name|remove
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dbWords
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|ndata
argument_list|)
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not remove index for "
operator|+
name|word
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|words
operator|.
name|size
argument_list|()
operator|+
literal|" words updated."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  Index an attribute value 	 * 	 *@param  attr  the attribute to be indexed 	 */
specifier|public
name|void
name|storeAttribute
parameter_list|(
name|IndexPaths
name|idx
parameter_list|,
name|AttrImpl
name|attr
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|attr
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|tokenizer
operator|.
name|setText
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|word
decl_stmt|;
name|TextToken
name|token
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|attr
operator|.
name|getGID
argument_list|()
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
literal|null
operator|&&
name|idx
operator|.
name|getIncludeAlphaNum
argument_list|()
operator|==
literal|false
operator|&&
name|token
operator|.
name|getType
argument_list|()
operator|==
name|TextToken
operator|.
name|ALPHANUM
condition|)
continue|continue;
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
name|invIdx
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|invIdx
operator|.
name|addRow
argument_list|(
name|word
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  Index a text node 	 * 	 *@param idx IndexPaths object passed in by the broker 	 *@param  text  the text node to be indexed 	 */
specifier|public
name|void
name|storeText
parameter_list|(
name|IndexPaths
name|idx
parameter_list|,
name|TextImpl
name|text
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|text
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|tokenizer
operator|.
name|setText
argument_list|(
name|text
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
name|TextToken
name|token
decl_stmt|;
name|String
name|word
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|text
operator|.
name|getGID
argument_list|()
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
literal|null
operator|&&
name|idx
operator|.
name|getIncludeAlphaNum
argument_list|()
operator|==
literal|false
operator|&&
name|token
operator|.
name|isAlpha
argument_list|()
operator|==
literal|false
condition|)
continue|continue;
name|word
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|//System.out.println( "'" + word + "'");
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
name|invIdx
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|invIdx
operator|.
name|addRow
argument_list|(
name|word
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|sync
parameter_list|()
block|{
comment|// uncomment this to get statistics about page buffer usage
name|dbWords
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on words db"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
specifier|static
class|class
name|WordRef
extends|extends
name|Value
block|{
specifier|public
name|WordRef
parameter_list|()
block|{
name|this
argument_list|(
literal|512
argument_list|)
expr_stmt|;
block|}
specifier|public
name|WordRef
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|size
index|]
expr_stmt|;
block|}
specifier|public
name|WordRef
parameter_list|(
name|short
name|collectionId
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|set
argument_list|(
name|collectionId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|WordRef
parameter_list|(
name|short
name|collectionId
parameter_list|,
name|String
name|word
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|set
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|final
name|void
name|set
parameter_list|(
name|short
name|collectionId
parameter_list|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|collectionId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
specifier|final
name|void
name|set
parameter_list|(
name|short
name|collectionId
parameter_list|,
name|String
name|word
parameter_list|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|collectionId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|writeChars
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
specifier|final
name|void
name|writeChars
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|int
name|slen
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|code
init|=
operator|(
name|int
operator|)
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0x01
operator|&&
name|code
operator|<=
literal|0x7F
condition|)
name|data
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|code
expr_stmt|;
if|else if
condition|(
operator|(
operator|(
name|code
operator|>=
literal|0x80
operator|)
operator|&&
operator|(
name|code
operator|<=
literal|0x7FF
operator|)
operator|)
operator|||
name|code
operator|==
literal|0
condition|)
block|{
name|data
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0xC0
operator||
operator|(
name|code
operator|>>
literal|6
operator|)
operator|)
expr_stmt|;
name|data
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
name|code
operator|&
literal|0x3F
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0xE0
operator||
operator|(
name|code
operator|>>>
literal|12
operator|)
operator|)
expr_stmt|;
name|data
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
operator|(
name|code
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
operator|)
expr_stmt|;
name|data
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
operator|(
literal|0x80
operator||
operator|(
name|code
operator|&
literal|0x3F
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 		 * @see org.dbxml.core.data.Value#streamTo(java.io.OutputStream) 		 */
specifier|public
name|void
name|streamTo
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|streamTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * @see java.lang.Object#toString() 		 */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|pos
argument_list|)
operator|+
operator|new
name|String
argument_list|(
name|data
argument_list|,
name|pos
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
comment|//	final static class WordRef extends Value {
comment|//
comment|//		WordRef(short collectionId) {
comment|//			data = new byte[2];
comment|//			ByteConversion.shortToByte(collectionId, data, 0);
comment|//			len = 2;
comment|//			pos = 0;
comment|//		}
comment|//
comment|//		WordRef(short collectionId, String word) {
comment|//			byte[] ndata;
comment|//			try {
comment|//				ndata = word.getBytes("UTF-8");
comment|//			} catch (UnsupportedEncodingException uee) {
comment|//				ndata = word.getBytes();
comment|//			}
comment|//			data = new byte[2 + ndata.length];
comment|//			ByteConversion.shortToByte(collectionId, data, 0);
comment|//			System.arraycopy(ndata, 0, data, 2, ndata.length);
comment|//			len = data.length;
comment|//			pos = 0;
comment|//		}
comment|//	}
comment|/** 	 *  This inner class is responsible for actually storing the list of 	 *  occurrences. 	 * 	 *@author     Wolfgang Meier<meier@ifs.tu-darmstadt.de> 	 *@created    25. Mai 2002 	 */
class|class
name|InvertedIndex
block|{
specifier|private
specifier|final
name|int
name|MAX_BUF
init|=
literal|100
decl_stmt|;
specifier|protected
name|DocumentImpl
name|doc
init|=
literal|null
decl_stmt|;
specifier|protected
name|boolean
name|flushed
init|=
literal|false
decl_stmt|;
comment|//protected TreeMap words = new TreeMap();
comment|//private Object2ObjectRBTreeMap words = new Object2ObjectRBTreeMap();
specifier|private
name|Object2ObjectAVLTreeMap
name|words
init|=
operator|new
name|Object2ObjectAVLTreeMap
argument_list|()
decl_stmt|;
specifier|private
name|VariableByteOutputStream
name|os
init|=
operator|new
name|VariableByteOutputStream
argument_list|()
decl_stmt|;
specifier|private
name|WordRef
name|reusableWordRef
init|=
operator|new
name|WordRef
argument_list|(
literal|512
argument_list|)
decl_stmt|;
specifier|private
name|long
name|currentSize
init|=
literal|0
decl_stmt|;
specifier|public
name|InvertedIndex
parameter_list|()
block|{
block|}
specifier|public
name|void
name|addRow
parameter_list|(
name|String
name|word
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|LongLinkedList
name|buf
init|=
operator|(
name|OrderedLongLinkedList
operator|)
name|words
operator|.
name|get
argument_list|(
name|word
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
name|buf
operator|=
operator|new
name|OrderedLongLinkedList
argument_list|()
expr_stmt|;
name|words
operator|.
name|put
argument_list|(
name|word
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|add
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|DocumentImpl
name|oldDoc
parameter_list|)
block|{
specifier|final
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|len
decl_stmt|;
name|Map
operator|.
name|Entry
name|entry
decl_stmt|;
name|String
name|word
decl_stmt|;
name|LongLinkedList
name|idList
decl_stmt|;
name|long
index|[]
name|ids
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|long
name|prevId
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|NodeSet
name|oldList
decl_stmt|;
name|DocumentSet
name|docs
decl_stmt|;
name|NodeProxy
name|p
decl_stmt|;
name|WordRef
name|ref
decl_stmt|;
name|Lock
name|lock
decl_stmt|;
name|String
index|[]
name|terms
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|words
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|entry
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|word
operator|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|terms
index|[
literal|0
index|]
operator|=
name|word
expr_stmt|;
name|idList
operator|=
operator|(
name|LongLinkedList
operator|)
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|docs
operator|=
operator|new
name|DocumentSet
argument_list|()
expr_stmt|;
name|docs
operator|.
name|add
argument_list|(
name|oldDoc
argument_list|)
expr_stmt|;
name|oldList
operator|=
name|getNodesExact
argument_list|(
name|docs
argument_list|,
name|terms
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|oldList
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|NodeProxy
operator|)
name|j
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|.
name|getTreeLevel
argument_list|(
name|p
operator|.
name|gid
argument_list|)
operator|<
name|oldDoc
operator|.
name|reindexRequired
argument_list|()
condition|)
name|idList
operator|.
name|add
argument_list|(
name|p
operator|.
name|gid
argument_list|)
expr_stmt|;
block|}
name|ids
operator|=
name|idList
operator|.
name|getData
argument_list|()
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|ids
argument_list|)
expr_stmt|;
name|len
operator|=
name|ids
operator|.
name|length
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|prevId
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|ids
index|[
name|j
index|]
operator|-
name|prevId
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"neg. delta: "
operator|+
name|delta
operator|+
literal|" for "
operator|+
name|word
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"id = "
operator|+
name|ids
index|[
name|j
index|]
operator|+
literal|"; prev = "
operator|+
name|prevId
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|prevId
operator|=
name|ids
index|[
name|j
index|]
expr_stmt|;
block|}
name|data
operator|=
name|os
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
name|os
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|WordRef
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|lock
operator|=
name|dbWords
operator|.
name|getLock
argument_list|()
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|//words = new TreeMap();
name|words
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
specifier|final
name|ProgressIndicator
name|progress
init|=
operator|new
name|ProgressIndicator
argument_list|(
name|words
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
return|return;
specifier|final
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|len
decl_stmt|;
name|Map
operator|.
name|Entry
name|entry
decl_stmt|;
name|String
name|word
decl_stmt|;
name|LongLinkedList
name|idList
decl_stmt|;
name|long
index|[]
name|ids
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|long
name|prevId
decl_stmt|,
name|id
decl_stmt|;
name|long
name|delta
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|words
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|entry
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|word
operator|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|idList
operator|=
operator|(
name|LongLinkedList
operator|)
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
name|len
operator|=
name|idList
operator|.
name|getSize
argument_list|()
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|prevId
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|idList
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|id
operator|=
operator|(
operator|(
name|LongLinkedList
operator|.
name|ListItem
operator|)
name|j
operator|.
name|next
argument_list|()
operator|)
operator|.
name|l
expr_stmt|;
name|delta
operator|=
name|id
operator|-
name|prevId
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"neg. delta: "
operator|+
name|delta
operator|+
literal|" for "
operator|+
name|word
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"id = "
operator|+
name|id
operator|+
literal|"; prev = "
operator|+
name|prevId
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|prevId
operator|=
name|id
expr_stmt|;
block|}
name|data
operator|=
name|os
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
name|os
operator|.
name|clear
argument_list|()
expr_stmt|;
name|flushWord
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|progress
operator|.
name|setValue
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|setChanged
argument_list|()
expr_stmt|;
name|notifyObservers
argument_list|(
name|progress
argument_list|)
expr_stmt|;
block|}
name|words
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//words = new TreeMap();
block|}
specifier|private
name|void
name|flushWord
parameter_list|(
name|short
name|collectionId
parameter_list|,
name|String
name|word
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|length
operator|==
literal|0
condition|)
return|return;
comment|// if data has already been written to the table,
comment|// we may need to do updates.
comment|//final WordRef ref = new WordRef(collectionId, word);
name|reusableWordRef
operator|.
name|set
argument_list|(
name|collectionId
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
name|dbWords
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|this
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|lock
operator|.
name|enter
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|dbWords
operator|.
name|append
argument_list|(
name|reusableWordRef
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|doc
operator|!=
literal|null
operator|&&
name|this
operator|.
name|doc
operator|.
name|getDocId
argument_list|()
operator|!=
name|doc
operator|.
name|getDocId
argument_list|()
condition|)
name|flush
argument_list|()
expr_stmt|;
name|this
operator|.
name|doc
operator|=
name|doc
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|WordsCallback
implements|implements
name|BTreeCallback
block|{
name|DocumentSet
name|docs
decl_stmt|;
name|Pattern
name|regexp
decl_stmt|;
name|ArraySet
name|result
decl_stmt|;
specifier|public
name|WordsCallback
parameter_list|(
name|Pattern
name|regexp
parameter_list|,
name|ArraySet
name|result
parameter_list|,
name|DocumentSet
name|docs
parameter_list|)
block|{
name|this
operator|.
name|regexp
operator|=
name|regexp
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|this
operator|.
name|docs
operator|=
name|docs
expr_stmt|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|pointer
parameter_list|)
block|{
name|String
name|word
decl_stmt|;
try|try
block|{
name|word
operator|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|word
operator|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|word
argument_list|,
name|regexp
argument_list|)
condition|)
block|{
name|Value
name|value
init|=
name|dbWords
operator|.
name|get
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|true
return|;
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
name|long
name|gid
decl_stmt|;
name|long
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|NodeProxy
name|proxy
decl_stmt|;
name|VariableByteInputStream
name|is
init|=
operator|new
name|VariableByteInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|is
operator|.
name|skip
argument_list|(
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|gid
operator|=
operator|(
name|last
operator|<
literal|0
condition|?
name|delta
else|:
name|last
operator|+
name|delta
operator|)
expr_stmt|;
name|last
operator|=
name|gid
expr_stmt|;
name|proxy
operator|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|TEXT_NODE
argument_list|)
expr_stmt|;
name|proxy
operator|.
name|addMatch
argument_list|(
operator|new
name|Match
argument_list|(
name|word
argument_list|,
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

