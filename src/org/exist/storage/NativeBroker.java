begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database  * Copyright (C) 2001-2007 The eXist team  * http://exist-db.org  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *    * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU Lesser General Public License for more details.  *   * You should have received a copy of the GNU Lesser General Public License  * along with this program; if not, write to the Free Software Foundation  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  *    * $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Indexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|backup
operator|.
name|RawDataBackup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|fulltext
operator|.
name|FTIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|fulltext
operator|.
name|FTIndexWorker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DOMIndexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|SecurityManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|EmbeddedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Paged
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Paged
operator|.
name|Page
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|RawNodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Journal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|LogEntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Loggable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|NativeSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArrayPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|DatabaseConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DocumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_comment
comment|/**  *  Main class for the native XML storage backend.  *  By "native" it is meant file-based, embedded backend.  *   * Provides access to all low-level operations required by  * the database. Extends {@link DBBroker}.  *   * Observer Design Pattern: role : this class is the subject (alias observable)  * for various classes that generate indices for the database content :  * @link org.exist.storage.NativeElementIndex  * @link org.exist.storage.NativeTextEngine  * @link org.exist.storage.NativeValueIndex   * @link org.exist.storage.NativeValueIndexByQName  *   * This class dispatches the various events (defined by the methods   * of @link org.exist.storage.ContentLoadingObserver) to indexing classes.  *   *@author     Wolfgang Meier  */
end_comment

begin_class
specifier|public
class|class
name|NativeBroker
extends|extends
name|DBBroker
block|{
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_RENAME_BINARY
init|=
literal|0x40
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_CREATE_BINARY
init|=
literal|0x41
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_BINARY
init|=
literal|0x42
decl_stmt|;
static|static
block|{
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_RENAME_BINARY
argument_list|,
name|RenameBinaryLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_CREATE_BINARY
argument_list|,
name|CreateBinaryLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_BINARY
argument_list|,
name|UpdateBinaryLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_ALWAYS
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_NEVER
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_AS_NEEDED
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|COLLECTIONS_DBX_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|ELEMENTS_DBX_ID
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|VALUES_DBX_ID
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|DOM_DBX_ID
init|=
literal|3
decl_stmt|;
comment|//Note : no ID for symbols ? Too bad...
specifier|public
specifier|static
specifier|final
name|String
name|PAGE_SIZE_ATTRIBUTE
init|=
literal|"pageSize"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_DEPTH_ATTRIBUTE
init|=
literal|"index-depth"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_INDEX_DEPTH
init|=
literal|"indexer.index-depth"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ALL_STORAGE_FILES
init|=
block|{
name|COLLECTIONS_DBX_ID
block|,
name|ELEMENTS_DBX_ID
block|,
name|VALUES_DBX_ID
block|,
name|DOM_DBX_ID
block|}
decl_stmt|;
comment|//private static final String TEMP_FRAGMENT_REMOVE_ERROR = "Could not remove temporary fragment";
comment|// private static final String TEMP_STORE_ERROR = "An error occurred while storing temporary data: ";
specifier|private
specifier|static
specifier|final
name|String
name|EXCEPTION_DURING_REINDEX
init|=
literal|"exception during reindex"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DATABASE_IS_READ_ONLY
init|=
literal|"database is read-only"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_DATA_DIR
init|=
literal|"data"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INDEX_DEPTH
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_MEMORY
init|=
literal|5000000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TEMP_FRAGMENT_TIMEOUT
init|=
literal|60000
decl_stmt|;
comment|/** default buffer size setting */
specifier|public
specifier|static
specifier|final
name|int
name|BUFFERS
init|=
literal|256
decl_stmt|;
comment|/** check available memory after storing DEFAULT_NODES_BEFORE_MEMORY_CHECK nodes */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
init|=
literal|500
decl_stmt|;
specifier|public
specifier|static
name|int
name|OFFSET_COLLECTION_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
name|int
name|OFFSET_VALUE
init|=
name|OFFSET_COLLECTION_ID
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
decl_stmt|;
comment|//2
comment|/** the database files */
specifier|protected
name|CollectionStore
name|collectionsDb
decl_stmt|;
specifier|protected
name|DOMFile
name|domDb
decl_stmt|;
comment|/** the index processors */
specifier|protected
name|NativeElementIndex
name|elementIndex
decl_stmt|;
specifier|protected
name|NativeValueIndex
name|valueIndex
decl_stmt|;
specifier|protected
name|IndexSpec
name|indexConfiguration
decl_stmt|;
specifier|protected
name|int
name|defaultIndexDepth
decl_stmt|;
specifier|protected
name|Serializer
name|xmlSerializer
decl_stmt|;
specifier|protected
name|boolean
name|readOnly
init|=
literal|false
decl_stmt|;
comment|/** used to count the nodes inserted after the last memory check */
specifier|protected
name|int
name|nodesCount
init|=
literal|0
decl_stmt|;
specifier|protected
name|int
name|nodesCountThreshold
init|=
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
decl_stmt|;
specifier|protected
name|String
name|dataDir
decl_stmt|;
specifier|protected
name|File
name|fsDir
decl_stmt|;
specifier|protected
name|File
name|fsBackupDir
decl_stmt|;
specifier|protected
name|int
name|pageSize
decl_stmt|;
specifier|protected
name|byte
name|prepend
decl_stmt|;
specifier|private
specifier|final
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
specifier|private
name|NodeProcessor
name|nodeProcessor
init|=
operator|new
name|NodeProcessor
argument_list|()
decl_stmt|;
specifier|private
name|EmbeddedXMLStreamReader
name|streamReader
init|=
literal|null
decl_stmt|;
specifier|protected
name|Journal
name|logManager
decl_stmt|;
comment|/** initialize database; read configuration, etc. */
specifier|public
name|NativeBroker
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|Configuration
name|config
parameter_list|)
throws|throws
name|EXistException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|logManager
operator|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
operator|.
name|getJournal
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing broker "
operator|+
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|prependDB
init|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.prepend-db"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"always"
operator|.
name|equalsIgnoreCase
argument_list|(
name|prependDB
argument_list|)
condition|)
block|{
name|prepend
operator|=
name|PREPEND_DB_ALWAYS
expr_stmt|;
block|}
if|else if
condition|(
literal|"never"
operator|.
name|equalsIgnoreCase
argument_list|(
name|prependDB
argument_list|)
condition|)
block|{
name|prepend
operator|=
name|PREPEND_DB_NEVER
expr_stmt|;
block|}
else|else
block|{
name|prepend
operator|=
name|PREPEND_DB_AS_NEEDED
expr_stmt|;
block|}
name|dataDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|BrokerPool
operator|.
name|PROPERTY_DATA_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
name|dataDir
operator|=
name|DEFAULT_DATA_DIR
expr_stmt|;
name|fsDir
operator|=
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
argument_list|)
argument_list|,
literal|"fs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fsDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Cannot make collection filesystem directory: "
operator|+
name|fsDir
argument_list|)
throw|;
block|}
block|}
name|fsBackupDir
operator|=
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
argument_list|)
argument_list|,
literal|"fs.journal"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsBackupDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fsBackupDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Cannot make collection filesystem directory: "
operator|+
name|fsBackupDir
argument_list|)
throw|;
block|}
block|}
name|nodesCountThreshold
operator|=
name|config
operator|.
name|getInteger
argument_list|(
name|BrokerPool
operator|.
name|PROPERTY_NODES_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodesCountThreshold
operator|>
literal|0
condition|)
name|nodesCountThreshold
operator|=
name|nodesCountThreshold
operator|*
literal|1000
expr_stmt|;
name|defaultIndexDepth
operator|=
name|config
operator|.
name|getInteger
argument_list|(
name|PROPERTY_INDEX_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultIndexDepth
operator|<
literal|0
condition|)
name|defaultIndexDepth
operator|=
name|DEFAULT_INDEX_DEPTH
expr_stmt|;
name|indexConfiguration
operator|=
operator|(
name|IndexSpec
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|Indexer
operator|.
name|PROPERTY_INDEXER_CONFIG
argument_list|)
expr_stmt|;
name|xmlSerializer
operator|=
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|setUser
argument_list|(
name|SecurityManager
operator|.
name|SYSTEM_USER
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|pool
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
try|try
block|{
comment|//TODO : refactor so that we can,
comment|//1) customize the different properties (file names, cache settings...)
comment|//2) have a consistent READ-ONLY behaviour (based on *mandatory* files ?)
comment|//3) have consistent file creation behaviour (we can probably avoid some unnecessary files)
comment|//4) use... *customized* factories for a better index plugability ;-)
comment|// Initialize DOM storage
name|domDb
operator|=
operator|(
name|DOMFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|DOMFile
operator|.
name|getConfigKeyForFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|domDb
operator|==
literal|null
condition|)
name|domDb
operator|=
operator|new
name|DOMFile
argument_list|(
name|pool
argument_list|,
name|DOM_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|domDb
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|domDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is read-only!"
argument_list|)
expr_stmt|;
name|readOnly
operator|=
literal|true
expr_stmt|;
block|}
comment|//Initialize collections storage
name|collectionsDb
operator|=
operator|(
name|CollectionStore
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|CollectionStore
operator|.
name|getConfigKeyForFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectionsDb
operator|==
literal|null
condition|)
name|collectionsDb
operator|=
operator|new
name|CollectionStore
argument_list|(
name|pool
argument_list|,
name|COLLECTIONS_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectionsDb
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is read-only!"
argument_list|)
expr_stmt|;
name|readOnly
operator|=
literal|true
expr_stmt|;
block|}
name|elementIndex
operator|=
operator|new
name|NativeElementIndex
argument_list|(
name|this
argument_list|,
name|ELEMENTS_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|VALUES_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|readOnly
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Database runs in read-only mode"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|addObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
name|super
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|//        textEngine.addObserver(o);
name|elementIndex
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|//TODO : what about other indexes observers ?
block|}
specifier|public
name|void
name|deleteObservers
parameter_list|()
block|{
name|super
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
if|if
condition|(
name|elementIndex
operator|!=
literal|null
condition|)
name|elementIndex
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
comment|//TODO : what about other indexes observers ?
comment|//        if (textEngine != null)
comment|//            textEngine.deleteObservers();
block|}
comment|// ============ dispatch the various events to indexing classes ==========
specifier|private
name|void
name|notifyRemoveNode
parameter_list|(
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|removeNode
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
comment|//private void notifyStoreAttribute(AttrImpl attr, NodePath currentPath, int indexingHint, RangeIndexSpec spec, boolean remove) {
comment|//    for (int i = 0; i< contentLoadingObservers.size(); i++) {
comment|//        ContentLoadingObserver observer = (ContentLoadingObserver) contentLoadingObservers.get(i);
comment|//        observer.storeAttribute(attr, currentPath, indexingHint, spec, remove);
comment|//    }
comment|//}
specifier|private
name|void
name|notifyStoreText
parameter_list|(
name|TextImpl
name|text
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|int
name|indexingHint
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|storeText
argument_list|(
name|text
argument_list|,
name|currentPath
argument_list|,
name|indexingHint
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyRemove
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifySync
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyFlush
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|observer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|//Ignore the exception ; try to continue on other files
block|}
block|}
block|}
specifier|private
name|void
name|notifyPrintStatistics
parameter_list|()
throws|throws
name|DBException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyClose
parameter_list|()
throws|throws
name|DBException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|notifyCloseAndRemove
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
block|}
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
block|}
comment|/**      * Update indexes for the given element node. This method is called when the indexer      * encounters a closing element tag. It updates any range indexes defined on the      * element value and adds the element id to the structural index.      *       * @param node the current element node      * @param currentPath node path leading to the element      * @param content contains the string value of the element. Needed if a range index      * is defined on it.      */
specifier|public
name|void
name|endElement
parameter_list|(
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
specifier|final
name|int
name|indexType
init|=
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
comment|//TODO : do not care about the current code redundancy : this will move in the (near) future
comment|// TODO : move to NativeValueIndex
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|node
operator|.
name|getQName
argument_list|()
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
comment|//NodeProxy p = new NodeProxy(node);
comment|//if (node.getOldInternalAddress() != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)
comment|//    p.setInternalAddress(node.getOldInternalAddress());
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//Curious... I assume getNodeValue() needs the old address
comment|//p.setInternalAddress(node.getInternalAddress());
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|remove
argument_list|)
expr_stmt|;
block|}
comment|// TODO : move to NativeValueIndexByQName
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasQNameIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|node
operator|.
name|getQName
argument_list|()
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
comment|//NodeProxy p = new NodeProxy(node);
comment|//if (node.getOldInternalAddress() != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)
comment|//    p.setInternalAddress(node.getOldInternalAddress());
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//Curious... I assume getNodeValue() needs the old address
comment|//p.setInternalAddress(node.getInternalAddress());
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_QNAME
argument_list|,
name|remove
argument_list|)
expr_stmt|;
comment|//            qnameValueIndex.setDocument((DocumentImpl) node.getOwnerDocument());
comment|//            qnameValueIndex.endElement((ElementImpl) node, currentPath, content);
block|}
block|}
comment|/*       private String getOldNodeContent(StoredNode node, long oldAddress) {       NodeProxy p = new NodeProxy(node);       if (oldAddress != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)       p.setInternalAddress(oldAddress);       String content = getNodeValue(node, false);       //Curious... I assume getNodeValue() needs the old address       p.setInternalAddress(node.getInternalAddress());       return content;       }*/
comment|/** Takes care of actually remove entries from the indices;      * must be called after one or more call to {@link #removeNode(Txn, StoredNode, NodePath, String)}. */
specifier|public
name|void
name|endRemove
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
name|notifyRemove
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
specifier|public
name|DOMFile
name|getDOMFile
parameter_list|()
block|{
return|return
name|domDb
return|;
block|}
specifier|public
name|BTree
name|getStorage
parameter_list|(
name|byte
name|id
parameter_list|)
block|{
comment|//Notice that there is no entry for the symbols table
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|DOM_DBX_ID
case|:
return|return
name|domDb
return|;
case|case
name|COLLECTIONS_DBX_ID
case|:
return|return
name|collectionsDb
return|;
case|case
name|ELEMENTS_DBX_ID
case|:
return|return
name|elementIndex
operator|.
name|dbNodes
return|;
case|case
name|VALUES_DBX_ID
case|:
return|return
name|valueIndex
operator|.
name|dbValues
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|byte
index|[]
name|getStorageFileIds
parameter_list|()
block|{
return|return
name|ALL_STORAGE_FILES
return|;
block|}
specifier|public
name|int
name|getDefaultIndexDepth
parameter_list|()
block|{
return|return
name|defaultIndexDepth
return|;
block|}
specifier|public
name|void
name|backupToArchive
parameter_list|(
name|RawDataBackup
name|backup
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|byte
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ALL_STORAGE_FILES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Paged
name|paged
init|=
name|getStorage
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|paged
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage file is null: "
operator|+
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|OutputStream
name|os
init|=
name|backup
operator|.
name|newEntry
argument_list|(
name|paged
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|paged
operator|.
name|backupToStream
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
name|OutputStream
name|os
init|=
name|backup
operator|.
name|newEntry
argument_list|(
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|backupSymbolsTo
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|backupToArchive
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|()
block|{
return|return
name|indexConfiguration
return|;
block|}
specifier|public
name|ElementIndex
name|getElementIndex
parameter_list|()
block|{
return|return
name|elementIndex
return|;
block|}
specifier|public
name|NativeValueIndex
name|getValueIndex
parameter_list|()
block|{
return|return
name|valueIndex
return|;
block|}
specifier|public
name|TextSearchEngine
name|getTextEngine
parameter_list|()
block|{
name|FTIndexWorker
name|worker
init|=
operator|(
name|FTIndexWorker
operator|)
name|indexController
operator|.
name|getWorkerByIndexId
argument_list|(
name|FTIndex
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|worker
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Fulltext index is not configured. Please check the<modules> section in conf.xml"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|worker
operator|.
name|getEngine
argument_list|()
return|;
block|}
specifier|public
name|EmbeddedXMLStreamReader
name|getXMLStreamReader
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
name|streamReader
operator|==
literal|null
condition|)
block|{
name|RawNodeIterator
name|iterator
init|=
operator|new
name|RawNodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|streamReader
operator|=
operator|new
name|EmbeddedXMLStreamReader
argument_list|(
name|this
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|reportAttributes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|streamReader
operator|.
name|reposition
argument_list|(
name|this
argument_list|,
name|node
argument_list|,
name|reportAttributes
argument_list|)
expr_stmt|;
block|}
return|return
name|streamReader
return|;
block|}
specifier|public
name|EmbeddedXMLStreamReader
name|newXMLStreamReader
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
name|RawNodeIterator
name|iterator
init|=
operator|new
name|RawNodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|)
decl_stmt|;
return|return
operator|new
name|EmbeddedXMLStreamReader
argument_list|(
name|this
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|iterator
argument_list|,
literal|null
argument_list|,
name|reportAttributes
argument_list|)
return|;
block|}
specifier|public
name|Iterator
name|getNodeIterator
parameter_list|(
name|StoredNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The node parameter cannot be null."
argument_list|)
throw|;
try|try
block|{
return|return
operator|new
name|NodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Serializer
name|getSerializer
parameter_list|()
block|{
name|xmlSerializer
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|xmlSerializer
return|;
block|}
specifier|public
name|Serializer
name|newSerializer
parameter_list|()
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|XmldbURI
name|prepend
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
block|{
switch|switch
condition|(
name|prepend
condition|)
block|{
case|case
name|PREPEND_DB_ALWAYS
case|:
return|return
name|uri
operator|.
name|prepend
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
return|;
case|case
name|PREPEND_DB_AS_NEEDED
case|:
return|return
name|uri
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|?
name|uri
else|:
name|uri
operator|.
name|prepend
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
return|;
default|default:
return|return
name|uri
return|;
block|}
block|}
comment|/**      * Creates a temporary collecion      *       * @param transaction : The transaction, which registers the acquired write locks. The locks should be released on commit/abort.      * @return The temporary collection      * @throws LockException      * @throws PermissionDeniedException      * @throws IOException      */
specifier|private
name|Collection
name|createTempCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
throws|,
name|IOException
block|{
name|User
name|u
init|=
name|getUser
argument_list|()
decl_stmt|;
try|try
block|{
name|setUser
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getUser
argument_list|(
name|SecurityManager
operator|.
name|DBA_USER
argument_list|)
argument_list|)
expr_stmt|;
name|Collection
name|temp
init|=
name|getOrCreateCollection
argument_list|(
name|transaction
argument_list|,
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|)
decl_stmt|;
name|temp
operator|.
name|setPermissions
argument_list|(
literal|0771
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
finally|finally
block|{
name|setUser
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* (non-Javadoc)      * @see org.exist.storage.DBBroker#getOrCreateCollection(org.exist.storage.txn.Txn, org.exist.xmldb.XmldbURI)      */
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
name|name
operator|=
name|prepend
argument_list|(
name|name
operator|.
name|normalizeCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
try|try
block|{
comment|//TODO : resolve URIs !
name|XmldbURI
index|[]
name|segments
init|=
name|name
operator|.
name|getPathSegments
argument_list|()
decl_stmt|;
name|XmldbURI
name|path
init|=
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
decl_stmt|;
name|Collection
name|sub
decl_stmt|;
name|Collection
name|current
init|=
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating root collection '"
operator|+
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|Collection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setPermissions
argument_list|(
literal|0777
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|getUser
argument_list|()
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
name|current
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
name|transaction
operator|.
name|acquireLock
argument_list|(
name|current
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|//TODO : acquire lock manually if transaction is null ?
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|XmldbURI
name|temp
init|=
name|segments
index|[
name|i
index|]
decl_stmt|;
name|path
operator|=
name|path
operator|.
name|append
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasSubcollectionNoLock
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|current
operator|=
name|getCollection
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Collection '"
operator|+
name|path
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Permission denied to create collection '"
operator|+
name|path
operator|+
literal|"'"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"User '"
operator|+
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to write to collection '"
operator|+
name|current
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating collection '"
operator|+
name|path
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
name|sub
operator|=
operator|new
name|Collection
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
name|transaction
operator|.
name|acquireLock
argument_list|(
name|sub
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|//TODO : acquire lock manually if transaction is null ?
name|current
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|sub
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|sub
expr_stmt|;
block|}
block|}
return|return
name|current
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|uri
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|uri
argument_list|,
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|,
name|lockMode
argument_list|)
return|;
block|}
comment|/**      *  Get collection object. If the collection does not exist, null is      *  returned.      *      *@param  uri  collection URI      *@return       The collection value      */
specifier|private
name|Collection
name|openCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|,
name|long
name|addr
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
name|uri
operator|=
name|prepend
argument_list|(
name|uri
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//We *must* declare it here (see below)
name|Collection
name|collection
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|collection
operator|=
name|collectionsCache
operator|.
name|get
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|VariableByteInput
name|is
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|collection
operator|=
operator|new
name|Collection
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|collection
operator|.
name|read
argument_list|(
name|this
argument_list|,
name|is
argument_list|)
expr_stmt|;
comment|//TODO : manage this from within the cache -pb
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exceptions ? -pb
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to encode '"
operator|+
name|uri
operator|+
literal|"' in UTF-8"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equalsInternal
argument_list|(
name|uri
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The collection received from the cache is not the requested: "
operator|+
name|uri
operator|+
literal|"; received: "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Important :
comment|//This code must remain ouside of the synchonized block
comment|//because another thread may already own a lock on the collection
comment|//This would result in a deadlock... until the time-out raises the Exception
comment|//TODO : make an attempt to an immediate lock ?
comment|//TODO : manage a collection of requests for locks ?
comment|//TODO : another yet smarter solution ?
if|if
condition|(
name|lockMode
operator|!=
name|Lock
operator|.
name|NO_LOCK
condition|)
block|{
try|try
block|{
name|collection
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on collection '"
operator|+
name|uri
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|collection
return|;
block|}
comment|/* (non-Javadoc)      * @see org.exist.storage.DBBroker#copyCollection(org.exist.storage.txn.Txn, org.exist.collections.Collection, org.exist.collections.Collection, org.exist.xmldb.XmldbURI)      */
specifier|public
name|void
name|copyCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newUri
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
comment|//TODO : resolve URIs !!!
if|if
condition|(
name|newUri
operator|!=
literal|null
operator|&&
name|newUri
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name must have one segment!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Read permission denied on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newUri
argument_list|)
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
try|try
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_COPY_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : relativize URI !!!
if|if
condition|(
name|newUri
operator|==
literal|null
condition|)
block|{
name|newUri
operator|=
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
expr_stmt|;
block|}
comment|//  check if another collection with the same name exists at the destination
comment|//TODO : resolve URIs !!! (destination.getURI().resolve(newURI))
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newUri
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old collection: "
operator|+
name|newUri
argument_list|)
expr_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
name|Collection
name|destCollection
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !!!
name|newUri
operator|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newUri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying collection to '"
operator|+
name|newUri
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|destCollection
operator|=
name|getOrCreateCollection
argument_list|(
name|transaction
argument_list|,
name|newUri
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|child
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying resource: '"
operator|+
name|child
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
comment|//TODO : put a lock on newDoc ?
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|destCollection
argument_list|,
name|child
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BinaryDocument
name|newDoc
init|=
operator|new
name|BinaryDocument
argument_list|(
name|pool
argument_list|,
name|destCollection
argument_list|,
name|child
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                         byte[] data = getBinaryResource((BinaryDocument) child);                         storeBinaryResource(transaction, newDoc, data);                          */
name|InputStream
name|is
init|=
name|getBinaryResource
argument_list|(
operator|(
name|BinaryDocument
operator|)
name|child
argument_list|)
decl_stmt|;
name|storeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|XmldbURI
name|name
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|XmldbURI
name|childName
init|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URIs ! collection.getURI().resolve(childName)
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|name
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection '"
operator|+
name|childName
operator|+
literal|"' not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|copyCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|destCollection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destCollection
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|moveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_MOVE_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// sourceDir must be known in advance, because once moveCollectionRecursive
comment|// is called, both collection and destination can point to the same resource
name|File
name|sourceDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Need to move each collection in the source tree individually, so recurse.
name|moveCollectionRecursive
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
expr_stmt|;
comment|// For binary resources, though, just move the top level directory and all descendants come with it.
name|moveBinaryFork
argument_list|(
name|transaction
argument_list|,
name|sourceDir
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|moveBinaryFork
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|File
name|sourceDir
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|targetDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|targetDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|File
name|targetDelDir
init|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|targetDelDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetDir
operator|.
name|renameTo
argument_list|(
name|targetDelDir
argument_list|)
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|targetDir
argument_list|,
name|targetDelDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot rename "
operator|+
name|targetDir
operator|+
literal|" to "
operator|+
name|targetDelDir
argument_list|)
expr_stmt|;
block|}
block|}
name|targetDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
name|sourceDir
operator|.
name|renameTo
argument_list|(
name|targetDir
argument_list|)
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceDir
argument_list|,
name|targetDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot move "
operator|+
name|sourceDir
operator|+
literal|" to "
operator|+
name|targetDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|moveCollectionRecursive
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|!=
literal|null
operator|&&
name|newName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name must have one segment!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move the db root collection"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
comment|// check if another collection with the same name exists at the destination
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
name|XmldbURI
name|uri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentURI
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
comment|//TODO : resolve URIs
name|parent
operator|.
name|removeCollection
argument_list|(
name|uri
operator|.
name|lastSegment
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|parent
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs destination.getURI().resolve(newName)
name|collection
operator|.
name|setPath
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|collection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|destination
condition|)
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|XmldbURI
name|childName
init|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URIs !!! name.resolve(childName)
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|uri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection "
operator|+
name|childName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|moveCollectionRecursive
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|collection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|canRemoveCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"User '"
operator|+
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
specifier|final
name|XmldbURI
name|uri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve from collection's base URI
comment|//TODO : resulve URIs !!! (uri.resolve(childName))
name|Collection
name|childCollection
init|=
name|openCollection
argument_list|(
name|uri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
try|try
block|{
name|canRemoveCollection
argument_list|(
name|childCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|childCollection
operator|!=
literal|null
condition|)
name|childCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|warn
argument_list|(
literal|"childCollection is null !"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes a collection and all child collections and resources      *       * @param transaction the transaction to use      * @param collection the collection to remove      * @return true if the collection was removed, false otherwise      */
specifier|public
name|boolean
name|removeCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"User '"
operator|+
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
try|try
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REMOVE_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
name|File
name|sourceDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|File
name|targetDir
init|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|canRemoveCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
specifier|final
name|XmldbURI
name|uri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|String
name|collName
init|=
name|uri
operator|.
name|getRawCollectionPath
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isRoot
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
operator|==
literal|null
decl_stmt|;
comment|// Notify the collection configuration manager
name|pool
operator|.
name|getConfigurationManager
argument_list|()
operator|.
name|invalidateAll
argument_list|(
name|uri
argument_list|)
expr_stmt|;
comment|// remove child collections
if|if
condition|(
name|sourceDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|targetDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
name|sourceDir
operator|.
name|renameTo
argument_list|(
name|targetDir
argument_list|)
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceDir
argument_list|,
name|targetDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot rename "
operator|+
name|sourceDir
operator|+
literal|" to "
operator|+
name|targetDir
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing children collections from their parent '"
operator|+
name|collName
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve from collection's base URI
comment|//TODO : resulve URIs !!! (uri.resolve(childName))
name|Collection
name|childCollection
init|=
name|openCollection
argument_list|(
name|uri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|childCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|childCollection
operator|!=
literal|null
condition|)
name|childCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|warn
argument_list|(
literal|"childCollection is null !"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Drop all index entries
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|// Drop custom indexes
name|indexController
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
comment|// remove from parent collection
comment|//TODO : resolve URIs ! (uri.resolve(".."))
name|Collection
name|parentCollection
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentURI
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
comment|// keep the lock for the transaction
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
name|transaction
operator|.
name|registerLock
argument_list|(
name|parentCollection
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection '"
operator|+
name|collName
operator|+
literal|"' from its parent..."
argument_list|)
expr_stmt|;
comment|//TODO : resolve from collection's base URI
name|parentCollection
operator|.
name|removeCollection
argument_list|(
name|uri
operator|.
name|lastSegment
argument_list|()
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parentCollection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"LockException while removing collection '"
operator|+
name|collName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|transaction
operator|==
literal|null
condition|)
name|parentCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//Update current state
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// remove the metadata of all documents in the collection
name|Value
name|docKey
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|docKey
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|)
expr_stmt|;
comment|// if this is not the root collection remove it...
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collName
argument_list|)
decl_stmt|;
comment|//... from the disk
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//... from the cache
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//and free its id for any futher use
name|freeCollectionId
argument_list|(
name|transaction
argument_list|,
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Simply save the collection on disk
comment|//It will remain cached
comment|//and its id well never be made available
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on '"
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while removing collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while removing collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
comment|//Remove child resources
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing resources in '"
operator|+
name|collName
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//Remove doc's metadata
comment|// WM: now removed in one step. see above.
comment|//removeResourceMetadata(transaction, doc);
comment|//Remove document nodes' index entries
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//Remove nodes themselves
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|long
name|page
init|=
operator|(
operator|(
name|BinaryDocument
operator|)
name|doc
operator|)
operator|.
name|getPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|>
name|Page
operator|.
name|NO_PAGE
condition|)
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
name|transaction
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|doc
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//Make doc's id available again
name|freeResourceId
argument_list|(
name|transaction
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection '"
operator|+
name|collName
operator|+
literal|"' took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Saves the specified collection to storage. Collections are usually cached in      * memory. If a collection is modified, this method needs to be called to make      * the changes persistent.      *       * Note: appending a new document to a collection does not require a save.      */
specifier|public
name|void
name|saveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"NativeBroker.saveCollection called with collection == null! Aborting."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
comment|// don't cache the collection during initialization: SecurityManager is not yet online
name|pool
operator|.
name|getCollectionsCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
name|collection
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
name|Value
name|name
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|collection
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
specifier|final
name|long
name|addr
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
comment|//TODO : exception !!! -pb
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not store collection data for '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Release the collection id assigned to a collection so it can be      * reused later.      *       * @param id      * @throws PermissionDeniedException      */
specifier|protected
name|void
name|freeCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
name|OFFSET_VALUE
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the next free collection id. If a collection is removed, its collection id      * is released so it can be reused.      *       * @return next free collection id.      * @throws ReadOnlyException      */
specifier|public
name|int
name|getFreeCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeCollectionId
init|=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
argument_list|)
expr_stmt|;
comment|//LOG.debug("reusing collection id: " + freeCollectionId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//            } else {
comment|//                try {
comment|//                    StringWriter sw = new StringWriter();
comment|//                    collectionsDb.dump(sw);
comment|//                    LOG.debug(CollectionStore.FREE_COLLECTION_ID_KEY + ": " + key.dump());
comment|//                    LOG.debug(sw.toString());
comment|//                } catch (IOException e) {
comment|//                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
comment|//                } catch (BTreeException e) {
comment|//                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
comment|//                }
block|}
return|return
name|freeCollectionId
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the next available unique collection id.      *       * @return next available unique collection id      * @throws ReadOnlyException      */
specifier|public
name|int
name|getNextCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|nextCollectionId
init|=
name|getFreeCollectionId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextCollectionId
operator|!=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
return|return
name|nextCollectionId
return|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|NEXT_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|nextCollectionId
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|XmldbURI
name|collectionName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|collectionName
operator|=
name|prepend
argument_list|(
name|collectionName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collectionName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|reindexCollection
argument_list|(
name|collection
argument_list|,
name|NodeProcessor
operator|.
name|MODE_STORE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REINDEX_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred during reindex: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reindexing collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NodeProcessor
operator|.
name|MODE_STORE
condition|)
name|dropCollectionIndex
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|next
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|next
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NodeProcessor
operator|.
name|MODE_REPAIR
condition|)
name|pool
operator|.
name|signalSystemStatus
argument_list|(
name|BrokerPool
operator|.
name|SIGNAL_STARTUP
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|XmldbURI
name|next
init|=
operator|(
name|XmldbURI
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URIs !!! (collection.getURI().resolve(next))
name|Collection
name|child
init|=
name|getCollection
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|next
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection '"
operator|+
name|next
operator|+
literal|"' not found"
argument_list|)
expr_stmt|;
else|else
block|{
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|dropCollectionIndex
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|indexController
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dropping index for document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Store into the temporary collection of the database a given in-memory Document      *      * The in-memory Document is stored without a transaction and is not journalled,      * if there is no temporary collection, this will first be created with a transaction      *      * @param doc The in-memory Document to store      * @return The document stored in the temp collection      */
specifier|public
name|DocumentImpl
name|storeTempResource
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
comment|//store the currentUser
name|User
name|currentUser
init|=
name|getUser
argument_list|()
decl_stmt|;
comment|//elevate getUser() to DBA_USER
name|setUser
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getUser
argument_list|(
name|SecurityManager
operator|.
name|DBA_USER
argument_list|)
argument_list|)
expr_stmt|;
comment|//start a transaction
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
comment|//create a name for the temporary document
name|XmldbURI
name|docName
init|=
name|XmldbURI
operator|.
name|create
argument_list|(
name|MessageDigester
operator|.
name|md5
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|+
literal|".xml"
argument_list|)
decl_stmt|;
comment|//get the temp collection
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
name|boolean
name|created
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|//if no temp collection
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
block|{
comment|//creates temp collection (with write lock)
name|temp
operator|=
name|createTempCollection
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to create temporary collection"
argument_list|)
expr_stmt|;
block|}
name|created
operator|=
literal|true
expr_stmt|;
block|}
comment|//create a temporary document
name|DocumentImpl
name|targetDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|temp
argument_list|,
name|docName
argument_list|)
decl_stmt|;
name|targetDoc
operator|.
name|setPermissions
argument_list|(
literal|0771
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|DocumentMetadata
name|metadata
init|=
operator|new
name|DocumentMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setLastModified
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
comment|//index the temporary document
name|DOMIndexer
name|indexer
init|=
operator|new
name|DOMIndexer
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|targetDoc
argument_list|)
decl_stmt|;
comment|//NULL transaction, so temporary fragment is not journalled - AR
name|indexer
operator|.
name|scan
argument_list|()
expr_stmt|;
name|indexer
operator|.
name|store
argument_list|()
expr_stmt|;
comment|//store the temporary document
name|temp
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
comment|//NULL transaction, so temporary fragment is not journalled - AR
comment|// unlock the temp collection
if|if
condition|(
name|transaction
operator|==
literal|null
condition|)
block|{
name|temp
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|created
condition|)
block|{
name|transaction
operator|.
name|registerLock
argument_list|(
name|temp
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
comment|//NULL transaction, so temporary fragment is not journalled - AR
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
comment|//commit the transaction
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
return|return
name|targetDoc
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to store temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//abort the transaction
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//restore the getUser()
name|setUser
argument_list|(
name|currentUser
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** remove all documents from temporary collection */
specifier|public
name|void
name|cleanUpTempResources
parameter_list|()
block|{
name|cleanUpTempResources
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** remove all documents from temporary collection      *       * @param forceRemoval Should temporary resources be forcefully removed       */
specifier|public
name|void
name|cleanUpTempResources
parameter_list|(
name|boolean
name|forceRemoval
parameter_list|)
block|{
name|Collection
name|temp
init|=
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
comment|/* We can remove the entire collection if all temp         data has timed out. It is much faster to remove a collection         than a number of documents from a collection         */
name|boolean
name|removeCollection
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|forceRemoval
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|temp
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|next
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|modified
init|=
name|next
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|modified
operator|<
name|TEMP_FRAGMENT_TIMEOUT
condition|)
block|{
name|removeCollection
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|//remove the entire temp collection?
if|if
condition|(
name|removeCollection
condition|)
block|{
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temp collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** store Document entry into its collection. */
specifier|public
name|void
name|storeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|doc
operator|.
name|write
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while writing document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|File
name|getCollectionFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|XmldbURI
name|uri
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getCollectionFile
argument_list|(
name|dir
argument_list|,
literal|null
argument_list|,
name|uri
argument_list|,
name|create
argument_list|)
return|;
block|}
specifier|private
name|File
name|getCollectionFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|Txn
name|transaction
parameter_list|,
name|XmldbURI
name|uri
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
block|{
name|dir
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"txn."
operator|+
name|transaction
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
operator|&&
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot make transaction filesystem directory: "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
block|}
name|XmldbURI
index|[]
name|segments
init|=
name|uri
operator|.
name|getPathSegments
argument_list|()
decl_stmt|;
name|File
name|binFile
init|=
name|dir
decl_stmt|;
name|int
name|last
init|=
name|segments
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|binFile
operator|=
operator|new
name|File
argument_list|(
name|binFile
argument_list|,
name|segments
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
operator|&&
name|i
operator|!=
name|last
operator|&&
operator|!
name|binFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|binFile
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot make collection filesystem directory: "
operator|+
name|binFile
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|binFile
return|;
block|}
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|blob
operator|.
name|setPage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|File
name|backupFile
init|=
literal|null
decl_stmt|;
name|boolean
name|exists
init|=
name|binFile
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|backupFile
operator|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|backupFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot backup binary resource for journal to "
operator|+
name|backupFile
argument_list|)
throw|;
block|}
block|}
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|binFile
argument_list|)
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|UpdateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|,
name|backupFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
name|blob
operator|.
name|setPage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|File
name|backupFile
init|=
literal|null
decl_stmt|;
name|boolean
name|exists
init|=
name|binFile
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|backupFile
operator|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|backupFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot backup binary resource for journal to "
operator|+
name|backupFile
argument_list|)
throw|;
block|}
block|}
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|65536
index|]
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|binFile
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|UpdateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|,
name|backupFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      *  get a document by its file name. The document's file name is used to      *  identify a document.      *      *@param  fileName absolute file name in the database;       *name can be given with or without the leading path /db/shakespeare.      *@return  The document value      *@exception  PermissionDeniedException       */
specifier|public
name|Document
name|getXMLResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|fileName
operator|=
name|prepend
argument_list|(
name|fileName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !!!
name|XmldbURI
name|collUri
init|=
name|fileName
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
name|XmldbURI
name|docUri
init|=
name|fileName
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '"
operator|+
name|collUri
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection '"
operator|+
name|collUri
operator|+
literal|"'"
argument_list|)
throw|;
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|docUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document '"
operator|+
name|fileName
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|BinaryDocument
name|bin
init|=
operator|(
name|BinaryDocument
operator|)
name|doc
decl_stmt|;
try|try
block|{
name|bin
operator|.
name|setContentLength
argument_list|(
operator|(
name|int
operator|)
name|getBinaryResourceSize
argument_list|(
name|bin
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot get content size for "
operator|+
name|bin
operator|.
name|getURI
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|//      if (!doc.getPermissions().validate(getUser(), Permission.READ))
comment|//          throw new PermissionDeniedException("not allowed to read document");
return|return
name|doc
return|;
block|}
specifier|public
name|DocumentImpl
name|getXMLResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|fileName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|fileName
operator|=
name|prepend
argument_list|(
name|fileName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !
name|XmldbURI
name|collUri
init|=
name|fileName
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
name|XmldbURI
name|docUri
init|=
name|fileName
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
name|Collection
name|collection
init|=
name|openCollection
argument_list|(
name|collUri
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '"
operator|+
name|collUri
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection '"
operator|+
name|collUri
operator|+
literal|"'"
argument_list|)
throw|;
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|docUri
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|//                LOG.debug("document '" + fileName + "' not found!");
return|return
literal|null
return|;
block|}
comment|//      if (!doc.getPermissions().validate(getUser(), Permission.READ))
comment|//          throw new PermissionDeniedException("not allowed to read document");
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|BinaryDocument
name|bin
init|=
operator|(
name|BinaryDocument
operator|)
name|doc
decl_stmt|;
try|try
block|{
name|bin
operator|.
name|setContentLength
argument_list|(
operator|(
name|int
operator|)
name|getBinaryResourceSize
argument_list|(
name|bin
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot get content size for "
operator|+
name|bin
operator|.
name|getURI
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not acquire lock on document "
operator|+
name|fileName
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : exception ? -pb
block|}
finally|finally
block|{
comment|//TOUNDERSTAND : by whom is this lock acquired ? -pb
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
name|collection
operator|.
name|release
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/*     public byte[] getBinaryResource(final BinaryDocument blob)         throws IOException     {     	if (blob.getPage() == Page.NO_PAGE)     		return new byte[0];         byte[] data = (byte[]) new DOMTransaction(this, domDb, Lock.WRITE_LOCK) { 			public Object start() throws ReadOnlyException { 			    return domDb.getBinary(blob.getPage()); 			} 	    } 	    .run();         return data;        ByteArrayOutputStream os = new ByteArrayOutputStream();        readBinaryResource(blob,os);        return os.toByteArray();     }      */
specifier|public
name|void
name|readBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
comment|/*     	if (blob.getPage() == Page.NO_PAGE)     		return;         new DOMTransaction(this, domDb, Lock.WRITE_LOCK) {             public Object start() throws ReadOnlyException {                 domDb.readBinary(blob.getPage(), os);                 return null;             }         }.run();         */
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|getBinaryResource
argument_list|(
name|blob
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|65536
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|long
name|getBinaryResourceSize
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|binFile
operator|.
name|length
argument_list|()
return|;
block|}
specifier|public
name|InputStream
name|getBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
comment|/*     	if (blob.getPage() == Page.NO_PAGE)     		return;         new DOMTransaction(this, domDb, Lock.WRITE_LOCK) {             public Object start() throws ReadOnlyException {                 domDb.readBinary(blob.getPage(), os);                 return null;             }         }.run();         */
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileInputStream
argument_list|(
name|binFile
argument_list|)
return|;
block|}
comment|//TODO : consider a better cooperation with Collection -pb
specifier|public
name|void
name|getCollectionResources
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
operator|new
name|DocumentCallback
argument_list|(
name|collection
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|getResourcesFailsafe
parameter_list|(
name|BTreeCallback
name|callback
parameter_list|,
name|boolean
name|fullScan
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|()
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullScan
condition|)
name|collectionsDb
operator|.
name|rawScan
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
else|else
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|getCollectionsFailsafe
parameter_list|(
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|()
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *  Get all the documents in this database matching the given      *  document-type's name.      * @return The documentsByDoctype value      */
specifier|public
name|MutableDocumentSet
name|getXMLResourcesByDoctype
parameter_list|(
name|String
name|doctypeName
parameter_list|,
name|MutableDocumentSet
name|result
parameter_list|)
block|{
name|MutableDocumentSet
name|docs
init|=
name|getAllXMLResources
argument_list|(
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|getDocumentIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|DocumentType
name|doctype
init|=
name|doc
operator|.
name|getDoctype
argument_list|()
decl_stmt|;
if|if
condition|(
name|doctype
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|doctypeName
operator|.
name|equals
argument_list|(
name|doctype
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
operator|&&
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      *  Adds all the documents in the database to the specified DocumentSet.      *      * @param docs a (possibly empty) document set to which the found      *  documents are added.      */
specifier|public
name|MutableDocumentSet
name|getAllXMLResources
parameter_list|(
name|MutableDocumentSet
name|docs
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
name|rootCollection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rootCollection
operator|=
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|rootCollection
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getAllDocuments(DocumentSet) - end - "
operator|+
literal|"loading "
operator|+
name|docs
operator|.
name|getDocumentCount
argument_list|()
operator|+
literal|" documents took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|rootCollection
operator|!=
literal|null
condition|)
name|rootCollection
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|//TODO : consider a better cooperation with Collection -pb
specifier|public
name|void
name|getResourceMetadata
parameter_list|(
name|DocumentImpl
name|document
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|document
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|VariableByteInput
name|istream
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|istream
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|readDocumentMeta
argument_list|(
name|istream
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|copyResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to copy resource "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to copy resource "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|newName
operator|=
name|doc
operator|.
name|getFileURI
argument_list|()
expr_stmt|;
block|}
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// check if the move would overwrite a collection
if|if
condition|(
name|getCollection
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource can not replace an existing collection"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy resource to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
name|destination
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
else|else
name|destination
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|getBinaryResource
argument_list|(
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newName
argument_list|,
name|is
argument_list|,
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getMimeType
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setPermissions
argument_list|(
name|doc
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|newDoc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|//          saveCollection(destination);
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred while copying resource"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred while copying resource"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|copyXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|oldDoc
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" to "
operator|+
name|newDoc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
init|=
name|oldDoc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|newDoc
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copy took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
comment|/** move Resource to another collection, with possible rename */
specifier|public
name|void
name|moveResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
block|{
comment|/* Copy reference to original document */
name|File
name|originalDocument
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
comment|//TODO : somewhat inconsistent (READ is enough for original doc whereas WRITE is mandatory for destination) -pb
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move resource "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move resource "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
throw|;
name|User
name|docUser
init|=
name|doc
operator|.
name|getUserLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|docUser
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|getUser
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
operator|.
name|equals
argument_list|(
name|docUser
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move '"
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" because is locked by getUser() '"
operator|+
name|docUser
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|newName
operator|=
name|doc
operator|.
name|getFileURI
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// check if the move would overwrite a collection
comment|//TODO : resolve URIs : destination.getURI().resolve(newName)
if|if
condition|(
name|getCollection
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource can not replace an existing collection"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move resource to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
name|destination
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
else|else
name|destination
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else                 if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
name|boolean
name|renameOnly
init|=
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
decl_stmt|;
name|collection
operator|.
name|unlinkDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setFileURI
argument_list|(
name|newName
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|setCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
comment|// reindexing
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|NodeProcessor
operator|.
name|MODE_REPAIR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// binary resource
name|doc
operator|.
name|setCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|File
name|colDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|File
name|binFile
init|=
operator|new
name|File
argument_list|(
name|colDir
argument_list|,
name|newName
operator|.
name|lastSegment
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|sourceFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/* Create required directories */
name|binFile
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|/* Rename original file to new location */
if|if
condition|(
name|originalDocument
operator|.
name|renameTo
argument_list|(
name|binFile
argument_list|)
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceFile
argument_list|,
name|binFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot rename "
operator|+
name|sourceFile
operator|+
literal|" to "
operator|+
name|binFile
operator|+
literal|" for journaling of binary resource move."
argument_list|)
expr_stmt|;
block|}
block|}
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|removeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|,
name|boolean
name|freeDocId
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing document "
operator|+
name|document
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" ("
operator|+
name|document
operator|.
name|getDocId
argument_list|()
operator|+
literal|") ..."
argument_list|)
expr_stmt|;
block|}
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - removing dom"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|document
operator|.
name|getMetadata
argument_list|()
operator|.
name|isReferenced
argument_list|()
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|document
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeDocId
condition|)
name|freeResourceId
argument_list|(
name|transaction
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeDocument(String) - "
operator|+
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dropIndex
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|document
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|indexController
operator|.
name|setDocument
argument_list|(
name|document
argument_list|,
name|StreamListener
operator|.
name|REMOVE_ALL_NODES
argument_list|)
expr_stmt|;
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
init|=
name|document
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|NodeProcessor
operator|.
name|MODE_REMOVE
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|notifyDropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|indexController
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"removing binary resource "
operator|+
name|blob
operator|.
name|getDocId
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|binFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|File
name|binBackupFile
init|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|,
name|binBackupFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|binBackupFile
argument_list|)
condition|)
block|{
comment|// Workaround for Java bug 6213298 - renameTo() sometimes doesn't work
comment|// See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6213298
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
block|}
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|binBackupFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot move file "
operator|+
name|binFile
operator|+
literal|" for delete journal to "
operator|+
name|binBackupFile
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*         if (blob.getPage() != Page.NO_PAGE) { 		    new DOMTransaction(this, domDb, Lock.WRITE_LOCK) { 				public Object start() throws ReadOnlyException { 				    domDb.removeOverflowValue(transaction, blob.getPage()); 				    return null; 				} 		    } 	        .run();         }          */
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param transaction      * @param document      */
specifier|private
name|void
name|removeResourceMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
comment|// remove document metadata
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing resource metadata for "
operator|+
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|document
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Release the document id reserved for a document so it      * can be reused.      *       * @param id      * @throws PermissionDeniedException      */
specifier|protected
name|void
name|freeResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_DOC_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|4
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the next unused document id. If a document is removed, its doc id is      * released, so it can be reused.      *       * @return Next unused document id      * @throws ReadOnlyException      */
specifier|public
name|int
name|getFreeResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeDocId
init|=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_DOC_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//LOG.debug("reusing document id: " + freeDocId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|4
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|//TODO : maybe something ? -pb
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|freeDocId
return|;
block|}
comment|/** get next Free Doc Id */
specifier|public
name|int
name|getNextResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
block|{
name|int
name|nextDocId
decl_stmt|;
try|try
block|{
name|nextDocId
operator|=
name|getFreeResourceId
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
comment|//TODO : rethrow ? -pb
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nextDocId
operator|!=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
condition|)
return|return
name|nextDocId
return|;
else|else
name|nextDocId
operator|=
literal|1
expr_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|NEXT_DOC_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Database is read-only"
argument_list|)
expr_stmt|;
return|return
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|nextDocId
return|;
block|}
comment|/**      * Reindex the nodes in the document. This method will either reindex all      * descendant nodes of the passed node, or all nodes below some level of      * the document if node is null.      */
specifier|private
name|void
name|reindexXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
condition|)
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setConfigEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|indexController
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|,
name|StreamListener
operator|.
name|STORE
argument_list|)
expr_stmt|;
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|mode
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
condition|)
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setConfigEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|defragXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
comment|//TODO : use dedicated function in XmldbURI
name|LOG
operator|.
name|debug
argument_list|(
literal|"============> Defragmenting document "
operator|+
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getURI
argument_list|()
operator|+
literal|"/"
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//        Writer writer = new StringWriter();
comment|//        try {
comment|//            domDb.dump(writer);
comment|//        } catch (BTreeException e1) {
comment|//            //  Auto-generated catch block
comment|//            e1.printStackTrace();
comment|//        } catch (IOException e1) {
comment|//            //  Auto-generated catch block
comment|//            e1.printStackTrace();
comment|//        }
comment|//        System.out.println(writer.toString());
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
comment|//          checkTree(doc);
comment|//            try {
comment|//                domDb.printFreeSpaceList();
comment|//            } catch (IOException e1) {
comment|//                // Auto-generated catch block
comment|//                e1.printStackTrace();
comment|//            }
comment|// remember this for later remove
specifier|final
name|long
name|firstChild
init|=
name|doc
operator|.
name|getFirstChildAddress
argument_list|()
decl_stmt|;
comment|// dropping old structure index
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// dropping dom index
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// create a copy of the old doc to copy the nodes into it
name|DocumentImpl
name|tempDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|tempDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|tempDoc
operator|.
name|setDocId
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy the nodes
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|tempDoc
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
comment|// checkTree(tempDoc);
comment|// remove the old nodes
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|firstChild
argument_list|)
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// checkTree(tempDoc);
name|doc
operator|.
name|copyChildren
argument_list|(
name|tempDoc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setSplitCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setPageCount
argument_list|(
name|tempDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getPageCount
argument_list|()
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|//Commented out since DocmentImpl has no more internal address
comment|//LOG.debug("new doc address = " + StorageAddress.toString(doc.getInternalAddress()));
name|closeDocument
argument_list|()
expr_stmt|;
comment|//          new DOMTransaction(this, domDb, Lock.READ_LOCK) {
comment|//              public Object start() throws ReadOnlyException {
comment|//                  LOG.debug("Pages used: " + domDb.debugPages(doc));
comment|//                  return null;
comment|//              }
comment|//          }.run();
comment|//            storeXMLResource(transaction, doc);
comment|//            checkTree(doc);
name|LOG
operator|.
name|debug
argument_list|(
literal|"Defragmentation took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** consistency Check of the database; useful after XUpdates;      * called if xupdate.consistency-checks is true in configuration */
specifier|public
name|void
name|checkXMLResourceConsistency
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
block|{
name|boolean
name|xupdateConsistencyChecks
init|=
literal|false
decl_stmt|;
name|Object
name|property
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getProperty
argument_list|(
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
name|xupdateConsistencyChecks
operator|=
operator|(
operator|(
name|Boolean
operator|)
name|property
operator|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|checkXMLResourceTree
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|//          elementIndex.consistencyCheck(doc);
block|}
block|}
comment|/** consistency Check of the database; useful after XUpdates;      * called by {@link #checkXMLResourceConsistency(DocumentImpl)} */
specifier|public
name|void
name|checkXMLResourceTree
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking DOM tree for document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|xupdateConsistencyChecks
init|=
literal|false
decl_stmt|;
name|Object
name|property
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getProperty
argument_list|(
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
name|xupdateConsistencyChecks
operator|=
operator|(
operator|(
name|Boolean
operator|)
name|property
operator|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pages used: "
operator|+
name|domDb
operator|.
name|debugPages
argument_list|(
name|doc
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//                Pass buf to the following method to get a dump of all node ids in the document
if|if
condition|(
operator|!
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|node
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"node tree: "
operator|+
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in document tree structure"
argument_list|)
throw|;
block|}
block|}
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|findKeys
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *  Store a node into the database. This method is called by the parser to      *  write a node to the storage backend.      *      *@param  node         the node to be stored      *@param  currentPath  path expression which points to this node's      *      element-parent or to itself if it is an element (currently used by      *      the Broker to determine if a node's content should be      *      fulltext-indexed).  @param index switch to activate fulltext indexation      */
specifier|public
name|void
name|storeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|IndexSpec
name|indexSpec
parameter_list|,
name|boolean
name|fullTextIndex
parameter_list|)
block|{
name|checkAvailableMemory
argument_list|()
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|long
name|address
decl_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|TEXT_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|CDATA_SECTION_NODE
operator|||
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
operator|>
name|defaultIndexDepth
condition|)
name|address
operator|=
name|domDb
operator|.
name|add
argument_list|(
name|transaction
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|address
operator|=
name|domDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"address is missing"
argument_list|)
expr_stmt|;
comment|//TODO : how can we continue here ? -pb
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|++
name|nodesCount
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|indexSpec
argument_list|,
name|fullTextIndex
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|doIndex
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|updateNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|boolean
name|reindex
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|internalAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|internalAddress
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
name|internalAddress
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Value
name|oldVal
init|=
name|domDb
operator|.
name|get
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|StoredNode
name|old
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|oldVal
operator|.
name|data
argument_list|()
argument_list|,
name|oldVal
operator|.
name|start
argument_list|()
argument_list|,
name|oldVal
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while storing "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"; old = "
operator|+
name|old
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//        if (reindex) {
comment|//            StreamListener listener = indexController.getStreamListener(node.getDocument(), StreamListener.STORE);
comment|//            IndexUtils.scanNode(transaction, node, listener);
comment|//        }
block|}
comment|/**      * Physically insert a node into the DOM storage.      */
specifier|public
name|void
name|insertNodeAfter
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|previous
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|previous
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|long
name|address
init|=
name|previous
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|copyNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|,
name|boolean
name|defrag
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|defrag
argument_list|,
name|index
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|copyNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|,
name|boolean
name|defrag
parameter_list|,
name|boolean
name|index
parameter_list|,
name|NodeId
name|oldNodeId
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|)
expr_stmt|;
name|storeNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|defrag
operator|&&
name|oldNodeId
operator|!=
literal|null
condition|)
name|pool
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyMove
argument_list|(
name|oldNodeId
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
comment|//save old value, whatever it is
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|oldAddress
argument_list|)
expr_stmt|;
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//restore old value, whatever it was
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|node
operator|.
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
operator|==
literal|1
condition|)
name|newDoc
operator|.
name|appendChild
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|NodeId
name|nodeId
init|=
name|node
operator|.
name|getNodeId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|child
init|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|oldNodeId
operator|=
name|child
operator|.
name|getNodeId
argument_list|()
expr_stmt|;
if|if
condition|(
name|defrag
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|nodeId
operator|=
name|nodeId
operator|.
name|newChild
argument_list|()
expr_stmt|;
else|else
name|nodeId
operator|=
name|nodeId
operator|.
name|nextSibling
argument_list|()
expr_stmt|;
name|child
operator|.
name|setNodeId
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|defrag
argument_list|,
name|index
argument_list|,
name|oldNodeId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Removes the Node Reference from the database.      * The index will be updated later, i.e. after all nodes have been physically       * removed. See {@link #endRemove(org.exist.storage.txn.Txn)}.      * removeNode() just adds the node ids to the list in elementIndex       * for later removal.      */
specifier|public
name|void
name|removeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|notifyRemoveNode
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|NodeProxy
name|p
init|=
operator|new
name|NodeProxy
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// save element by calling ElementIndex
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GeneralRangeIndexSpec
name|spec1
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec1
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|spec1
operator|.
name|getType
argument_list|()
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|QNameRangeIndexSpec
name|qnSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|qname
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|qnSpec
operator|.
name|getType
argument_list|()
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_QNAME
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|//Strange : does it mean that the node is added 2 times under 2 different identities ?
name|AttrImpl
name|attr
decl_stmt|;
name|attr
operator|=
operator|(
name|AttrImpl
operator|)
name|node
expr_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|AttrImpl
operator|.
name|ID
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|ID
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREF
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREFS
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// do nothing special
block|}
name|RangeIndexSpec
name|spec2
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec2
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
literal|null
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|spec2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|qnSpec
operator|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
literal|null
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|qnSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
break|break;
block|}
block|}
specifier|public
name|void
name|removeAllNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|StreamListener
name|listener
parameter_list|)
block|{
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|Stack
name|stack
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
name|collectNodesForRemoval
argument_list|(
name|transaction
argument_list|,
name|stack
argument_list|,
name|iterator
argument_list|,
name|listener
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RemovedNode
name|next
init|=
operator|(
name|RemovedNode
operator|)
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|removeNode
argument_list|(
name|transaction
argument_list|,
name|next
operator|.
name|node
argument_list|,
name|next
operator|.
name|path
argument_list|,
name|next
operator|.
name|content
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|collectNodesForRemoval
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Stack
name|stack
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StreamListener
name|listener
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|RemovedNode
name|removed
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|String
name|content
init|=
literal|null
decl_stmt|;
name|GeneralRangeIndexSpec
name|spec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
name|int
name|childCount
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childCount
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|child
init|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|child
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
name|collectNodesForRemoval
argument_list|(
name|transaction
argument_list|,
name|stack
argument_list|,
name|iterator
argument_list|,
name|listener
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|!=
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Index a single node, which has been added through an XUpdate      * operation. This method is only called if inserting the node is possible      * without changing the node identifiers of sibling or parent nodes. In other       * cases, reindex will be called.      */
specifier|public
name|void
name|indexNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|NodeProcessor
operator|.
name|MODE_STORE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|indexNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|int
name|repairMode
parameter_list|)
block|{
name|elementIndex
operator|.
name|setInUpdateMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|setMode
argument_list|(
name|repairMode
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|index
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|checkNodeTree
parameter_list|(
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|docIsValid
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|StoredNode
name|previous
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|child
init|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|isSiblingOf
argument_list|(
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|&&
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"node "
operator|+
name|child
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" cannot be a sibling of "
operator|+
name|previous
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"; node read from "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|child
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
name|previous
operator|=
name|child
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|i
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|": "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
name|NodeId
name|parentId
init|=
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|getParentId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentId
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|child
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" is not a child of "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
name|boolean
name|check
init|=
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIsValid
condition|)
name|docIsValid
operator|=
name|check
expr_stmt|;
block|}
block|}
return|return
name|docIsValid
return|;
block|}
comment|/**      * Called by reindex to walk through all nodes in the tree and reindex them      * if necessary.      *       * @param iterator      * @param node      * @param currentPath      */
specifier|private
name|void
name|scanNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|int
name|mode
parameter_list|,
name|StreamListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
break|break;
default|default :
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unhandled node type: "
operator|+
name|node
operator|.
name|getNodeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|child
init|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|i
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|mode
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|NodeProcessor
operator|.
name|MODE_REPAIR
condition|)
name|pool
operator|.
name|signalSystemStatus
argument_list|(
name|BrokerPool
operator|.
name|SIGNAL_STARTUP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
name|mode
operator|==
name|NodeProcessor
operator|.
name|MODE_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|StoredNode
name|node
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
return|return
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|node
argument_list|,
name|addWhitespace
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|StoredNode
name|objectWith
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|NodeId
name|nodeId
parameter_list|)
block|{
return|return
operator|(
name|StoredNode
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|,
name|nodeId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|nodeId
operator|+
literal|" not found. This is usually not an error."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|StoredNode
name|objectWith
parameter_list|(
specifier|final
name|NodeProxy
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|getInternalAddress
argument_list|()
operator|==
name|StoredNode
operator|.
name|UNKNOWN_NODE_IMPL_ADDRESS
condition|)
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|)
return|;
return|return
operator|(
name|StoredNode
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
comment|// DocumentImpl sets the nodeId to DOCUMENT_NODE when it's trying to find its top-level
comment|// children (for which it doesn't persist the actual node ids), so ignore that.  Nobody else
comment|// should be passing DOCUMENT_NODE into here.
name|boolean
name|fakeNodeId
init|=
name|p
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|NodeId
operator|.
name|DOCUMENT_NODE
argument_list|)
decl_stmt|;
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|p
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" not found in document "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getURI
argument_list|()
operator|+
literal|"; docId = "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|": "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//					LOG.debug(domDb.debugPages(p.doc, true));
comment|//					return null;
if|if
condition|(
name|fakeNodeId
condition|)
return|return
literal|null
return|;
block|}
else|else
block|{
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
name|p
operator|.
name|getDocument
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|p
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakeNodeId
condition|)
return|return
name|node
return|;
if|if
condition|(
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|==
name|node
operator|.
name|getDocId
argument_list|()
operator|&&
name|p
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|p
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" not found in document "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getURI
argument_list|()
operator|+
literal|"; docId = "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|": "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
operator|+
literal|"; found node "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" instead"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// retry based on nodeid
name|StoredNode
name|node
init|=
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|p
operator|.
name|setInternalAddress
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
comment|// update proxy with correct address
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|void
name|repair
parameter_list|()
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing index files ..."
argument_list|)
expr_stmt|;
name|notifyCloseAndRemove
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|removeIndexes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove index failes during repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Recreating index files ..."
argument_list|)
expr_stmt|;
try|try
block|{
name|elementIndex
operator|=
operator|new
name|NativeElementIndex
argument_list|(
name|this
argument_list|,
name|ELEMENTS_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|VALUES_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception during repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|reopenIndexes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DatabaseConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to reopen index files after repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|initIndexModules
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reindexing database files ..."
argument_list|)
expr_stmt|;
comment|//Reindex from root collection
name|reindexCollection
argument_list|(
literal|null
argument_list|,
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
argument_list|,
name|NodeProcessor
operator|.
name|MODE_REPAIR
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|notifyFlush
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|indexController
operator|.
name|flush
argument_list|()
expr_stmt|;
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|sync
parameter_list|(
name|int
name|syncEvent
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
return|return;
try|try
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while flushing dom.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
if|if
condition|(
name|syncEvent
operator|==
name|Sync
operator|.
name|MAJOR_SYNC
condition|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|notifySync
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|sync
argument_list|()
expr_stmt|;
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Memory: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|1024
argument_list|)
operator|+
literal|"K total; "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|maxMemory
argument_list|()
operator|/
literal|1024
argument_list|)
operator|+
literal|"K max; "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
literal|1024
argument_list|)
operator|+
literal|"K free"
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|notifyPrintStatistics
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|dbe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR_SYNC
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|notifyClose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** check available memory */
specifier|public
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|nodesCountThreshold
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
if|if
condition|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|>=
name|run
operator|.
name|maxMemory
argument_list|()
operator|&&
name|run
operator|.
name|freeMemory
argument_list|()
operator|<
name|pool
operator|.
name|getReservedMem
argument_list|()
condition|)
block|{
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|totalMemory
argument_list|()
argument_list|)
operator|+
literal|"; max: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|maxMemory
argument_list|()
argument_list|)
operator|+
literal|"; free: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
operator|+
literal|"; reserved: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|pool
operator|.
name|getReservedMem
argument_list|()
argument_list|)
operator|+
literal|"; used: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|pool
operator|.
name|getCacheManager
argument_list|()
operator|.
name|getSizeInBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|nodesCount
operator|>
name|nodesCountThreshold
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|//TOUNDERSTAND : why not use shutdown ? -pb
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NodeRef
extends|extends
name|Value
block|{
specifier|public
specifier|static
name|int
name|OFFSET_DOCUMENT_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
name|int
name|OFFSET_NODE_ID
init|=
name|OFFSET_DOCUMENT_ID
operator|+
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
decl_stmt|;
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|len
operator|=
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
expr_stmt|;
name|pos
operator|=
name|OFFSET_DOCUMENT_ID
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|,
name|NodeId
name|nodeId
parameter_list|)
block|{
name|len
operator|=
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
operator|+
name|nodeId
operator|.
name|size
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
expr_stmt|;
name|nodeId
operator|.
name|serialize
argument_list|(
name|data
argument_list|,
name|OFFSET_NODE_ID
argument_list|)
expr_stmt|;
name|pos
operator|=
name|OFFSET_DOCUMENT_ID
expr_stmt|;
block|}
name|int
name|getDocId
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|final
specifier|static
class|class
name|RemovedNode
block|{
name|StoredNode
name|node
decl_stmt|;
name|String
name|content
decl_stmt|;
name|NodePath
name|path
decl_stmt|;
name|RemovedNode
parameter_list|(
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|path
parameter_list|,
name|String
name|content
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
block|}
block|}
comment|/** Delegate for Node Processings : indexing */
specifier|private
class|class
name|NodeProcessor
block|{
specifier|final
specifier|static
name|int
name|MODE_STORE
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|MODE_REPAIR
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
name|int
name|MODE_REMOVE
init|=
literal|2
decl_stmt|;
specifier|private
name|Txn
name|transaction
decl_stmt|;
specifier|private
name|StoredNode
name|node
decl_stmt|;
specifier|private
name|NodePath
name|currentPath
decl_stmt|;
comment|/** work variables */
specifier|private
name|DocumentImpl
name|doc
decl_stmt|;
specifier|private
name|long
name|address
decl_stmt|;
specifier|private
name|IndexSpec
name|idxSpec
decl_stmt|;
specifier|private
name|FulltextIndexSpec
name|ftIdx
decl_stmt|;
specifier|private
name|int
name|level
decl_stmt|;
specifier|private
name|int
name|mode
init|=
name|MODE_STORE
decl_stmt|;
comment|/** overall switch to activate fulltext indexation */
specifier|private
name|boolean
name|fullTextIndex
init|=
literal|true
decl_stmt|;
name|NodeProcessor
parameter_list|()
block|{
block|}
specifier|public
name|void
name|reset
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|IndexSpec
name|indexSpec
parameter_list|,
name|boolean
name|fullTextIndex
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"illegal node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : why continue processing ? return ? -pb
name|this
operator|.
name|transaction
operator|=
name|transaction
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|currentPath
operator|=
name|currentPath
expr_stmt|;
name|this
operator|.
name|mode
operator|=
name|MODE_STORE
expr_stmt|;
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
expr_stmt|;
name|address
operator|=
name|node
operator|.
name|getInternalAddress
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexSpec
operator|==
literal|null
condition|)
name|indexSpec
operator|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexConfiguration
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|)
expr_stmt|;
name|idxSpec
operator|=
name|indexSpec
expr_stmt|;
name|ftIdx
operator|=
name|idxSpec
operator|==
literal|null
condition|?
literal|null
else|:
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
expr_stmt|;
name|level
operator|=
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
expr_stmt|;
name|this
operator|.
name|fullTextIndex
operator|=
name|fullTextIndex
expr_stmt|;
block|}
specifier|public
name|void
name|setMode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
comment|/** Updates the various indices */
specifier|public
name|void
name|doIndex
parameter_list|()
block|{
comment|//TODO : resolve URI !
specifier|final
name|boolean
name|isTemp
init|=
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
operator|.
name|equalsInternal
argument_list|(
operator|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|)
operator|.
name|getCollection
argument_list|()
operator|.
name|getURI
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
block|{
comment|//Compute index type
comment|//TODO : let indexers OR it themselves
comment|//we'd need to notify the ElementIndexer at the very end then...
name|int
name|indexType
init|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
operator|&&
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|TEXT
expr_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
operator|&&
name|currentPath
operator|!=
literal|null
operator|&&
name|ftIdx
operator|.
name|matchMixedElement
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|TEXT_MIXED_CONTENT
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|-
name|node
operator|.
name|getAttributesCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|MIXED_CONTENT
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|QNAME_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
name|indexType
operator||=
name|qnIdx
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
block|}
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
comment|//	                    notifyStartElement((ElementImpl)node, currentPath, fullTextIndex);
if|if
condition|(
name|mode
operator|!=
name|MODE_REMOVE
condition|)
block|{
name|NodeProxy
name|p
init|=
operator|new
name|NodeProxy
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|p
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
block|{
name|QName
name|qname
init|=
name|node
operator|.
name|getQName
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|boolean
name|fullTextIndexing
init|=
literal|false
decl_stmt|;
comment|//Compute index type
comment|//TODO : let indexers OR it themselves
comment|//we'd need to notify the ElementIndexer at the very end then...
name|int
name|indexType
init|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
if|if
condition|(
name|fullTextIndex
operator|&&
operator|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|matchAttribute
argument_list|(
name|currentPath
argument_list|)
operator|)
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|TEXT
expr_stmt|;
name|fullTextIndexing
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|RangeIndexSpec
name|rangeSpec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangeSpec
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|rangeSpec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rangeSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|//Oh dear : is it the right semantics then ?
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|rangeSpec
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
block|}
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|QNAME_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
name|indexType
operator||=
name|qnIdx
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|//Oh dear : is it the right semantics then ?
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|qnIdx
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
block|}
block|}
comment|//notifyStoreAttribute((AttrImpl)node, currentPath, NativeValueIndex.WITH_PATH, null);
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|MODE_REMOVE
condition|)
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
name|AttrImpl
name|attr
init|=
operator|(
name|AttrImpl
operator|)
name|node
decl_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|AttrImpl
operator|.
name|ID
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|ID
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREF
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREFS
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// do nothing special
block|}
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|notifyStoreText
argument_list|(
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|fullTextIndex
condition|?
name|NativeTextEngine
operator|.
name|DO_NOT_TOKENIZE
else|:
name|NativeTextEngine
operator|.
name|TOKENIZE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/** Stores this node into the database, if it's an element */
specifier|public
name|void
name|store
parameter_list|()
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_STORE
operator|&&
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|defaultIndexDepth
condition|)
block|{
comment|//TODO : used to be this, but NativeBroker.this avoids an owner change
operator|new
name|DOMTransaction
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** check available memory */
specifier|private
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|mode
operator|!=
name|MODE_REMOVE
operator|&&
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
if|if
condition|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|>=
name|run
operator|.
name|maxMemory
argument_list|()
operator|&&
name|run
operator|.
name|freeMemory
argument_list|()
operator|<
name|pool
operator|.
name|getReservedMem
argument_list|()
condition|)
block|{
comment|//LOG.info(
comment|//  "total memory: " + run.totalMemory() + "; free: " + run.freeMemory());
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Updates the various indices and stores this node into the database */
specifier|public
name|void
name|index
parameter_list|()
block|{
operator|++
name|nodesCount
expr_stmt|;
name|checkAvailableMemory
argument_list|()
expr_stmt|;
name|doIndex
argument_list|()
expr_stmt|;
name|store
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
class|class
name|DocumentCallback
implements|implements
name|BTreeCallback
block|{
specifier|private
name|Collection
name|collection
decl_stmt|;
specifier|public
name|DocumentCallback
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|this
operator|.
name|collection
operator|=
name|collection
expr_stmt|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
try|try
block|{
name|byte
name|type
init|=
name|key
operator|.
name|data
argument_list|()
index|[
name|key
operator|.
name|start
argument_list|()
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
operator|+
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_TYPE
index|]
decl_stmt|;
name|VariableByteInput
name|istream
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|DocumentImpl
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
name|doc
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|pool
argument_list|,
name|collection
argument_list|)
expr_stmt|;
else|else
name|doc
operator|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|collection
argument_list|)
expr_stmt|;
name|doc
operator|.
name|read
argument_list|(
name|istream
argument_list|)
expr_stmt|;
name|collection
operator|.
name|addDocument
argument_list|(
literal|null
argument_list|,
name|NativeBroker
operator|.
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"EOFException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

