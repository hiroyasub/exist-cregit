begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-06 Wolfgang M. Meier  *  wolfgang@exist-db.org  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *   *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|Collator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|BinaryDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ElementImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ExtArrayNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeIndexListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSetHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|StoredNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|TextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DOMIndexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|MD5
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|SecurityManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Paged
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMFileIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|NativeSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArrayPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Collations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|sanity
operator|.
name|SanityCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|StringValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DocumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|/**  *  Main class for the native XML storage backend.  *  By "native" it is meant file-based, embedded backend.  *   * Provides access to all low-level operations required by  * the database. Extends {@link DBBroker}.  *   * Observer Design Pattern: role : this class is the subject (alias observable)  * for various classes that generate indices for the database content :  * @link org.exist.storage.NativeElementIndex,  * @link org.exist.storage.NativeTextEngine,  * @link org.exist.storage.NativeValueIndex,   * @link org.exist.storage.NativeValueIndexByQName  *   * This class dispatches the various events (defined by the methods   * of @link org.exist.storage.ContentLoadingObserver) to indexing classes.  *   *@author     Wolfgang Meier  */
end_comment

begin_class
specifier|public
class|class
name|NativeBroker
extends|extends
name|DBBroker
block|{
specifier|public
specifier|static
specifier|final
name|byte
name|COLLECTIONS_DBX_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|ELEMENTS_DBX_ID
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|VALUES_DBX_ID
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|WORDS_DBX_ID
init|=
literal|3
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|DOM_DBX_ID
init|=
literal|4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|VALUES_QNAME_DBX_ID
init|=
literal|5
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ELEMENTS_DBX
init|=
literal|"elements.dbx"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|VALUES_DBX
init|=
literal|"values.dbx"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|VALUES_QNAME_DBX
init|=
literal|"values-by-qname.dbx"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DOM_DBX
init|=
literal|"dom.dbx"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|COLLECTIONS_DBX
init|=
literal|"collections.dbx"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WORDS_DBX
init|=
literal|"words.dbx"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ALL_STORAGE_FILES
init|=
block|{
name|COLLECTIONS_DBX_ID
block|,
name|ELEMENTS_DBX_ID
block|,
name|VALUES_DBX_ID
block|,
name|VALUES_QNAME_DBX_ID
block|,
name|WORDS_DBX_ID
block|,
name|DOM_DBX_ID
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TEMP_FRAGMENT_REMOVE_ERROR
init|=
literal|"Could not remove temporary fragment"
decl_stmt|;
comment|// private static final String TEMP_STORE_ERROR = "An error occurred while storing temporary data: ";
specifier|private
specifier|static
specifier|final
name|String
name|EXCEPTION_DURING_REINDEX
init|=
literal|"exception during reindex"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DATABASE_IS_READ_ONLY
init|=
literal|"database is read-only"
decl_stmt|;
comment|/**      * Log4J Logger for this class      */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NativeBroker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|final
name|String
name|DEFAULT_DATA_DIR
init|=
literal|"data"
decl_stmt|;
specifier|public
specifier|final
name|int
name|DEFAULT_PAGE_SIZE
init|=
literal|4096
decl_stmt|;
specifier|public
specifier|final
name|int
name|DEFAULT_INDEX_DEPTH
init|=
literal|1
decl_stmt|;
specifier|public
specifier|final
name|int
name|DEFAULT_MIN_MEMORY
init|=
literal|5000000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TEMP_FRAGMENT_TIMEOUT
init|=
literal|300000
decl_stmt|;
comment|/** default buffer size setting */
specifier|public
specifier|final
specifier|static
name|int
name|BUFFERS
init|=
literal|256
decl_stmt|;
comment|/** check available memory after storing DEFAULT_NODES_BEFORE_MEMORY_CHECK nodes */
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
init|=
literal|10000
decl_stmt|;
specifier|public
specifier|final
name|double
name|DEFAULT_VALUE_CACHE_GROWTH
init|=
literal|1.25
decl_stmt|;
specifier|public
specifier|final
name|double
name|DEFAULT_VALUE_KEY_THRESHOLD
init|=
literal|0.01
decl_stmt|;
specifier|public
specifier|final
name|double
name|DEFAULT_VALUE_VALUE_THRESHOLD
init|=
literal|0.04
decl_stmt|;
specifier|public
specifier|final
name|double
name|DEFAULT_WORD_CACHE_GROWTH
init|=
literal|1.4
decl_stmt|;
specifier|public
specifier|final
name|double
name|DEFAULT_WORD_KEY_THRESHOLD
init|=
literal|0.01
decl_stmt|;
specifier|public
specifier|final
name|double
name|DEFAULT_WORD_VALUE_THRESHOLD
init|=
literal|0.015
decl_stmt|;
comment|/** the database files */
specifier|protected
name|CollectionStore
name|collectionsDb
decl_stmt|;
specifier|protected
name|DOMFile
name|domDb
decl_stmt|;
specifier|protected
name|BFile
name|elementsDb
decl_stmt|;
specifier|protected
name|BFile
name|valuesDb
decl_stmt|;
specifier|protected
name|BFile
name|dbWords
decl_stmt|;
specifier|protected
name|BFile
name|valuesDbQname
decl_stmt|;
comment|/** the index processors */
specifier|protected
name|NativeTextEngine
name|textEngine
decl_stmt|;
specifier|protected
name|NativeElementIndex
name|elementIndex
decl_stmt|;
specifier|protected
name|NativeValueIndex
name|valueIndex
decl_stmt|;
specifier|protected
name|NativeValueIndexByQName
name|qnameValueIndex
decl_stmt|;
specifier|protected
name|IndexSpec
name|idxConf
decl_stmt|;
specifier|protected
name|int
name|defaultIndexDepth
decl_stmt|;
comment|/** switch to activate/deactivate the feature "new index by QName" */
specifier|private
name|boolean
name|qnameValueIndexation
init|=
literal|true
decl_stmt|;
comment|// false;
specifier|protected
name|Serializer
name|xmlSerializer
decl_stmt|;
specifier|protected
name|boolean
name|readOnly
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|memMinFree
decl_stmt|;
comment|/** used to count the nodes inserted after the last memory check */
specifier|protected
name|int
name|nodesCount
init|=
literal|0
decl_stmt|;
specifier|protected
name|String
name|dataDir
decl_stmt|;
specifier|protected
name|int
name|pageSize
decl_stmt|;
specifier|private
specifier|final
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
specifier|private
name|NodeProcessor
name|nodeProcessor
init|=
operator|new
name|NodeProcessor
argument_list|()
decl_stmt|;
comment|/** initialize database; read configuration, etc. */
specifier|public
name|NativeBroker
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|Configuration
name|config
parameter_list|)
throws|throws
name|EXistException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing broker "
operator|+
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|dataDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.data-dir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
name|dataDir
operator|=
name|DEFAULT_DATA_DIR
expr_stmt|;
name|pageSize
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.page-size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pageSize
operator|<
literal|0
condition|)
name|pageSize
operator|=
name|DEFAULT_PAGE_SIZE
expr_stmt|;
name|Paged
operator|.
name|setPageSize
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
name|defaultIndexDepth
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"indexer.index-depth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultIndexDepth
operator|<
literal|0
condition|)
name|defaultIndexDepth
operator|=
name|DEFAULT_INDEX_DEPTH
expr_stmt|;
name|memMinFree
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.min_free_memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memMinFree
operator|<
literal|0
condition|)
name|memMinFree
operator|=
name|DEFAULT_MIN_MEMORY
expr_stmt|;
name|idxConf
operator|=
operator|(
name|IndexSpec
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"indexer.config"
argument_list|)
expr_stmt|;
name|xmlSerializer
operator|=
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|user
operator|=
name|SecurityManager
operator|.
name|SYSTEM_USER
expr_stmt|;
try|try
block|{
comment|// Initialize DOM storage
name|domDb
operator|=
operator|(
name|DOMFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.dom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|domDb
operator|==
literal|null
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|DOM_DBX
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating '"
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
name|domDb
operator|=
operator|new
name|DOMFile
argument_list|(
name|pool
argument_list|,
name|file
argument_list|,
name|pool
operator|.
name|getCacheManager
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.dom"
argument_list|,
name|domDb
argument_list|)
expr_stmt|;
block|}
name|readOnly
operator|=
name|readOnly
operator|&
name|domDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
comment|// Initialize collections storage
name|collectionsDb
operator|=
operator|(
name|CollectionStore
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.collections"
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectionsDb
operator|==
literal|null
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|COLLECTIONS_DBX
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating '"
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
name|collectionsDb
operator|=
operator|new
name|CollectionStore
argument_list|(
name|pool
argument_list|,
name|file
argument_list|,
name|pool
operator|.
name|getCacheManager
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.collections"
argument_list|,
name|collectionsDb
argument_list|)
expr_stmt|;
block|}
name|readOnly
operator|=
name|readOnly
operator|&
name|collectionsDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
comment|//TODO : is it necessary to create them if we are in read-only mode ?
name|createIndexFiles
argument_list|()
expr_stmt|;
if|if
condition|(
name|readOnly
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Database runs in read-only mode"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|createIndexFiles
parameter_list|()
throws|throws
name|DBException
block|{
name|elementsDb
operator|=
name|createValueIndexFile
argument_list|(
name|ELEMENTS_DBX_ID
argument_list|,
literal|false
argument_list|,
name|config
argument_list|,
name|dataDir
argument_list|,
name|ELEMENTS_DBX
argument_list|,
literal|"db-connection.elements"
argument_list|,
name|DEFAULT_VALUE_VALUE_THRESHOLD
argument_list|)
expr_stmt|;
name|elementIndex
operator|=
operator|new
name|NativeElementIndex
argument_list|(
name|this
argument_list|,
name|elementsDb
argument_list|)
expr_stmt|;
name|addContentLoadingObserver
argument_list|(
name|elementIndex
argument_list|)
expr_stmt|;
name|valuesDb
operator|=
name|createValueIndexFile
argument_list|(
name|VALUES_DBX_ID
argument_list|,
literal|false
argument_list|,
name|config
argument_list|,
name|dataDir
argument_list|,
name|VALUES_DBX
argument_list|,
literal|"db-connection.values"
argument_list|,
name|DEFAULT_VALUE_VALUE_THRESHOLD
argument_list|)
expr_stmt|;
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|valuesDb
argument_list|)
expr_stmt|;
name|addContentLoadingObserver
argument_list|(
name|valueIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnameValueIndexation
condition|)
block|{
name|valuesDbQname
operator|=
name|createValueIndexFile
argument_list|(
name|VALUES_QNAME_DBX_ID
argument_list|,
literal|false
argument_list|,
name|config
argument_list|,
name|dataDir
argument_list|,
name|VALUES_QNAME_DBX
argument_list|,
literal|"db-connection2.values"
argument_list|,
name|DEFAULT_VALUE_VALUE_THRESHOLD
argument_list|)
expr_stmt|;
name|qnameValueIndex
operator|=
operator|new
name|NativeValueIndexByQName
argument_list|(
name|this
argument_list|,
name|valuesDbQname
argument_list|)
expr_stmt|;
name|addContentLoadingObserver
argument_list|(
name|qnameValueIndex
argument_list|)
expr_stmt|;
block|}
name|dbWords
operator|=
operator|(
name|BFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.words"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbWords
operator|==
literal|null
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|WORDS_DBX
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating '"
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
name|dbWords
operator|=
operator|new
name|BFile
argument_list|(
name|pool
argument_list|,
name|NativeBroker
operator|.
name|WORDS_DBX_ID
argument_list|,
literal|false
argument_list|,
name|file
argument_list|,
name|pool
operator|.
name|getCacheManager
argument_list|()
argument_list|,
name|DEFAULT_WORD_CACHE_GROWTH
argument_list|,
name|DEFAULT_WORD_KEY_THRESHOLD
argument_list|,
name|DEFAULT_WORD_VALUE_THRESHOLD
argument_list|)
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.words"
argument_list|,
name|dbWords
argument_list|)
expr_stmt|;
block|}
name|textEngine
operator|=
operator|new
name|NativeTextEngine
argument_list|(
name|this
argument_list|,
name|config
argument_list|,
name|dbWords
argument_list|)
expr_stmt|;
name|addContentLoadingObserver
argument_list|(
name|textEngine
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|readOnly
operator|&
name|dbWords
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
specifier|private
name|BFile
name|createValueIndexFile
parameter_list|(
name|byte
name|id
parameter_list|,
name|boolean
name|transactional
parameter_list|,
name|Configuration
name|config
parameter_list|,
name|String
name|dataDir
parameter_list|,
name|String
name|dataFile
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|double
name|thresholdData
parameter_list|)
throws|throws
name|DBException
block|{
name|BFile
name|db
init|=
operator|(
name|BFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|==
literal|null
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|dataFile
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating '"
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
name|db
operator|=
operator|new
name|BFile
argument_list|(
name|pool
argument_list|,
name|id
argument_list|,
name|transactional
argument_list|,
name|file
argument_list|,
name|pool
operator|.
name|getCacheManager
argument_list|()
argument_list|,
name|DEFAULT_VALUE_CACHE_GROWTH
argument_list|,
name|DEFAULT_VALUE_KEY_THRESHOLD
argument_list|,
name|thresholdData
argument_list|)
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
name|propertyName
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
name|readOnly
operator|=
name|readOnly
operator|&
name|db
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
return|return
name|db
return|;
block|}
comment|/** Observer Design Pattern: List of ContentLoadingObserver objects */
specifier|private
name|List
name|contentLoadingObservers
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|public
name|void
name|addObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
name|super
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|deleteObservers
parameter_list|()
block|{
name|super
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
if|if
condition|(
name|elementIndex
operator|!=
literal|null
condition|)
name|elementIndex
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
if|if
condition|(
name|textEngine
operator|!=
literal|null
condition|)
name|textEngine
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
block|}
comment|/** Remove all observers */
specifier|public
name|void
name|clearContentLoadingObservers
parameter_list|()
block|{
name|contentLoadingObservers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Observer Design Pattern: add an observer. */
specifier|public
name|void
name|addContentLoadingObserver
parameter_list|(
name|ContentLoadingObserver
name|observer
parameter_list|)
block|{
name|contentLoadingObservers
operator|.
name|add
argument_list|(
name|observer
argument_list|)
expr_stmt|;
block|}
comment|/** Observer Design Pattern: remove an observer. */
specifier|public
name|void
name|removeContentLoadingObserver
parameter_list|(
name|ContentLoadingObserver
name|observer
parameter_list|)
block|{
name|contentLoadingObservers
operator|.
name|remove
argument_list|(
name|observer
argument_list|)
expr_stmt|;
block|}
comment|// ============ dispatch the various events to indexing classes ==========
specifier|private
name|void
name|notifyStartElement
parameter_list|(
name|ElementImpl
name|elem
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
comment|// WM: don't use an iterator here. The method may be called a few million times for a single document.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|startElement
argument_list|(
name|elem
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyRemoveElement
parameter_list|(
name|ElementImpl
name|elem
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|removeElement
argument_list|(
name|elem
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyStoreAttribute
parameter_list|(
name|AttrImpl
name|attr
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyStoreText
parameter_list|(
name|TextImpl
name|text
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|storeText
argument_list|(
name|text
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyFlush
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifySync
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyReindex
parameter_list|(
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyRemove
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ContentLoadingObserver
name|observer
init|=
operator|(
name|ContentLoadingObserver
operator|)
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// etc ... TODO for all methods of ContentLoadingObserver
comment|/**      * Update indexes for the given element node. This method is called when the indexer      * encounters a closing element tag. It updates any range indexes defined on the      * element value and adds the element id to the structural index.      *       * @param node the current element node      * @param currentPath node path leading to the element      * @param content contains the string value of the element. Needed if a range index      * is defined on it.      */
specifier|public
name|void
name|endElement
parameter_list|(
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|,
name|long
name|oldAddress
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
comment|//      tempProxy.reset(doc, node.getGID(), node.getInternalAddress());
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
comment|//      final IndexSpec idxSpec =
comment|//          doc.getCollection().getIdxConf(this);
specifier|final
name|int
name|indexType
init|=
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|node
operator|.
name|getQName
argument_list|()
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
comment|// TODO move_to NativeValueIndex
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|oldAddress
operator|!=
name|StoredNode
operator|.
name|UNKNOWN_NODE_IMPL_ADDRESS
condition|)
name|tempProxy
operator|.
name|setInternalAddress
argument_list|(
name|oldAddress
argument_list|)
expr_stmt|;
name|content
operator|=
name|getNodeValue
argument_list|(
name|tempProxy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tempProxy
operator|.
name|setInternalAddress
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO move_to NativeValueIndexByQName
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasQNameIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
comment|//          RangeIndexSpec qnIdx = idxSpec.getIndexByQName(node.getQName());
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|oldAddress
operator|!=
name|StoredNode
operator|.
name|UNKNOWN_NODE_IMPL_ADDRESS
condition|)
name|tempProxy
operator|.
name|setInternalAddress
argument_list|(
name|oldAddress
argument_list|)
expr_stmt|;
name|content
operator|=
name|getNodeValue
argument_list|(
name|tempProxy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tempProxy
operator|.
name|setInternalAddress
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//          qnameValueIndex.setDocument(doc);
comment|//          qnameValueIndex.storeElement(qnIdx.getType(),
comment|//                  (ElementImpl) node, content.toString());
if|if
condition|(
name|qnameValueIndex
operator|!=
literal|null
condition|)
name|qnameValueIndex
operator|.
name|endElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
comment|// notifyEndElement((ElementImpl) node, currentPath, content);
block|}
comment|//       TODO move_to NativeElementIndex; name change (See ContentLoadingObserver ): addRow() --> endElement()
comment|// save element by calling ElementIndex
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
comment|/** Takes care of actually remove entries from the indices;      * must be called after one or more call to {@link #removeNode()}. */
specifier|public
name|void
name|endRemove
parameter_list|()
block|{
name|notifyRemove
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|getBackendType
parameter_list|()
block|{
return|return
name|NATIVE
return|;
block|}
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
specifier|public
name|int
name|getPageSize
parameter_list|()
block|{
return|return
name|pageSize
return|;
block|}
specifier|public
name|DOMFile
name|getDOMFile
parameter_list|()
block|{
return|return
name|domDb
return|;
block|}
specifier|public
name|BTree
name|getStorage
parameter_list|(
name|byte
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|COLLECTIONS_DBX_ID
case|:
return|return
name|collectionsDb
return|;
case|case
name|ELEMENTS_DBX_ID
case|:
return|return
name|elementsDb
return|;
case|case
name|WORDS_DBX_ID
case|:
return|return
name|dbWords
return|;
case|case
name|VALUES_DBX_ID
case|:
return|return
name|valuesDb
return|;
case|case
name|VALUES_QNAME_DBX_ID
case|:
return|return
name|valuesDbQname
return|;
case|case
name|DOM_DBX_ID
case|:
return|return
name|domDb
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|byte
index|[]
name|getStorageFileIds
parameter_list|()
block|{
return|return
name|ALL_STORAGE_FILES
return|;
block|}
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|()
block|{
return|return
name|idxConf
return|;
block|}
specifier|public
name|Serializer
name|getSerializer
parameter_list|()
block|{
name|xmlSerializer
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|xmlSerializer
return|;
block|}
specifier|public
name|Serializer
name|newSerializer
parameter_list|()
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|ElementIndex
name|getElementIndex
parameter_list|()
block|{
return|return
name|elementIndex
return|;
block|}
specifier|public
name|NativeValueIndex
name|getValueIndex
parameter_list|()
block|{
return|return
name|valueIndex
return|;
block|}
specifier|public
name|NativeValueIndexByQName
name|getQNameValueIndex
parameter_list|()
block|{
return|return
name|qnameValueIndex
return|;
block|}
specifier|public
name|TextSearchEngine
name|getTextEngine
parameter_list|()
block|{
return|return
name|textEngine
return|;
block|}
specifier|public
name|Iterator
name|getDOMIterator
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|DOMFileIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|proxy
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create DOM iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create DOM iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Iterator
name|getNodeIterator
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
comment|//      domDb.setOwnerObject(this);
try|try
block|{
return|return
operator|new
name|NodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|proxy
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** create temporary collection */
specifier|private
name|Collection
name|createTempCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
name|User
name|u
init|=
name|user
decl_stmt|;
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|user
operator|=
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getUser
argument_list|(
name|SecurityManager
operator|.
name|DBA_USER
argument_list|)
expr_stmt|;
name|Collection
name|temp
init|=
name|getOrCreateCollection
argument_list|(
name|transaction
argument_list|,
name|TEMP_COLLECTION
argument_list|)
decl_stmt|;
name|temp
operator|.
name|setPermissions
argument_list|(
literal|0771
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
finally|finally
block|{
name|user
operator|=
name|u
expr_stmt|;
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** remove temporary collection */
specifier|public
name|void
name|cleanUpTempCollection
parameter_list|()
block|{
name|Collection
name|temp
init|=
name|getCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|txn
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|txn
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|name
operator|=
name|XmldbURI
operator|.
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
try|try
block|{
comment|//TODO : use dedicated function in XmldbURI
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|temp
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|ROOT_COLLECTION
decl_stmt|;
name|Collection
name|sub
decl_stmt|;
name|Collection
name|current
init|=
name|getCollection
argument_list|(
name|ROOT_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating root collection '"
operator|+
name|ROOT_COLLECTION
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|Collection
argument_list|(
name|ROOT_COLLECTION
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setPermissions
argument_list|(
literal|0777
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|user
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
name|current
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
name|transaction
operator|.
name|acquireLock
argument_list|(
name|current
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|temp
operator|=
name|tok
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|path
operator|=
name|path
operator|+
literal|"/"
operator|+
name|temp
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasSubcollection
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|current
operator|=
name|getCollection
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Collection '"
operator|+
name|path
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Permission denied to create collection '"
operator|+
name|path
operator|+
literal|"'"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"User '"
operator|+
name|user
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to write to collection '"
operator|+
name|current
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating collection '"
operator|+
name|path
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
name|sub
operator|=
operator|new
name|Collection
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|user
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
name|transaction
operator|.
name|acquireLock
argument_list|(
name|sub
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|current
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|sub
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|sub
expr_stmt|;
block|}
block|}
return|return
name|current
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|name
argument_list|,
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|addr
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|name
argument_list|,
name|addr
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|name
argument_list|,
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|,
name|lockMode
argument_list|)
return|;
block|}
comment|/** 	 *  Get collection object. If the collection does not exist, null is 	 *  returned. 	 * 	 *@param  name  collection name 	 *@return       The collection value 	 */
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|addr
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
name|name
operator|=
name|XmldbURI
operator|.
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Collection
name|collection
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|collection
operator|=
name|collectionsCache
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|VariableByteInput
name|is
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|collection
operator|=
operator|new
name|Collection
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|collection
operator|.
name|read
argument_list|(
name|this
argument_list|,
name|is
argument_list|)
expr_stmt|;
comment|//TODO : manage this from within the cache -pb
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//TODO : rethrow exceptions ? -pb
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to encode '"
operator|+
name|name
operator|+
literal|"' in UTF-8"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|//Important :
comment|//This code must remain ouside of the synchonized block
comment|//because another thread may already own a lock on the collection
comment|//This would result in a deadlock... until the time-out raises the Exception
comment|//TODO : make an attempt to an immediate lock ?
comment|//TODO : manage a collection of requests for locks ?
comment|//TODO : another yet smarter solution ?
if|if
condition|(
name|lockMode
operator|!=
name|Lock
operator|.
name|NO_LOCK
condition|)
block|{
try|try
block|{
name|collection
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on collection '"
operator|+
name|name
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|collection
return|;
block|}
specifier|public
name|void
name|copyCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Read permission denied on collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
comment|///TODO : use dedicated function in XmldbURI
name|int
name|p
init|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|newName
operator|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|///TODO : use dedicated function in XmldbURI
if|if
condition|(
name|newName
operator|.
name|indexOf
argument_list|(
literal|"/"
argument_list|)
operator|!=
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name is illegal (may not contain a '/')"
argument_list|)
throw|;
comment|//  check if another collection with the same name exists at the destination
comment|//TODO : use dedicated function in XmldbURI
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|newName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old collection: "
operator|+
name|newName
argument_list|)
expr_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Collection
name|destCollection
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|///TODO : use dedicated function in XmldbURI
name|newName
operator|=
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|newName
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying collection to '"
operator|+
name|newName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|destCollection
operator|=
name|getOrCreateCollection
argument_list|(
name|transaction
argument_list|,
name|newName
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|child
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying resource: '"
operator|+
name|child
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|destCollection
argument_list|,
name|child
operator|.
name|getFileName
argument_list|()
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BinaryDocument
name|newDoc
init|=
operator|new
name|BinaryDocument
argument_list|(
name|this
argument_list|,
name|child
operator|.
name|getFileName
argument_list|()
argument_list|,
name|destCollection
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data
init|=
name|getBinaryResource
argument_list|(
operator|(
name|BinaryDocument
operator|)
name|child
argument_list|)
decl_stmt|;
name|storeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|childName
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|///TODO : use dedicated function in XmldbURI
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|name
operator|+
literal|"/"
operator|+
name|childName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection '"
operator|+
name|childName
operator|+
literal|"' not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|copyCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|destCollection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destCollection
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|moveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move the db root collection"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
comment|///TODO : use dedicated function in XmldbURI
name|int
name|p
init|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|newName
operator|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newName
operator|.
name|indexOf
argument_list|(
literal|"/"
argument_list|)
operator|!=
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name is illegal (may not contain a '/')"
argument_list|)
throw|;
comment|// check if another collection with the same name exists at the destination
comment|//TODO : use dedicated function in XmldbURI
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|newName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentPath
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|removeCollection
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|parent
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Value
name|key
decl_stmt|;
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|///TODO : use dedicated function in XmldbURI
name|collection
operator|.
name|setName
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|newName
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|collection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|destination
condition|)
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|String
name|childName
decl_stmt|;
name|Collection
name|child
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childName
operator|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
comment|///TODO : use dedicated function in XmldbURI
name|child
operator|=
name|openCollection
argument_list|(
name|name
operator|+
literal|"/"
operator|+
name|childName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection "
operator|+
name|childName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|moveCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|collection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|public
name|boolean
name|removeCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"User '"
operator|+
name|user
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
specifier|final
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isRoot
init|=
name|collection
operator|.
name|getParentPath
argument_list|()
operator|==
literal|null
decl_stmt|;
comment|//Drop all index entries
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
comment|// remove from parent collection
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentPath
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
comment|// keep the lock for the transaction
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
name|transaction
operator|.
name|registerLock
argument_list|(
name|parent
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection '"
operator|+
name|name
operator|+
literal|"' from its parent..."
argument_list|)
expr_stmt|;
comment|//TODO : resolve from collection's base URI
name|parent
operator|.
name|removeCollection
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"LockException while removing collection '"
operator|+
name|name
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|transaction
operator|==
literal|null
condition|)
name|collection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// remove child collections
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing children collections from their parent '"
operator|+
name|name
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|String
name|childName
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve from collection's base URI
name|Collection
name|childCollection
init|=
name|openCollection
argument_list|(
name|name
operator|+
literal|"/"
operator|+
name|childName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|childCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|childCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|//Update current state
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// if this is not the root collection remove it...
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
name|Value
name|key
decl_stmt|;
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|//TODO : real exception ; we are in trouble ! -pb
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not encode '"
operator|+
name|name
operator|+
literal|"' in UTF-8"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//... from the disk
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//... from the cache
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//and free its id for any futher use
name|freeCollectionId
argument_list|(
name|transaction
argument_list|,
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Simply save the collection on disk
comment|//It will remain cached
comment|//and its id well never be made available
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on '"
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|//Remove child resources
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing resources in '"
operator|+
name|name
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//Remove doc's metadata
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|//Remove document nodes' index entries
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//Remove nodes themselves
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
name|transaction
argument_list|,
operator|(
operator|(
name|BinaryDocument
operator|)
name|doc
operator|)
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|doc
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//Make doc's id available again
name|freeResourceId
argument_list|(
name|transaction
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection '"
operator|+
name|name
operator|+
literal|"' took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Saves the specified collection to storage. Collections are usually cached in      * memory. If a collection is modified, this method needs to be called to make      * the changes persistent.      *       * Note: appending a new document to a collection does not require a save.      * Instead, {@link #addDocument(Collection, DocumentImpl)} is called.      */
specifier|public
name|void
name|saveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
comment|// don't cache the collection during initialization: SecurityManager is not yet online
name|pool
operator|.
name|getCollectionsCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
name|collection
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
name|Value
name|name
decl_stmt|;
try|try
block|{
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|uee
argument_list|)
expr_stmt|;
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|collection
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
specifier|final
name|long
name|addr
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
comment|//TODO : exception !!! -pb
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not store collection data for '"
operator|+
name|collection
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Release the collection id assigned to a collection so it can be      * reused later.      *       * @param id      * @throws PermissionDeniedException      */
specifier|protected
name|void
name|freeCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|short
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|CollectionStore
operator|.
name|FREE_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|2
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Get the next free collection id. If a collection is removed, its collection id      * is released so it can be reused.      *       * @return      * @throws ReadOnlyException      */
specifier|public
name|short
name|getFreeCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|short
name|freeCollectionId
init|=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|CollectionStore
operator|.
name|FREE_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|//              LOG.debug("reusing collection id: " + freeCollectionId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|2
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|freeCollectionId
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Get the next available unique collection id.      *       * @return      * @throws ReadOnlyException      */
specifier|public
name|short
name|getNextCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|short
name|nextCollectionId
init|=
name|getFreeCollectionId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextCollectionId
operator|!=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
return|return
name|nextCollectionId
return|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|CollectionStore
operator|.
name|NEXT_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|nextCollectionId
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|String
name|collectionName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collectionName
operator|.
name|startsWith
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
name|collectionName
operator|=
name|ROOT_COLLECTION
operator|+
name|collectionName
expr_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collectionName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|reindexCollection
argument_list|(
name|collection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|boolean
name|repairMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
name|repairMode
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred during reindex: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|boolean
name|repairMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reindexing collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repairMode
condition|)
name|dropCollectionIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|next
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|next
argument_list|,
name|repairMode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|next
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|///TODO : use dedicated function in XmldbURI
name|Collection
name|child
init|=
name|getCollection
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection '"
operator|+
name|next
operator|+
literal|"' not found"
argument_list|)
expr_stmt|;
else|else
block|{
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|repairMode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|dropCollectionIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dropping index for document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** store into the temporary collection of the database a given in-memory Document */
specifier|public
name|DocumentImpl
name|storeTempResource
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
name|user
operator|=
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getUser
argument_list|(
name|SecurityManager
operator|.
name|DBA_USER
argument_list|)
expr_stmt|;
name|String
name|docName
init|=
name|MD5
operator|.
name|md
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|".xml"
decl_stmt|;
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
name|temp
operator|=
name|createTempCollection
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
else|else
name|transaction
operator|.
name|registerLock
argument_list|(
name|temp
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|DocumentImpl
name|targetDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|temp
argument_list|)
decl_stmt|;
name|targetDoc
operator|.
name|setFileName
argument_list|(
name|docName
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setPermissions
argument_list|(
literal|0771
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|DocumentMetadata
name|metadata
init|=
operator|new
name|DocumentMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setLastModified
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|DOMIndexer
name|indexer
init|=
operator|new
name|DOMIndexer
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|targetDoc
argument_list|)
decl_stmt|;
name|indexer
operator|.
name|scan
argument_list|()
expr_stmt|;
name|indexer
operator|.
name|store
argument_list|()
expr_stmt|;
name|temp
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
return|return
name|targetDoc
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** remove all documents from temporary collection */
specifier|public
name|void
name|cleanUpTempResources
parameter_list|()
block|{
name|Collection
name|temp
init|=
name|getCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|txn
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|temp
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|next
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|modified
init|=
name|next
operator|.
name|getMetadata
argument_list|()
operator|.
name|getLastModified
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|modified
operator|>
name|TEMP_FRAGMENT_TIMEOUT
condition|)
try|try
block|{
name|temp
operator|.
name|removeXMLResource
argument_list|(
name|txn
argument_list|,
name|this
argument_list|,
name|next
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|transact
operator|.
name|commit
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Transaction aborted: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** remove from the temporary collection of the database a given list of Documents. */
specifier|public
name|void
name|cleanUpTempResources
parameter_list|(
name|List
name|docs
parameter_list|)
block|{
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
name|Txn
name|txn
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
name|txn
operator|.
name|registerLock
argument_list|(
name|temp
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|temp
operator|.
name|removeXMLResource
argument_list|(
name|txn
argument_list|,
name|this
argument_list|,
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|txn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|txn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** store Document entry into its collection. */
specifier|public
name|void
name|storeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|write
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|long
name|metaPointer
init|=
name|collectionsDb
operator|.
name|storeValue
argument_list|(
name|transaction
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|ostream
operator|.
name|clear
argument_list|()
expr_stmt|;
name|doc
operator|.
name|setMetadataLocation
argument_list|(
name|metaPointer
argument_list|)
expr_stmt|;
name|doc
operator|.
name|write
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|DocumentKey
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while writing document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing binary resource "
operator|+
name|blob
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
name|blob
operator|.
name|setPage
argument_list|(
name|domDb
operator|.
name|addBinary
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
comment|/**      *  get a document by its file name. The document's file name is used to      *  identify a document.      *      *@param  fileName absolute file name in the database;       *name can be given with or without the leading path /db/shakespeare.      *@return  The document value      *@exception  PermissionDeniedException        */
specifier|public
name|Document
name|getXMLResource
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|fileName
operator|=
name|XmldbURI
operator|.
name|checkPath2
argument_list|(
name|fileName
argument_list|,
name|ROOT_COLLECTION
argument_list|)
expr_stmt|;
comment|//TODO : use dedicated function in XmldbURI
name|int
name|pos
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|collName
init|=
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|String
name|docName
init|=
name|fileName
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '"
operator|+
name|collName
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection '"
operator|+
name|collName
operator|+
literal|"'"
argument_list|)
throw|;
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|docName
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document '"
operator|+
name|fileName
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//      if (!doc.getPermissions().validate(user, Permission.READ))
comment|//          throw new PermissionDeniedException("not allowed to read document");
return|return
name|doc
return|;
block|}
specifier|public
name|DocumentImpl
name|getXMLResource
parameter_list|(
name|String
name|fileName
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|fileName
operator|=
name|XmldbURI
operator|.
name|checkPath2
argument_list|(
name|fileName
argument_list|,
name|ROOT_COLLECTION
argument_list|)
expr_stmt|;
comment|///TODO : use dedicated function in XmldbURI
name|int
name|pos
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|collName
init|=
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|String
name|docName
init|=
name|fileName
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Collection
name|collection
init|=
name|openCollection
argument_list|(
name|collName
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '"
operator|+
name|collName
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to read collection '"
operator|+
name|collName
operator|+
literal|"'"
argument_list|)
throw|;
try|try
block|{
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|docName
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document '"
operator|+
name|fileName
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//      if (!doc.getPermissions().validate(user, Permission.READ))
comment|//          throw new PermissionDeniedException("not allowed to read document");
return|return
name|doc
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not acquire lock on document "
operator|+
name|fileName
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : exception ? -pb
block|}
finally|finally
block|{
comment|//TOUNDERSTAND : by whom is this lock acquired ? -pb
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
name|collection
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|byte
index|[]
name|getBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
operator|(
name|byte
index|[]
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
return|return
name|domDb
operator|.
name|getBinary
argument_list|(
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
decl_stmt|;
return|return
name|data
return|;
block|}
comment|//TODO : consider a better cooperation with Collection -pb
specifier|public
name|void
name|getCollectionResources
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|DocumentKey
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
operator|new
name|DocumentCallback
argument_list|(
name|collection
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *  get all the documents in this database matching the given      *  document-type's name.      *      *@param  doctypeName  Description of the Parameter      *@param  user         Description of the Parameter      *@return              The documentsByDoctype value      */
specifier|public
name|DocumentSet
name|getXMLResourcesByDoctype
parameter_list|(
name|String
name|doctypeName
parameter_list|,
name|DocumentSet
name|result
parameter_list|)
block|{
name|DocumentSet
name|docs
init|=
name|getAllXMLResources
argument_list|(
operator|new
name|DocumentSet
argument_list|()
argument_list|)
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|DocumentType
name|doctype
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|doctype
operator|=
name|doc
operator|.
name|getDoctype
argument_list|()
expr_stmt|;
if|if
condition|(
name|doctype
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|doctypeName
operator|.
name|equals
argument_list|(
name|doctype
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
operator|&&
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      *  Adds all the documents in the database to the specified DocumentSet.      *      * @param docs a (possibly empty) document set to which the found      *  documents are added.      */
specifier|public
name|DocumentSet
name|getAllXMLResources
parameter_list|(
name|DocumentSet
name|docs
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
name|root
init|=
literal|null
decl_stmt|;
try|try
block|{
name|root
operator|=
name|openCollection
argument_list|(
name|ROOT_COLLECTION
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|root
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getAllDocuments(DocumentSet) - end - "
operator|+
literal|"loading "
operator|+
name|docs
operator|.
name|getLength
argument_list|()
operator|+
literal|" documents from "
operator|+
name|docs
operator|.
name|getCollectionCount
argument_list|()
operator|+
literal|"collections took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
finally|finally
block|{
name|root
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|//TODO : consider a better cooperation with Collection -pb
specifier|public
name|void
name|getResourceMetadata
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|SanityCheck
operator|.
name|ASSERT
argument_list|(
name|doc
operator|.
name|getMetadataLocation
argument_list|()
operator|!=
name|StoredNode
operator|.
name|UNKNOWN_NODE_IMPL_ADDRESS
argument_list|,
literal|"Missing pointer to metadata location in document "
operator|+
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|VariableByteInput
name|istream
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|doc
operator|.
name|getMetadataLocation
argument_list|()
argument_list|)
decl_stmt|;
name|DocumentMetadata
name|metadata
init|=
operator|new
name|DocumentMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|read
argument_list|(
name|istream
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|copyXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to copy resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to copy resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
comment|///TODO : use dedicated function in XmldbURI
name|int
name|p
init|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|newName
operator|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// check if the move would overwrite a collection
comment|///TODO : use dedicated function in XmldbURI
if|if
condition|(
name|getCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|newName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource can not replace an existing collection"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy resource to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
name|destination
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
else|else
name|destination
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|getBinaryResource
argument_list|(
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
decl_stmt|;
name|destination
operator|.
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newName
argument_list|,
name|data
argument_list|,
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getMimeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setPermissions
argument_list|(
name|doc
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
comment|//          saveCollection(destination);
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred while copying resource"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|copyXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|oldDoc
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying document "
operator|+
name|oldDoc
operator|.
name|getFileName
argument_list|()
operator|+
literal|" to "
operator|+
name|newDoc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Iterator
name|iterator
decl_stmt|;
name|NodeList
name|nodes
init|=
name|oldDoc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|StoredNode
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|oldDoc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|newDoc
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copy took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
comment|/** move Resource to another collection, with possible rename */
specifier|public
name|void
name|moveXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
comment|//TODO : somewhat inconsistent (READ is enough for original doc whereas WRITE is mandatory for destination) -pb
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
name|User
name|docUser
init|=
name|doc
operator|.
name|getUserLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|docUser
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|user
operator|.
name|getName
argument_list|()
operator|)
operator|.
name|equals
argument_list|(
name|docUser
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move '"
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
operator|+
literal|" because is locked by user '"
operator|+
name|docUser
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
comment|///TODO : use dedicated function in XmldbURI
name|int
name|p
init|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|newName
operator|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// check if the move would overwrite a collection
comment|///TODO : use dedicated function in XmldbURI
if|if
condition|(
name|getCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|newName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource can not replace an existing collection"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move resource to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
name|oldDoc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
name|destination
operator|.
name|removeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
else|else
name|destination
operator|.
name|removeXMLResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|oldDoc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else                 if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|boolean
name|renameOnly
init|=
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
decl_stmt|;
name|collection
operator|.
name|unlinkDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
name|notifyDropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
comment|// reindexing
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// binary resource
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|,
name|boolean
name|freeDocId
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing document "
operator|+
name|document
operator|.
name|getFileName
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
block|}
name|notifyDropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - removing dom"
argument_list|)
expr_stmt|;
block|}
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|document
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeDocId
condition|)
name|freeResourceId
argument_list|(
name|transaction
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeDocument(String) - "
operator|+
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"removing binary resource "
operator|+
name|blob
operator|.
name|getDocId
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
name|transaction
argument_list|,
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param transaction      * @param document      */
specifier|private
name|void
name|removeResourceMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
comment|// remove document metadata
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|DocumentKey
argument_list|(
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|document
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Release the document id reserved for a document so it 	 * can be reused. 	 *  	 * @param id 	 * @throws PermissionDeniedException 	 */
specifier|protected
name|void
name|freeResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|CollectionStore
operator|.
name|FREE_DOC_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|4
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Get the next unused document id. If a document is removed, its doc id is 	 * released, so it can be reused. 	 *  	 * @return 	 * @throws ReadOnlyException 	 */
specifier|public
name|int
name|getFreeResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeDocId
init|=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|CollectionStore
operator|.
name|FREE_DOC_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//				LOG.debug("reusing document id: " + freeDocId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|4
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|//TODO : maybe something ? -pb
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|freeDocId
return|;
block|}
comment|/** get next Free Doc Id */
specifier|public
name|int
name|getNextResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
block|{
name|int
name|nextDocId
decl_stmt|;
try|try
block|{
name|nextDocId
operator|=
name|getFreeResourceId
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
comment|//TODO : rethrow ? -pb
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nextDocId
operator|!=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
condition|)
return|return
name|nextDocId
return|;
else|else
name|nextDocId
operator|=
literal|1
expr_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
name|CollectionStore
operator|.
name|NEXT_DOC_ID_KEY
argument_list|)
decl_stmt|;
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"database read-only"
argument_list|)
expr_stmt|;
return|return
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextDocId
return|;
block|}
comment|/**      * Reindex the nodes in the document. This method will either reindex all      * descendant nodes of the passed node, or all nodes below some level of      * the document if node is null.      */
specifier|public
name|void
name|reindexXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|)
block|{
name|int
name|idxLevel
init|=
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|reindexRequired
argument_list|()
decl_stmt|;
if|if
condition|(
name|idxLevel
operator|==
name|DocumentMetadata
operator|.
name|REINDEX_ALL
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
return|return;
block|}
name|oldDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setReindexRequired
argument_list|(
name|idxLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindexing level "
operator|+
name|idxLevel
operator|+
literal|" of document "
operator|+
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|//      checkTree(doc);
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// remove all old index keys from the btree
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|ArrayList
name|nodes
init|=
name|domDb
operator|.
name|findKeys
argument_list|(
name|query
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|nodes
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ref
operator|=
operator|(
name|Value
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|long
name|gid
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|ref
operator|.
name|data
argument_list|()
argument_list|,
name|ref
operator|.
name|start
argument_list|()
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|>=
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|NodeSetHelper
operator|.
name|isDescendant
argument_list|(
name|oldDoc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|gid
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|domDb
operator|.
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while reindexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while reindexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
try|try
block|{
comment|// now reindex the nodes
name|Iterator
name|iterator
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|n
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|node
operator|.
name|getPath
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error occured while reindexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|notifyReindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setReindexRequired
argument_list|(
name|DocumentMetadata
operator|.
name|REINDEX_ALL
argument_list|)
expr_stmt|;
comment|//      checkTree(doc);
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindex took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reindex the nodes in the document. This method will either reindex all      * descendant nodes of the passed node, or all nodes below some level of      * the document if node is null.      */
specifier|private
name|void
name|reindexXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|boolean
name|repairMode
parameter_list|)
block|{
if|if
condition|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
condition|)
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setConfigEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Iterator
name|iterator
decl_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|StoredNode
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
literal|true
argument_list|,
name|repairMode
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|CollectionConfiguration
operator|.
name|DEFAULT_COLLECTION_CONFIG_FILE
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
condition|)
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setConfigEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|defragXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
comment|//TODO : use dedicated function in XmldbURI
name|LOG
operator|.
name|debug
argument_list|(
literal|"============> Defragmenting document "
operator|+
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"/"
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
comment|//        Writer writer = new StringWriter();
comment|//        try {
comment|//            domDb.dump(writer);
comment|//        } catch (BTreeException e1) {
comment|//            //  Auto-generated catch block
comment|//            e1.printStackTrace();
comment|//        } catch (IOException e1) {
comment|//            //  Auto-generated catch block
comment|//            e1.printStackTrace();
comment|//        }
comment|//        System.out.println(writer.toString());
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
comment|//          checkTree(doc);
comment|//            try {
comment|//                domDb.printFreeSpaceList();
comment|//            } catch (IOException e1) {
comment|//                // Auto-generated catch block
comment|//                e1.printStackTrace();
comment|//            }
comment|// remember this for later remove
specifier|final
name|long
name|firstChild
init|=
name|doc
operator|.
name|getFirstChildAddress
argument_list|()
decl_stmt|;
comment|// dropping old structure index
name|elementIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnameValueIndex
operator|!=
literal|null
condition|)
name|qnameValueIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|// dropping dom index
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// create a copy of the old doc to copy the nodes into it
name|DocumentImpl
name|tempDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|,
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
decl_stmt|;
name|tempDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|tempDoc
operator|.
name|setDocId
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy the nodes
name|Iterator
name|iterator
decl_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|StoredNode
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|tempDoc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
comment|//          checkTree(tempDoc);
comment|// remove the old nodes
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|firstChild
argument_list|)
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//          checkTree(tempDoc);
name|doc
operator|.
name|copyChildren
argument_list|(
name|tempDoc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setSplitCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setPageCount
argument_list|(
name|tempDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getPageCount
argument_list|()
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|//Commented out since DocmentImpl has no more internal address
comment|//LOG.debug("new doc address = " + StorageAddress.toString(doc.getInternalAddress()));
name|closeDocument
argument_list|()
expr_stmt|;
comment|//          new DOMTransaction(this, domDb, Lock.READ_LOCK) {
comment|//              public Object start() throws ReadOnlyException {
comment|//                  LOG.debug("Pages used: " + domDb.debugPages(doc));
comment|//                  return null;
comment|//              }
comment|//          }.run();
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|//            checkTree(doc);
name|LOG
operator|.
name|debug
argument_list|(
literal|"Defragmentation took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** consistency Check of the database; useful after XUpdates;      * called if xupdate.consistency-checks is true in configuration */
specifier|public
name|void
name|checkXMLResourceConsistency
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
block|{
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
name|checkXMLResourceTree
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|//          elementIndex.consistencyCheck(doc);
block|}
block|}
comment|/** consistency Check of the database; useful after XUpdates;      * called by {@link #checkResourceConsistency()} */
specifier|public
name|void
name|checkXMLResourceTree
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking DOM tree for document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pages used: "
operator|+
name|domDb
operator|.
name|debugPages
argument_list|(
name|doc
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|StoredNode
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|findKeys
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *  Store a node into the database. This method is called by the parser to      *  write a node to the storage backend.      *      *@param  node         the node to be stored      *@param  currentPath  path expression which points to this node's      *      element-parent or to itself if it is an element (currently used by      *      the Broker to determine if a node's content should be      *      fulltext-indexed).  @param index switch to activate fulltext indexation      */
specifier|public
name|void
name|storeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
name|checkAvailableMemory
argument_list|()
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
comment|//        final boolean isTemp = TEMP_COLLECTION.equals(doc.getCollection().getName());
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|//        final FulltextIndexSpec ftIdx = idxSpec != null ? idxSpec.getFulltextIndexSpec() : null;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
if|if
condition|(
name|gid
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal node: "
operator|+
name|gid
operator|+
literal|"; "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|depth
init|=
name|idxSpec
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idxSpec
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|long
name|address
init|=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
decl_stmt|;
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|TEXT_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|||
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|>
name|depth
condition|)
name|address
operator|=
name|domDb
operator|.
name|add
argument_list|(
name|transaction
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|address
operator|=
name|domDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"address is missing"
argument_list|)
expr_stmt|;
comment|//TODO : how can we continue here ? -pb
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|++
name|nodesCount
expr_stmt|;
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|doIndex
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|updateNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|internalAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|internalAddress
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
name|internalAddress
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Value
name|oldVal
init|=
name|domDb
operator|.
name|get
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|StoredNode
name|old
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|oldVal
operator|.
name|data
argument_list|()
argument_list|,
name|oldVal
operator|.
name|start
argument_list|()
argument_list|,
name|oldVal
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while storing "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
operator|+
literal|"; old = "
operator|+
name|old
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Physically insert a node into the DOM storage.      */
specifier|public
name|void
name|insertNodeAfter
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|previous
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|previous
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|long
name|address
init|=
name|previous
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|previous
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|copyNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|)
expr_stmt|;
name|storeNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
name|oldAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getGID
argument_list|()
operator|==
name|StoredNode
operator|.
name|NODE_IMPL_ROOT_NODE_GID
condition|)
block|{
name|newDoc
operator|.
name|appendChild
argument_list|(
operator|(
name|StoredNode
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|NodeSetHelper
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|StoredNode
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Removes the Node Reference from the database.      * The index will be updated later, i.e. after all nodes have been physically       * removed. See {@link #endRemove()}.       * removeNode() just adds the node ids to the list in elementIndex       * for later removal.      */
specifier|public
name|void
name|removeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|FulltextIndexSpec
name|ftIdx
init|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
comment|//      final String nodeName = node.getNodeName();
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// save element by calling ElementIndex
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|GeneralRangeIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
name|spec
operator|.
name|getType
argument_list|()
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
comment|// qnameValueIndex.removeElement((ElementImpl) node, currentPath, content);
name|notifyRemoveElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexAttribs
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
condition|)
block|{
name|indexAttribs
operator|=
name|ftIdx
operator|.
name|matchAttribute
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexAttribs
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|GeneralRangeIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|spec
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
comment|//                  RangeIndexSpec qnIdx = idxSpec.getIndexByQName(idxQName);
comment|//                  if (qnIdx != null&& qnameValueIndexation) {
comment|//                      qnameValueIndex.setDocument(doc);
comment|//                      qnameValueIndex.storeAttribute(qnIdx, (AttrImpl) node);
comment|//                  }
block|}
if|if
condition|(
name|qnameValueIndex
operator|!=
literal|null
condition|)
name|qnameValueIndex
operator|.
name|removeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// qnameValueIndex.storeAttribute( (AttrImpl)node, currentPath, true);
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
block|{
name|boolean
name|valore
init|=
operator|(
name|ftIdx
operator|==
literal|null
condition|?
literal|false
else|:
name|ftIdx
operator|.
name|preserveContent
argument_list|(
name|currentPath
argument_list|)
operator|)
decl_stmt|;
name|textEngine
operator|.
name|storeText
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|valore
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|public
name|void
name|removeAllNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|Stack
name|stack
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
name|collectNodesForRemoval
argument_list|(
name|stack
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|RemovedNode
name|next
decl_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|next
operator|=
operator|(
name|RemovedNode
operator|)
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|removeNode
argument_list|(
name|transaction
argument_list|,
name|next
operator|.
name|node
argument_list|,
name|next
operator|.
name|path
argument_list|,
name|next
operator|.
name|content
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|collectNodesForRemoval
parameter_list|(
name|Stack
name|stack
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|RemovedNode
name|removed
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|String
name|content
init|=
literal|null
decl_stmt|;
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|GeneralRangeIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
name|RangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
operator|||
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|NodeProxy
name|p
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|content
operator|=
name|getNodeValue
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|NodeSetHelper
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|StoredNode
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
operator|(
operator|(
name|ElementImpl
operator|)
name|child
operator|)
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
name|collectNodesForRemoval
argument_list|(
name|stack
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
default|default :
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/**      * Index a single node, which has been added through an XUpdate      * operation. This method is only called if inserting the node is possible      * without changing the node identifiers of sibling or parent nodes. In other       * cases, reindex will be called.      */
specifier|public
name|void
name|indexNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|indexNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|repairMode
parameter_list|)
block|{
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|index
argument_list|()
expr_stmt|;
block|}
comment|/**      * Reindex the given node after the DOM tree has been       * modified by an XUpdate.      *       * @param node      * @param currentPath      */
specifier|private
name|void
name|reindexNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|reindex
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|checkNodeTree
parameter_list|(
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|NodeSetHelper
operator|.
name|getFirstChildId
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|StoredNode
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Called by reindex to walk through all nodes in the tree and reindex them      * if necessary.      *       * @param iterator      * @param node      * @param currentPath      */
specifier|private
name|void
name|scanNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|fullReindex
parameter_list|,
name|boolean
name|repairMode
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullReindex
condition|)
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|repairMode
argument_list|)
expr_stmt|;
else|else
name|reindexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|NodeSetHelper
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|StoredNode
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|StoredNode
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|fullReindex
argument_list|,
name|repairMode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
operator|(
name|fullReindex
operator|||
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
operator|>=
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|reindexRequired
argument_list|()
operator|)
condition|)
block|{
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *  Do a sequential search through the DOM-file.      *      *@param  context     Description of the Parameter      *@param  doc         Description of the Parameter      *@param  relation    Description of the Parameter      *@param  truncation  Description of the Parameter      *@param  expr        Description of the Parameter      *@return             Description of the Return Value      */
specifier|protected
name|NodeSet
name|scanNodesSequential
parameter_list|(
name|NodeSet
name|context
parameter_list|,
name|DocumentSet
name|doc
parameter_list|,
name|int
name|relation
parameter_list|,
name|int
name|truncation
parameter_list|,
name|String
name|expr
parameter_list|,
name|Collator
name|collator
parameter_list|)
block|{
name|ExtArrayNodeSet
name|resultNodeSet
init|=
operator|new
name|ExtArrayNodeSet
argument_list|()
decl_stmt|;
name|NodeProxy
name|p
decl_stmt|;
name|String
name|content
decl_stmt|;
name|String
name|cmp
decl_stmt|;
name|Pattern
name|regexp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|relation
operator|==
name|Constants
operator|.
name|REGEXP
condition|)
block|{
name|regexp
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|expr
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
operator||
name|Pattern
operator|.
name|UNICODE_CASE
argument_list|)
expr_stmt|;
name|truncation
operator|=
name|Constants
operator|.
name|REGEXP
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|context
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|NodeProxy
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|setOwnerObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|content
operator|=
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire read lock on "
operator|+
name|domDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
finally|finally
block|{
name|domDb
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isCaseSensitive
argument_list|()
condition|)
name|cmp
operator|=
name|StringValue
operator|.
name|collapseWhitespace
argument_list|(
name|content
argument_list|)
expr_stmt|;
else|else
block|{
name|cmp
operator|=
name|StringValue
operator|.
name|collapseWhitespace
argument_list|(
name|content
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|truncation
condition|)
block|{
case|case
name|Constants
operator|.
name|TRUNC_LEFT
case|:
if|if
condition|(
name|Collations
operator|.
name|endsWith
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|Collations
operator|.
name|startsWith
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_BOTH
case|:
if|if
condition|(
name|Collations
operator|.
name|indexOf
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
operator|!=
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_NONE
case|:
name|int
name|result
init|=
name|Collations
operator|.
name|compare
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|relation
condition|)
block|{
case|case
name|Constants
operator|.
name|LT
case|:
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|LTEQ
case|:
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|GT
case|:
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|GTEQ
case|:
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|EQ
case|:
if|if
condition|(
name|result
operator|==
name|Constants
operator|.
name|EQUAL
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|NEQ
case|:
if|if
condition|(
name|result
operator|!=
name|Constants
operator|.
name|EQUAL
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal argument 'relation': "
operator|+
name|relation
argument_list|)
throw|;
block|}
break|break;
case|case
name|Constants
operator|.
name|REGEXP
case|:
name|Matcher
name|matcher
init|=
name|regexp
operator|.
name|matcher
argument_list|(
name|cmp
argument_list|)
decl_stmt|;
if|if
condition|(
name|regexp
operator|!=
literal|null
operator|&&
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|resultNodeSet
return|;
block|}
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|NodeProxy
name|proxy
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
return|return
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|proxy
argument_list|,
name|addWhitespace
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|NodeSet
name|getNodesEqualTo
parameter_list|(
name|NodeSet
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|int
name|relation
parameter_list|,
name|int
name|truncation
parameter_list|,
name|String
name|expr
parameter_list|,
name|Collator
name|collator
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isCaseSensitive
argument_list|()
condition|)
name|expr
operator|=
name|expr
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
return|return
name|scanNodesSequential
argument_list|(
name|context
argument_list|,
name|docs
argument_list|,
name|relation
argument_list|,
name|truncation
argument_list|,
name|expr
argument_list|,
name|collator
argument_list|)
return|;
block|}
specifier|public
name|NodeList
name|getNodeRange
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|long
name|first
parameter_list|,
specifier|final
name|long
name|last
parameter_list|)
block|{
name|NodeListImpl
name|result
init|=
operator|new
name|NodeListImpl
argument_list|(
operator|(
name|int
operator|)
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|first
init|;
name|gid
operator|<=
name|last
condition|;
name|gid
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|objectWith
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|Node
name|objectWith
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|long
name|gid
parameter_list|)
block|{
return|return
operator|(
name|Node
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|,
name|gid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
decl_stmt|;
name|node
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|Node
name|objectWith
parameter_list|(
specifier|final
name|NodeProxy
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|getInternalAddress
argument_list|()
operator|==
name|StoredNode
operator|.
name|UNKNOWN_NODE_IMPL_ADDRESS
condition|)
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getGID
argument_list|()
argument_list|)
return|;
return|return
operator|(
name|Node
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|p
operator|.
name|getGID
argument_list|()
operator|+
literal|" not found in document "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"; docId = "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|//					LOG.debug(domDb.debugPages(p.doc, true));
comment|//					return null;
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getGID
argument_list|()
argument_list|)
return|;
comment|// retry?
block|}
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|p
operator|.
name|getDocument
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|setGID
argument_list|(
name|p
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|protected
name|void
name|repair
parameter_list|()
throws|throws
name|PermissionDeniedException
block|{
name|Collection
name|root
init|=
name|getCollection
argument_list|(
name|ROOT_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing index files ..."
argument_list|)
expr_stmt|;
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
name|elementsDb
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.elements"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|dbWords
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.words"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|valuesDb
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.values"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnameValueIndexation
condition|)
block|{
name|valuesDbQname
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection2.values"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Recreating index files ..."
argument_list|)
expr_stmt|;
try|try
block|{
name|createIndexFiles
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception during repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Reindexing database files ..."
argument_list|)
expr_stmt|;
name|reindexCollection
argument_list|(
literal|null
argument_list|,
name|root
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|notifyFlush
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbols
operator|!=
literal|null
operator|&&
name|symbols
operator|.
name|hasChanged
argument_list|()
condition|)
try|try
block|{
name|saveSymbols
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|sync
parameter_list|(
name|int
name|syncEvent
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
return|return;
try|try
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while flushing dom.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
if|if
condition|(
name|syncEvent
operator|==
name|Sync
operator|.
name|MAJOR_SYNC
condition|)
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|notifySync
argument_list|()
expr_stmt|;
comment|//              System.gc();
name|Runtime
name|runtime
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Memory: "
operator|+
operator|(
name|runtime
operator|.
name|totalMemory
argument_list|()
operator|/
literal|1024
operator|)
operator|+
literal|"K total; "
operator|+
operator|(
name|runtime
operator|.
name|maxMemory
argument_list|()
operator|/
literal|1024
operator|)
operator|+
literal|"K max; "
operator|+
operator|(
name|runtime
operator|.
name|freeMemory
argument_list|()
operator|/
literal|1024
operator|)
operator|+
literal|"K free"
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
if|if
condition|(
name|elementsDb
operator|!=
literal|null
condition|)
name|elementsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuesDb
operator|!=
literal|null
condition|)
name|valuesDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuesDbQname
operator|!=
literal|null
condition|)
name|valuesDbQname
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
if|if
condition|(
name|textEngine
operator|!=
literal|null
condition|)
name|textEngine
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|dbe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|cleanUpTempCollection
argument_list|()
expr_stmt|;
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR_SYNC
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|textEngine
operator|.
name|close
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|elementsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|valuesDb
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|qnameValueIndex
operator|!=
literal|null
condition|)
name|qnameValueIndex
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** check available memory */
specifier|private
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
specifier|final
name|double
name|percent
init|=
operator|(
operator|(
name|double
operator|)
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
operator|(
name|double
operator|)
name|run
operator|.
name|maxMemory
argument_list|()
operator|)
operator|*
literal|100
decl_stmt|;
if|if
condition|(
name|percent
operator|<
name|memMinFree
condition|)
block|{
comment|//LOG.info(
comment|//  "total memory: " + run.totalMemory() + "; free: " + run.freeMemory());
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//TOUNDERSTAND : why not use shutdown ? -pb
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NodeRef
extends|extends
name|Value
block|{
comment|/* 		public NodeRef() { 			data = new byte[12]; 		}         */
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|4
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|gid
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
literal|12
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|getDocId
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* 		long getGid() { 			return ByteConversion.byteToLong(data, 4); 		}         */
comment|/* 		void set(int docId, long gid) { 			ByteConversion.intToByte(docId, data, 0); 			ByteConversion.longToByte(gid, data, 4); 			len = 12; 			pos = 0; 		}         */
block|}
specifier|private
specifier|final
specifier|static
class|class
name|RemovedNode
block|{
name|StoredNode
name|node
decl_stmt|;
name|String
name|content
decl_stmt|;
name|NodePath
name|path
decl_stmt|;
name|RemovedNode
parameter_list|(
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|path
parameter_list|,
name|String
name|content
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
block|}
block|}
comment|/** Delegate for Node Processings : indexing */
specifier|private
class|class
name|NodeProcessor
block|{
specifier|private
name|Txn
name|transaction
decl_stmt|;
specifier|private
name|StoredNode
name|node
decl_stmt|;
specifier|private
name|NodePath
name|currentPath
decl_stmt|;
comment|/** work variables */
specifier|private
name|short
name|nodeType
decl_stmt|;
specifier|private
name|long
name|gid
decl_stmt|;
specifier|private
name|DocumentImpl
name|doc
decl_stmt|;
specifier|private
name|long
name|address
decl_stmt|;
specifier|private
name|IndexSpec
name|idxSpec
decl_stmt|;
specifier|private
name|FulltextIndexSpec
name|ftIdx
decl_stmt|;
specifier|private
name|int
name|depth
decl_stmt|;
specifier|private
name|int
name|level
decl_stmt|;
comment|/** overall switch to activate fulltext indexation */
specifier|private
name|boolean
name|index
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|repairMode
init|=
literal|false
decl_stmt|;
name|NodeProcessor
parameter_list|()
block|{
block|}
specifier|public
name|void
name|reset
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getGID
argument_list|()
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal node: "
operator|+
name|node
operator|.
name|getGID
argument_list|()
operator|+
literal|"; "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : why continue processing ? return ? -pb
name|this
operator|.
name|transaction
operator|=
name|transaction
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|currentPath
operator|=
name|currentPath
expr_stmt|;
name|nodeType
operator|=
name|node
operator|.
name|getNodeType
argument_list|()
expr_stmt|;
name|gid
operator|=
name|node
operator|.
name|getGID
argument_list|()
expr_stmt|;
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
expr_stmt|;
name|address
operator|=
name|node
operator|.
name|getInternalAddress
argument_list|()
expr_stmt|;
name|idxSpec
operator|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|)
expr_stmt|;
name|ftIdx
operator|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
expr_stmt|;
name|depth
operator|=
name|idxSpec
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idxSpec
operator|.
name|getIndexDepth
argument_list|()
expr_stmt|;
name|level
operator|=
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reset
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
specifier|public
name|void
name|setRepairMode
parameter_list|(
name|boolean
name|repair
parameter_list|)
block|{
name|this
operator|.
name|repairMode
operator|=
name|repair
expr_stmt|;
block|}
comment|/** Updates the various indices */
specifier|public
name|void
name|doIndex
parameter_list|()
block|{
name|int
name|indexType
init|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
specifier|final
name|boolean
name|isTemp
init|=
name|TEMP_COLLECTION
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
comment|// --move to-- NativeValueIndex
name|RangeIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|indexType
operator|=
name|spec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
comment|//                        // --move to-- NativeValueIndexByQName
comment|//                        RangeIndexSpec qnIdx = idxSpec.getIndexByQName(node.getQName());
comment|//                        if (qnIdx != null&& qnameValueIndexation) {
comment|//                            indexType |= RangeIndexSpec.QNAME_INDEX;
comment|//                        }
block|}
comment|// --move to-- NativeTextEngine
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|TEXT
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|-
name|node
operator|.
name|getAttributesCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|MIXED_CONTENT
expr_stmt|;
block|}
comment|// --move to-- NativeValueIndex NativeTextEngine
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
comment|// qnameValueIndex.startElement((ElementImpl)node, currentPath, index);
name|notifyStartElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|boolean
name|indexAttribs
init|=
literal|false
decl_stmt|;
name|QName
name|qname
init|=
name|node
operator|.
name|getQName
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
comment|// --move to-- NativeElementIndex NativeValueIndex NativeTextEngine
if|if
condition|(
name|index
operator|&&
operator|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|matchAttribute
argument_list|(
name|currentPath
argument_list|)
operator|)
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|TEXT
expr_stmt|;
name|indexAttribs
operator|=
literal|true
expr_stmt|;
block|}
comment|// --move to-- NativeValueIndex
comment|// TODO : valueIndex.storeAttribute( (AttrImpl)node, currentPath, index);
name|GeneralRangeIndexSpec
name|valSpec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|valSpec
operator|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|valSpec
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|valSpec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|valSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|valSpec
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
comment|// qnameValueIndex.storeAttribute( (AttrImpl)node, currentPath, index);
name|notifyStoreAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// --move to-- NativeTextEngine
comment|// TODO : textEngine.storeAttribute( (AttrImpl)node, currentPath, index);
if|if
condition|(
name|indexAttribs
operator|&&
operator|!
name|isTemp
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|//                  --move to-- NativeElementIndex
comment|// TODO : elementIndex.storeAttribute(node, currentPath, index);
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// --move to-- NativeElementIndex
comment|// TODO : elementIndex.storeAttribute(node, currentPath, index);
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//LOG.debug("found ID: " + qname.getLocalName());
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addNode
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
comment|//                    // --move to-- ???
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// --move to-- NativeTextEngine
comment|// TODO textEngine.storeText( (TextImpl) node, currentPath, index);
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexText
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
operator|&&
name|currentPath
operator|!=
literal|null
condition|)
name|indexText
operator|=
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexText
operator|&&
operator|!
name|isTemp
operator|&&
name|index
condition|)
block|{
name|boolean
name|valore
init|=
operator|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
condition|?
literal|false
else|:
name|ftIdx
operator|.
name|preserveContent
argument_list|(
name|currentPath
argument_list|)
operator|)
decl_stmt|;
name|textEngine
operator|.
name|storeText
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|valore
argument_list|)
expr_stmt|;
block|}
name|notifyStoreText
argument_list|(
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// storeText( TextImpl node, NodePath currentPath, boolean fullTextIndexSwitch );
break|break;
block|}
block|}
comment|/** Stores this node into the database, if it's an element */
specifier|public
name|void
name|store
parameter_list|()
block|{
if|if
condition|(
operator|!
name|repairMode
operator|&&
name|nodeType
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|depth
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** check available memory */
specifier|private
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
specifier|final
name|int
name|percent
init|=
operator|(
name|int
operator|)
operator|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
operator|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|100
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|percent
operator|<
name|memMinFree
condition|)
block|{
comment|//LOG.info(
comment|//  "total memory: " + run.totalMemory() + "; free: " + run.freeMemory());
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Updates the various indices and stores this node into the database */
specifier|public
name|void
name|index
parameter_list|()
block|{
operator|++
name|nodesCount
expr_stmt|;
name|checkAvailableMemory
argument_list|()
expr_stmt|;
name|doIndex
argument_list|()
expr_stmt|;
name|store
argument_list|()
expr_stmt|;
block|}
comment|/** Updates the various indices and stores this node into the database          * if necessary */
specifier|public
name|void
name|reindex
parameter_list|()
block|{
if|if
condition|(
name|level
operator|>=
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
name|NodeIndexListener
name|listener
init|=
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getIndexListener
argument_list|()
decl_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
name|listener
operator|.
name|nodeChanged
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|store
argument_list|()
expr_stmt|;
name|doIndex
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|final
class|class
name|DocumentCallback
implements|implements
name|BTreeCallback
block|{
specifier|private
name|Collection
name|collection
decl_stmt|;
specifier|public
name|DocumentCallback
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|this
operator|.
name|collection
operator|=
name|collection
expr_stmt|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
try|try
block|{
name|byte
name|type
init|=
name|key
operator|.
name|data
argument_list|()
index|[
name|key
operator|.
name|start
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|VariableByteInput
name|istream
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|DocumentImpl
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
name|doc
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|collection
argument_list|)
expr_stmt|;
else|else
name|doc
operator|=
operator|new
name|DocumentImpl
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|collection
argument_list|)
expr_stmt|;
name|doc
operator|.
name|read
argument_list|(
name|istream
argument_list|)
expr_stmt|;
comment|//Commented since DocumentImpl forked from what is now StoredNode
comment|//doc.setInternalAddress(pointer);
name|collection
operator|.
name|addDocument
argument_list|(
literal|null
argument_list|,
name|NativeBroker
operator|.
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"EOFException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

