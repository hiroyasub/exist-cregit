begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-03 Wolfgang M. Meier  *  wolfgang@exist-db.org  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *   *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|Collator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|MalformedPatternException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|PatternCompiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|PatternMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Perl5Compiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Perl5Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|data
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|Paged
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|indexer
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|IndexInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ArraySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|BinaryDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeIndexListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|TextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|MD5
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|SecurityManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|NativeSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|DOMFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|DOMFileIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|DOMTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|StorageAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArrayPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Collations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|sanity
operator|.
name|SanityCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|StringValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DocumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  *  Main class for the native XML storage backend.  *   * Provides access to all low-level operations required by  * the database. Extends {@link DBBroker}.  *  *@author     Wolfgang Meier  */
end_comment

begin_class
specifier|public
class|class
name|NativeBroker
extends|extends
name|DBBroker
block|{
specifier|private
specifier|static
specifier|final
name|String
name|TEMP_FRAGMENT_REMOVE_ERROR
init|=
literal|"Could not remove temporary fragment"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TEMP_STORE_ERROR
init|=
literal|"An error occurred while storing temporary data: "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EXCEPTION_DURING_REINDEX
init|=
literal|"exception during reindex"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DATABASE_IS_READ_ONLY
init|=
literal|"database is read-only"
decl_stmt|;
comment|/**      * Log4J Logger for this class      */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NativeBroker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|TEMP_FRAGMENT_TIMEOUT
init|=
literal|300000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ROOT_COLLECTION
init|=
literal|"/db"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TEMP_COLLECTION
init|=
literal|"/db/system/temp"
decl_stmt|;
comment|/** default buffer size setting */
specifier|protected
specifier|final
specifier|static
name|int
name|BUFFERS
init|=
literal|256
decl_stmt|;
comment|/** check available memory after storing MEM_LIMIT_CHECK nodes */
specifier|protected
specifier|final
specifier|static
name|int
name|MEM_LIMIT_CHECK
init|=
literal|10000
decl_stmt|;
comment|// the database files
specifier|protected
name|CollectionStore
name|collectionsDb
decl_stmt|;
specifier|protected
name|DOMFile
name|domDb
decl_stmt|;
specifier|protected
name|BFile
name|elementsDb
decl_stmt|;
specifier|protected
name|BFile
name|valuesDb
decl_stmt|;
specifier|protected
name|NativeTextEngine
name|textEngine
decl_stmt|;
specifier|protected
name|NativeElementIndex
name|elementIndex
decl_stmt|;
specifier|protected
name|NativeValueIndex
name|valueIndex
decl_stmt|;
specifier|protected
name|Serializer
name|xmlSerializer
decl_stmt|;
specifier|protected
name|PatternCompiler
name|compiler
init|=
operator|new
name|Perl5Compiler
argument_list|()
decl_stmt|;
specifier|protected
name|PatternMatcher
name|matcher
init|=
operator|new
name|Perl5Matcher
argument_list|()
decl_stmt|;
specifier|protected
name|int
name|defaultIndexDepth
init|=
literal|1
decl_stmt|;
specifier|protected
name|IndexSpec
name|idxConf
decl_stmt|;
specifier|protected
name|boolean
name|readOnly
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|memMinFree
decl_stmt|;
comment|// used to count the nodes inserted after the last memory check
specifier|protected
name|int
name|nodesCount
init|=
literal|0
decl_stmt|;
specifier|protected
name|int
name|pageSize
decl_stmt|;
specifier|private
specifier|final
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
specifier|public
name|NativeBroker
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|Configuration
name|config
parameter_list|)
throws|throws
name|EXistException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|String
name|dataDir
decl_stmt|;
name|int
name|buffers
decl_stmt|,
name|cacheSize
decl_stmt|;
name|String
name|temp
decl_stmt|;
name|boolean
name|compress
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|dataDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.data-dir"
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|dataDir
operator|=
literal|"data"
expr_stmt|;
if|if
condition|(
operator|(
name|pageSize
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.page-size"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pageSize
operator|=
literal|4096
expr_stmt|;
if|if
condition|(
operator|(
name|buffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|buffers
operator|=
name|BUFFERS
expr_stmt|;
if|if
condition|(
operator|(
name|cacheSize
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.cache-size"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|long
name|totalMem
init|=
name|cacheSize
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|buffers
operator|=
operator|(
name|int
operator|)
operator|(
name|totalMem
operator|/
name|pageSize
operator|/
literal|64
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|defaultIndexDepth
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"indexer.index-depth"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|defaultIndexDepth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|memMinFree
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.min_free_memory"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|memMinFree
operator|=
literal|5000000
expr_stmt|;
name|Paged
operator|.
name|setPageSize
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
name|String
name|pathSep
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|int
name|indexBuffers
decl_stmt|,
name|dataBuffers
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|elementsDb
operator|=
operator|(
name|BFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.elements"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|indexBuffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.elements.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|4
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
operator|*
literal|10
expr_stmt|;
block|}
else|else
name|dataBuffers
operator|=
name|indexBuffers
operator|>>
literal|2
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"elements index buffer size: "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|elementsDb
operator|=
operator|new
name|BFile
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"elements.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elementsDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating elements.dbx"
argument_list|)
expr_stmt|;
name|elementsDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|elementsDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.elements"
argument_list|,
name|elementsDb
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|elementsDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|valuesDb
operator|=
operator|(
name|BFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.values"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|4
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
operator|*
literal|10
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"values index buffer size: "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|valuesDb
operator|=
operator|new
name|BFile
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"values.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valuesDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating values.dbx"
argument_list|)
expr_stmt|;
name|valuesDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|valuesDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.values"
argument_list|,
name|valuesDb
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|valuesDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|domDb
operator|=
operator|(
name|DOMFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.dom"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|config
operator|.
name|hasProperty
argument_list|(
literal|"db-connection.buffers"
argument_list|)
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
expr_stmt|;
name|dataBuffers
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|4
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
operator|*
literal|4
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"page buffer size = "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|domDb
operator|=
operator|new
name|DOMFile
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"dom.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|domDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating dom.dbx"
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|domDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.dom"
argument_list|,
name|domDb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readOnly
condition|)
name|readOnly
operator|=
name|domDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|collectionsDb
operator|=
operator|(
name|CollectionStore
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.collections"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|indexBuffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.collections.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|6
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
operator|*
literal|6
expr_stmt|;
block|}
else|else
name|dataBuffers
operator|=
name|indexBuffers
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"collections index buffer size: "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|collectionsDb
operator|=
operator|new
name|CollectionStore
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"collections.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|collectionsDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating collections.dbx"
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.collections"
argument_list|,
name|collectionsDb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readOnly
condition|)
name|readOnly
operator|=
name|collectionsDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|readOnly
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"database runs in read-only mode"
argument_list|)
expr_stmt|;
name|idxConf
operator|=
operator|(
name|IndexSpec
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"indexer.config"
argument_list|)
expr_stmt|;
name|textEngine
operator|=
operator|new
name|NativeTextEngine
argument_list|(
name|this
argument_list|,
name|config
argument_list|,
name|buffers
argument_list|)
expr_stmt|;
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|valuesDb
argument_list|)
expr_stmt|;
name|xmlSerializer
operator|=
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|elementIndex
operator|=
operator|new
name|NativeElementIndex
argument_list|(
name|this
argument_list|,
name|elementsDb
argument_list|)
expr_stmt|;
name|user
operator|=
name|SecurityManager
operator|.
name|SYSTEM_USER
expr_stmt|;
if|if
condition|(
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
name|getOrCreateCollection
argument_list|(
name|ROOT_COLLECTION
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to initialize database: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to initialize database: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
specifier|final
specifier|static
name|String
name|normalizeCollectionName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'/'
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
name|i
operator|+
literal|1
operator|&&
name|name
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
else|else
name|out
operator|.
name|append
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|addObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
name|super
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|boolean
name|compare
parameter_list|(
name|Collator
name|collator
parameter_list|,
name|String
name|o1
parameter_list|,
name|String
name|o2
parameter_list|,
name|int
name|relation
parameter_list|)
block|{
name|int
name|cmp
init|=
name|Collations
operator|.
name|compare
argument_list|(
name|collator
argument_list|,
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|relation
condition|)
block|{
case|case
name|Constants
operator|.
name|LT
case|:
return|return
operator|(
name|cmp
operator|<
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|LTEQ
case|:
return|return
operator|(
name|cmp
operator|<=
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|GT
case|:
return|return
operator|(
name|cmp
operator|>
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|GTEQ
case|:
return|return
operator|(
name|cmp
operator|>=
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|EQ
case|:
return|return
operator|(
name|cmp
operator|==
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|NEQ
case|:
return|return
operator|(
name|cmp
operator|!=
literal|0
operator|)
return|;
block|}
return|return
literal|false
return|;
comment|// never reached
block|}
specifier|public
name|ElementIndex
name|getElementIndex
parameter_list|()
block|{
return|return
name|elementIndex
return|;
block|}
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|()
block|{
return|return
name|idxConf
return|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|textEngine
operator|.
name|flush
argument_list|()
expr_stmt|;
name|elementIndex
operator|.
name|flush
argument_list|()
expr_stmt|;
name|valueIndex
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbols
operator|!=
literal|null
operator|&&
name|symbols
operator|.
name|hasChanged
argument_list|()
condition|)
try|try
block|{
name|saveSymbols
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|endRemove
parameter_list|()
block|{
name|textEngine
operator|.
name|remove
argument_list|()
expr_stmt|;
name|elementIndex
operator|.
name|remove
argument_list|()
expr_stmt|;
name|valueIndex
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|/** 	 *  get all the documents in this database repository. The documents are 	 *  returned as a DocumentSet. 	 * 	 *@param  user  Description of the Parameter 	 *@return       The allDocuments value 	 */
specifier|public
name|DocumentSet
name|getAllDocuments
parameter_list|(
name|DocumentSet
name|docs
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
name|root
init|=
literal|null
decl_stmt|;
try|try
block|{
name|root
operator|=
name|openCollection
argument_list|(
name|ROOT_COLLECTION
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|root
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getAllDocuments(DocumentSet) - end - "
operator|+
literal|"loading "
operator|+
name|docs
operator|.
name|getLength
argument_list|()
operator|+
literal|" documents from "
operator|+
name|docs
operator|.
name|getCollectionCount
argument_list|()
operator|+
literal|"collections took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
finally|finally
block|{
name|root
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|addr
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|name
argument_list|,
name|addr
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
return|return
name|openCollection
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|lockMode
argument_list|)
return|;
block|}
comment|/** 	 *  Get collection object. If the collection does not exist, null is 	 *  returned. 	 * 	 *@param  name  Description of the Parameter 	 *@return       The collection value 	 */
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|addr
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
comment|//	final long start = System.currentTimeMillis();
name|name
operator|=
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|name
operator|=
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
name|name
operator|=
name|ROOT_COLLECTION
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|Collection
name|collection
init|=
name|collectionsCache
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
comment|//				LOG.debug("loading collection " + name);
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|collection
operator|=
operator|new
name|Collection
argument_list|(
name|collectionsDb
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|collection
operator|.
name|read
argument_list|(
name|this
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections.dbx"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lockMode
operator|!=
name|Lock
operator|.
name|NO_LOCK
condition|)
block|{
try|try
block|{
comment|//					LOG.debug("acquiring lock on " + collection.getName());
name|collection
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
comment|//					LOG.debug("lock acquired");
block|}
catch|catch
parameter_list|(
name|LockException
name|e1
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not acquire lock on collection "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
comment|// don't cache the collection during initialization: SecurityManager is not yet online
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//			LOG.debug(
comment|//				"loading collection "
comment|//					+ name
comment|//					+ " took "
comment|//					+ (System.currentTimeMillis() - start)
comment|//					+ "ms.");
return|return
name|collection
return|;
block|}
block|}
specifier|public
name|void
name|reloadCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Value
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|getAddress
argument_list|()
operator|==
operator|-
literal|1
condition|)
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|collection
operator|.
name|getAddress
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|collection
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection data not found for collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|collection
operator|.
name|read
argument_list|(
name|this
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections.dbx"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|Iterator
name|getDOMIterator
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|DOMFileIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|proxy
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create DOM iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create DOM iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Iterator
name|getNodeIterator
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
comment|//		domDb.setOwnerObject(this);
try|try
block|{
return|return
operator|new
name|NodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|proxy
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 *  get a document by it's file name. The document's file name is used to 	 *  identify a document. File names are stored without the leading path. 	 * 	 *@param  fileName                       Description of the Parameter 	 *@param  user                           Description of the Parameter 	 *@return                                The document value 	 *@exception  PermissionDeniedException  Description of the Exception 	 */
specifier|public
name|Document
name|getDocument
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|fileName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|fileName
operator|=
literal|'/'
operator|+
name|fileName
expr_stmt|;
if|if
condition|(
operator|!
name|fileName
operator|.
name|startsWith
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|fileName
operator|=
literal|"/db"
operator|+
name|fileName
expr_stmt|;
name|int
name|pos
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|String
name|collName
init|=
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|String
name|docName
init|=
name|fileName
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission denied to read collection"
argument_list|)
throw|;
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|docName
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document "
operator|+
name|fileName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//		if (!doc.getPermissions().validate(user, Permission.READ))
comment|//			throw new PermissionDeniedException("not allowed to read document");
return|return
name|doc
return|;
block|}
specifier|public
name|DocumentImpl
name|openDocument
parameter_list|(
name|String
name|docPath
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|docPath
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|docPath
operator|=
literal|'/'
operator|+
name|docPath
expr_stmt|;
if|if
condition|(
operator|!
name|docPath
operator|.
name|startsWith
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|docPath
operator|=
literal|"/db"
operator|+
name|docPath
expr_stmt|;
name|int
name|pos
init|=
name|docPath
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|String
name|collName
init|=
name|docPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|String
name|docName
init|=
name|docPath
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Collection
name|collection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|collection
operator|=
name|openCollection
argument_list|(
name|collName
argument_list|,
name|lockMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission denied to read collection"
argument_list|)
throw|;
block|}
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|docName
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|//				LOG.debug("document " + docPath + " not found!");
return|return
literal|null
return|;
block|}
comment|//		if (!doc.getPermissions().validate(user, Permission.READ))
comment|//			throw new PermissionDeniedException("not allowed to read document");
return|return
name|doc
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not acquire lock on document "
operator|+
name|docPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
name|collection
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|DocumentSet
name|getDocumentsByCollection
parameter_list|(
name|String
name|collection
parameter_list|,
name|DocumentSet
name|docs
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|getDocumentsByCollection
argument_list|(
name|collection
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|DocumentSet
name|getDocumentsByCollection
parameter_list|(
name|String
name|collection
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
operator|||
name|collection
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|docs
return|;
if|if
condition|(
name|collection
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|collection
operator|=
literal|"/"
operator|+
name|collection
expr_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|startsWith
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
name|collection
operator|=
name|ROOT_COLLECTION
operator|+
name|collection
expr_stmt|;
name|Collection
name|root
init|=
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collection
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
name|docs
operator|=
name|root
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
name|inclusive
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"loading "
operator|+
name|docs
operator|.
name|getLength
argument_list|()
operator|+
literal|" documents from collection "
operator|+
name|collection
operator|+
literal|" took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/** 	 *  get all the documents in this database matching the given 	 *  document-type's name. 	 * 	 *@param  doctypeName  Description of the Parameter 	 *@param  user         Description of the Parameter 	 *@return              The documentsByDoctype value 	 */
specifier|public
name|DocumentSet
name|getDocumentsByDoctype
parameter_list|(
name|String
name|doctypeName
parameter_list|,
name|DocumentSet
name|result
parameter_list|)
block|{
name|DocumentSet
name|docs
init|=
name|getAllDocuments
argument_list|(
operator|new
name|DocumentSet
argument_list|()
argument_list|)
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|DocumentType
name|doctype
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|doctype
operator|=
name|doc
operator|.
name|getDoctype
argument_list|()
expr_stmt|;
if|if
condition|(
name|doctype
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|doctypeName
operator|.
name|equals
argument_list|(
name|doctype
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
operator|&&
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** 	 * Release the collection id assigned to a collection so it can be 	 * reused later. 	 *  	 * @param id 	 * @throws PermissionDeniedException 	 */
specifier|protected
name|void
name|freeCollection
parameter_list|(
name|short
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//		LOG.debug("freeing collection " + id);
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_collection_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|2
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Get the next free collection id. If a collection is removed, its collection id 	 * is released so it can be reused. 	 *  	 * @return 	 * @throws ReadOnlyException 	 */
specifier|protected
name|short
name|getFreeCollectionId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|short
name|freeCollectionId
init|=
operator|-
literal|1
decl_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_collection_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|//				LOG.debug("reusing collection id: " + freeCollectionId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|2
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|freeCollectionId
return|;
block|}
comment|/** 	 * Get the next available unique collection id. 	 *  	 * @return 	 * @throws ReadOnlyException 	 */
specifier|protected
name|short
name|getNextCollectionId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|short
name|nextCollectionId
init|=
name|getFreeCollectionId
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextCollectionId
operator|>
operator|-
literal|1
condition|)
return|return
name|nextCollectionId
return|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__next_collection_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextCollectionId
return|;
block|}
comment|/** 	 * Release the document id reserved for a document so it 	 * can be reused. 	 *  	 * @param id 	 * @throws PermissionDeniedException 	 */
specifier|protected
name|void
name|freeDocument
parameter_list|(
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//		LOG.debug("freeing document " + id);
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_doc_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|4
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Get the next unused document id. If a document is removed, its doc id is 	 * released, so it can be reused. 	 *  	 * @return 	 * @throws ReadOnlyException 	 */
specifier|protected
name|int
name|getFreeDocId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeDocId
init|=
operator|-
literal|1
decl_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_doc_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//				LOG.debug("reusing document id: " + freeDocId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|4
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|freeDocId
return|;
block|}
specifier|public
name|int
name|getNextDocId
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|int
name|nextDocId
decl_stmt|;
try|try
block|{
name|nextDocId
operator|=
name|getFreeDocId
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e1
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nextDocId
operator|>
operator|-
literal|1
condition|)
return|return
name|nextDocId
return|;
else|else
name|nextDocId
operator|=
literal|1
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__next_doc_id"
argument_list|)
decl_stmt|;
name|Value
name|data
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|data
operator|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"database read-only"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextDocId
return|;
block|}
comment|/** 	 * Index a single node, which has been added through an XUpdate 	 * operation. This method is only called if inserting the node is possible 	 * without changing the node identifiers of sibling or parent nodes. In other  	 * cases, reindex will be called. 	 */
specifier|public
name|void
name|index
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
comment|// first, check available memory
if|if
condition|(
operator|++
name|nodesCount
operator|>
name|MEM_LIMIT_CHECK
condition|)
block|{
specifier|final
name|int
name|percent
init|=
operator|(
name|int
operator|)
operator|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
operator|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|100
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|percent
operator|<
name|memMinFree
condition|)
block|{
comment|//LOG.info(
comment|//	"total memory: " + run.totalMemory() + "; free: " + run.freeMemory());
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|FulltextIndexSpec
name|ftIdx
init|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|address
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"node "
operator|+
name|gid
operator|+
literal|": internal address missing"
argument_list|)
expr_stmt|;
specifier|final
name|int
name|depth
init|=
name|idxSpec
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idxSpec
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
specifier|final
name|int
name|level
init|=
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
decl_stmt|;
name|int
name|indexType
init|=
name|ValueIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
name|NodeProxy
name|tempProxy
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// skip
comment|//				qname = node.getQName();
comment|//				qname.setNameType(ElementValue.ELEMENT);
comment|//				tempProxy = new NodeProxy(doc, gid, address);
comment|//				if (idxSpec != null) {
comment|//				    ValueIndexSpec spec = idxSpec.getIndexByPath(currentPath);
comment|//				    if(spec != null) {
comment|//				        indexType = spec.getIndexType();
comment|//				    }
comment|//				}
comment|//				if(ftIdx == null || currentPath == null || ftIdx.match(currentPath))
comment|//				    indexType |= ValueIndexSpec.TEXT;
comment|//				tempProxy.setIndexType(indexType);
comment|//				elementIndex.setDocument(doc);
comment|//				elementIndex.addRow(qname, tempProxy);
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|tempProxy
operator|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|addComponent
argument_list|(
operator|new
name|QName
argument_list|(
literal|'@'
operator|+
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
name|indexType
operator|=
name|spec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|ValueIndexSpec
operator|.
name|TEXT
expr_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexAttribs
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ftIdx
operator|.
name|getIncludeAttributes
argument_list|()
condition|)
block|{
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|indexAttribs
operator|=
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|indexAttribs
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|spec
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexAttribs
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeText
argument_list|(
name|spec
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexText
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
operator|&&
name|currentPath
operator|!=
literal|null
condition|)
name|indexText
operator|=
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
name|boolean
name|valore
init|=
operator|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
condition|?
literal|false
else|:
name|ftIdx
operator|.
name|preserveContent
argument_list|(
name|currentPath
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|indexText
condition|)
name|textEngine
operator|.
name|storeText
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|valore
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|depth
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Reindex the nodes in the document. This method will either reindex all 	 * descendant nodes of the passed node, or all nodes below some level of 	 * the document if node is null. 	 */
specifier|public
name|void
name|reindex
parameter_list|(
specifier|final
name|DocumentImpl
name|oldDoc
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|,
specifier|final
name|NodeImpl
name|node
parameter_list|)
block|{
name|int
name|idxLevel
init|=
name|doc
operator|.
name|reindexRequired
argument_list|()
decl_stmt|;
if|if
condition|(
name|idxLevel
operator|<
literal|0
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
return|return;
block|}
name|oldDoc
operator|.
name|setReindexRequired
argument_list|(
name|idxLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindexing level "
operator|+
name|idxLevel
operator|+
literal|" of document "
operator|+
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|//		checkTree(doc);
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// remove all old index keys from the btree
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|ArrayList
name|nodes
init|=
name|domDb
operator|.
name|findKeys
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|long
name|gid
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|nodes
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ref
operator|=
operator|(
name|Value
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|gid
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|ref
operator|.
name|data
argument_list|()
argument_list|,
name|ref
operator|.
name|start
argument_list|()
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|>=
name|doc
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|XMLUtil
operator|.
name|isDescendant
argument_list|(
name|oldDoc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|gid
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|removeValue
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|domDb
operator|.
name|removeValue
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while reindexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while reindexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
try|try
block|{
comment|// now reindex the nodes
name|Iterator
name|iterator
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|NodeImpl
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|node
argument_list|,
name|node
operator|.
name|getPath
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error occured while reindexing document: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|elementIndex
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setReindexRequired
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//		checkTree(doc);
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindex took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Reindex the given node after the DOM tree has been  	 * modified by an XUpdate. 	 *  	 * @param node 	 * @param currentPath 	 */
specifier|private
name|void
name|reindex
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getGID
argument_list|()
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal node: "
operator|+
name|node
operator|.
name|getGID
argument_list|()
operator|+
literal|"; "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|FulltextIndexSpec
name|ftIdx
init|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|final
name|int
name|depth
init|=
name|idxSpec
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idxSpec
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
specifier|final
name|int
name|level
init|=
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|doc
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
name|NodeIndexListener
name|listener
init|=
name|doc
operator|.
name|getIndexListener
argument_list|()
decl_stmt|;
comment|// jmv if ((listener = doc.getIndexListener()) != null)
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
name|listener
operator|.
name|nodeChanged
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|depth
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|indexType
init|=
name|ValueIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// skip
comment|//					qname = node.getQName();
comment|//					qname.setNameType(ElementValue.ELEMENT);
comment|//					if (idxSpec != null) {
comment|//					    ValueIndexSpec spec = idxSpec.getIndexByPath(currentPath);
comment|//					    if(spec != null)
comment|//					        indexType = spec.getIndexType();
comment|//					}
comment|//					if(ftIdx == null || currentPath == null || ftIdx.match(currentPath))
comment|//					    indexType |= ValueIndexSpec.TEXT;
comment|//					tempProxy.setIndexType(indexType);
comment|//
comment|//					elementIndex.setDocument(doc);
comment|//					elementIndex.addRow(qname, tempProxy);
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|currentPath
operator|.
name|addComponent
argument_list|(
operator|new
name|QName
argument_list|(
literal|'@'
operator|+
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
name|indexType
operator|=
name|spec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|ValueIndexSpec
operator|.
name|TEXT
expr_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|spec
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexAttribs
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ftIdx
operator|.
name|getIncludeAttributes
argument_list|()
condition|)
block|{
name|indexAttribs
operator|=
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
block|}
else|else
name|indexAttribs
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|indexAttribs
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
literal|"&"
operator|+
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeText
argument_list|(
name|spec
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
block|{
name|boolean
name|valore
init|=
operator|(
name|ftIdx
operator|==
literal|null
condition|?
literal|false
else|:
name|ftIdx
operator|.
name|preserveContent
argument_list|(
name|currentPath
argument_list|)
operator|)
decl_stmt|;
name|textEngine
operator|.
name|storeText
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|valore
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/** 	 * Called by reindex to walk through all nodes in the tree and reindex them 	 * if necessary. 	 *  	 * @param iterator 	 * @param node 	 * @param currentPath 	 */
specifier|private
name|void
name|scanNodes
parameter_list|(
name|Iterator
name|iterator
parameter_list|,
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|fullReindex
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullReindex
condition|)
name|index
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
else|else
name|reindex
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|firstChildId
init|=
name|XMLUtil
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|NodeImpl
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|NodeImpl
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|fullReindex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Reindex the nodes in the document. This method will either reindex all 	 * descendant nodes of the passed node, or all nodes below some level of 	 * the document if node is null. 	 */
specifier|private
name|void
name|reindex
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reindexing document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|CollectionConfiguration
operator|.
name|COLLECTION_CONFIG_SUFFIX
argument_list|)
condition|)
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setConfigEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Iterator
name|iterator
decl_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|NodeImpl
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|CollectionConfiguration
operator|.
name|COLLECTION_CONFIG_SUFFIX
argument_list|)
condition|)
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setConfigEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindex took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|copyResource
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to copy resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to copy resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|int
name|p
init|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|newName
operator|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// check if the move would overwrite a collection
if|if
condition|(
name|getCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource can not replace an existing collection"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot copy resource to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
name|collection
operator|.
name|removeDocument
argument_list|(
name|this
argument_list|,
name|oldDoc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|newName
argument_list|,
name|destination
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextDocId
argument_list|(
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|copyResource
argument_list|(
name|doc
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|updateDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
comment|//	        saveCollection(destination);
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|copyResource
parameter_list|(
name|DocumentImpl
name|oldDoc
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying document "
operator|+
name|oldDoc
operator|.
name|getFileName
argument_list|()
operator|+
literal|" to "
operator|+
name|newDoc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Iterator
name|iterator
decl_stmt|;
name|NodeList
name|nodes
init|=
name|oldDoc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|NodeImpl
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|oldDoc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|newDoc
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copy took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|defrag
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"============> Defragmenting document "
operator|+
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
comment|//			checkTree(doc);
comment|// remember this for later remove
specifier|final
name|long
name|firstChild
init|=
name|doc
operator|.
name|getFirstChildAddress
argument_list|()
decl_stmt|;
comment|// dropping old structure index
name|elementIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|// dropping dom index
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// create a copy of the old doc to copy the nodes into it
name|DocumentImpl
name|tempDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|,
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|)
decl_stmt|;
name|tempDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|tempDoc
operator|.
name|setDocId
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy the nodes
name|Iterator
name|iterator
decl_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|NodeImpl
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|tempDoc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
comment|//			checkTree(tempDoc);
comment|// remove the old nodes
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|removeAll
argument_list|(
name|firstChild
argument_list|)
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//			checkTree(tempDoc);
name|doc
operator|.
name|copyChildren
argument_list|(
name|tempDoc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setSplitCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setAddress
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setPageCount
argument_list|(
name|tempDoc
operator|.
name|getPageCount
argument_list|()
argument_list|)
expr_stmt|;
comment|//			checkTree(doc);
name|storeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"new doc address = "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
comment|//			new DOMTransaction(this, domDb, Lock.READ_LOCK) {
comment|//				public Object start() throws ReadOnlyException {
comment|//					LOG.debug("Pages used: " + domDb.debugPages(doc));
comment|//					return null;
comment|//				}
comment|//			}.run();
name|saveCollection
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Defragmentation took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|copyNodes
parameter_list|(
name|Iterator
name|iterator
parameter_list|,
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getGID
argument_list|()
operator|==
literal|1
condition|)
name|newDoc
operator|.
name|appendChild
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|XMLUtil
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|NodeImpl
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|NodeImpl
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|copyNodes
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|consistencyCheck
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
block|{
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
name|checkTree
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|//			elementIndex.consistencyCheck(doc);
block|}
block|}
specifier|public
name|void
name|checkTree
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking DOM tree for document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pages used: "
operator|+
name|domDb
operator|.
name|debugPages
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|NodeImpl
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Iterator
name|iterator
init|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|checkTree
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|findKeys
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkTree
parameter_list|(
name|Iterator
name|iterator
parameter_list|,
name|NodeImpl
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|XMLUtil
operator|.
name|getFirstChildId
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|NodeImpl
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|NodeImpl
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"child "
operator|+
name|gid
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|checkTree
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|NodeProxy
name|proxy
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
return|return
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|proxy
argument_list|,
name|addWhitespace
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
comment|/** 	 *  This method handles left or left-and-right truncated search terms. In 	 *  these cases it is not possible to use the cdata-index, since it contains 	 *  just the first 8 bytes of every cdata-string. 	 * 	 *@param  context   Description of the Parameter 	 *@param  docs      Description of the Parameter 	 *@param  relation  Description of the Parameter 	 *@param  expr      Description of the Parameter 	 *@return           The nodesEqualTo value 	 */
specifier|public
name|NodeSet
name|getNodesEqualTo
parameter_list|(
name|NodeSet
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|int
name|relation
parameter_list|,
name|String
name|expr
parameter_list|,
name|Collator
name|collator
parameter_list|)
block|{
comment|//		long start = System.currentTimeMillis();
comment|// NodeSet temp;
name|int
name|truncation
init|=
name|Constants
operator|.
name|TRUNC_NONE
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|expr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'%'
condition|)
block|{
name|expr
operator|=
name|expr
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|truncation
operator|=
name|Constants
operator|.
name|TRUNC_LEFT
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|expr
operator|.
name|charAt
argument_list|(
name|expr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'%'
condition|)
block|{
name|expr
operator|=
name|expr
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|expr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|truncation
operator|=
operator|(
name|truncation
operator|==
name|Constants
operator|.
name|TRUNC_LEFT
operator|)
condition|?
name|Constants
operator|.
name|TRUNC_BOTH
else|:
name|Constants
operator|.
name|TRUNC_RIGHT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isCaseSensitive
argument_list|()
condition|)
name|expr
operator|=
name|expr
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|NodeSet
name|result
init|=
name|scanSequential
argument_list|(
name|context
argument_list|,
name|docs
argument_list|,
name|relation
argument_list|,
name|truncation
argument_list|,
name|expr
argument_list|,
name|collator
argument_list|)
decl_stmt|;
comment|//				LOG.debug(
comment|//					"searching "
comment|//						+ result.getLength()
comment|//						+ " nodes took "
comment|//						+ (System.currentTimeMillis() - start)
comment|//						+ "ms.");
return|return
name|result
return|;
block|}
comment|/** 	 *  get collection object If the collection does not yet exists, it is 	 *  created automatically. 	 * 	 *@param  name                           the collection's name 	 *@param  user                           Description of the Parameter 	 *@return                                The orCreateCollection value 	 *@exception  PermissionDeniedException  Description of the Exception 	 *@author=@author 	 */
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//		final long start = System.currentTimeMillis();
name|name
operator|=
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|name
operator|=
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
name|name
operator|=
name|ROOT_COLLECTION
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
try|try
block|{
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|temp
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|ROOT_COLLECTION
decl_stmt|;
name|Collection
name|sub
decl_stmt|;
name|Collection
name|current
init|=
name|getCollection
argument_list|(
name|ROOT_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating root collection /db"
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|Collection
argument_list|(
name|collectionsDb
argument_list|,
name|ROOT_COLLECTION
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setPermissions
argument_list|(
literal|0777
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|user
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|temp
operator|=
name|tok
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|path
operator|=
name|path
operator|+
literal|"/"
operator|+
name|temp
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasSubcollection
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|current
operator|=
name|getCollection
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"permission denied to create collection "
operator|+
name|path
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"not allowed to write to collection"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating collection "
operator|+
name|path
argument_list|)
expr_stmt|;
name|sub
operator|=
operator|new
name|Collection
argument_list|(
name|collectionsDb
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|user
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|addCollection
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|sub
expr_stmt|;
block|}
block|}
comment|//			LOG.debug("getOrCreateCollection took " +
comment|//				(System.currentTimeMillis() - start) + "ms.");
return|return
name|current
return|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** 	 *  Gets a range of nodes, starting with first, ending with last 	 * 	 *@param  doc    the document 	 *@param  first  node-id of the first node 	 *@param  last   node-id of the last node 	 *@return        a list of nodes 	 */
specifier|public
name|NodeList
name|getRange
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|long
name|first
parameter_list|,
specifier|final
name|long
name|last
parameter_list|)
block|{
name|NodeListImpl
name|result
init|=
operator|new
name|NodeListImpl
argument_list|(
operator|(
name|int
operator|)
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|first
init|;
name|gid
operator|<=
name|last
condition|;
name|gid
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|objectWith
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|Serializer
name|getSerializer
parameter_list|()
block|{
name|xmlSerializer
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|xmlSerializer
return|;
block|}
specifier|public
name|TextSearchEngine
name|getTextEngine
parameter_list|()
block|{
return|return
name|textEngine
return|;
block|}
specifier|public
name|NativeValueIndex
name|getValueIndex
parameter_list|()
block|{
return|return
name|valueIndex
return|;
block|}
specifier|public
name|Serializer
name|newSerializer
parameter_list|()
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Node
name|objectWith
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|long
name|gid
parameter_list|)
block|{
return|return
operator|(
name|Node
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|,
name|gid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
comment|//				    if(LOG.isDebugEnabled()) {
comment|//				        LOG.debug("node " + gid + " not found in document " + ((DocumentImpl)doc).getDocId());
comment|//				        Thread.dumpStack();
comment|//				    }
return|return
literal|null
return|;
block|}
name|NodeImpl
name|node
init|=
name|NodeImpl
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
decl_stmt|;
name|node
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|Node
name|objectWith
parameter_list|(
specifier|final
name|NodeProxy
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|getInternalAddress
argument_list|()
operator|<
literal|0
condition|)
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|gid
argument_list|)
return|;
return|return
operator|(
name|Node
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|p
operator|.
name|gid
operator|+
literal|" not found in document "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"; docId = "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
comment|//					LOG.debug(domDb.debugPages(p.doc));
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
comment|//					return null;
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|gid
argument_list|)
return|;
comment|// retry?
block|}
name|NodeImpl
name|node
init|=
name|NodeImpl
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|p
operator|.
name|getDocument
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|setGID
argument_list|(
name|p
operator|.
name|gid
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|void
name|dropIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|textEngine
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dropping index for document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reindexing collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|next
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|reindex
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|next
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Collection
name|child
init|=
name|getCollection
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection "
operator|+
name|next
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
else|else
name|reindex
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|String
name|collectionName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collectionName
operator|.
name|startsWith
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
name|collectionName
operator|=
name|ROOT_COLLECTION
operator|+
name|collectionName
expr_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collectionName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|reindex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|removeCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"not allowed to remove collection"
argument_list|)
throw|;
specifier|final
name|boolean
name|isRoot
init|=
name|collection
operator|.
name|getParentPath
argument_list|()
operator|==
literal|null
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
comment|// remove from parent collection
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentPath
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|removeCollection
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"LockException while removing collection "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|parent
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// remove child collections
name|String
name|childName
decl_stmt|;
name|Collection
name|childCollection
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing sub-collections"
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childName
operator|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|childCollection
operator|=
name|openCollection
argument_list|(
name|name
operator|+
literal|'/'
operator|+
name|childName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|childCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|childCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// if this is not the root collection remove it completely
if|if
condition|(
name|isRoot
condition|)
name|saveCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
else|else
block|{
name|Value
name|key
decl_stmt|;
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|freeCollection
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on collections.dbx"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|textEngine
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing resources ..."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing document "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
operator|(
operator|(
name|BinaryDocument
operator|)
name|doc
operator|)
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeImpl
name|node
init|=
operator|(
name|NodeImpl
operator|)
name|doc
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|freeDocument
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
name|void
name|removeDocument
parameter_list|(
specifier|final
name|DocumentImpl
name|document
parameter_list|,
name|boolean
name|freeDocId
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"removeDocument() - "
operator|+
literal|"removing document "
operator|+
name|document
operator|.
name|getDocId
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
block|}
name|elementIndex
operator|.
name|dropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|dropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|dropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - removing dom"
argument_list|)
expr_stmt|;
block|}
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|NodeImpl
name|node
init|=
operator|(
name|NodeImpl
operator|)
name|document
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
if|if
condition|(
name|freeDocId
condition|)
name|freeDocument
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeDocument(String) - "
operator|+
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeNode
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|FulltextIndexSpec
name|ftIdx
init|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|>
operator|-
literal|1
condition|)
name|domDb
operator|.
name|remove
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|domDb
operator|.
name|remove
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// save element by calling ElementIndex
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|currentPath
operator|.
name|addComponent
argument_list|(
operator|new
name|QName
argument_list|(
literal|'@'
operator|+
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexAttribs
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|ftIdx
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ftIdx
operator|.
name|getIncludeAttributes
argument_list|()
condition|)
block|{
name|indexAttribs
operator|=
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
block|}
else|else
name|indexAttribs
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|indexAttribs
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|spec
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
block|{
name|boolean
name|valore
init|=
operator|(
name|ftIdx
operator|==
literal|null
condition|?
literal|false
else|:
name|ftIdx
operator|.
name|preserveContent
argument_list|(
name|currentPath
argument_list|)
operator|)
decl_stmt|;
name|textEngine
operator|.
name|storeText
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|valore
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeText
argument_list|(
name|spec
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
specifier|public
name|void
name|addDocument
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|Value
name|name
decl_stmt|;
try|try
block|{
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|uee
argument_list|)
expr_stmt|;
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|storeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|doc
operator|.
name|write
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|long
name|address
init|=
name|collectionsDb
operator|.
name|append
argument_list|(
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not store collection data for "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections.dbx"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|saveCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
comment|// don't cache the collection during initialization: SecurityManager is not yet online
name|pool
operator|.
name|getCollectionsCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|<
literal|0
condition|)
name|collection
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|Value
name|name
decl_stmt|;
try|try
block|{
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|uee
argument_list|)
expr_stmt|;
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|collection
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
specifier|final
name|long
name|addr
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not store collection data for "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock for collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|moveResource
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move resource "
operator|+
name|doc
operator|.
name|getFileName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|int
name|p
init|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|newName
operator|=
name|doc
operator|.
name|getFileName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// check if the move would overwrite a collection
if|if
condition|(
name|getCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource can not replace an existing collection"
argument_list|)
throw|;
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move resource to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|UPDATE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Resource with same name exists in target "
operator|+
literal|"collection and update is denied"
argument_list|)
throw|;
name|collection
operator|.
name|removeDocument
argument_list|(
name|this
argument_list|,
name|oldDoc
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else 	            if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|boolean
name|renameOnly
init|=
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
decl_stmt|;
name|collection
operator|.
name|unlinkDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
name|elementIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
comment|// reindexing
name|reindex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|saveCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|copyCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Read permission denied on collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|int
name|p
init|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|newName
operator|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newName
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|>
operator|-
literal|1
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name is illegal (may not contain a '/')"
argument_list|)
throw|;
comment|//	check if another collection with the same name exists at the destination
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing old collection: "
operator|+
name|newName
argument_list|)
expr_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Collection
name|destCollection
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|newName
operator|=
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying collection to "
operator|+
name|newName
argument_list|)
expr_stmt|;
name|destCollection
operator|=
name|getOrCreateCollection
argument_list|(
name|newName
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|child
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying resource: "
operator|+
name|child
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|this
argument_list|,
name|child
operator|.
name|getFileName
argument_list|()
argument_list|,
name|destCollection
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|copyResource
argument_list|(
name|child
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
name|saveCollection
argument_list|(
name|destCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|childName
init|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|name
operator|+
literal|'/'
operator|+
name|childName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection "
operator|+
name|childName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|copyCollection
argument_list|(
name|child
argument_list|,
name|destCollection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|saveCollection
argument_list|(
name|destCollection
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|moveCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|ROOT_COLLECTION
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move the db root collection"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|int
name|p
init|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|newName
operator|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newName
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|>
operator|-
literal|1
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name is illegal (may not contain a '/')"
argument_list|)
throw|;
comment|// check if another collection with the same name exists at the destination
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|removeCollection
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentPath
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|removeCollection
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|parent
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Value
name|key
decl_stmt|;
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setName
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|saveCollection
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|destination
condition|)
name|saveCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|String
name|childName
decl_stmt|;
name|Collection
name|child
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childName
operator|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|child
operator|=
name|openCollection
argument_list|(
name|name
operator|+
literal|'/'
operator|+
name|childName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection "
operator|+
name|childName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|moveCollection
argument_list|(
name|child
argument_list|,
name|collection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/** 	 *  Do a sequential search through the DOM-file. 	 * 	 *@param  context     Description of the Parameter 	 *@param  doc         Description of the Parameter 	 *@param  relation    Description of the Parameter 	 *@param  truncation  Description of the Parameter 	 *@param  expr        Description of the Parameter 	 *@return             Description of the Return Value 	 */
specifier|protected
name|NodeSet
name|scanSequential
parameter_list|(
name|NodeSet
name|context
parameter_list|,
name|DocumentSet
name|doc
parameter_list|,
name|int
name|relation
parameter_list|,
name|int
name|truncation
parameter_list|,
name|String
name|expr
parameter_list|,
name|Collator
name|collator
parameter_list|)
block|{
name|ArraySet
name|resultNodeSet
init|=
operator|new
name|ArraySet
argument_list|(
name|context
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|NodeProxy
name|p
decl_stmt|;
name|String
name|content
decl_stmt|;
name|String
name|cmp
decl_stmt|;
name|Pattern
name|regexp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|relation
operator|==
name|Constants
operator|.
name|REGEXP
condition|)
try|try
block|{
name|regexp
operator|=
name|compiler
operator|.
name|compile
argument_list|(
name|expr
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|Perl5Compiler
operator|.
name|CASE_INSENSITIVE_MASK
argument_list|)
expr_stmt|;
name|truncation
operator|=
name|Constants
operator|.
name|REGEXP
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedPatternException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|context
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|NodeProxy
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|setOwnerObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|content
operator|=
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire read lock on dom.dbx"
argument_list|)
expr_stmt|;
continue|continue;
block|}
finally|finally
block|{
name|domDb
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isCaseSensitive
argument_list|()
condition|)
name|cmp
operator|=
name|StringValue
operator|.
name|collapseWhitespace
argument_list|(
name|content
argument_list|)
expr_stmt|;
else|else
block|{
name|cmp
operator|=
name|StringValue
operator|.
name|collapseWhitespace
argument_list|(
name|content
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|truncation
condition|)
block|{
case|case
name|Constants
operator|.
name|TRUNC_LEFT
case|:
if|if
condition|(
name|Collations
operator|.
name|endsWith
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|Collations
operator|.
name|startsWith
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_BOTH
case|:
if|if
condition|(
operator|-
literal|1
operator|<
name|Collations
operator|.
name|indexOf
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_NONE
case|:
if|if
condition|(
name|compare
argument_list|(
name|collator
argument_list|,
name|cmp
argument_list|,
name|expr
argument_list|,
name|relation
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|REGEXP
case|:
if|if
condition|(
name|regexp
operator|!=
literal|null
operator|&&
name|matcher
operator|.
name|contains
argument_list|(
name|cmp
argument_list|,
name|regexp
argument_list|)
condition|)
block|{
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|resultNodeSet
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|super
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR_SYNC
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|close
argument_list|()
expr_stmt|;
name|domDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|elementsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|valuesDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 *  Store a node into the database. This method is called by the parser to 	 *  write a node to the storage backend. 	 * 	 *@param  node         the node to be stored 	 *@param  currentPath  path expression which points to this node's 	 *      element-parent or to itself if it is an element (currently used by 	 *      the Broker to determine if a node's content should be 	 *      fulltext-indexed). 	 */
specifier|public
name|void
name|store
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|boolean
name|index
parameter_list|)
block|{
comment|// first, check available memory
if|if
condition|(
name|nodesCount
operator|>
name|MEM_LIMIT_CHECK
condition|)
block|{
specifier|final
name|int
name|percent
init|=
operator|(
name|int
operator|)
operator|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
operator|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|100
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|percent
operator|<
name|memMinFree
condition|)
block|{
comment|//LOG.info(
comment|//	"total memory: " + run.totalMemory() + "; free: " + run.freeMemory());
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isTemp
init|=
name|TEMP_COLLECTION
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|FulltextIndexSpec
name|ftIdx
init|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
if|if
condition|(
name|gid
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal node: "
operator|+
name|gid
operator|+
literal|"; "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
specifier|final
name|int
name|depth
init|=
name|idxSpec
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idxSpec
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|long
name|address
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|TEXT_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|||
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|>
name|depth
condition|)
name|address
operator|=
name|domDb
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|address
operator|=
name|domDb
operator|.
name|put
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|<
literal|0
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"address is missing"
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|++
name|nodesCount
expr_stmt|;
name|NodeProxy
name|tempProxy
init|=
literal|null
decl_stmt|;
name|QName
name|qname
decl_stmt|;
name|int
name|indexType
init|=
name|ValueIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// skip
comment|//				tempProxy = new NodeProxy(doc, gid, node.getInternalAddress());
comment|//				if (idxSpec != null) {
comment|//				    ValueIndexSpec spec = idxSpec.getIndexByPath(currentPath);
comment|//				    if(spec != null)
comment|//				        indexType = spec.getIndexType();
comment|//				}
comment|//				if(ftIdx == null || currentPath == null || ftIdx.match(currentPath))
comment|//				    indexType |= ValueIndexSpec.TEXT;
comment|//				tempProxy.setIndexType(indexType);
comment|//
comment|//				// save element by calling ElementIndex
comment|//				elementIndex.setDocument(doc);
comment|//				elementIndex.addRow(node.getQName(), tempProxy);
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|tempProxy
operator|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|addComponent
argument_list|(
operator|new
name|QName
argument_list|(
literal|'@'
operator|+
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|indexType
operator|=
name|spec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|ValueIndexSpec
operator|.
name|TEXT
expr_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
name|boolean
name|indexAttribs
init|=
name|index
decl_stmt|;
if|if
condition|(
name|index
operator|&&
name|ftIdx
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ftIdx
operator|.
name|getIncludeAttributes
argument_list|()
condition|)
block|{
name|indexAttribs
operator|=
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
expr_stmt|;
block|}
else|else
name|indexAttribs
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|spec
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexAttribs
operator|&&
operator|!
name|isTemp
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//LOG.debug("found ID: " + qname.getLocalName());
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
operator|!
name|isTemp
operator|&&
name|index
condition|)
block|{
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeText
argument_list|(
name|spec
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
block|{
name|boolean
name|valore
init|=
operator|(
name|ftIdx
operator|==
literal|null
condition|?
literal|false
else|:
name|ftIdx
operator|.
name|preserveContent
argument_list|(
name|currentPath
argument_list|)
operator|)
decl_stmt|;
name|textEngine
operator|.
name|storeText
argument_list|(
name|ftIdx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|valore
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
specifier|public
name|void
name|endElement
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexSpec
name|idxSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIdxConf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|FulltextIndexSpec
name|ftIdx
init|=
name|idxSpec
operator|!=
literal|null
condition|?
name|idxSpec
operator|.
name|getFulltextIndexSpec
argument_list|()
else|:
literal|null
decl_stmt|;
name|int
name|indexType
init|=
name|ValueIndexSpec
operator|.
name|NO_INDEX
decl_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
name|ValueIndexSpec
name|spec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
name|indexType
operator|=
name|spec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ftIdx
operator|==
literal|null
operator|||
name|currentPath
operator|==
literal|null
operator|||
name|ftIdx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|indexType
operator||=
name|ValueIndexSpec
operator|.
name|TEXT
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|-
name|node
operator|.
name|getAttributesCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|indexType
operator||=
name|ValueIndexSpec
operator|.
name|MIXED_CONTENT
expr_stmt|;
block|}
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|node
operator|.
name|getQName
argument_list|()
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
comment|// save element by calling ElementIndex
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|storeDocument
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|doc
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|doc
operator|.
name|getAddress
argument_list|()
operator|>
operator|-
literal|1
condition|)
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|setAddress
argument_list|(
name|domDb
operator|.
name|add
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|//				LOG.debug("Document metadata stored to " + StorageAddress.toString(doc.getAddress()));
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|updateDocument
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
name|storeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
comment|//				if (blob.getPage()> -1) {
comment|//					domDb.remove(blob.getPage());
comment|//				}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing binary resource "
operator|+
name|blob
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
name|blob
operator|.
name|setPage
argument_list|(
name|domDb
operator|.
name|addBinary
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|byte
index|[]
name|getBinaryResourceData
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
operator|(
name|byte
index|[]
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
return|return
name|domDb
operator|.
name|getBinary
argument_list|(
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
decl_stmt|;
return|return
name|data
return|;
block|}
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"removing binary resource "
operator|+
name|blob
operator|.
name|getDocId
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|blob
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|readDocumentMetadata
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
specifier|final
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
decl_stmt|;
name|doc
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|sync
parameter_list|(
name|int
name|syncEvent
parameter_list|)
block|{
try|try
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while flushing dom.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
if|if
condition|(
name|syncEvent
operator|==
name|Sync
operator|.
name|MAJOR_SYNC
condition|)
block|{
name|elementIndex
operator|.
name|sync
argument_list|()
expr_stmt|;
name|textEngine
operator|.
name|sync
argument_list|()
expr_stmt|;
name|valueIndex
operator|.
name|sync
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|Runtime
name|runtime
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Memory: "
operator|+
operator|(
name|runtime
operator|.
name|totalMemory
argument_list|()
operator|/
literal|1024
operator|)
operator|+
literal|"K total; "
operator|+
operator|(
name|runtime
operator|.
name|maxMemory
argument_list|()
operator|/
literal|1024
operator|)
operator|+
literal|"K max; "
operator|+
operator|(
name|runtime
operator|.
name|freeMemory
argument_list|()
operator|/
literal|1024
operator|)
operator|+
literal|"K free"
argument_list|)
expr_stmt|;
comment|// uncomment this to get statistics on page buffer usage
name|elementsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|valuesDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|domDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|dbe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|getPageSize
parameter_list|()
block|{
return|return
name|pageSize
return|;
block|}
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|internalAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
operator|-
literal|1
operator|<
name|internalAddress
condition|)
name|domDb
operator|.
name|update
argument_list|(
name|internalAddress
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|domDb
operator|.
name|update
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Value
name|oldVal
init|=
name|domDb
operator|.
name|get
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|NodeImpl
name|old
init|=
name|NodeImpl
operator|.
name|deserialize
argument_list|(
name|oldVal
operator|.
name|data
argument_list|()
argument_list|,
name|oldVal
operator|.
name|start
argument_list|()
argument_list|,
name|oldVal
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while storing "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
operator|+
literal|"; old = "
operator|+
name|old
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Physically insert a node into the DOM storage. 	 */
specifier|public
name|void
name|insertAfter
parameter_list|(
specifier|final
name|NodeImpl
name|previous
parameter_list|,
specifier|final
name|NodeImpl
name|node
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|previous
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|long
name|address
init|=
name|previous
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|>
operator|-
literal|1
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|doc
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|previous
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|doc
argument_list|,
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
specifier|public
name|DocumentImpl
name|storeTemporaryDoc
parameter_list|(
name|String
name|data
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
name|String
name|docName
init|=
name|MD5
operator|.
name|md
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|".xml"
decl_stmt|;
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
name|temp
operator|=
name|createTempCollection
argument_list|()
expr_stmt|;
name|IndexInfo
name|info
decl_stmt|;
try|try
block|{
name|info
operator|=
name|temp
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|docName
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|TEMP_STORE_ERROR
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|TEMP_STORE_ERROR
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|temp
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|temp
operator|.
name|store
argument_list|(
name|this
argument_list|,
name|info
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|TEMP_STORE_ERROR
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
name|TEMP_STORE_ERROR
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|info
operator|.
name|getDocument
argument_list|()
return|;
block|}
specifier|public
name|void
name|removeTempDocs
parameter_list|(
name|List
name|docs
parameter_list|)
block|{
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
try|try
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|temp
operator|.
name|removeDocument
argument_list|(
name|this
argument_list|,
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|TEMP_FRAGMENT_REMOVE_ERROR
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|temp
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|cleanUpAll
parameter_list|()
block|{
name|Collection
name|temp
init|=
name|getCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|removeCollection
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
name|Collection
name|temp
init|=
name|getCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
return|return;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|temp
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DocumentImpl
name|next
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|modified
init|=
name|next
operator|.
name|getLastModified
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|modified
operator|>
name|TEMP_FRAGMENT_TIMEOUT
condition|)
try|try
block|{
name|temp
operator|.
name|removeDocument
argument_list|(
name|this
argument_list|,
name|next
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermissionDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Collection
name|createTempCollection
parameter_list|()
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
block|{
name|User
name|u
init|=
name|user
decl_stmt|;
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|user
operator|=
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getUser
argument_list|(
name|SecurityManager
operator|.
name|DBA_USER
argument_list|)
expr_stmt|;
name|Collection
name|temp
init|=
name|getOrCreateCollection
argument_list|(
name|TEMP_COLLECTION
argument_list|)
decl_stmt|;
name|temp
operator|.
name|setPermissions
argument_list|(
literal|0777
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
name|user
operator|=
name|u
expr_stmt|;
block|}
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NodeRef
extends|extends
name|Value
block|{
comment|/**          * Log4J Logger for this class          */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NodeRef
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
name|NodeRef
parameter_list|()
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|gid
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
literal|12
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|4
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|getDocId
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|long
name|getGid
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
return|;
block|}
name|void
name|set
parameter_list|(
name|int
name|docId
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|gid
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
literal|12
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

