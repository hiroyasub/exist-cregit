begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database  * Copyright (C) 2001-2007 The eXist team  * http://exist-db.org  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *    * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU Lesser General Public License for more details.  *   * You should have received a copy of the GNU Lesser General Public License  * along with this program; if not, write to the Free Software Foundation  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  *    * $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|Indexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|backup
operator|.
name|RawDataBackup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
operator|.
name|CollectionEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
operator|.
name|SubCollectionEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionConfigurationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|CollectionTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|CollectionTriggers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|CollectionTriggersVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|DocumentTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|DocumentTriggers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|DocumentTriggersVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|triggers
operator|.
name|TriggerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|fulltext
operator|.
name|FTIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|fulltext
operator|.
name|FTIndexWorker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StreamListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|indexing
operator|.
name|StructuralIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DOMIndexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|numbering
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Account
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|MessageDigester
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|stax
operator|.
name|EmbeddedXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Paged
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
operator|.
name|Paged
operator|.
name|Page
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|DOMTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|dom
operator|.
name|RawNodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|index
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Journal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|LogEntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Loggable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|lock
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|NativeSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
operator|.
name|Sync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArrayPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|DatabaseConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DocumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_comment
comment|/**  *  Main class for the native XML storage backend.  *  By "native" it is meant file-based, embedded backend.  *   * Provides access to all low-level operations required by  * the database. Extends {@link DBBroker}.  *   * Observer Design Pattern: role : this class is the subject (alias observable)  * for various classes that generate indices for the database content :  * @link org.exist.storage.NativeElementIndex  * @link org.exist.storage.NativeTextEngine  * @link org.exist.storage.NativeValueIndex   * @link org.exist.storage.NativeValueIndexByQName  *   * This class dispatches the various events (defined by the methods   * of @link org.exist.storage.ContentLoadingObserver) to indexing classes.  *   *@author     Wolfgang Meier  */
end_comment

begin_class
specifier|public
class|class
name|NativeBroker
extends|extends
name|DBBroker
block|{
specifier|public
specifier|final
specifier|static
name|String
name|EXIST_STATISTICS_LOGGER
init|=
literal|"org.exist.statistics"
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|Logger
name|LOGSTATS
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|EXIST_STATISTICS_LOGGER
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_RENAME_BINARY
init|=
literal|0x40
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_CREATE_BINARY
init|=
literal|0x41
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_BINARY
init|=
literal|0x42
decl_stmt|;
static|static
block|{
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_RENAME_BINARY
argument_list|,
name|RenameBinaryLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_CREATE_BINARY
argument_list|,
name|CreateBinaryLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_BINARY
argument_list|,
name|UpdateBinaryLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_ALWAYS
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_NEVER
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|PREPEND_DB_AS_NEEDED
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|COLLECTIONS_DBX_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|VALUES_DBX_ID
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|DOM_DBX_ID
init|=
literal|3
decl_stmt|;
comment|//Note : no ID for symbols ? Too bad...
specifier|public
specifier|static
specifier|final
name|String
name|PAGE_SIZE_ATTRIBUTE
init|=
literal|"pageSize"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_DEPTH_ATTRIBUTE
init|=
literal|"index-depth"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_INDEX_DEPTH
init|=
literal|"indexer.index-depth"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ALL_STORAGE_FILES
init|=
block|{
name|COLLECTIONS_DBX_ID
block|,
name|VALUES_DBX_ID
block|,
name|DOM_DBX_ID
block|}
decl_stmt|;
comment|//private static final String TEMP_FRAGMENT_REMOVE_ERROR = "Could not remove temporary fragment";
comment|// private static final String TEMP_STORE_ERROR = "An error occurred while storing temporary data: ";
specifier|private
specifier|static
specifier|final
name|String
name|EXCEPTION_DURING_REINDEX
init|=
literal|"exception during reindex"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DATABASE_IS_READ_ONLY
init|=
literal|"database is read-only"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_DATA_DIR
init|=
literal|"data"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INDEX_DEPTH
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_MEMORY
init|=
literal|5000000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TEMP_FRAGMENT_TIMEOUT
init|=
literal|60000
decl_stmt|;
comment|/** default buffer size setting */
specifier|public
specifier|static
specifier|final
name|int
name|BUFFERS
init|=
literal|256
decl_stmt|;
comment|/** check available memory after storing DEFAULT_NODES_BEFORE_MEMORY_CHECK nodes */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
init|=
literal|500
decl_stmt|;
specifier|public
specifier|static
name|int
name|OFFSET_COLLECTION_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
name|int
name|OFFSET_VALUE
init|=
name|OFFSET_COLLECTION_ID
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
decl_stmt|;
comment|//2
specifier|public
specifier|final
specifier|static
name|String
name|INIT_COLLECTION_CONFIG
init|=
literal|"collection.xconf.init"
decl_stmt|;
comment|/** the database files */
specifier|protected
name|CollectionStore
name|collectionsDb
decl_stmt|;
specifier|protected
name|DOMFile
name|domDb
decl_stmt|;
comment|/** the index processors */
specifier|protected
name|NativeValueIndex
name|valueIndex
decl_stmt|;
specifier|protected
name|IndexSpec
name|indexConfiguration
decl_stmt|;
specifier|protected
name|int
name|defaultIndexDepth
decl_stmt|;
specifier|protected
name|Serializer
name|xmlSerializer
decl_stmt|;
comment|/** used to count the nodes inserted after the last memory check */
specifier|protected
name|int
name|nodesCount
init|=
literal|0
decl_stmt|;
specifier|protected
name|int
name|nodesCountThreshold
init|=
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
decl_stmt|;
specifier|protected
name|String
name|dataDir
decl_stmt|;
specifier|protected
name|File
name|fsDir
decl_stmt|;
specifier|protected
name|File
name|fsBackupDir
decl_stmt|;
specifier|protected
name|int
name|pageSize
decl_stmt|;
specifier|protected
name|byte
name|prepend
decl_stmt|;
specifier|private
specifier|final
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
specifier|private
name|NodeProcessor
name|nodeProcessor
init|=
operator|new
name|NodeProcessor
argument_list|()
decl_stmt|;
specifier|private
name|EmbeddedXMLStreamReader
name|streamReader
init|=
literal|null
decl_stmt|;
specifier|protected
name|Journal
name|logManager
decl_stmt|;
specifier|protected
name|boolean
name|incrementalDocIds
init|=
literal|false
decl_stmt|;
comment|/** initialize database; read configuration, etc. */
specifier|public
name|NativeBroker
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|Configuration
name|config
parameter_list|)
throws|throws
name|EXistException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|logManager
operator|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
operator|.
name|getJournal
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing broker "
operator|+
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|prependDB
init|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.prepend-db"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"always"
operator|.
name|equalsIgnoreCase
argument_list|(
name|prependDB
argument_list|)
condition|)
block|{
name|prepend
operator|=
name|PREPEND_DB_ALWAYS
expr_stmt|;
block|}
if|else if
condition|(
literal|"never"
operator|.
name|equalsIgnoreCase
argument_list|(
name|prependDB
argument_list|)
condition|)
block|{
name|prepend
operator|=
name|PREPEND_DB_NEVER
expr_stmt|;
block|}
else|else
block|{
name|prepend
operator|=
name|PREPEND_DB_AS_NEEDED
expr_stmt|;
block|}
name|dataDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|BrokerPool
operator|.
name|PROPERTY_DATA_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
block|{
name|dataDir
operator|=
name|DEFAULT_DATA_DIR
expr_stmt|;
block|}
name|fsDir
operator|=
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
argument_list|)
argument_list|,
literal|"fs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fsDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Cannot make collection filesystem directory: "
operator|+
name|fsDir
argument_list|)
throw|;
block|}
block|}
name|fsBackupDir
operator|=
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
argument_list|)
argument_list|,
literal|"fs.journal"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsBackupDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fsBackupDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Cannot make collection filesystem directory: "
operator|+
name|fsBackupDir
argument_list|)
throw|;
block|}
block|}
name|nodesCountThreshold
operator|=
name|config
operator|.
name|getInteger
argument_list|(
name|BrokerPool
operator|.
name|PROPERTY_NODES_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodesCountThreshold
operator|>
literal|0
condition|)
block|{
name|nodesCountThreshold
operator|=
name|nodesCountThreshold
operator|*
literal|1000
expr_stmt|;
block|}
name|defaultIndexDepth
operator|=
name|config
operator|.
name|getInteger
argument_list|(
name|PROPERTY_INDEX_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultIndexDepth
operator|<
literal|0
condition|)
block|{
name|defaultIndexDepth
operator|=
name|DEFAULT_INDEX_DEPTH
expr_stmt|;
block|}
specifier|final
name|String
name|docIdProp
init|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|BrokerPool
operator|.
name|DOC_ID_MODE_PROPERTY
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIdProp
operator|!=
literal|null
condition|)
block|{
name|incrementalDocIds
operator|=
name|docIdProp
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"incremental"
argument_list|)
expr_stmt|;
block|}
name|indexConfiguration
operator|=
operator|(
name|IndexSpec
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|Indexer
operator|.
name|PROPERTY_INDEXER_CONFIG
argument_list|)
expr_stmt|;
name|xmlSerializer
operator|=
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|setSubject
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|//TODO : refactor so that we can,
comment|//1) customize the different properties (file names, cache settings...)
comment|//2) have a consistent READ-ONLY behaviour (based on *mandatory* files ?)
comment|//3) have consistent file creation behaviour (we can probably avoid some unnecessary files)
comment|//4) use... *customized* factories for a better index plugability ;-)
comment|// Initialize DOM storage
name|domDb
operator|=
operator|(
name|DOMFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|DOMFile
operator|.
name|getConfigKeyForFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|domDb
operator|==
literal|null
condition|)
block|{
name|domDb
operator|=
operator|new
name|DOMFile
argument_list|(
name|pool
argument_list|,
name|DOM_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domDb
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|domDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is read-only!"
argument_list|)
expr_stmt|;
name|pool
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
block|}
comment|//Initialize collections storage
name|collectionsDb
operator|=
operator|(
name|CollectionStore
operator|)
name|config
operator|.
name|getProperty
argument_list|(
name|CollectionStore
operator|.
name|getConfigKeyForFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|collectionsDb
operator|==
literal|null
condition|)
block|{
name|collectionsDb
operator|=
operator|new
name|CollectionStore
argument_list|(
name|pool
argument_list|,
name|COLLECTIONS_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collectionsDb
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is read-only!"
argument_list|)
expr_stmt|;
name|pool
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
block|}
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|VALUES_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Database runs in read-only mode"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ElementIndex
name|getElementIndex
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|addObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
name|super
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|//textEngine.addObserver(o);
comment|//elementIndex.addObserver(o);
comment|//TODO : what about other indexes observers ?
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|deleteObservers
parameter_list|()
block|{
name|super
operator|.
name|deleteObservers
argument_list|()
expr_stmt|;
comment|//if (elementIndex != null)
comment|//elementIndex.deleteObservers();
comment|//TODO : what about other indexes observers ?
comment|//if (textEngine != null)
comment|//textEngine.deleteObservers();
block|}
comment|// ============ dispatch the various events to indexing classes ==========
specifier|private
name|void
name|notifyRemoveNode
parameter_list|(
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|removeNode
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
comment|//private void notifyStoreAttribute(AttrImpl attr, NodePath currentPath, int indexingHint, RangeIndexSpec spec, boolean remove) {
comment|//    for (int i = 0; i< contentLoadingObservers.size(); i++) {
comment|//        ContentLoadingObserver observer = (ContentLoadingObserver) contentLoadingObservers.get(i);
comment|//        observer.storeAttribute(attr, currentPath, indexingHint, spec, remove);
comment|//    }
comment|//}
specifier|private
name|void
name|notifyStoreText
parameter_list|(
name|TextImpl
name|text
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|int
name|indexingHint
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|storeText
argument_list|(
name|text
argument_list|,
name|currentPath
argument_list|,
name|indexingHint
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|dropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyDropIndex
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|dropIndex
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyRemove
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifySync
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyFlush
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|observer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|//Ignore the exception ; try to continue on other files
block|}
block|}
block|}
specifier|private
name|void
name|notifyPrintStatistics
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|notifyClose
parameter_list|()
throws|throws
name|DBException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|notifyCloseAndRemove
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contentLoadingObservers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ContentLoadingObserver
name|observer
init|=
name|contentLoadingObservers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|observer
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
block|}
name|clearContentLoadingObservers
argument_list|()
expr_stmt|;
block|}
comment|/**      * Update indexes for the given element node. This method is called when the indexer      * encounters a closing element tag. It updates any range indexes defined on the      * element value and adds the element id to the structural index.      *       * @param node the current element node      * @param currentPath node path leading to the element      * @param content contains the string value of the element. Needed if a range index      * is defined on it.      */
annotation|@
name|Override
specifier|public
name|void
name|endElement
parameter_list|(
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
specifier|final
name|int
name|indexType
init|=
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
comment|//TODO : do not care about the current code redundancy : this will move in the (near) future
comment|// TODO : move to NativeValueIndex
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|node
operator|.
name|getQName
argument_list|()
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
comment|//NodeProxy p = new NodeProxy(node);
comment|//if (node.getOldInternalAddress() != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)
comment|//    p.setInternalAddress(node.getOldInternalAddress());
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//Curious... I assume getNodeValue() needs the old address
comment|//p.setInternalAddress(node.getInternalAddress());
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|remove
argument_list|)
expr_stmt|;
block|}
comment|// TODO : move to NativeValueIndexByQName
if|if
condition|(
name|RangeIndexSpec
operator|.
name|hasQNameIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|node
operator|.
name|getQName
argument_list|()
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
comment|//NodeProxy p = new NodeProxy(node);
comment|//if (node.getOldInternalAddress() != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)
comment|//    p.setInternalAddress(node.getOldInternalAddress());
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//Curious... I assume getNodeValue() needs the old address
comment|//p.setInternalAddress(node.getInternalAddress());
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|RangeIndexSpec
operator|.
name|indexTypeToXPath
argument_list|(
name|indexType
argument_list|)
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_QNAME
argument_list|,
name|remove
argument_list|)
expr_stmt|;
comment|//qnameValueIndex.setDocument((DocumentImpl) node.getOwnerDocument());
comment|//qnameValueIndex.endElement((ElementImpl) node, currentPath, content);
block|}
block|}
comment|/*       private String getOldNodeContent(StoredNode node, long oldAddress) {           NodeProxy p = new NodeProxy(node);           if (oldAddress != StoredNode.UNKNOWN_NODE_IMPL_ADDRESS)               p.setInternalAddress(oldAddress);           String content = getNodeValue(node, false);           //Curious... I assume getNodeValue() needs the old address           p.setInternalAddress(node.getInternalAddress());           return content;       }       */
comment|/** Takes care of actually remove entries from the indices;      * must be called after one or more call to {@link #removeNode(Txn, StoredNode, NodePath, String)}. */
annotation|@
name|Override
specifier|public
name|void
name|endRemove
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
name|notifyRemove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|pool
operator|.
name|isReadOnly
argument_list|()
return|;
block|}
specifier|public
name|DOMFile
name|getDOMFile
parameter_list|()
block|{
return|return
name|domDb
return|;
block|}
specifier|public
name|BTree
name|getStorage
parameter_list|(
name|byte
name|id
parameter_list|)
block|{
comment|//Notice that there is no entry for the symbols table
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|DOM_DBX_ID
case|:
return|return
name|domDb
return|;
case|case
name|COLLECTIONS_DBX_ID
case|:
return|return
name|collectionsDb
return|;
case|case
name|VALUES_DBX_ID
case|:
return|return
name|valueIndex
operator|.
name|dbValues
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|byte
index|[]
name|getStorageFileIds
parameter_list|()
block|{
return|return
name|ALL_STORAGE_FILES
return|;
block|}
specifier|public
name|int
name|getDefaultIndexDepth
parameter_list|()
block|{
return|return
name|defaultIndexDepth
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|backupToArchive
parameter_list|(
name|RawDataBackup
name|backup
parameter_list|)
throws|throws
name|IOException
throws|,
name|EXistException
block|{
for|for
control|(
specifier|final
name|byte
name|i
range|:
name|ALL_STORAGE_FILES
control|)
block|{
specifier|final
name|Paged
name|paged
init|=
name|getStorage
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|paged
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage file is null: "
operator|+
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|OutputStream
name|os
init|=
name|backup
operator|.
name|newEntry
argument_list|(
name|paged
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|paged
operator|.
name|backupToStream
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|backupToArchive
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|backupBinary
argument_list|(
name|backup
argument_list|,
name|fsDir
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|backupToArchive
argument_list|(
name|backup
argument_list|)
expr_stmt|;
comment|//TODO backup counters
comment|//TODO USE zip64 or tar to create snapshots larger then 4Gb
block|}
specifier|private
name|void
name|backupBinary
parameter_list|(
name|RawDataBackup
name|backup
parameter_list|,
name|File
name|file
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|path
operator|=
name|path
operator|+
literal|"/"
operator|+
name|file
operator|.
name|getName
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
for|for
control|(
specifier|final
name|File
name|f
range|:
name|file
operator|.
name|listFiles
argument_list|()
control|)
block|{
name|backupBinary
argument_list|(
name|backup
argument_list|,
name|f
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|OutputStream
name|os
init|=
name|backup
operator|.
name|newEntry
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexSpec
name|getIndexConfiguration
parameter_list|()
block|{
return|return
name|indexConfiguration
return|;
block|}
annotation|@
name|Override
specifier|public
name|StructuralIndex
name|getStructuralIndex
parameter_list|()
block|{
return|return
operator|(
name|StructuralIndex
operator|)
name|getIndexController
argument_list|()
operator|.
name|getWorkerByIndexName
argument_list|(
name|StructuralIndex
operator|.
name|STRUCTURAL_INDEX_ID
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NativeValueIndex
name|getValueIndex
parameter_list|()
block|{
return|return
name|valueIndex
return|;
block|}
annotation|@
name|Override
specifier|public
name|TextSearchEngine
name|getTextEngine
parameter_list|()
block|{
specifier|final
name|FTIndexWorker
name|worker
init|=
operator|(
name|FTIndexWorker
operator|)
name|indexController
operator|.
name|getWorkerByIndexId
argument_list|(
name|FTIndex
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|worker
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Fulltext index is not configured. Please check the<modules> section in conf.xml"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|worker
operator|.
name|getEngine
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|EmbeddedXMLStreamReader
name|getXMLStreamReader
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
name|streamReader
operator|==
literal|null
condition|)
block|{
specifier|final
name|RawNodeIterator
name|iterator
init|=
operator|new
name|RawNodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|streamReader
operator|=
operator|new
name|EmbeddedXMLStreamReader
argument_list|(
name|this
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|reportAttributes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|streamReader
operator|.
name|reposition
argument_list|(
name|this
argument_list|,
name|node
argument_list|,
name|reportAttributes
argument_list|)
expr_stmt|;
block|}
return|return
name|streamReader
return|;
block|}
annotation|@
name|Override
specifier|public
name|EmbeddedXMLStreamReader
name|newXMLStreamReader
parameter_list|(
name|NodeHandle
name|node
parameter_list|,
name|boolean
name|reportAttributes
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
specifier|final
name|RawNodeIterator
name|iterator
init|=
operator|new
name|RawNodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|)
decl_stmt|;
return|return
operator|new
name|EmbeddedXMLStreamReader
argument_list|(
name|this
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|iterator
argument_list|,
literal|null
argument_list|,
name|reportAttributes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|getNodeIterator
parameter_list|(
name|StoredNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The node parameter cannot be null."
argument_list|)
throw|;
block|}
try|try
block|{
return|return
operator|new
name|NodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Serializer
name|getSerializer
parameter_list|()
block|{
name|xmlSerializer
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|xmlSerializer
return|;
block|}
annotation|@
name|Override
specifier|public
name|Serializer
name|newSerializer
parameter_list|()
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|XmldbURI
name|prepend
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
block|{
switch|switch
condition|(
name|prepend
condition|)
block|{
case|case
name|PREPEND_DB_ALWAYS
case|:
return|return
name|uri
operator|.
name|prepend
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
return|;
case|case
name|PREPEND_DB_AS_NEEDED
case|:
return|return
name|uri
operator|.
name|startsWith
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|?
name|uri
else|:
name|uri
operator|.
name|prepend
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
return|;
default|default:
return|return
name|uri
return|;
block|}
block|}
comment|/**      * Creates a temporary collecion      *       * @param transaction : The transaction, which registers the acquired write locks. The locks should be released on commit/abort.      * @return The temporary collection      * @throws LockException      * @throws PermissionDeniedException      * @throws IOException      * @throws TriggerException       */
specifier|private
name|Collection
name|createTempCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|LockException
throws|,
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
specifier|final
name|Subject
name|u
init|=
name|getSubject
argument_list|()
decl_stmt|;
try|try
block|{
name|setSubject
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Collection
name|temp
init|=
name|getOrCreateCollection
argument_list|(
name|transaction
argument_list|,
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|)
decl_stmt|;
name|temp
operator|.
name|setPermissions
argument_list|(
literal|0771
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
finally|finally
block|{
name|setSubject
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|String
name|readInitCollectionConfig
parameter_list|()
block|{
specifier|final
name|File
name|fInitCollectionConfig
init|=
operator|new
name|File
argument_list|(
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getExistHome
argument_list|()
argument_list|,
name|INIT_COLLECTION_CONFIG
argument_list|)
decl_stmt|;
if|if
condition|(
name|fInitCollectionConfig
operator|.
name|exists
argument_list|()
operator|&&
name|fInitCollectionConfig
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
specifier|final
name|StringBuilder
name|initCollectionConfig
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|is
operator|=
operator|new
name|FileInputStream
argument_list|(
name|fInitCollectionConfig
argument_list|)
expr_stmt|;
name|int
name|read
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|byte
name|buf
index|[]
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|read
operator|=
name|is
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|initCollectionConfig
operator|.
name|append
argument_list|(
operator|new
name|String
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|read
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|initCollectionConfig
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
empty_stmt|;
return|return
literal|null
return|;
block|}
comment|/* (non-Javadoc)      * @see org.exist.storage.DBBroker#getOrCreateCollection(org.exist.storage.txn.Txn, org.exist.xmldb.XmldbURI)      */
annotation|@
name|Override
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|XmldbURI
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
name|name
operator|=
name|prepend
argument_list|(
name|name
operator|.
name|normalizeCollectionPath
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
try|try
block|{
comment|//TODO : resolve URIs !
specifier|final
name|XmldbURI
index|[]
name|segments
init|=
name|name
operator|.
name|getPathSegments
argument_list|()
decl_stmt|;
name|XmldbURI
name|path
init|=
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
decl_stmt|;
name|Collection
name|sub
decl_stmt|;
name|Collection
name|current
init|=
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating root collection '"
operator|+
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CollectionTrigger
name|trigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeCreateCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|Collection
argument_list|(
name|this
argument_list|,
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
expr_stmt|;
name|current
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
name|current
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
block|{
name|transaction
operator|.
name|acquireLock
argument_list|(
name|current
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
comment|//TODO : acquire lock manually if transaction is null ?
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterCreateCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
comment|//import an initial collection configuration
try|try
block|{
specifier|final
name|String
name|initCollectionConfig
init|=
name|readInitCollectionConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|initCollectionConfig
operator|!=
literal|null
condition|)
block|{
name|CollectionConfigurationManager
name|collectionConfigurationManager
init|=
name|pool
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|collectionConfigurationManager
operator|==
literal|null
condition|)
block|{
comment|//might not yet have been initialised
name|pool
operator|.
name|initCollectionConfigurationManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|collectionConfigurationManager
operator|=
name|pool
operator|.
name|getConfigurationManager
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|collectionConfigurationManager
operator|!=
literal|null
condition|)
block|{
name|collectionConfigurationManager
operator|.
name|addConfiguration
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|current
argument_list|,
name|initCollectionConfig
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|CollectionConfigurationException
name|cce
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not load initial collection configuration for /db: "
operator|+
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|,
name|cce
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|XmldbURI
name|temp
init|=
name|segments
index|[
name|i
index|]
decl_stmt|;
name|path
operator|=
name|path
operator|.
name|append
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasSubcollectionNoLock
argument_list|(
name|this
argument_list|,
name|temp
argument_list|)
condition|)
block|{
name|current
operator|=
name|getCollection
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Collection '"
operator|+
name|path
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Permission denied to create collection '"
operator|+
name|path
operator|+
literal|"'"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to write to collection '"
operator|+
name|current
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Permission denied to create collection '"
operator|+
name|path
operator|+
literal|"'"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed to execute to collection '"
operator|+
name|current
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|current
operator|.
name|hasDocument
argument_list|(
name|this
argument_list|,
name|path
operator|.
name|lastSegment
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Collection '"
operator|+
name|current
operator|.
name|getURI
argument_list|()
operator|+
literal|"' have document '"
operator|+
name|path
operator|.
name|lastSegment
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Collection '"
operator|+
name|current
operator|.
name|getURI
argument_list|()
operator|+
literal|"' have document '"
operator|+
name|path
operator|.
name|lastSegment
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating collection '"
operator|+
name|path
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CollectionTrigger
name|trigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|current
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeCreateCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|sub
operator|=
operator|new
name|Collection
argument_list|(
name|this
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|//inherit the group to the sub-collection if current collection is setGid
if|if
condition|(
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|isSetGid
argument_list|()
condition|)
block|{
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sub
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
block|{
name|transaction
operator|.
name|acquireLock
argument_list|(
name|sub
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
comment|//TODO : acquire lock manually if transaction is null ?
name|current
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|sub
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterCreateCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|current
operator|=
name|sub
expr_stmt|;
block|}
block|}
return|return
name|current
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|openCollection
argument_list|(
name|uri
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|openCollection
argument_list|(
name|uri
argument_list|,
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|,
name|lockMode
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findCollectionsMatching
parameter_list|(
name|String
name|regexp
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|collections
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regexp
argument_list|)
decl_stmt|;
specifier|final
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
literal|""
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|//TODO write a regexp lookup for key data in BTree.query
comment|//IndexQuery idxQuery = new IndexQuery(IndexQuery.REGEXP, regexp);
comment|//List<Value> keys = collectionsDb.findKeysByCollectionName(idxQuery);
specifier|final
name|List
argument_list|<
name|Value
argument_list|>
name|keys
init|=
name|collectionsDb
operator|.
name|getKeys
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Value
name|key
range|:
name|keys
control|)
block|{
comment|//TODO restrict keys to just collection uri's
specifier|final
name|String
name|collectionName
init|=
operator|new
name|String
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|)
decl_stmt|;
name|m
operator|.
name|reset
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|matches
argument_list|()
condition|)
block|{
name|collections
operator|.
name|add
argument_list|(
name|collectionName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|//LOG.error("Unable to encode '" + uri + "' in UTF-8");
comment|//return null;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|//return null;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//return null;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//return null;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//return null;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|collections
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readCollectionEntry
parameter_list|(
name|SubCollectionEntry
name|entry
parameter_list|)
block|{
specifier|final
name|XmldbURI
name|uri
init|=
name|prepend
argument_list|(
name|entry
operator|.
name|getUri
argument_list|()
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|collection
operator|=
name|collectionsCache
operator|.
name|get
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteInput
name|is
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not read collection entry for: "
operator|+
name|uri
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//read the entry details
name|entry
operator|.
name|read
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to encode '"
operator|+
name|uri
operator|+
literal|"' in UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equalsInternal
argument_list|(
name|uri
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The collection received from the cache is not the requested: "
operator|+
name|uri
operator|+
literal|"; received: "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|.
name|read
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      *  Get collection object. If the collection does not exist, null is      *  returned.      *      *@param  uri  collection URI      *@return       The collection value      */
specifier|private
name|Collection
name|openCollection
parameter_list|(
name|XmldbURI
name|uri
parameter_list|,
name|long
name|addr
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|uri
operator|=
name|prepend
argument_list|(
name|uri
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//We *must* declare it here (see below)
name|Collection
name|collection
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|collection
operator|=
name|collectionsCache
operator|.
name|get
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|VariableByteInput
name|is
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|collection
operator|=
operator|new
name|Collection
argument_list|(
name|this
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|collection
operator|.
name|read
argument_list|(
name|this
argument_list|,
name|is
argument_list|)
expr_stmt|;
comment|//TODO : manage this from within the cache -pb
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
block|{
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
comment|//TODO : rethrow exceptions ? -pb
block|}
catch|catch
parameter_list|(
specifier|final
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to encode '"
operator|+
name|uri
operator|+
literal|"' in UTF-8"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equalsInternal
argument_list|(
name|uri
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The collection received from the cache is not the requested: "
operator|+
name|uri
operator|+
literal|"; received: "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to open collection: "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" by "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|//Important :
comment|//This code must remain outside of the synchonized block
comment|//because another thread may already own a lock on the collection
comment|//This would result in a deadlock... until the time-out raises the Exception
comment|//TODO : make an attempt to an immediate lock ?
comment|//TODO : manage a collection of requests for locks ?
comment|//TODO : another yet smarter solution ?
if|if
condition|(
name|lockMode
operator|!=
name|Lock
operator|.
name|NO_LOCK
condition|)
block|{
try|try
block|{
name|collection
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on collection '"
operator|+
name|uri
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|collection
return|;
block|}
comment|/**      * Checks all permissions in the tree to ensure that a copy operation will succeed      */
specifier|protected
name|void
name|checkPermissionsForCopy
parameter_list|(
specifier|final
name|Collection
name|src
parameter_list|,
specifier|final
name|XmldbURI
name|destUri
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
operator|!
name|src
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
operator||
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|src
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|Collection
name|dest
init|=
name|getCollection
argument_list|(
name|destUri
argument_list|)
decl_stmt|;
specifier|final
name|XmldbURI
name|newDestUri
init|=
name|destUri
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|newDest
init|=
name|getCollection
argument_list|(
name|newDestUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
literal|null
condition|)
block|{
comment|//if(!dest.getPermissionsNoLock().validate(getSubject(), Permission.EXECUTE | Permission.WRITE | Permission.READ)) {
comment|//TODO do we really need WRITE permission on the dest?
if|if
condition|(
operator|!
name|dest
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
operator||
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|src
operator|.
name|getURI
argument_list|()
operator|+
literal|" to "
operator|+
name|dest
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|newDest
operator|!=
literal|null
condition|)
block|{
comment|//TODO why do we need READ access on the dest collection?
comment|/*if(!dest.getPermissionsNoLock().validate(getSubject(), Permission.EXECUTE | Permission.READ)) {                     throw new PermissionDeniedException("Permission denied to copy collection " + src.getURI() + " to " + dest.getURI() + " by " + getSubject().getName());                 }*/
comment|//if(newDest.isEmpty(this)) {
if|if
condition|(
operator|!
name|newDest
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
operator||
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|src
operator|.
name|getURI
argument_list|()
operator|+
literal|" to "
operator|+
name|newDest
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|//}
block|}
block|}
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|itSrcSubDoc
init|=
name|src
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|itSrcSubDoc
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|srcSubDoc
init|=
name|itSrcSubDoc
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|srcSubDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|src
operator|.
name|getURI
argument_list|()
operator|+
literal|" for resource "
operator|+
name|srcSubDoc
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|//if the destination resource exists, we must have write access to replace it's metadata etc. (this follows the Linux convention)
if|if
condition|(
name|newDest
operator|!=
literal|null
operator|&&
operator|!
name|newDest
operator|.
name|isEmpty
argument_list|(
name|this
argument_list|)
condition|)
block|{
specifier|final
name|DocumentImpl
name|newDestSubDoc
init|=
name|newDest
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|srcSubDoc
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
comment|//TODO check this uri is just the filename!
if|if
condition|(
name|newDestSubDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|newDestSubDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Permission denied to copy collection "
operator|+
name|src
operator|.
name|getURI
argument_list|()
operator|+
literal|" for resource "
operator|+
name|newDestSubDoc
operator|.
name|getURI
argument_list|()
operator|+
literal|" by "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|itSrcSubColUri
init|=
name|src
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|itSrcSubColUri
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|srcSubColUri
init|=
name|itSrcSubColUri
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|srcSubCol
init|=
name|getCollection
argument_list|(
name|src
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|srcSubColUri
argument_list|)
argument_list|)
decl_stmt|;
name|checkPermissionsForCopy
argument_list|(
name|srcSubCol
argument_list|,
name|newDestUri
argument_list|,
name|srcSubColUri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* (non-Javadoc)      * @see org.exist.storage.DBBroker#copyCollection(org.exist.storage.txn.Txn, org.exist.collections.Collection, org.exist.collections.Collection, org.exist.xmldb.XmldbURI)      */
annotation|@
name|Override
specifier|public
name|void
name|copyCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|Collection
name|collection
parameter_list|,
specifier|final
name|Collection
name|destination
parameter_list|,
specifier|final
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
throws|,
name|EXistException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
comment|//TODO : resolve URIs !!!
if|if
condition|(
name|newName
operator|!=
literal|null
operator|&&
name|newName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name must have one segment!"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|srcURI
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|dstURI
init|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|dstURI
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_COPY_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|XmldbURI
name|parentName
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|parent
init|=
name|parentName
operator|==
literal|null
condition|?
name|collection
else|:
name|getCollection
argument_list|(
name|parentName
argument_list|)
decl_stmt|;
specifier|final
name|CollectionTrigger
name|trigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeCopyCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|,
name|dstURI
argument_list|)
expr_stmt|;
comment|//atomically check all permissions in the tree to ensure a copy operation will succeed before starting copying
name|checkPermissionsForCopy
argument_list|(
name|collection
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
argument_list|,
name|newName
argument_list|)
expr_stmt|;
specifier|final
name|DocumentTrigger
name|docTrigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|newCollection
init|=
name|doCopyCollection
argument_list|(
name|transaction
argument_list|,
name|docTrigger
argument_list|,
name|collection
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|afterCopyCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|newCollection
argument_list|,
name|srcURI
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Collection
name|doCopyCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentTrigger
name|trigger
parameter_list|,
specifier|final
name|Collection
name|collection
parameter_list|,
specifier|final
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|EXistException
throws|,
name|TriggerException
throws|,
name|LockException
block|{
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|newName
operator|=
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|lastSegment
argument_list|()
expr_stmt|;
block|}
name|newName
operator|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying collection to '"
operator|+
name|newName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Collection
name|destCollection
init|=
name|getOrCreateCollection
argument_list|(
name|transaction
argument_list|,
name|newName
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|child
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying resource: '"
operator|+
name|child
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
comment|//TODO The code below seems quite different to that in NativeBroker#copyResource presumably should be the same?
specifier|final
name|XmldbURI
name|newUri
init|=
name|destCollection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|child
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeCopyDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|child
argument_list|,
name|newUri
argument_list|)
expr_stmt|;
comment|//are we overwriting an existing document?
specifier|final
name|CollectionEntry
name|oldDoc
decl_stmt|;
if|if
condition|(
name|destCollection
operator|.
name|hasDocument
argument_list|(
name|this
argument_list|,
name|child
operator|.
name|getFileURI
argument_list|()
argument_list|)
condition|)
block|{
name|oldDoc
operator|=
name|destCollection
operator|.
name|getResourceEntry
argument_list|(
name|this
argument_list|,
name|child
operator|.
name|getFileURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldDoc
operator|=
literal|null
expr_stmt|;
block|}
name|DocumentImpl
name|createdDoc
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
comment|//TODO : put a lock on newDoc ?
specifier|final
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|destCollection
argument_list|,
name|child
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
comment|//preserve permissions from existing doc we are replacing
name|newDoc
operator|.
name|setPermissions
argument_list|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO use newDoc.copyOf(oldDoc) ideally, but we cannot currently access oldDoc without READ access to it, which we may not have (and should not need for this)!
block|}
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|createdDoc
operator|=
name|newDoc
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|BinaryDocument
name|newDoc
init|=
operator|new
name|BinaryDocument
argument_list|(
name|pool
argument_list|,
name|destCollection
argument_list|,
name|child
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|child
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
comment|//preserve permissions from existing doc we are replacing
name|newDoc
operator|.
name|setPermissions
argument_list|(
name|oldDoc
operator|.
name|getPermissions
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO use newDoc.copyOf(oldDoc) ideally, but we cannot currently access oldDoc without READ access to it, which we may not have (and should not need for this)!
block|}
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|getBinaryResource
argument_list|(
operator|(
name|BinaryDocument
operator|)
name|child
argument_list|)
expr_stmt|;
name|storeBinaryResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destCollection
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|createdDoc
operator|=
name|newDoc
expr_stmt|;
block|}
name|trigger
operator|.
name|afterCopyDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|createdDoc
argument_list|,
name|child
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destCollection
argument_list|)
expr_stmt|;
specifier|final
name|XmldbURI
name|name
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URIs ! collection.getURI().resolve(childName)
specifier|final
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|name
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection '"
operator|+
name|childName
operator|+
literal|"' not found"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|doCopyCollection
argument_list|(
name|transaction
argument_list|,
name|trigger
argument_list|,
name|child
argument_list|,
name|destCollection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destCollection
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
return|return
name|destCollection
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|moveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|!=
literal|null
operator|&&
name|newName
operator|.
name|numSegments
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name must have one segment!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|equals
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move the db root collection"
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|parentName
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|parent
init|=
name|parentName
operator|==
literal|null
condition|?
name|collection
else|:
name|getCollection
argument_list|(
name|parentName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|parent
operator|.
name|getURI
argument_list|()
operator|+
literal|" to move collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection to move collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|parent
operator|.
name|getURI
argument_list|()
operator|+
literal|" to move collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
comment|/*          * If replacing another collection in the move i.e. /db/col1/A -> /db/col2 (where /db/col2/A exists)          * we have to make sure the permissions to remove /db/col2/A are okay!          *           * So we must call removeCollection on /db/col2/A          * Which will ensure that collection can be removed and then remove it.          */
specifier|final
name|XmldbURI
name|movedToCollectionUri
init|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
specifier|final
name|Collection
name|existingMovedToCollection
init|=
name|getCollection
argument_list|(
name|movedToCollectionUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingMovedToCollection
operator|!=
literal|null
condition|)
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|existingMovedToCollection
argument_list|)
expr_stmt|;
block|}
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_MOVE_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|XmldbURI
name|srcURI
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|dstURI
init|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
specifier|final
name|CollectionTrigger
name|trigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|,
name|dstURI
argument_list|)
expr_stmt|;
comment|// sourceDir must be known in advance, because once moveCollectionRecursive
comment|// is called, both collection and destination can point to the same resource
specifier|final
name|File
name|fsSourceDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Need to move each collection in the source tree individually, so recurse.
name|moveCollectionRecursive
argument_list|(
name|transaction
argument_list|,
name|trigger
argument_list|,
name|collection
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
expr_stmt|;
comment|// For binary resources, though, just move the top level directory and all descendants come with it.
name|moveBinaryFork
argument_list|(
name|transaction
argument_list|,
name|fsSourceDir
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|,
name|srcURI
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|moveBinaryFork
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|File
name|sourceDir
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|targetDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|targetDir
operator|.
name|exists
argument_list|()
condition|)
block|{
specifier|final
name|File
name|targetDelDir
init|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|targetDelDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetDir
operator|.
name|renameTo
argument_list|(
name|targetDelDir
argument_list|)
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|targetDir
argument_list|,
name|targetDelDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot rename "
operator|+
name|targetDir
operator|+
literal|" to "
operator|+
name|targetDelDir
argument_list|)
expr_stmt|;
block|}
block|}
name|targetDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
name|sourceDir
operator|.
name|renameTo
argument_list|(
name|targetDir
argument_list|)
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceDir
argument_list|,
name|targetDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot move "
operator|+
name|sourceDir
operator|+
literal|" to "
operator|+
name|targetDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|moveCollectionRecursive
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|CollectionTrigger
name|trigger
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|LockException
throws|,
name|TriggerException
block|{
specifier|final
name|XmldbURI
name|uri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
specifier|final
name|XmldbURI
name|srcURI
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|dstURI
init|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|,
name|dstURI
argument_list|)
expr_stmt|;
specifier|final
name|XmldbURI
name|parentName
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|parentName
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
comment|//TODO : resolve URIs
name|parent
operator|.
name|removeCollection
argument_list|(
name|this
argument_list|,
name|uri
operator|.
name|lastSegment
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|parent
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs destination.getURI().resolve(newName)
name|collection
operator|.
name|setPath
argument_list|(
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addCollection
argument_list|(
name|this
argument_list|,
name|collection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|!=
name|destination
condition|)
block|{
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
comment|//} catch (ReadOnlyException e) {
comment|//throw new PermissionDeniedException(DATABASE_IS_READ_ONLY);
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|trigger
operator|.
name|afterMoveCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|,
name|srcURI
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URIs !!! name.resolve(childName)
specifier|final
name|Collection
name|child
init|=
name|openCollection
argument_list|(
name|uri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection "
operator|+
name|childName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|moveCollectionRecursive
argument_list|(
name|transaction
argument_list|,
name|trigger
argument_list|,
name|child
argument_list|,
name|collection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Removes a collection and all child collections and resources      *       * We first traverse down the Collection tree to ensure that the Permissions      * enable the Collection Tree to be removed. We then return back up the Collection      * tree, removing each child as we progresses upwards.      *       * @param transaction the transaction to use      * @param collection the collection to remove      * @return true if the collection was removed, false otherwise      * @throws TriggerException       */
annotation|@
name|Override
specifier|public
name|boolean
name|removeCollection
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|parentName
init|=
name|collection
operator|.
name|getParentURI
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isRoot
init|=
name|parentName
operator|==
literal|null
decl_stmt|;
specifier|final
name|Collection
name|parent
init|=
name|isRoot
condition|?
name|collection
else|:
name|getCollection
argument_list|(
name|parentName
argument_list|)
decl_stmt|;
comment|//parent collection permissions
if|if
condition|(
operator|!
name|parent
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' is not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|parent
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' is not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|//this collection permissions
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' is not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|isEmpty
argument_list|(
name|this
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' is not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' is not allowed to remove collection '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REMOVE_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|CollectionTrigger
name|colTrigger
init|=
operator|new
name|CollectionTriggers
argument_list|(
name|this
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|colTrigger
operator|.
name|beforeDeleteCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
specifier|final
name|XmldbURI
name|uri
init|=
name|collection
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|String
name|collName
init|=
name|uri
operator|.
name|getRawCollectionPath
argument_list|()
decl_stmt|;
comment|// Notify the collection configuration manager
specifier|final
name|CollectionConfigurationManager
name|manager
init|=
name|pool
operator|.
name|getConfigurationManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
name|manager
operator|.
name|invalidate
argument_list|(
name|uri
argument_list|,
name|getBrokerPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing children collections from their parent '"
operator|+
name|collName
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|childName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve from collection's base URI
comment|//TODO : resulve URIs !!! (uri.resolve(childName))
specifier|final
name|Collection
name|childCollection
init|=
name|openCollection
argument_list|(
name|uri
operator|.
name|append
argument_list|(
name|childName
argument_list|)
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|childCollection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|childCollection
operator|!=
literal|null
condition|)
block|{
name|childCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"childCollection is null !"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//Drop all index entries
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|// Drop custom indexes
name|indexController
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
comment|// remove from parent collection
comment|//TODO : resolve URIs ! (uri.resolve(".."))
specifier|final
name|Collection
name|parentCollection
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentURI
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
comment|// keep the lock for the transaction
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
block|{
name|transaction
operator|.
name|registerLock
argument_list|(
name|parentCollection
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentCollection
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection '"
operator|+
name|collName
operator|+
literal|"' from its parent..."
argument_list|)
expr_stmt|;
comment|//TODO : resolve from collection's base URI
name|parentCollection
operator|.
name|removeCollection
argument_list|(
name|this
argument_list|,
name|uri
operator|.
name|lastSegment
argument_list|()
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|parentCollection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"LockException while removing collection '"
operator|+
name|collName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|transaction
operator|==
literal|null
condition|)
block|{
name|parentCollection
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//Update current state
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
comment|// remove the metadata of all documents in the collection
specifier|final
name|Value
name|docKey
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|docKey
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|)
expr_stmt|;
comment|// if this is not the root collection remove it...
if|if
condition|(
operator|!
name|isRoot
condition|)
block|{
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collName
argument_list|)
decl_stmt|;
comment|//... from the disk
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//... from the cache
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//and free its id for any futher use
name|freeCollectionId
argument_list|(
name|transaction
argument_list|,
name|collection
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Simply save the collection on disk
comment|//It will remain cached
comment|//and its id well never be made available
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on '"
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
comment|//catch(ReadOnlyException e) {
comment|//throw new PermissionDeniedException(DATABASE_IS_READ_ONLY);
comment|//}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while removing collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while removing collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
comment|//Remove child resources
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing resources in '"
operator|+
name|collName
operator|+
literal|"'..."
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentTrigger
name|docTrigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|docTrigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|//Remove doc's metadata
comment|// WM: now removed in one step. see above.
comment|//removeResourceMetadata(transaction, doc);
comment|//Remove document nodes' index entries
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
specifier|final
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//Remove nodes themselves
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
specifier|final
name|long
name|page
init|=
operator|(
operator|(
name|BinaryDocument
operator|)
name|doc
operator|)
operator|.
name|getPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|>
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
name|transaction
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|doc
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|docTrigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//Make doc's id available again
name|freeResourceId
argument_list|(
name|transaction
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//now that the database has been updated, update the binary collections on disk
specifier|final
name|File
name|fsSourceDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|File
name|fsTargetDir
init|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// remove child binary collections
if|if
condition|(
name|fsSourceDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|fsTargetDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|//XXX: log first, rename second ??? -shabanovd
comment|// DW: not sure a Fatal is required here. Copy and delete
comment|// maybe?
if|if
condition|(
name|fsSourceDir
operator|.
name|renameTo
argument_list|(
name|fsTargetDir
argument_list|)
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|fsSourceDir
argument_list|,
name|fsTargetDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//XXX: throw IOException -shabanovd
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot rename "
operator|+
name|fsSourceDir
operator|+
literal|" to "
operator|+
name|fsTargetDir
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing collection '"
operator|+
name|collName
operator|+
literal|"' took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
name|colTrigger
operator|.
name|afterDeleteCollection
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Saves the specified collection to storage. Collections are usually cached in      * memory. If a collection is modified, this method needs to be called to make      * the changes persistent.      *       * Note: appending a new document to a collection does not require a save.      *       * @throws PermissionDeniedException       * @throws IOException       * @throws TriggerException       */
annotation|@
name|Override
specifier|public
name|void
name|saveCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"NativeBroker.saveCollection called with collection == null! Aborting."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|pool
operator|.
name|isInitializing
argument_list|()
condition|)
block|{
comment|// don't cache the collection during initialization: SecurityManager is not yet online
name|pool
operator|.
name|getCollectionsCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
block|{
name|collection
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|(
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Value
name|name
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|collection
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
specifier|final
name|long
name|addr
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
comment|//TODO : exception !!! -pb
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not store collection data for '"
operator|+
name|collection
operator|.
name|getURI
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Release the collection id assigned to a collection so it can be      * reused later.      *       * @param id      * @throws PermissionDeniedException      */
specifier|protected
name|void
name|freeCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
name|OFFSET_VALUE
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
comment|//} catch (ReadOnlyException e) {
comment|//throw new PermissionDeniedException(DATABASE_IS_READ_ONLY);
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the next free collection id. If a collection is removed, its collection id      * is released so it can be reused.      *       * @return next free collection id.      * @throws ReadOnlyException      */
specifier|public
name|int
name|getFreeCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeCollectionId
init|=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
argument_list|)
expr_stmt|;
comment|//LOG.debug("reusing collection id: " + freeCollectionId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
operator|>
literal|0
condition|)
block|{
specifier|final
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|freeCollectionId
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the next available unique collection id.      *       * @return next available unique collection id      * @throws ReadOnlyException      */
specifier|public
name|int
name|getNextCollectionId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|nextCollectionId
init|=
name|getFreeCollectionId
argument_list|(
name|transaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextCollectionId
operator|!=
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
condition|)
block|{
return|return
name|nextCollectionId
return|;
block|}
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|NEXT_COLLECTION_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
name|OFFSET_COLLECTION_ID
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|nextCollectionId
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Collection
operator|.
name|UNKNOWN_COLLECTION_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|XmldbURI
name|collectionName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
name|collectionName
operator|=
name|prepend
argument_list|(
name|collectionName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collectionName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|reindexCollection
argument_list|(
name|collection
argument_list|,
name|NodeProcessor
operator|.
name|MODE_STORE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
specifier|final
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Start indexing collection %s"
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|startJob
argument_list|(
name|ProcessMonitor
operator|.
name|ACTION_REINDEX_COLLECTION
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred during reindex: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|transact
operator|.
name|close
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|pool
operator|.
name|getProcessMonitor
argument_list|()
operator|.
name|endJob
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Finished indexing collection %s in %s msec."
argument_list|,
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindexCollection
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reindexing collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NodeProcessor
operator|.
name|MODE_STORE
condition|)
block|{
name|dropCollectionIndex
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|next
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|next
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|XmldbURI
argument_list|>
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|XmldbURI
name|next
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO : resolve URIs !!! (collection.getURI().resolve(next))
specifier|final
name|Collection
name|child
init|=
name|getCollection
argument_list|(
name|collection
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|next
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection '"
operator|+
name|next
operator|+
literal|"' not found"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reindexCollection
argument_list|(
name|transaction
argument_list|,
name|child
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|dropCollectionIndex
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|dropCollectionIndex
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|dropCollectionIndex
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|,
name|boolean
name|reindex
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on collection "
operator|+
name|collection
operator|.
name|getURI
argument_list|()
argument_list|)
throw|;
block|}
name|notifyDropIndex
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|indexController
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|,
name|this
argument_list|,
name|reindex
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|(
name|this
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dropping index for document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
specifier|final
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Store into the temporary collection of the database a given in-memory Document      *      * The in-memory Document is stored without a transaction and is not journalled,      * if there is no temporary collection, this will first be created with a transaction      *      * @param doc The in-memory Document to store      * @return The document stored in the temp collection      */
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|storeTempResource
parameter_list|(
name|org
operator|.
name|exist
operator|.
name|memtree
operator|.
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
throws|,
name|PermissionDeniedException
throws|,
name|LockException
block|{
comment|//store the currentUser
specifier|final
name|Subject
name|currentUser
init|=
name|getSubject
argument_list|()
decl_stmt|;
comment|//elevate getUser() to DBA_USER
name|setSubject
argument_list|(
name|pool
operator|.
name|getSecurityManager
argument_list|()
operator|.
name|getSystemSubject
argument_list|()
argument_list|)
expr_stmt|;
comment|//start a transaction
specifier|final
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
specifier|final
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
comment|//create a name for the temporary document
specifier|final
name|XmldbURI
name|docName
init|=
name|XmldbURI
operator|.
name|create
argument_list|(
name|MessageDigester
operator|.
name|md5
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|+
literal|".xml"
argument_list|)
decl_stmt|;
comment|//get the temp collection
name|Collection
name|temp
init|=
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
name|boolean
name|created
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|//if no temp collection
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
block|{
comment|//creates temp collection (with write lock)
name|temp
operator|=
name|createTempCollection
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to create temporary collection"
argument_list|)
expr_stmt|;
comment|//TODO : emergency exit?
block|}
name|created
operator|=
literal|true
expr_stmt|;
block|}
comment|//create a temporary document
specifier|final
name|DocumentImpl
name|targetDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|temp
argument_list|,
name|docName
argument_list|)
decl_stmt|;
name|targetDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|setMode
argument_list|(
name|Permission
operator|.
name|DEFAULT_TEMPORARY_DOCUMENT_PERM
argument_list|)
expr_stmt|;
specifier|final
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|DocumentMetadata
name|metadata
init|=
operator|new
name|DocumentMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setLastModified
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setCreated
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|targetDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
comment|//index the temporary document
specifier|final
name|DOMIndexer
name|indexer
init|=
operator|new
name|DOMIndexer
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|targetDoc
argument_list|)
decl_stmt|;
comment|//NULL transaction, so temporary fragment is not journalled - AR
name|indexer
operator|.
name|scan
argument_list|()
expr_stmt|;
name|indexer
operator|.
name|store
argument_list|()
expr_stmt|;
comment|//store the temporary document
name|temp
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
comment|//NULL transaction, so temporary fragment is not journalled - AR
comment|// unlock the temp collection
if|if
condition|(
name|transaction
operator|==
literal|null
condition|)
block|{
name|temp
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|created
condition|)
block|{
name|transaction
operator|.
name|registerLock
argument_list|(
name|temp
operator|.
name|getLock
argument_list|()
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
comment|//NULL transaction, so temporary fragment is not journalled - AR
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|targetDoc
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
comment|//commit the transaction
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
return|return
name|targetDoc
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to store temporary fragment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//abort the transaction
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|transact
operator|.
name|close
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
comment|//restore the user
name|setUser
argument_list|(
name|currentUser
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** remove all documents from temporary collection      *       * @param forceRemoval Should temporary resources be forcefully removed       */
annotation|@
name|Override
specifier|public
name|void
name|cleanUpTempResources
parameter_list|(
name|boolean
name|forceRemoval
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|Collection
name|temp
init|=
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|TransactionManager
name|transact
init|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
decl_stmt|;
specifier|final
name|Txn
name|transaction
init|=
name|transact
operator|.
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|removeCollection
argument_list|(
name|transaction
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|transact
operator|.
name|commit
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|transact
operator|.
name|abort
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove temp collection: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|transact
operator|.
name|close
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getResourceById
parameter_list|(
name|int
name|collectionId
parameter_list|,
name|byte
name|resourceType
parameter_list|,
name|int
name|documentId
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|XmldbURI
name|uri
init|=
literal|null
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
comment|//final VariableByteOutputStream ostream = new VariableByteOutputStream(8);
comment|//doc.write(ostream);
comment|//Value key = new CollectionStore.DocumentKey(doc.getCollection().getId(), doc.getResourceType(), doc.getDocId());
comment|//collectionsDb.put(transaction, key, ostream.data(), true);
comment|//Value collectionKey = new CollectionStore.CollectionKey
comment|//collectionsDb.get(Value.EMPTY_VALUE)
comment|//get the collection uri
name|String
name|collectionUri
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|collectionId
operator|==
literal|0
condition|)
block|{
name|collectionUri
operator|=
literal|"/db"
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
specifier|final
name|Value
name|collectionDbKey
range|:
name|collectionsDb
operator|.
name|getKeys
argument_list|()
control|)
block|{
if|if
condition|(
name|collectionDbKey
operator|.
name|data
argument_list|()
index|[
literal|0
index|]
operator|==
name|CollectionStore
operator|.
name|KEY_TYPE_COLLECTION
condition|)
block|{
comment|//Value collectionDbValue = collectionsDb.get(collectionDbKey);
specifier|final
name|VariableByteInput
name|vbi
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|collectionDbKey
argument_list|)
decl_stmt|;
specifier|final
name|int
name|id
init|=
name|vbi
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|//check if the collection id matches (first 4 bytes)
if|if
condition|(
name|collectionId
operator|==
name|id
condition|)
block|{
name|collectionUri
operator|=
operator|new
name|String
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|collectionDbKey
operator|.
name|data
argument_list|()
argument_list|,
literal|1
argument_list|,
name|collectionDbKey
operator|.
name|data
argument_list|()
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|//get the resource uri
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collectionId
argument_list|,
name|resourceType
argument_list|,
name|documentId
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteInput
name|vbi
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|vbi
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|//skip doc id
specifier|final
name|String
name|resourceUri
init|=
name|vbi
operator|.
name|readUTF
argument_list|()
decl_stmt|;
comment|//get the resource
name|uri
operator|=
name|XmldbURI
operator|.
name|createInternal
argument_list|(
name|collectionUri
operator|+
literal|"/"
operator|+
name|resourceUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|te
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Query Terminated"
argument_list|,
name|te
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Problem reading btree"
argument_list|,
name|bte
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IOException while reading recource data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|getResource
argument_list|(
name|uri
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
return|;
block|}
comment|/** store Document entry into its collection. */
annotation|@
name|Override
specifier|public
name|void
name|storeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|doc
operator|.
name|write
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//} catch (ReadOnlyException e) {
comment|//LOG.warn(DATABASE_IS_READ_ONLY);
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while writing document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|storeMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|TriggerException
block|{
specifier|final
name|Collection
name|col
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|col
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeUpdateDocumentMetadata
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterUpdateDocumentMetadata
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|File
name|getCollectionFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|XmldbURI
name|uri
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getCollectionFile
argument_list|(
name|dir
argument_list|,
literal|null
argument_list|,
name|uri
argument_list|,
name|create
argument_list|)
return|;
block|}
specifier|public
name|File
name|getCollectionBinaryFileFsPath
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|fsDir
argument_list|,
name|uri
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|File
name|getCollectionFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|Txn
name|transaction
parameter_list|,
name|XmldbURI
name|uri
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
condition|)
block|{
name|dir
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"txn."
operator|+
name|transaction
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
operator|&&
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot make transaction filesystem directory: "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
comment|//XXX: replace by transaction operation id/number from Txn
comment|//add unique id for operation in transaction
name|dir
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"oper."
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
operator|&&
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot make transaction filesystem directory: "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
block|}
specifier|final
name|XmldbURI
index|[]
name|segments
init|=
name|uri
operator|.
name|getPathSegments
argument_list|()
decl_stmt|;
name|File
name|binFile
init|=
name|dir
decl_stmt|;
specifier|final
name|int
name|last
init|=
name|segments
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|binFile
operator|=
operator|new
name|File
argument_list|(
name|binFile
argument_list|,
name|segments
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
operator|&&
name|i
operator|!=
name|last
operator|&&
operator|!
name|binFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|binFile
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot make collection filesystem directory: "
operator|+
name|binFile
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|binFile
return|;
block|}
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|blob
operator|.
name|setPage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
specifier|final
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|File
name|backupFile
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|exists
init|=
name|binFile
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|backupFile
operator|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|backupFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot backup binary resource for journal to "
operator|+
name|backupFile
argument_list|)
throw|;
block|}
block|}
specifier|final
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|binFile
argument_list|)
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|,
name|backupFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|CreateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
name|blob
operator|.
name|setPage
argument_list|(
name|Page
operator|.
name|NO_PAGE
argument_list|)
expr_stmt|;
specifier|final
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|File
name|backupFile
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|exists
init|=
name|binFile
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|backupFile
operator|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|backupFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot backup binary resource for journal to "
operator|+
name|backupFile
argument_list|)
throw|;
block|}
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|65536
index|]
decl_stmt|;
specifier|final
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|binFile
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|UpdateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|,
name|backupFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|CreateBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|Document
name|getXMLResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|getResource
argument_list|(
name|fileName
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
return|;
block|}
comment|/**      *  get a document by its file name. The document's file name is used to      *  identify a document.      *      *@param  fileName absolute file name in the database;       *name can be given with or without the leading path /db/shakespeare.      *@return  The document value      *@exception  PermissionDeniedException       */
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|,
name|int
name|accessType
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|fileName
operator|=
name|prepend
argument_list|(
name|fileName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !!!
specifier|final
name|XmldbURI
name|collUri
init|=
name|fileName
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|docUri
init|=
name|fileName
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '"
operator|+
name|collUri
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//if(!collection.getPermissions().validate(getSubject(), Permission.READ)) {
comment|//throw new PermissionDeniedException("Permission denied to read collection '" + collUri + "' by " + getSubject().getName());
comment|//}
specifier|final
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|docUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document '"
operator|+
name|fileName
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|accessType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' not allowed requested access to document '"
operator|+
name|fileName
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
specifier|final
name|BinaryDocument
name|bin
init|=
operator|(
name|BinaryDocument
operator|)
name|doc
decl_stmt|;
try|try
block|{
name|bin
operator|.
name|setContentLength
argument_list|(
name|getBinaryResourceSize
argument_list|(
name|bin
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot get content size for "
operator|+
name|bin
operator|.
name|getURI
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
annotation|@
name|Override
specifier|public
name|DocumentImpl
name|getXMLResource
parameter_list|(
name|XmldbURI
name|fileName
parameter_list|,
name|int
name|lockMode
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|fileName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|fileName
operator|=
name|prepend
argument_list|(
name|fileName
operator|.
name|toCollectionPathURI
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO : resolve URIs !
specifier|final
name|XmldbURI
name|collUri
init|=
name|fileName
operator|.
name|removeLastSegment
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|docUri
init|=
name|fileName
operator|.
name|lastSegment
argument_list|()
decl_stmt|;
specifier|final
name|Collection
name|collection
init|=
name|openCollection
argument_list|(
name|collUri
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection '"
operator|+
name|collUri
operator|+
literal|"' not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
comment|//if (!collection.getPermissions().validate(getSubject(), Permission.EXECUTE)) {
comment|//    throw new PermissionDeniedException("Permission denied to read collection '" + collUri + "' by " + getSubject().getName());
comment|//}
specifier|final
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocumentWithLock
argument_list|(
name|this
argument_list|,
name|docUri
argument_list|,
name|lockMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|//LOG.debug("document '" + fileName + "' not found!");
return|return
literal|null
return|;
block|}
comment|//if (!doc.getMode().validate(getUser(), Permission.READ))
comment|//throw new PermissionDeniedException("not allowed to read document");
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
specifier|final
name|BinaryDocument
name|bin
init|=
operator|(
name|BinaryDocument
operator|)
name|doc
decl_stmt|;
try|try
block|{
name|bin
operator|.
name|setContentLength
argument_list|(
name|getBinaryResourceSize
argument_list|(
name|bin
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot get content size for "
operator|+
name|bin
operator|.
name|getURI
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not acquire lock on document "
operator|+
name|fileName
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : exception ? -pb
block|}
finally|finally
block|{
comment|//TOUNDERSTAND : by whom is this lock acquired ? -pb
comment|// If we don't check for the NO_LOCK we'll pop someone else's lock off
if|if
condition|(
name|lockMode
operator|!=
name|Lock
operator|.
name|NO_LOCK
condition|)
block|{
name|collection
operator|.
name|release
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|,
specifier|final
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|getBinaryResource
argument_list|(
name|blob
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|655360
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getBinaryResourceSize
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|binFile
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|File
name|getBinaryFile
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|InputStream
name|getBinaryResource
parameter_list|(
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileInputStream
argument_list|(
name|binFile
argument_list|)
return|;
block|}
comment|//TODO : consider a better cooperation with Collection -pb
annotation|@
name|Override
specifier|public
name|void
name|getCollectionResources
parameter_list|(
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
parameter_list|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|collectionInternalAccess
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
operator|new
name|DocumentCallback
argument_list|(
name|collectionInternalAccess
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|getResourcesFailsafe
parameter_list|(
name|BTreeCallback
name|callback
parameter_list|,
name|boolean
name|fullScan
parameter_list|)
throws|throws
name|TerminatedException
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|()
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullScan
condition|)
block|{
name|collectionsDb
operator|.
name|rawScan
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|getCollectionsFailsafe
parameter_list|(
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|()
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *  Get all the documents in this database matching the given      *  document-type's name.      * @return The documentsByDoctype value      */
annotation|@
name|Override
specifier|public
name|MutableDocumentSet
name|getXMLResourcesByDoctype
parameter_list|(
name|String
name|doctypeName
parameter_list|,
name|MutableDocumentSet
name|result
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|MutableDocumentSet
name|docs
init|=
name|getAllXMLResources
argument_list|(
operator|new
name|DefaultDocumentSet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DocumentImpl
argument_list|>
name|i
init|=
name|docs
operator|.
name|getDocumentIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|DocumentType
name|doctype
init|=
name|doc
operator|.
name|getDoctype
argument_list|()
decl_stmt|;
if|if
condition|(
name|doctype
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|doctypeName
operator|.
name|equals
argument_list|(
name|doctype
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
operator|&&
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      *  Adds all the documents in the database to the specified DocumentSet.      *      * @param docs a (possibly empty) document set to which the found      *  documents are added.      */
annotation|@
name|Override
specifier|public
name|MutableDocumentSet
name|getAllXMLResources
parameter_list|(
name|MutableDocumentSet
name|docs
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
name|rootCollection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rootCollection
operator|=
name|openCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|rootCollection
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getAllDocuments(DocumentSet) - end - "
operator|+
literal|"loading "
operator|+
name|docs
operator|.
name|getDocumentCount
argument_list|()
operator|+
literal|" documents took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|rootCollection
operator|!=
literal|null
condition|)
block|{
name|rootCollection
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//TODO : consider a better cooperation with Collection -pb
annotation|@
name|Override
specifier|public
name|void
name|getResourceMetadata
parameter_list|(
name|DocumentImpl
name|document
parameter_list|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|document
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VariableByteInput
name|istream
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|istream
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|readDocumentMeta
argument_list|(
name|istream
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param doc src document      * @param destination destination collection      * @param newName the new name for the document      */
annotation|@
name|Override
specifier|public
name|void
name|copyResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|EXistException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
specifier|final
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' has insufficient privileges to copy the resource '"
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' has insufficient privileges to copy the resource '"
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|newName
operator|=
name|doc
operator|.
name|getFileURI
argument_list|()
expr_stmt|;
block|}
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' does not have execute access on the destination collection '"
operator|+
name|destination
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
name|destination
operator|.
name|hasChildCollection
argument_list|(
name|this
argument_list|,
name|newName
operator|.
name|lastSegment
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"The collection '"
operator|+
name|destination
operator|.
name|getURI
argument_list|()
operator|+
literal|"' already has a sub-collection named '"
operator|+
name|newName
operator|.
name|lastSegment
argument_list|()
operator|+
literal|"', you cannot create a Document with the same name as an existing collection."
argument_list|)
throw|;
block|}
specifier|final
name|XmldbURI
name|newURI
init|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
specifier|final
name|XmldbURI
name|oldUri
init|=
name|doc
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account '"
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' does not have write access on the destination collection '"
operator|+
name|destination
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//overwrite existing document
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Cannot copy resource to itself '"
operator|+
name|doc
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|oldDoc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"A resource with the same name already exists in the target collection '"
operator|+
name|oldDoc
operator|.
name|getURI
argument_list|()
operator|+
literal|"', and you do not have write access on that resource."
argument_list|)
throw|;
block|}
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|newURI
argument_list|)
expr_stmt|;
block|}
name|trigger
operator|.
name|beforeCopyDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|newURI
argument_list|)
expr_stmt|;
name|DocumentImpl
name|newDocument
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
name|getBinaryResource
argument_list|(
operator|(
name|BinaryDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
name|newDocument
operator|=
name|destination
operator|.
name|addBinaryResource
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newName
argument_list|,
name|is
argument_list|,
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getMimeType
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DocumentImpl
name|newDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|destination
argument_list|,
name|newName
argument_list|)
decl_stmt|;
name|newDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|,
name|oldDoc
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|setDocId
argument_list|(
name|getNextResourceId
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|newDoc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
name|copyXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|newDoc
operator|.
name|getUpdateLock
argument_list|()
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|newDocument
operator|=
name|newDoc
expr_stmt|;
block|}
name|trigger
operator|.
name|afterCopyDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|newDocument
argument_list|,
name|oldUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"An error occurred while copying resource"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TriggerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|copyXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|oldDoc
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copying document "
operator|+
name|oldDoc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" to "
operator|+
name|newDoc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|indexController
operator|.
name|setDocument
argument_list|(
name|newDoc
argument_list|,
name|StreamListener
operator|.
name|STORE
argument_list|)
expr_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
specifier|final
name|NodeList
name|nodes
init|=
name|oldDoc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|newDoc
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copy took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
comment|/**      * Move (and/or rename) a Resource to another collection      *       * @param doc source document      * @param destination the destination collection      * @param newName the new name for the resource      *       * @throws TriggerException      */
annotation|@
name|Override
specifier|public
name|void
name|moveResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|XmldbURI
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
throws|,
name|IOException
throws|,
name|TriggerException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
specifier|final
name|Account
name|docUser
init|=
name|doc
operator|.
name|getUserLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|docUser
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|)
operator|.
name|equals
argument_list|(
name|docUser
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move '"
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" because is locked by getUser() '"
operator|+
name|docUser
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|Collection
name|collection
init|=
name|doc
operator|.
name|getCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on source Collection to move resource "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
throw|;
block|}
comment|/**          * As per the rules of Linux -          *           * mv is NOT a copy operation unless we are traversing filesystems.          * We consider eXist to be a single filesystem, so we only need          * WRITE and EXECUTE access on the source and destination collections          * as we are effectively just re-linking the file.          *           * - Adam 2013-03-26          */
comment|//must be owner of have execute access for the rename
comment|//        if(!((doc.getPermissions().getOwner().getId() != getSubject().getId()) | (doc.getPermissions().validate(getSubject(), Permission.EXECUTE)))) {
comment|//            throw new PermissionDeniedException("Account "+getSubject().getName()+" have insufficient privileges on destination Collection to move resource " + doc.getFileURI());
comment|//        }
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissionsNoLock
argument_list|()
operator|.
name|validate
argument_list|(
name|getSubject
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
operator||
name|Permission
operator|.
name|EXECUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Account "
operator|+
name|getSubject
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" have insufficient privileges on destination Collection to move resource "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
throw|;
block|}
comment|/* Copy reference to original document */
specifier|final
name|File
name|fsOriginalDocument
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|XmldbURI
name|oldName
init|=
name|doc
operator|.
name|getFileURI
argument_list|()
decl_stmt|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|newName
operator|=
name|oldName
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|destination
operator|.
name|hasChildCollection
argument_list|(
name|this
argument_list|,
name|newName
operator|.
name|lastSegment
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"The collection '"
operator|+
name|destination
operator|.
name|getURI
argument_list|()
operator|+
literal|"' have collection '"
operator|+
name|newName
operator|.
name|lastSegment
argument_list|()
operator|+
literal|"'. "
operator|+
literal|"Document with same name can't be created."
argument_list|)
throw|;
block|}
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|,
name|collection
argument_list|)
decl_stmt|;
comment|// check if the move would overwrite a collection
comment|//TODO : resolve URIs : destination.getURI().resolve(newName)
specifier|final
name|DocumentImpl
name|oldDoc
init|=
name|destination
operator|.
name|getDocument
argument_list|(
name|this
argument_list|,
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|doc
operator|.
name|getDocId
argument_list|()
operator|==
name|oldDoc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move resource to itself '"
operator|+
name|doc
operator|.
name|getURI
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// GNU mv command would prompt for Confirmation here, you can say yes or pass the '-f' flag. As we cant prompt for confirmation we assume OK
comment|/* if(!oldDoc.getPermissions().validate(getSubject(), Permission.WRITE)) {                     throw new PermissionDeniedException("Resource with same name exists in target collection and write is denied");                 }                 */
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|oldDoc
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|oldDoc
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|renameOnly
init|=
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|oldURI
init|=
name|doc
operator|.
name|getURI
argument_list|()
decl_stmt|;
specifier|final
name|XmldbURI
name|newURI
init|=
name|destination
operator|.
name|getURI
argument_list|()
operator|.
name|append
argument_list|(
name|newName
argument_list|)
decl_stmt|;
name|trigger
operator|.
name|beforeMoveDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|newURI
argument_list|)
expr_stmt|;
name|collection
operator|.
name|unlinkDocument
argument_list|(
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setFileURI
argument_list|(
name|newName
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getResourceType
argument_list|()
operator|==
name|DocumentImpl
operator|.
name|XML_FILE
condition|)
block|{
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
comment|//XXX: BUG: doc have new uri here!
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|setCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renameOnly
condition|)
block|{
comment|// reindexing
name|reindexXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|NodeProcessor
operator|.
name|MODE_REPAIR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// binary resource
name|doc
operator|.
name|setCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addDocument
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|File
name|colDir
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|destination
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|File
name|binFile
init|=
operator|new
name|File
argument_list|(
name|colDir
argument_list|,
name|newName
operator|.
name|lastSegment
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|sourceFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|doc
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/* Create required directories */
name|binFile
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|/* Rename original file to new location */
if|if
condition|(
name|fsOriginalDocument
operator|.
name|renameTo
argument_list|(
name|binFile
argument_list|)
condition|)
block|{
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|sourceFile
argument_list|,
name|binFile
argument_list|)
decl_stmt|;
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Cannot rename "
operator|+
name|sourceFile
operator|+
literal|" to "
operator|+
name|binFile
operator|+
literal|" for journaling of binary resource move."
argument_list|)
expr_stmt|;
block|}
block|}
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|transaction
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterMoveDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|doc
argument_list|,
name|oldURI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|,
name|boolean
name|freeDocId
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing document "
operator|+
name|document
operator|.
name|getFileURI
argument_list|()
operator|+
literal|" ("
operator|+
name|document
operator|.
name|getDocId
argument_list|()
operator|+
literal|") ..."
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentTrigger
name|trigger
init|=
operator|new
name|DocumentTriggers
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|freeDocId
condition|)
block|{
name|trigger
operator|.
name|beforeDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removeDocument() - removing dom"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|document
operator|.
name|getMetadata
argument_list|()
operator|.
name|isReferenced
argument_list|()
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|document
operator|.
name|getFirstChild
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeDocId
condition|)
block|{
name|freeResourceId
argument_list|(
name|transaction
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|trigger
operator|.
name|afterDeleteDocument
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|document
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"removeDocument(String) - "
operator|+
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TriggerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dropIndex
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|document
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|indexController
operator|.
name|setDocument
argument_list|(
name|document
argument_list|,
name|StreamListener
operator|.
name|REMOVE_ALL_NODES
argument_list|)
expr_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
specifier|final
name|NodeList
name|nodes
init|=
name|document
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|NodeProcessor
operator|.
name|MODE_REMOVE
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|notifyDropIndex
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|indexController
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BinaryDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|IOException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing binary resource "
operator|+
name|blob
operator|.
name|getDocId
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|binFile
init|=
name|getCollectionFile
argument_list|(
name|fsDir
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|binFile
operator|.
name|exists
argument_list|()
condition|)
block|{
specifier|final
name|File
name|binBackupFile
init|=
name|getCollectionFile
argument_list|(
name|fsBackupDir
argument_list|,
name|transaction
argument_list|,
name|blob
operator|.
name|getURI
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Loggable
name|loggable
init|=
operator|new
name|RenameBinaryLoggable
argument_list|(
name|this
argument_list|,
name|transaction
argument_list|,
name|binFile
argument_list|,
name|binBackupFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|binBackupFile
argument_list|)
condition|)
block|{
comment|// Workaround for Java bug 6213298 - renameTo() sometimes doesn't work
comment|// See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6213298
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
comment|//ignore
block|}
if|if
condition|(
operator|!
name|binFile
operator|.
name|renameTo
argument_list|(
name|binBackupFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot move file "
operator|+
name|binFile
operator|+
literal|" for delete journal to "
operator|+
name|binBackupFile
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|removeResourceMetadata
argument_list|(
name|transaction
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|setDocument
argument_list|(
name|blob
argument_list|,
name|StreamListener
operator|.
name|REMOVE_BINARY
argument_list|)
expr_stmt|;
name|getIndexController
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * @param transaction      * @param document      */
specifier|private
name|void
name|removeResourceMetadata
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|document
parameter_list|)
block|{
comment|// remove document metadata
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing resource metadata for "
operator|+
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|DocumentKey
argument_list|(
name|document
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|document
operator|.
name|getResourceType
argument_list|()
argument_list|,
name|document
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|//} catch (ReadOnlyException e) {
comment|//LOG.warn(DATABASE_IS_READ_ONLY);
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Release the document id reserved for a document so it      * can be reused.      *       * @param id      * @throws PermissionDeniedException      */
specifier|protected
name|void
name|freeResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|incrementalDocIds
condition|)
block|{
return|return;
block|}
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_DOC_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|4
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
comment|//} catch (ReadOnlyException e) {
comment|//throw new PermissionDeniedException(DATABASE_IS_READ_ONLY);
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the next unused document id. If a document is removed, its doc id is      * released, so it can be reused.      *       * @return Next unused document id      * @throws ReadOnlyException      */
specifier|public
name|int
name|getFreeResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeDocId
init|=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|FREE_DOC_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
specifier|final
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//LOG.debug("reusing document id: " + freeDocId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|4
operator|>
literal|0
condition|)
block|{
specifier|final
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collectionsDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|//TODO : maybe something ? -pb
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
return|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|freeDocId
return|;
block|}
comment|/** get next Free Doc Id       * @throws EXistException If there's no free document id */
annotation|@
name|Override
specifier|public
name|int
name|getNextResourceId
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Collection
name|collection
parameter_list|)
throws|throws
name|EXistException
block|{
name|int
name|nextDocId
decl_stmt|;
try|try
block|{
name|nextDocId
operator|=
name|getFreeResourceId
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
comment|//TODO : rethrow ? -pb
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nextDocId
operator|!=
name|DocumentImpl
operator|.
name|UNKNOWN_DOCUMENT_ID
condition|)
block|{
return|return
name|nextDocId
return|;
block|}
name|nextDocId
operator|=
literal|1
expr_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|Value
name|key
init|=
operator|new
name|CollectionStore
operator|.
name|CollectionKey
argument_list|(
name|CollectionStore
operator|.
name|NEXT_DOC_ID_KEY
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
if|if
condition|(
name|nextDocId
operator|==
literal|0x7FFFFFFF
condition|)
block|{
name|pool
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|EXistException
argument_list|(
literal|"Max. number of document ids reached. Database is set to "
operator|+
literal|"read-only state. Please do a complete backup/restore to compact the db and "
operator|+
literal|"free document ids."
argument_list|)
throw|;
block|}
block|}
specifier|final
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//} catch (ReadOnlyException e) {
comment|//LOG.warn("Database is read-only");
comment|//return DocumentImpl.UNKNOWN_DOCUMENT_ID;
comment|//TODO : rethrow ? -pb
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//TODO : rethrow ? -pb
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|nextDocId
return|;
block|}
comment|/**      * Reindex the nodes in the document. This method will either reindex all      * descendant nodes of the passed node, or all nodes below some level of      * the document if node is null.      */
specifier|private
name|void
name|reindexXMLResource
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|.
name|isCollectionConfig
argument_list|()
condition|)
block|{
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setCollectionConfigEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|indexController
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|,
name|StreamListener
operator|.
name|STORE
argument_list|)
expr_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
specifier|final
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|mode
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|isCollectionConfig
argument_list|()
condition|)
block|{
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|setCollectionConfigEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|defragXMLResource
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
comment|//TODO : use dedicated function in XmldbURI
name|LOG
operator|.
name|debug
argument_list|(
literal|"============> Defragmenting document "
operator|+
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getURI
argument_list|()
operator|+
literal|"/"
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|firstChild
init|=
name|doc
operator|.
name|getFirstChildAddress
argument_list|()
decl_stmt|;
comment|// dropping old structure index
name|dropIndex
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// dropping dom index
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"method terminated"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// create a copy of the old doc to copy the nodes into it
specifier|final
name|DocumentImpl
name|tempDoc
init|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|,
name|doc
operator|.
name|getCollection
argument_list|()
argument_list|,
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
decl_stmt|;
name|tempDoc
operator|.
name|copyOf
argument_list|(
name|doc
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tempDoc
operator|.
name|setDocId
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
name|indexController
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|,
name|StreamListener
operator|.
name|STORE
argument_list|)
expr_stmt|;
specifier|final
name|StreamListener
name|listener
init|=
name|indexController
operator|.
name|getStreamListener
argument_list|()
decl_stmt|;
comment|// copy the nodes
specifier|final
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
operator|new
name|NodePath
argument_list|()
argument_list|,
name|tempDoc
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
comment|// remove the old nodes
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|removeAll
argument_list|(
name|transaction
argument_list|,
name|firstChild
argument_list|)
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|doc
operator|.
name|copyChildren
argument_list|(
name|tempDoc
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setSplitCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|doc
operator|.
name|getMetadata
argument_list|()
operator|.
name|setPageCount
argument_list|(
name|tempDoc
operator|.
name|getMetadata
argument_list|()
operator|.
name|getPageCount
argument_list|()
argument_list|)
expr_stmt|;
name|storeXMLResource
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|closeDocument
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Defragmentation took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** consistency Check of the database; useful after XUpdates;      * called if xupdate.consistency-checks is true in configuration */
annotation|@
name|Override
specifier|public
name|void
name|checkXMLResourceConsistency
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|EXistException
block|{
name|boolean
name|xupdateConsistencyChecks
init|=
literal|false
decl_stmt|;
specifier|final
name|Object
name|property
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getProperty
argument_list|(
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
name|xupdateConsistencyChecks
operator|=
operator|(
operator|(
name|Boolean
operator|)
name|property
operator|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|checkXMLResourceTree
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** consistency Check of the database; useful after XUpdates;      * called by {@link #checkXMLResourceConsistency(DocumentImpl)} */
annotation|@
name|Override
specifier|public
name|void
name|checkXMLResourceTree
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking DOM tree for document "
operator|+
name|doc
operator|.
name|getFileURI
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|xupdateConsistencyChecks
init|=
literal|false
decl_stmt|;
specifier|final
name|Object
name|property
init|=
name|pool
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getProperty
argument_list|(
name|PROPERTY_XUPDATE_CONSISTENCY_CHECKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
name|xupdateConsistencyChecks
operator|=
operator|(
operator|(
name|Boolean
operator|)
name|property
operator|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|xupdateConsistencyChecks
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pages used: "
operator|+
name|domDb
operator|.
name|debugPages
argument_list|(
name|doc
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
specifier|final
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|node
init|=
operator|(
name|StoredNode
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//Pass buf to the following method to get a dump of all node ids in the document
if|if
condition|(
operator|!
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|node
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"node tree: "
operator|+
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error in document tree structure"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|findKeys
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"start() - "
operator|+
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *  Store a node into the database. This method is called by the parser to      *  write a node to the storage backend.      *      *@param  node         the node to be stored      *@param  currentPath  path expression which points to this node's      *      element-parent or to itself if it is an element (currently used by      *      the Broker to determine if a node's content should be      *      fulltext-indexed).  @param index switch to activate fulltext indexation      */
annotation|@
name|Override
specifier|public
name|void
name|storeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|IndexSpec
name|indexSpec
parameter_list|,
name|boolean
name|fullTextIndex
parameter_list|)
block|{
name|checkAvailableMemory
argument_list|()
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|long
name|address
decl_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|TEXT_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|CDATA_SECTION_NODE
operator|||
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
operator|>
name|defaultIndexDepth
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|add
argument_list|(
name|transaction
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|address
operator|=
name|domDb
operator|.
name|put
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"address is missing"
argument_list|)
expr_stmt|;
block|}
comment|//TODO : how can we continue here ? -pb
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|++
name|nodesCount
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|indexSpec
argument_list|,
name|fullTextIndex
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|doIndex
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|updateNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|boolean
name|reindex
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|internalAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|internalAddress
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
name|internalAddress
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domDb
operator|.
name|update
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
specifier|final
name|Value
name|oldVal
init|=
name|domDb
operator|.
name|get
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|StoredNode
name|old
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|oldVal
operator|.
name|data
argument_list|()
argument_list|,
name|oldVal
operator|.
name|start
argument_list|()
argument_list|,
name|oldVal
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while storing "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"; old = "
operator|+
name|old
operator|.
name|getNodeName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Physically insert a node into the DOM storage.      */
annotation|@
name|Override
specifier|public
name|void
name|insertNodeAfter
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|previous
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|previous
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|long
name|address
init|=
name|previous
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|!=
name|BFile
operator|.
name|UNKNOWN_ADDRESS
condition|)
block|{
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|transaction
argument_list|,
name|doc
argument_list|,
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|copyNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|,
name|boolean
name|defrag
parameter_list|,
name|boolean
name|index
parameter_list|,
name|StreamListener
name|listener
parameter_list|)
block|{
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|defrag
argument_list|,
name|index
argument_list|,
name|listener
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|copyNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|DocumentImpl
name|newDoc
parameter_list|,
name|boolean
name|defrag
parameter_list|,
name|boolean
name|index
parameter_list|,
name|StreamListener
name|listener
parameter_list|,
name|NodeId
name|oldNodeId
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|newDoc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|BFile
operator|.
name|UNKNOWN_ADDRESS
argument_list|)
expr_stmt|;
name|storeNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|defrag
operator|&&
name|oldNodeId
operator|!=
literal|null
condition|)
block|{
name|pool
operator|.
name|getNotificationService
argument_list|()
operator|.
name|notifyMove
argument_list|(
name|oldNodeId
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
comment|//save old value, whatever it is
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|oldAddress
argument_list|)
expr_stmt|;
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//restore old value, whatever it was
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|node
operator|.
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
operator|==
literal|1
condition|)
block|{
name|newDoc
operator|.
name|appendChild
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
break|break;
default|default :
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unhandled node type: "
operator|+
name|node
operator|.
name|getNodeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|NodeId
name|nodeId
init|=
name|node
operator|.
name|getNodeId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|oldNodeId
operator|=
name|child
operator|.
name|getNodeId
argument_list|()
expr_stmt|;
if|if
condition|(
name|defrag
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|nodeId
operator|=
name|nodeId
operator|.
name|newChild
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nodeId
operator|=
name|nodeId
operator|.
name|nextSibling
argument_list|()
expr_stmt|;
block|}
name|child
operator|.
name|setNodeId
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
name|copyNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|newDoc
argument_list|,
name|defrag
argument_list|,
name|index
argument_list|,
name|listener
argument_list|,
name|oldNodeId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Removes the Node Reference from the database.      * The index will be updated later, i.e. after all nodes have been physically       * removed. See {@link #endRemove(org.exist.storage.txn.Txn)}.      * removeNode() just adds the node ids to the list in elementIndex       * for later removal.      */
annotation|@
name|Override
specifier|public
name|void
name|removeNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|String
name|content
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|,
name|doc
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|address
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|notifyRemoveNode
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
name|content
argument_list|)
expr_stmt|;
specifier|final
name|NodeProxy
name|p
init|=
operator|new
name|NodeProxy
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
specifier|final
name|GeneralRangeIndexSpec
name|spec1
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec1
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|spec1
operator|.
name|getType
argument_list|()
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|QNameRangeIndexSpec
name|qnSpec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|qname
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeElement
argument_list|(
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|content
argument_list|,
name|qnSpec
operator|.
name|getType
argument_list|()
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_QNAME
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
comment|//Strange : does it mean that the node is added 2 times under 2 different identities ?
name|AttrImpl
name|attr
decl_stmt|;
name|attr
operator|=
operator|(
name|AttrImpl
operator|)
name|node
expr_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|AttrImpl
operator|.
name|ID
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|ID
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREF
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREFS
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// do nothing special
block|}
specifier|final
name|RangeIndexSpec
name|spec2
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec2
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
literal|null
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|spec2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|qnSpec
operator|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
literal|null
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|qnSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
break|break;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAllNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|StreamListener
name|listener
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
init|=
name|getNodeIterator
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
specifier|final
name|Stack
argument_list|<
name|RemovedNode
argument_list|>
name|stack
init|=
operator|new
name|Stack
argument_list|<
name|RemovedNode
argument_list|>
argument_list|()
decl_stmt|;
name|collectNodesForRemoval
argument_list|(
name|transaction
argument_list|,
name|stack
argument_list|,
name|iterator
argument_list|,
name|listener
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RemovedNode
name|next
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|removeNode
argument_list|(
name|transaction
argument_list|,
name|next
operator|.
name|node
argument_list|,
name|next
operator|.
name|path
argument_list|,
name|next
operator|.
name|content
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|collectNodesForRemoval
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Stack
argument_list|<
name|RemovedNode
argument_list|>
name|stack
parameter_list|,
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
parameter_list|,
name|StreamListener
name|listener
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|RemovedNode
name|removed
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
specifier|final
name|DocumentImpl
name|doc
init|=
name|node
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|String
name|content
init|=
literal|null
decl_stmt|;
specifier|final
name|GeneralRangeIndexSpec
name|spec
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByPathConfiguration
argument_list|(
name|this
argument_list|,
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexByQNameConfiguration
argument_list|(
name|this
argument_list|,
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|content
operator|=
name|getNodeValue
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|childCount
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|child
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectNodesForRemoval
argument_list|(
name|transaction
argument_list|,
name|stack
argument_list|,
name|iterator
argument_list|,
name|listener
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|!=
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|removed
operator|=
operator|new
name|RemovedNode
argument_list|(
name|node
argument_list|,
operator|new
name|NodePath
argument_list|(
name|currentPath
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Index a single node, which has been added through an XUpdate      * operation. This method is only called if inserting the node is possible      * without changing the node identifiers of sibling or parent nodes. In other       * cases, reindex will be called.      */
annotation|@
name|Override
specifier|public
name|void
name|indexNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|)
block|{
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|NodeProcessor
operator|.
name|MODE_STORE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|indexNode
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|int
name|repairMode
parameter_list|)
block|{
name|nodeProcessor
operator|.
name|reset
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|setMode
argument_list|(
name|repairMode
argument_list|)
expr_stmt|;
name|nodeProcessor
operator|.
name|index
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|checkNodeTree
parameter_list|(
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|docIsValid
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|StoredNode
name|previous
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|StoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|isSiblingOf
argument_list|(
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|&&
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|previous
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"node "
operator|+
name|child
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" cannot be a sibling of "
operator|+
name|previous
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"; node read from "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|child
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
name|previous
operator|=
name|child
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|i
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|": "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
comment|//TODO : emergency exit ?
block|}
specifier|final
name|NodeId
name|parentId
init|=
name|child
operator|.
name|getNodeId
argument_list|()
operator|.
name|getParentId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentId
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|child
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" is not a child of "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
name|docIsValid
operator|=
literal|false
expr_stmt|;
block|}
name|boolean
name|check
init|=
name|checkNodeTree
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIsValid
condition|)
block|{
name|docIsValid
operator|=
name|check
expr_stmt|;
block|}
block|}
block|}
return|return
name|docIsValid
return|;
block|}
comment|/**      * Called by reindex to walk through all nodes in the tree and reindex them      * if necessary.      *       * @param iterator      * @param node      * @param currentPath      */
specifier|private
name|void
name|scanNodes
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Iterator
argument_list|<
name|StoredNode
argument_list|>
name|iterator
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|int
name|mode
parameter_list|,
name|StreamListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|indexNode
argument_list|(
name|transaction
argument_list|,
name|node
argument_list|,
name|currentPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
case|case
name|Node
operator|.
name|CDATA_SECTION_NODE
case|:
name|listener
operator|.
name|characters
argument_list|(
name|transaction
argument_list|,
operator|(
name|CharacterDataImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|listener
operator|.
name|startElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|listener
operator|.
name|attribute
argument_list|(
name|transaction
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|COMMENT_NODE
case|:
case|case
name|Node
operator|.
name|PROCESSING_INSTRUCTION_NODE
case|:
break|break;
default|default :
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unhandled node type: "
operator|+
name|node
operator|.
name|getNodeType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoredNode
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"child "
operator|+
name|i
operator|+
literal|" not found for node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; children = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Wrong node id"
argument_list|)
throw|;
block|}
name|scanNodes
argument_list|(
name|transaction
argument_list|,
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|,
name|mode
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|endElement
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|,
literal|null
argument_list|,
name|mode
operator|==
name|NodeProcessor
operator|.
name|MODE_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|endElement
argument_list|(
name|transaction
argument_list|,
operator|(
name|ElementImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|StoredNode
name|node
parameter_list|,
specifier|final
name|boolean
name|addWhitespace
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
return|return
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|node
argument_list|,
name|addWhitespace
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|StoredNode
name|objectWith
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|NodeId
name|nodeId
parameter_list|)
block|{
return|return
operator|(
name|StoredNode
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|,
name|nodeId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|nodeId
operator|+
literal|" not found. This is usually not an error."
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|final
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|StoredNode
name|objectWith
parameter_list|(
specifier|final
name|NodeProxy
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|StorageAddress
operator|.
name|hasAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|(
name|StoredNode
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
comment|// DocumentImpl sets the nodeId to DOCUMENT_NODE when it's trying to find its top-level
comment|// children (for which it doesn't persist the actual node ids), so ignore that.  Nobody else
comment|// should be passing DOCUMENT_NODE into here.
specifier|final
name|boolean
name|fakeNodeId
init|=
name|p
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|NodeId
operator|.
name|DOCUMENT_NODE
argument_list|)
decl_stmt|;
specifier|final
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|p
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" not found in document "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getURI
argument_list|()
operator|+
literal|"; docId = "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|": "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakeNodeId
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
specifier|final
name|StoredNode
name|node
init|=
name|StoredNode
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
name|p
operator|.
name|getDocument
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|p
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakeNodeId
condition|)
block|{
return|return
name|node
return|;
block|}
if|if
condition|(
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|==
name|node
operator|.
name|getDocId
argument_list|()
operator|&&
name|p
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|p
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" not found in document "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getURI
argument_list|()
operator|+
literal|"; docId = "
operator|+
name|p
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocId
argument_list|()
operator|+
literal|": "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
operator|+
literal|"; found node "
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" instead"
argument_list|)
expr_stmt|;
block|}
comment|// retry based on nodeid
specifier|final
name|StoredNode
name|node
init|=
name|objectWith
argument_list|(
name|p
operator|.
name|getDocument
argument_list|()
argument_list|,
name|p
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|p
operator|.
name|setInternalAddress
argument_list|(
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// update proxy with correct address
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|repair
parameter_list|()
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|pool
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing index files ..."
argument_list|)
expr_stmt|;
name|notifyCloseAndRemove
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|removeIndexes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove index failes during repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Recreating index files ..."
argument_list|)
expr_stmt|;
try|try
block|{
name|valueIndex
operator|=
operator|new
name|NativeValueIndex
argument_list|(
name|this
argument_list|,
name|VALUES_DBX_ID
argument_list|,
name|dataDir
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception during repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|reopenIndexes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DatabaseConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to reopen index files after repair: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|initIndexModules
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reindexing database files ..."
argument_list|)
expr_stmt|;
comment|//Reindex from root collection
name|reindexCollection
argument_list|(
literal|null
argument_list|,
name|getCollection
argument_list|(
name|XmldbURI
operator|.
name|ROOT_COLLECTION_URI
argument_list|)
argument_list|,
name|NodeProcessor
operator|.
name|MODE_REPAIR
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|repairPrimary
parameter_list|()
block|{
name|rebuildIndex
argument_list|(
name|DOM_DBX_ID
argument_list|)
expr_stmt|;
name|rebuildIndex
argument_list|(
name|COLLECTIONS_DBX_ID
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|rebuildIndex
parameter_list|(
name|byte
name|indexId
parameter_list|)
block|{
name|BTree
name|btree
init|=
name|getStorage
argument_list|(
name|indexId
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|btree
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rebuilding index "
operator|+
name|btree
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|btree
operator|.
name|rebuild
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Index "
operator|+
name|btree
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" was rebuilt."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught error while rebuilding core index "
operator|+
name|btree
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught error while rebuilding core index "
operator|+
name|btree
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TerminatedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught error while rebuilding core index "
operator|+
name|btree
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught error while rebuilding core index "
operator|+
name|btree
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|notifyFlush
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|.
name|getSymbols
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|indexController
operator|.
name|flush
argument_list|()
expr_stmt|;
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|int
name|syncEvent
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while flushing dom.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
if|if
condition|(
name|syncEvent
operator|==
name|Sync
operator|.
name|MAJOR_SYNC
condition|)
block|{
specifier|final
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|collectionsDb
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
block|}
name|notifySync
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getIndexManager
argument_list|()
operator|.
name|sync
argument_list|()
expr_stmt|;
specifier|final
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
name|LOGSTATS
operator|.
name|info
argument_list|(
literal|"Memory: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|1024
argument_list|)
operator|+
literal|"K total; "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|maxMemory
argument_list|()
operator|/
literal|1024
argument_list|)
operator|+
literal|"K max; "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
literal|1024
argument_list|)
operator|+
literal|"K free"
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|notifyPrintStatistics
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|DBException
name|dbe
parameter_list|)
block|{
name|dbe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|sync
argument_list|(
name|Sync
operator|.
name|MAJOR_SYNC
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|notifyClose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** check available memory */
annotation|@
name|Override
specifier|public
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|nodesCountThreshold
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
if|if
condition|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|>=
name|run
operator|.
name|maxMemory
argument_list|()
operator|&&
name|run
operator|.
name|freeMemory
argument_list|()
operator|<
name|pool
operator|.
name|getReservedMem
argument_list|()
condition|)
block|{
specifier|final
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|totalMemory
argument_list|()
argument_list|)
operator|+
literal|"; max: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|maxMemory
argument_list|()
argument_list|)
operator|+
literal|"; free: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
operator|+
literal|"; reserved: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|pool
operator|.
name|getReservedMem
argument_list|()
argument_list|)
operator|+
literal|"; used: "
operator|+
name|nf
operator|.
name|format
argument_list|(
name|pool
operator|.
name|getCacheManager
argument_list|()
operator|.
name|getSizeInBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|nodesCount
operator|>
name|nodesCountThreshold
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|//TOUNDERSTAND : why not use shutdown ? -pb
annotation|@
name|Override
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NodeRef
extends|extends
name|Value
block|{
specifier|public
specifier|static
name|int
name|OFFSET_DOCUMENT_ID
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
name|int
name|OFFSET_NODE_ID
init|=
name|OFFSET_DOCUMENT_ID
operator|+
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
decl_stmt|;
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|len
operator|=
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
expr_stmt|;
name|pos
operator|=
name|OFFSET_DOCUMENT_ID
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|,
name|NodeId
name|nodeId
parameter_list|)
block|{
name|len
operator|=
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_ID
operator|+
name|nodeId
operator|.
name|size
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
expr_stmt|;
name|nodeId
operator|.
name|serialize
argument_list|(
name|data
argument_list|,
name|OFFSET_NODE_ID
argument_list|)
expr_stmt|;
name|pos
operator|=
name|OFFSET_DOCUMENT_ID
expr_stmt|;
block|}
name|int
name|getDocId
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|OFFSET_DOCUMENT_ID
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|final
specifier|static
class|class
name|RemovedNode
block|{
name|StoredNode
name|node
decl_stmt|;
name|String
name|content
decl_stmt|;
name|NodePath
name|path
decl_stmt|;
name|RemovedNode
parameter_list|(
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|path
parameter_list|,
name|String
name|content
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
block|}
block|}
comment|/** Delegate for Node Processings : indexing */
specifier|private
class|class
name|NodeProcessor
block|{
specifier|final
specifier|static
name|int
name|MODE_STORE
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|MODE_REPAIR
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
name|int
name|MODE_REMOVE
init|=
literal|2
decl_stmt|;
specifier|private
name|Txn
name|transaction
decl_stmt|;
specifier|private
name|StoredNode
name|node
decl_stmt|;
specifier|private
name|NodePath
name|currentPath
decl_stmt|;
comment|/** work variables */
specifier|private
name|DocumentImpl
name|doc
decl_stmt|;
specifier|private
name|long
name|address
decl_stmt|;
specifier|private
name|IndexSpec
name|idxSpec
decl_stmt|;
comment|//private FulltextIndexSpec ftIdx;
specifier|private
name|int
name|level
decl_stmt|;
specifier|private
name|int
name|mode
init|=
name|MODE_STORE
decl_stmt|;
comment|/** overall switch to activate fulltext indexation */
specifier|private
name|boolean
name|fullTextIndex
init|=
literal|true
decl_stmt|;
name|NodeProcessor
parameter_list|()
block|{
comment|//ignore
block|}
specifier|public
name|void
name|reset
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|StoredNode
name|node
parameter_list|,
name|NodePath
name|currentPath
parameter_list|,
name|IndexSpec
name|indexSpec
parameter_list|,
name|boolean
name|fullTextIndex
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"illegal node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//TODO : why continue processing ? return ? -pb
name|this
operator|.
name|transaction
operator|=
name|transaction
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|currentPath
operator|=
name|currentPath
expr_stmt|;
name|this
operator|.
name|mode
operator|=
name|MODE_STORE
expr_stmt|;
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
expr_stmt|;
name|address
operator|=
name|node
operator|.
name|getInternalAddress
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexSpec
operator|==
literal|null
condition|)
block|{
name|indexSpec
operator|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getIndexConfiguration
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
name|idxSpec
operator|=
name|indexSpec
expr_stmt|;
comment|//ftIdx = idxSpec == null ? null : idxSpec.getFulltextIndexSpec();
name|level
operator|=
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|getTreeLevel
argument_list|()
expr_stmt|;
name|this
operator|.
name|fullTextIndex
operator|=
name|fullTextIndex
expr_stmt|;
block|}
specifier|public
name|void
name|setMode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
comment|/** Updates the various indices */
specifier|public
name|void
name|doIndex
parameter_list|()
block|{
comment|//TODO : resolve URI !
specifier|final
name|boolean
name|isTemp
init|=
name|XmldbURI
operator|.
name|TEMP_COLLECTION_URI
operator|.
name|equalsInternal
argument_list|(
operator|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|)
operator|.
name|getCollection
argument_list|()
operator|.
name|getURI
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|indexType
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|//Compute index type
comment|//TODO : let indexers OR it themselves
comment|//we'd need to notify the ElementIndexer at the very end then...
name|indexType
operator|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
operator|&&
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|QNAME_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|indexType
operator||=
name|qnIdx
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|(
operator|(
name|ElementImpl
operator|)
name|node
operator|)
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
comment|//notifyStartElement((ElementImpl)node, currentPath, fullTextIndex);
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
specifier|final
name|QName
name|qname
init|=
name|node
operator|.
name|getQName
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|currentPath
operator|.
name|addComponent
argument_list|(
name|qname
argument_list|)
expr_stmt|;
block|}
comment|//Compute index type
comment|//TODO : let indexers OR it themselves
comment|//we'd need to notify the ElementIndexer at the very end then...
name|indexType
operator|=
name|RangeIndexSpec
operator|.
name|NO_INDEX
expr_stmt|;
if|if
condition|(
name|idxSpec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RangeIndexSpec
name|rangeSpec
init|=
name|idxSpec
operator|.
name|getIndexByPath
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangeSpec
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|rangeSpec
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rangeSpec
operator|!=
literal|null
condition|)
block|{
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|//Oh dear : is it the right semantics then ?
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|rangeSpec
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
block|}
specifier|final
name|QNameRangeIndexSpec
name|qnIdx
init|=
name|idxSpec
operator|.
name|getIndexByQName
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qnIdx
operator|!=
literal|null
condition|)
block|{
name|indexType
operator||=
name|RangeIndexSpec
operator|.
name|QNAME_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|RangeIndexSpec
operator|.
name|hasRangeIndex
argument_list|(
name|indexType
argument_list|)
condition|)
block|{
name|indexType
operator||=
name|qnIdx
operator|.
name|getIndexType
argument_list|()
expr_stmt|;
block|}
name|valueIndex
operator|.
name|setDocument
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|)
expr_stmt|;
comment|//Oh dear : is it the right semantics then ?
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
operator|(
name|AttrImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|qnIdx
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|tempProxy
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
specifier|final
name|AttrImpl
name|attr
init|=
operator|(
name|AttrImpl
operator|)
name|node
decl_stmt|;
name|attr
operator|.
name|setIndexType
argument_list|(
name|indexType
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|AttrImpl
operator|.
name|ID
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|ID
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREF
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AttrImpl
operator|.
name|IDREFS
case|:
name|valueIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
specifier|final
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|attr
operator|.
name|getValue
argument_list|()
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|valueIndex
operator|.
name|storeAttribute
argument_list|(
name|attr
argument_list|,
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|,
name|currentPath
argument_list|,
name|NativeValueIndex
operator|.
name|WITHOUT_PATH
argument_list|,
name|Type
operator|.
name|IDREF
argument_list|,
name|NativeValueIndex
operator|.
name|IDX_GENERIC
argument_list|,
name|mode
operator|==
name|MODE_REMOVE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// do nothing special
block|}
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|currentPath
operator|.
name|removeLastComponent
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|notifyStoreText
argument_list|(
operator|(
name|TextImpl
operator|)
name|node
argument_list|,
name|currentPath
argument_list|,
name|fullTextIndex
condition|?
name|NativeTextEngine
operator|.
name|DO_NOT_TOKENIZE
else|:
name|NativeTextEngine
operator|.
name|TOKENIZE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/** Stores this node into the database, if it's an element */
specifier|public
name|void
name|store
parameter_list|()
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_STORE
operator|&&
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|defaultIndexDepth
condition|)
block|{
comment|//TODO : used to be this, but NativeBroker.this avoids an owner change
operator|new
name|DOMTransaction
argument_list|(
name|NativeBroker
operator|.
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|EXCEPTION_DURING_REINDEX
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** check available memory */
specifier|private
name|void
name|checkAvailableMemory
parameter_list|()
block|{
if|if
condition|(
name|mode
operator|!=
name|MODE_REMOVE
operator|&&
name|nodesCount
operator|>
name|DEFAULT_NODES_BEFORE_MEMORY_CHECK
condition|)
block|{
if|if
condition|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|>=
name|run
operator|.
name|maxMemory
argument_list|()
operator|&&
name|run
operator|.
name|freeMemory
argument_list|()
operator|<
name|pool
operator|.
name|getReservedMem
argument_list|()
condition|)
block|{
comment|//LOG.info("total memory: " + run.totalMemory() + "; free: " + run.freeMemory());
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Updates the various indices and stores this node into the database */
specifier|public
name|void
name|index
parameter_list|()
block|{
operator|++
name|nodesCount
expr_stmt|;
name|checkAvailableMemory
argument_list|()
expr_stmt|;
name|doIndex
argument_list|()
expr_stmt|;
name|store
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
class|class
name|DocumentCallback
implements|implements
name|BTreeCallback
block|{
specifier|private
specifier|final
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
decl_stmt|;
specifier|private
name|DocumentCallback
parameter_list|(
specifier|final
name|Collection
operator|.
name|InternalAccess
name|collectionInternalAccess
parameter_list|)
block|{
name|this
operator|.
name|collectionInternalAccess
operator|=
name|collectionInternalAccess
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|indexInfo
parameter_list|(
specifier|final
name|Value
name|key
parameter_list|,
specifier|final
name|long
name|pointer
parameter_list|)
throws|throws
name|TerminatedException
block|{
try|try
block|{
specifier|final
name|byte
name|type
init|=
name|key
operator|.
name|data
argument_list|()
index|[
name|key
operator|.
name|start
argument_list|()
operator|+
name|Collection
operator|.
name|LENGTH_COLLECTION_ID
operator|+
name|DocumentImpl
operator|.
name|LENGTH_DOCUMENT_TYPE
index|]
decl_stmt|;
specifier|final
name|VariableByteInput
name|istream
init|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DocumentImpl
operator|.
name|BINARY_FILE
condition|)
block|{
name|doc
operator|=
operator|new
name|BinaryDocument
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|=
operator|new
name|DocumentImpl
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|read
argument_list|(
name|istream
argument_list|)
expr_stmt|;
name|collectionInternalAccess
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"EOFException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IOException while reading document data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|EXistException
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"EXistException while reading document data"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

