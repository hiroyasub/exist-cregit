begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-03 Wolfgang M. Meier  *  wolfgang@exist-db.org  *  http://exist-db.org  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *   *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|MalformedPatternException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|PatternCompiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|PatternMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Perl5Compiler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|oro
operator|.
name|text
operator|.
name|regex
operator|.
name|Perl5Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|data
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|Paged
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|indexer
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|EXistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ArraySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|AttrImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|BLOBDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|ExtArrayNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeIndexListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|TextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|NativeSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|serializers
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|BFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|DOMFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|DOMFileIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|DOMTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|StorageAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArrayPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Occurrences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|VariableByteInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xpath
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DocumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|/**  *  Main class for the native XML storage backend.  *   * Provides access to all low-level operations required by  * the database. Extends {@link DBBroker}.  *  *@author     Wolfgang Meier  *@created    15. Mai 2002  */
end_comment

begin_class
specifier|public
class|class
name|NativeBroker
extends|extends
name|DBBroker
block|{
comment|// default buffer size setting
specifier|protected
specifier|final
specifier|static
name|int
name|BUFFERS
init|=
literal|256
decl_stmt|;
comment|// check available memory after storing MEM_LIMIT_CHECK nodes
specifier|protected
specifier|static
name|int
name|MEM_LIMIT_CHECK
init|=
literal|10000
decl_stmt|;
specifier|private
specifier|static
name|Category
name|LOG
init|=
name|Category
operator|.
name|getInstance
argument_list|(
name|NativeBroker
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|CollectionStore
name|collectionsDb
init|=
literal|null
decl_stmt|;
specifier|protected
name|DOMFile
name|domDb
init|=
literal|null
decl_stmt|;
specifier|protected
name|NativeElementIndex
name|elementIndex
decl_stmt|;
specifier|protected
name|ElementPool
name|elementPool
init|=
operator|new
name|ElementPool
argument_list|(
literal|50
argument_list|)
decl_stmt|;
specifier|protected
name|BFile
name|elementsDb
init|=
literal|null
decl_stmt|;
specifier|protected
name|NativeTextEngine
name|textEngine
decl_stmt|;
specifier|protected
name|Serializer
name|xmlSerializer
decl_stmt|;
specifier|protected
name|PatternCompiler
name|compiler
init|=
operator|new
name|Perl5Compiler
argument_list|()
decl_stmt|;
specifier|protected
name|PatternMatcher
name|matcher
init|=
operator|new
name|Perl5Matcher
argument_list|()
decl_stmt|;
specifier|protected
name|int
name|defaultIndexDepth
init|=
literal|1
decl_stmt|;
specifier|protected
name|Map
name|idxPathMap
decl_stmt|;
specifier|protected
name|boolean
name|readOnly
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|memMinFree
decl_stmt|;
specifier|protected
name|int
name|nodesCount
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
specifier|public
name|NativeBroker
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|Configuration
name|config
parameter_list|)
throws|throws
name|EXistException
block|{
name|super
argument_list|(
name|pool
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|String
name|dataDir
decl_stmt|;
name|int
name|buffers
decl_stmt|,
name|pageSize
decl_stmt|,
name|cacheSize
decl_stmt|;
name|String
name|temp
decl_stmt|;
name|boolean
name|compress
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|dataDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.data-dir"
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|dataDir
operator|=
literal|"data"
expr_stmt|;
if|if
condition|(
operator|(
name|pageSize
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.page-size"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pageSize
operator|=
literal|4096
expr_stmt|;
if|if
condition|(
operator|(
name|buffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|buffers
operator|=
name|BUFFERS
expr_stmt|;
if|if
condition|(
operator|(
name|cacheSize
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.cache-size"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|long
name|totalMem
init|=
name|cacheSize
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|buffers
operator|=
operator|(
name|int
operator|)
operator|(
name|totalMem
operator|/
name|pageSize
operator|/
literal|64
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|defaultIndexDepth
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"indexer.index-depth"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|defaultIndexDepth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|memMinFree
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.min_free_memory"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|memMinFree
operator|=
literal|5000000
expr_stmt|;
name|Paged
operator|.
name|setPageSize
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
name|String
name|pathSep
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|int
name|indexBuffers
decl_stmt|,
name|dataBuffers
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|elementsDb
operator|=
operator|(
name|BFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.elements"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|indexBuffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.elements.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|4
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
operator|*
literal|11
expr_stmt|;
block|}
else|else
name|dataBuffers
operator|=
name|indexBuffers
operator|>>
literal|2
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"elements index buffer size: "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|elementsDb
operator|=
operator|new
name|BFile
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"elements.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elementsDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating elements.dbx"
argument_list|)
expr_stmt|;
name|elementsDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|elementsDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.elements"
argument_list|,
name|elementsDb
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|elementsDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|domDb
operator|=
operator|(
name|DOMFile
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.dom"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|config
operator|.
name|hasProperty
argument_list|(
literal|"db-connection.buffers"
argument_list|)
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
expr_stmt|;
name|dataBuffers
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|4
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"page buffer size = "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|domDb
operator|=
operator|new
name|DOMFile
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"dom.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|domDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating dom.dbx"
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|domDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.dom"
argument_list|,
name|domDb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readOnly
condition|)
name|readOnly
operator|=
name|domDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|collectionsDb
operator|=
operator|(
name|CollectionStore
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"db-connection.collections"
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|indexBuffers
operator|=
name|config
operator|.
name|getInteger
argument_list|(
literal|"db-connection.collections.buffers"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|indexBuffers
operator|=
name|buffers
operator|*
literal|8
expr_stmt|;
name|dataBuffers
operator|=
name|buffers
operator|*
literal|8
expr_stmt|;
block|}
else|else
name|dataBuffers
operator|=
name|indexBuffers
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"collections index buffer size: "
operator|+
name|indexBuffers
operator|+
literal|"; "
operator|+
name|dataBuffers
argument_list|)
expr_stmt|;
name|collectionsDb
operator|=
operator|new
name|CollectionStore
argument_list|(
operator|new
name|File
argument_list|(
name|dataDir
operator|+
name|pathSep
operator|+
literal|"collections.dbx"
argument_list|)
argument_list|,
name|indexBuffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|collectionsDb
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating collections.dbx"
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|open
argument_list|()
expr_stmt|;
name|config
operator|.
name|setProperty
argument_list|(
literal|"db-connection.collections"
argument_list|,
name|collectionsDb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readOnly
condition|)
name|readOnly
operator|=
name|collectionsDb
operator|.
name|isReadOnly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|readOnly
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"database runs in read-only mode"
argument_list|)
expr_stmt|;
name|idxPathMap
operator|=
operator|(
name|Map
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"indexer.map"
argument_list|)
expr_stmt|;
name|textEngine
operator|=
operator|new
name|NativeTextEngine
argument_list|(
name|this
argument_list|,
name|config
argument_list|,
name|buffers
argument_list|)
expr_stmt|;
name|xmlSerializer
operator|=
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|elementIndex
operator|=
operator|new
name|NativeElementIndex
argument_list|(
name|this
argument_list|,
name|config
argument_list|,
name|elementsDb
argument_list|)
expr_stmt|;
name|user
operator|=
operator|new
name|User
argument_list|(
literal|"admin"
argument_list|,
literal|null
argument_list|,
literal|"dba"
argument_list|)
expr_stmt|;
name|getOrCreateCollection
argument_list|(
literal|"/db"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
specifier|final
specifier|static
name|String
name|normalizeCollectionName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'/'
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
name|i
operator|+
literal|1
operator|&&
name|name
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
else|else
name|out
operator|.
name|append
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|addObserver
parameter_list|(
name|Observer
name|o
parameter_list|)
block|{
name|super
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addObserver
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|boolean
name|compare
parameter_list|(
name|String
name|o1
parameter_list|,
name|String
name|o2
parameter_list|,
name|int
name|relation
parameter_list|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
operator|!
name|isCaseSensitive
argument_list|()
condition|)
name|cmp
operator|=
name|o1
operator|.
name|compareToIgnoreCase
argument_list|(
name|o2
argument_list|)
expr_stmt|;
else|else
name|cmp
operator|=
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|relation
condition|)
block|{
case|case
name|Constants
operator|.
name|LT
case|:
return|return
operator|(
name|cmp
operator|<
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|LTEQ
case|:
return|return
operator|(
name|cmp
operator|<=
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|GT
case|:
return|return
operator|(
name|cmp
operator|>
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|GTEQ
case|:
return|return
operator|(
name|cmp
operator|>=
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|EQ
case|:
return|return
operator|(
name|cmp
operator|==
literal|0
operator|)
return|;
case|case
name|Constants
operator|.
name|NEQ
case|:
return|return
operator|(
name|cmp
operator|!=
literal|0
operator|)
return|;
block|}
return|return
literal|false
return|;
comment|// never reached
block|}
specifier|public
name|Occurrences
index|[]
name|scanIndexedElements
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"you don't have the permission"
operator|+
literal|" to read collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|List
name|collections
init|=
name|inclusive
condition|?
name|collection
operator|.
name|getDescendants
argument_list|(
name|this
argument_list|,
name|user
argument_list|)
else|:
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|collections
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|short
name|collectionId
decl_stmt|,
name|elementId
decl_stmt|;
name|ElementValue
name|ref
decl_stmt|;
name|IndexQuery
name|query
decl_stmt|;
name|ArrayList
name|values
decl_stmt|;
name|Value
name|val
index|[]
decl_stmt|;
name|String
name|name
decl_stmt|;
name|Collection
name|current
decl_stmt|;
name|TreeMap
name|map
init|=
operator|new
name|TreeMap
argument_list|()
decl_stmt|;
name|Occurrences
name|oc
decl_stmt|;
name|VariableByteInputStream
name|is
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|elementsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
name|Short
name|id
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collections
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|current
operator|=
operator|(
name|Collection
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|current
operator|.
name|getId
argument_list|()
expr_stmt|;
name|ref
operator|=
operator|new
name|ElementValue
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|,
name|collectionId
argument_list|)
expr_stmt|;
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|values
operator|=
name|elementsDb
operator|.
name|findEntries
argument_list|(
name|query
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|values
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|val
operator|=
operator|(
name|Value
index|[]
operator|)
name|j
operator|.
name|next
argument_list|()
expr_stmt|;
name|elementId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|val
index|[
literal|0
index|]
operator|.
name|getData
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id
operator|=
operator|new
name|Short
argument_list|(
name|elementId
argument_list|)
expr_stmt|;
name|name
operator|=
name|NativeBroker
operator|.
name|getSymbols
argument_list|()
operator|.
name|getName
argument_list|(
name|elementId
argument_list|)
expr_stmt|;
name|oc
operator|=
operator|(
name|Occurrences
operator|)
name|map
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|==
literal|null
condition|)
block|{
name|oc
operator|=
operator|new
name|Occurrences
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|is
operator|=
operator|new
name|VariableByteInputStream
argument_list|(
name|val
index|[
literal|1
index|]
operator|.
name|data
argument_list|()
argument_list|,
name|val
index|[
literal|1
index|]
operator|.
name|start
argument_list|()
argument_list|,
name|val
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|oc
operator|.
name|addOccurrences
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|is
operator|.
name|skip
argument_list|(
name|len
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unexpected exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception while reading element index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception while reading element index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Occurrences
index|[]
name|result
init|=
operator|new
name|Occurrences
index|[
name|map
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|(
name|Occurrences
index|[]
operator|)
name|map
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/** 	 *  Find elements by their tag name. This method is comparable to the DOM's 	 *  method call getElementsByTagName. All elements matching tagName and 	 *  belonging to one of the documents in the DocumentSet docs are returned. 	 * 	 *@param  docs     Description of the Parameter 	 *@param  tagName  Description of the Parameter 	 *@return          Description of the Return Value 	 */
specifier|public
name|NodeSet
name|findElementsByTagName
parameter_list|(
name|byte
name|type
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|QName
name|qname
parameter_list|)
block|{
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|//final ArraySet result = new ArraySet(10000);
specifier|final
name|ExtArrayNodeSet
name|result
init|=
operator|new
name|ExtArrayNodeSet
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|int
name|len
decl_stmt|;
name|short
name|collectionId
decl_stmt|;
name|long
name|gid
decl_stmt|,
name|address
decl_stmt|;
name|VariableByteInputStream
name|is
decl_stmt|;
name|ElementValue
name|ref
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|InputStream
name|dis
decl_stmt|;
name|short
name|sym
decl_stmt|,
name|nsSym
decl_stmt|;
name|Collection
name|collection
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|elementsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|getCollectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|collection
operator|=
operator|(
name|Collection
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|collectionId
operator|=
name|collection
operator|.
name|getId
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ElementValue
operator|.
name|ATTRIBUTE_ID
condition|)
block|{
name|sym
operator|=
name|NativeBroker
operator|.
name|getSymbols
argument_list|()
operator|.
name|getSymbol
argument_list|(
name|qname
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
name|nsSym
operator|=
name|NativeBroker
operator|.
name|getSymbols
argument_list|()
operator|.
name|getNSSymbol
argument_list|(
name|qname
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|ElementValue
argument_list|(
operator|(
name|byte
operator|)
name|type
argument_list|,
name|collectionId
argument_list|,
name|sym
argument_list|,
name|nsSym
argument_list|)
expr_stmt|;
block|}
else|else
name|ref
operator|=
operator|new
name|ElementValue
argument_list|(
operator|(
name|byte
operator|)
name|type
argument_list|,
name|collectionId
argument_list|,
name|qname
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|dis
operator|=
name|elementsDb
operator|.
name|getAsStream
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|dis
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io exception while reading elements for "
operator|+
name|qname
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|dis
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dis
operator|==
literal|null
condition|)
continue|continue;
name|is
operator|=
operator|new
name|VariableByteInputStream
argument_list|(
name|dis
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|getDoc
argument_list|(
name|docId
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|is
operator|.
name|skip
argument_list|(
name|len
operator|*
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
name|gid
operator|=
name|gid
operator|+
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
comment|//address = is.readFixedLong();
name|result
operator|.
name|add
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|ELEMENT_NODE
argument_list|,
comment|//		address),
name|StorageAddress
operator|.
name|read
argument_list|(
name|is
argument_list|)
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unexpected io error"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|sort
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"found "
operator|+
name|qname
operator|+
literal|": "
operator|+
name|result
operator|.
name|getLength
argument_list|()
operator|+
literal|" in "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|void
name|flush
parameter_list|()
block|{
name|textEngine
operator|.
name|flush
argument_list|()
expr_stmt|;
name|elementIndex
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbols
operator|!=
literal|null
operator|&&
name|symbols
operator|.
name|hasChanged
argument_list|()
condition|)
try|try
block|{
name|DBBroker
operator|.
name|saveSymbols
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EXistException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|nodesCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|endRemove
parameter_list|()
block|{
name|textEngine
operator|.
name|remove
argument_list|()
expr_stmt|;
name|elementIndex
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|/** 	 *  get all the documents in this database repository. The documents are 	 *  returned as a DocumentSet. 	 * 	 *@param  user  Description of the Parameter 	 *@return       The allDocuments value 	 */
specifier|public
name|DocumentSet
name|getAllDocuments
parameter_list|(
name|DocumentSet
name|docs
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
name|root
init|=
name|getCollection
argument_list|(
literal|"/db"
argument_list|)
decl_stmt|;
name|root
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"loading "
operator|+
name|docs
operator|.
name|getLength
argument_list|()
operator|+
literal|" documents from "
operator|+
name|docs
operator|.
name|getCollectionCount
argument_list|()
operator|+
literal|"collections took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/** 	 *  Attributes are stored in the element-index (with a leading "@" in the 	 *  name). So simply call findElementsByTagName() 	 * 	 *@param  docs  Description of the Parameter 	 *@param  name  Description of the Parameter 	 *@return       The attributesByName value 	 */
specifier|public
name|NodeSet
name|getAttributesByName
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|QName
name|qname
parameter_list|)
block|{
name|qname
operator|.
name|setLocalName
argument_list|(
name|qname
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"searching attrib "
operator|+
name|qname
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
name|NodeSet
name|result
init|=
name|findElementsByTagName
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|,
name|docs
argument_list|,
name|qname
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"found "
operator|+
name|result
operator|.
name|getLength
argument_list|()
operator|+
literal|" matching attributes"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|getCollection
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/** 	 *  get collection object. If the collection does not exist, null is 	 *  returned. 	 * 	 *@param  name  Description of the Parameter 	 *@return       The collection value 	 */
specifier|public
name|Collection
name|getCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|addr
parameter_list|)
block|{
comment|//	final long start = System.currentTimeMillis();
name|name
operator|=
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|name
operator|=
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|name
operator|=
literal|"/db"
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collection
name|collection
init|=
literal|null
decl_stmt|;
name|InputStream
name|dis
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|collection
operator|=
name|collectionsDb
operator|.
name|getCollectionCache
argument_list|()
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
return|return
name|collection
return|;
block|}
name|collection
operator|=
operator|new
name|Collection
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|dis
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dis
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dis
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|VariableByteInputStream
name|istream
init|=
operator|new
name|VariableByteInputStream
argument_list|(
name|dis
argument_list|)
decl_stmt|;
try|try
block|{
name|collection
operator|.
name|read
argument_list|(
name|this
argument_list|,
name|istream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|collectionsDb
operator|.
name|getCollectionCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collection store"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|//			LOG.debug(
comment|//				"loading collection "
comment|//					+ name
comment|//					+ " took "
comment|//					+ (System.currentTimeMillis() - start)
comment|//					+ "ms.");
return|return
name|collection
return|;
block|}
specifier|public
name|Iterator
name|getDOMIterator
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|DOMFileIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|proxy
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create DOM iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create DOM iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Iterator
name|getNodeIterator
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
name|domDb
operator|.
name|setOwnerObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|new
name|NodeIterator
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|proxy
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to create node iterator"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|int
name|getDatabaseType
parameter_list|()
block|{
return|return
name|DBBroker
operator|.
name|NATIVE
return|;
block|}
comment|/** 	 *  get a document by it's file name. The document's file name is used to 	 *  identify a document. File names are stored without the leading path. 	 * 	 *@param  fileName                       Description of the Parameter 	 *@param  user                           Description of the Parameter 	 *@return                                The document value 	 *@exception  PermissionDeniedException  Description of the Exception 	 */
specifier|public
name|Document
name|getDocument
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
operator|!
name|fileName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|fileName
operator|=
literal|'/'
operator|+
name|fileName
expr_stmt|;
name|int
name|pos
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|String
name|collName
init|=
operator|(
name|pos
operator|>
literal|0
operator|)
condition|?
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
else|:
literal|"/"
decl_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|collName
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission denied to read collection"
argument_list|)
throw|;
name|DocumentImpl
name|doc
init|=
name|collection
operator|.
name|getDocument
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document "
operator|+
name|fileName
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"not allowed to read document"
argument_list|)
throw|;
return|return
name|doc
return|;
block|}
specifier|public
name|DocumentSet
name|getDocumentsByCollection
parameter_list|(
name|String
name|collection
parameter_list|,
name|DocumentSet
name|docs
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
return|return
name|getDocumentsByCollection
argument_list|(
name|collection
argument_list|,
name|docs
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|DocumentSet
name|getDocumentsByCollection
parameter_list|(
name|String
name|collection
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
operator|||
name|collection
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|docs
return|;
if|if
condition|(
name|collection
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|collection
operator|=
literal|"/"
operator|+
name|collection
expr_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|startsWith
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|collection
operator|=
literal|"/db"
operator|+
name|collection
expr_stmt|;
name|Collection
name|root
init|=
name|getCollection
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|collection
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
name|docs
operator|=
name|root
operator|.
name|allDocs
argument_list|(
name|this
argument_list|,
name|docs
argument_list|,
name|inclusive
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"loading "
operator|+
name|docs
operator|.
name|getLength
argument_list|()
operator|+
literal|" documents from collection "
operator|+
name|collection
operator|+
literal|" took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/** 	 *  get all the documents in this database matching the given 	 *  document-type's name. 	 * 	 *@param  doctypeName  Description of the Parameter 	 *@param  user         Description of the Parameter 	 *@return              The documentsByDoctype value 	 */
specifier|public
name|DocumentSet
name|getDocumentsByDoctype
parameter_list|(
name|String
name|doctypeName
parameter_list|,
name|DocumentSet
name|result
parameter_list|)
block|{
name|DocumentSet
name|docs
init|=
name|getAllDocuments
argument_list|(
operator|new
name|DocumentSet
argument_list|()
argument_list|)
decl_stmt|;
name|DocumentImpl
name|doc
decl_stmt|;
name|DocumentType
name|doctype
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|docs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|doc
operator|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|doctype
operator|=
name|doc
operator|.
name|getDoctype
argument_list|()
expr_stmt|;
if|if
condition|(
name|doctype
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|doctypeName
operator|.
name|equals
argument_list|(
name|doctype
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
operator|&&
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|READ
argument_list|)
condition|)
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|short
name|getNextCollectionId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|short
name|nextCollectionId
init|=
literal|0
decl_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__next_collection_id"
argument_list|)
decl_stmt|;
name|Value
name|data
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|data
operator|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextCollectionId
return|;
block|}
comment|/** 	 *  get the number of documents in the repository this is used to determine 	 *  a free document-id for the document to be stored. 	 * 	 *@param  collection  Description of the Parameter 	 *@return             The nextDocId value 	 */
specifier|public
name|int
name|getNextDocId
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|int
name|nextDocId
init|=
literal|1
decl_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__next_doc_id"
argument_list|)
decl_stmt|;
name|Value
name|data
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|data
operator|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"database read-only"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextDocId
return|;
block|}
specifier|public
name|void
name|index
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|IndexPaths
name|idx
init|=
operator|(
name|IndexPaths
operator|)
name|idxPathMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDoctype
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"node "
operator|+
name|gid
operator|+
literal|": internal address missing"
argument_list|)
expr_stmt|;
specifier|final
name|int
name|depth
init|=
name|idx
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idx
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
specifier|final
name|int
name|level
init|=
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
decl_stmt|;
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// save element by calling ElementIndex
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|getIncludeAttributes
argument_list|()
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|idx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
comment|// if (idx == null || idx.match(currentPath))
name|textEngine
operator|.
name|storeText
argument_list|(
name|idx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|depth
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reindex
parameter_list|(
name|DocumentImpl
name|oldDoc
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|,
name|NodeImpl
name|node
parameter_list|)
block|{
name|int
name|idxLevel
init|=
name|doc
operator|.
name|reindexRequired
argument_list|()
decl_stmt|;
if|if
condition|(
name|idxLevel
operator|<
literal|0
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
return|return;
block|}
name|oldDoc
operator|.
name|setReindexRequired
argument_list|(
name|idxLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindexing level "
operator|+
name|idxLevel
operator|+
literal|" of document "
operator|+
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// remove old dom index
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
name|domDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
comment|// try to acquire a lock on the file
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|setOwnerObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|final
name|ArrayList
name|nodes
init|=
name|domDb
operator|.
name|findKeys
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|long
name|gid
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|nodes
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ref
operator|=
operator|(
name|Value
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|gid
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|ref
operator|.
name|data
argument_list|()
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|>=
name|doc
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|XMLUtil
operator|.
name|isDescendantOrSelf
argument_list|(
name|oldDoc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|gid
argument_list|)
condition|)
block|{
name|domDb
operator|.
name|removeValue
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|domDb
operator|.
name|removeValue
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
comment|// timed out
name|LOG
operator|.
name|warn
argument_list|(
literal|"lock timed out during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// reindex the nodes
name|Iterator
name|iterator
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|NodeList
name|nodes
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|n
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
operator|(
name|NodeImpl
operator|)
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|n
operator|.
name|getGID
argument_list|()
argument_list|,
name|n
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|n
argument_list|,
operator|new
name|StringBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iterator
operator|=
name|getNodeIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|node
argument_list|,
name|node
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|elementIndex
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|textEngine
operator|.
name|reindex
argument_list|(
name|oldDoc
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|doc
operator|.
name|setReindexRequired
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"reindex took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|reindex
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|StringBuffer
name|currentPath
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getGID
argument_list|()
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal node: "
operator|+
name|node
operator|.
name|getGID
argument_list|()
operator|+
literal|"; "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|IndexPaths
name|idx
init|=
operator|(
name|IndexPaths
operator|)
name|idxPathMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDoctype
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|int
name|depth
init|=
name|idx
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idx
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
specifier|final
name|int
name|level
init|=
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|doc
operator|.
name|reindexRequired
argument_list|()
condition|)
block|{
name|NodeIndexListener
name|listener
decl_stmt|;
if|if
condition|(
operator|(
name|listener
operator|=
name|doc
operator|.
name|getIndexListener
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|listener
operator|.
name|nodeChanged
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|ELEMENT_NODE
operator|&&
name|level
operator|<=
name|depth
condition|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|domDb
operator|.
name|addValue
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception during reindex"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// save element by calling ElementIndex
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|tempProxy
operator|.
name|setHasIndex
argument_list|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|match
argument_list|(
name|currentPath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|tempProxy
operator|.
name|setHasIndex
argument_list|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|match
argument_list|(
name|currentPath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|idx
operator|==
literal|null
operator|||
operator|(
name|idx
operator|.
name|getIncludeAttributes
argument_list|()
operator|&&
name|idx
operator|.
name|match
argument_list|(
name|currentPath
operator|+
literal|"/@"
operator|+
name|nodeName
argument_list|)
operator|)
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|idx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
literal|"&"
operator|+
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|match
argument_list|(
name|currentPath
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
name|textEngine
operator|.
name|storeText
argument_list|(
name|idx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
specifier|private
name|void
name|scanNodes
parameter_list|(
name|Iterator
name|iterator
parameter_list|,
name|NodeImpl
name|node
parameter_list|,
name|StringBuffer
name|currentPath
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
name|currentPath
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
name|reindex
argument_list|(
name|node
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|firstChildId
init|=
name|XMLUtil
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"no child found: expected = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
operator|+
literal|"; node = "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"wrong node id"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|long
name|p
decl_stmt|;
name|Value
name|value
decl_stmt|;
name|NodeImpl
name|child
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|child
operator|=
operator|(
name|NodeImpl
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|scanNodes
argument_list|(
name|iterator
argument_list|,
name|child
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|String
name|getNodeValue
parameter_list|(
specifier|final
name|NodeProxy
name|proxy
parameter_list|)
block|{
return|return
operator|(
name|String
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|READ_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
return|return
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|proxy
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
comment|/** 	 *  This method handles left or left-and-right truncated search terms. In 	 *  these cases it is not possible to use the cdata-index, since it contains 	 *  just the first 8 bytes of every cdata-string. 	 * 	 *@param  context   Description of the Parameter 	 *@param  docs      Description of the Parameter 	 *@param  relation  Description of the Parameter 	 *@param  expr      Description of the Parameter 	 *@return           The nodesEqualTo value 	 */
specifier|public
name|NodeSet
name|getNodesEqualTo
parameter_list|(
name|NodeSet
name|context
parameter_list|,
name|DocumentSet
name|docs
parameter_list|,
name|int
name|relation
parameter_list|,
name|String
name|expr
parameter_list|)
block|{
comment|//		long start = System.currentTimeMillis();
name|NodeSet
name|temp
decl_stmt|;
name|int
name|truncation
init|=
name|Constants
operator|.
name|TRUNC_NONE
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|expr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'%'
condition|)
block|{
name|expr
operator|=
name|expr
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|truncation
operator|=
name|Constants
operator|.
name|TRUNC_LEFT
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|expr
operator|.
name|charAt
argument_list|(
name|expr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'%'
condition|)
block|{
name|expr
operator|=
name|expr
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|expr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|truncation
operator|=
operator|(
name|truncation
operator|==
name|Constants
operator|.
name|TRUNC_LEFT
operator|)
condition|?
name|Constants
operator|.
name|TRUNC_BOTH
else|:
name|Constants
operator|.
name|TRUNC_RIGHT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isCaseSensitive
argument_list|()
condition|)
name|expr
operator|=
name|expr
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|NodeSet
name|result
init|=
name|scanSequential
argument_list|(
name|context
argument_list|,
name|docs
argument_list|,
name|relation
argument_list|,
name|truncation
argument_list|,
name|expr
argument_list|)
decl_stmt|;
comment|//		LOG.debug(
comment|//			"searching "
comment|//				+ context.getLength()
comment|//				+ " nodes took "
comment|//				+ (System.currentTimeMillis() - start)
comment|//				+ "ms.");
return|return
name|result
return|;
block|}
comment|/** 	 *  get collection object If the collection does not yet exists, it is 	 *  created automatically. 	 * 	 *@param  name                           the collection's name 	 *@param  user                           Description of the Parameter 	 *@return                                The orCreateCollection value 	 *@exception  PermissionDeniedException  Description of the Exception 	 *@author=@author 	 */
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//		final long start = System.currentTimeMillis();
name|name
operator|=
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|name
operator|=
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|name
operator|=
literal|"/db"
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Collection
name|current
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|temp
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|path
init|=
literal|"/db"
decl_stmt|;
name|Collection
name|sub
decl_stmt|;
name|current
operator|=
name|getCollection
argument_list|(
literal|"/db"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating root collection /db"
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|Collection
argument_list|(
literal|"/db"
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setPermissions
argument_list|(
literal|0777
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|user
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|temp
operator|=
name|tok
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|path
operator|=
name|path
operator|+
literal|"/"
operator|+
name|temp
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasSubcollection
argument_list|(
name|temp
argument_list|)
condition|)
name|current
operator|=
name|getCollection
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"not allowed to write to collection"
argument_list|)
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating collection "
operator|+
name|path
argument_list|)
expr_stmt|;
name|sub
operator|=
operator|new
name|Collection
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|user
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|addCollection
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|sub
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"database read-only"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|//			LOG.debug("getOrCreateCollection took " +
comment|//				(System.currentTimeMillis() - start) + "ms.");
return|return
name|current
return|;
block|}
comment|/** 	 *  Gets a range of nodes, starting with first, ending with last 	 * 	 *@param  doc    the document 	 *@param  first  node-id of the first node 	 *@param  last   node-id of the last node 	 *@return        a list of nodes 	 */
specifier|public
name|NodeList
name|getRange
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|long
name|first
parameter_list|,
specifier|final
name|long
name|last
parameter_list|)
block|{
name|NodeListImpl
name|result
init|=
operator|new
name|NodeListImpl
argument_list|(
operator|(
name|int
operator|)
operator|(
name|last
operator|-
name|first
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|first
init|;
name|gid
operator|<=
name|last
condition|;
name|gid
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|objectWith
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|Serializer
name|getSerializer
parameter_list|()
block|{
name|xmlSerializer
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|xmlSerializer
return|;
block|}
specifier|public
name|TextSearchEngine
name|getTextEngine
parameter_list|()
block|{
return|return
name|textEngine
return|;
block|}
specifier|public
name|Serializer
name|newSerializer
parameter_list|()
block|{
return|return
operator|new
name|NativeSerializer
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
name|Node
name|objectWith
parameter_list|(
specifier|final
name|Document
name|doc
parameter_list|,
specifier|final
name|long
name|gid
parameter_list|)
block|{
return|return
operator|(
name|Node
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
operator|new
name|NodeProxy
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|,
name|gid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"node "
operator|+
name|gid
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
comment|//throw new RuntimeException("node " + gid + " not found");
return|return
literal|null
return|;
block|}
name|NodeImpl
name|node
init|=
name|NodeImpl
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|doc
argument_list|)
decl_stmt|;
name|node
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|val
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|Node
name|objectWith
parameter_list|(
specifier|final
name|NodeProxy
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|getInternalAddress
argument_list|()
operator|<
literal|0
condition|)
return|return
name|objectWith
argument_list|(
name|p
operator|.
name|doc
argument_list|,
name|p
operator|.
name|gid
argument_list|)
return|;
return|return
operator|(
name|Node
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"node "
operator|+
name|p
operator|.
name|gid
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|NodeImpl
name|node
init|=
name|NodeImpl
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|,
operator|(
name|DocumentImpl
operator|)
name|p
operator|.
name|doc
argument_list|)
decl_stmt|;
name|node
operator|.
name|setGID
argument_list|(
name|p
operator|.
name|gid
argument_list|)
expr_stmt|;
name|node
operator|.
name|setOwnerDocument
argument_list|(
name|p
operator|.
name|doc
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|p
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|removeCollection
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"database is read-only"
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|name
operator|=
literal|"/db"
operator|+
name|name
expr_stmt|;
name|Collection
name|collection
init|=
name|getCollection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"collection "
operator|+
name|name
operator|+
literal|" not found!"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"not allowed to remove collection"
argument_list|)
throw|;
name|String
name|childCollection
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing sub-collections"
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childCollection
operator|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|removeCollection
argument_list|(
operator|(
name|name
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|?
literal|"/"
operator|+
name|childCollection
else|:
name|name
operator|+
literal|"/"
operator|+
name|childCollection
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// if this is not the root collection remove it completely
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|saveCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
else|else
block|{
name|Value
name|key
decl_stmt|;
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"/db"
argument_list|)
condition|)
name|collectionsDb
operator|.
name|getCollectionCache
argument_list|()
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Collection
name|parent
init|=
name|collection
operator|.
name|getParent
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|removeCollection
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|parent
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|parent
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
operator|(
operator|(
name|NativeTextEngine
operator|)
name|textEngine
operator|)
operator|.
name|removeCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing elements ..."
argument_list|)
expr_stmt|;
name|short
name|collectionId
init|=
name|collection
operator|.
name|getId
argument_list|()
decl_stmt|;
name|Value
name|ref
init|=
operator|new
name|ElementValue
argument_list|(
name|collectionId
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|lock
operator|=
name|elementsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|elementsDb
operator|.
name|removeAll
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"could not acquire lock on elements index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|elementPool
operator|.
name|clear
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removed collection ..."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing dom ..."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|NodeList
name|children
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|NodeImpl
name|node
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|children
operator|.
name|getLength
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|node
operator|=
operator|(
name|NodeImpl
operator|)
name|children
operator|.
name|item
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|Iterator
name|k
init|=
name|getDOMIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|removeNodes
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
name|domDb
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|Value
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"db error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing document"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|removeDocument
parameter_list|(
name|String
name|docName
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"database is read-only"
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
operator|!
name|docName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
name|docName
operator|=
literal|'/'
operator|+
name|docName
expr_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|getDocument
argument_list|(
name|docName
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"document "
operator|+
name|docName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"write access to collection denied; user="
operator|+
name|user
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|doc
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission to remove document denied"
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"removing document "
operator|+
name|doc
operator|.
name|getDocId
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
comment|// drop element-index
name|short
name|collectionId
init|=
name|doc
operator|.
name|getCollection
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|Value
name|ref
init|=
operator|new
name|ElementValue
argument_list|(
name|collectionId
argument_list|)
decl_stmt|;
name|IndexQuery
name|query
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|elementsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|ArrayList
name|elements
init|=
name|elementsDb
operator|.
name|findKeys
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"found "
operator|+
name|elements
operator|.
name|size
argument_list|()
operator|+
literal|" elements."
argument_list|)
expr_stmt|;
name|Value
name|key
decl_stmt|;
name|Value
name|value
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|byte
index|[]
name|ndata
decl_stmt|;
name|VariableByteInputStream
name|is
decl_stmt|;
name|VariableByteOutputStream
name|os
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|docId
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|long
name|address
decl_stmt|;
name|boolean
name|changed
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
operator|(
name|Value
operator|)
name|elements
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|value
operator|=
name|elementsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|data
operator|=
name|value
operator|.
name|getData
argument_list|()
expr_stmt|;
name|is
operator|=
operator|new
name|VariableByteInputStream
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|os
operator|=
operator|new
name|VariableByteOutputStream
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|false
expr_stmt|;
try|try
block|{
while|while
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|docId
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|len
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|docId
operator|!=
name|doc
operator|.
name|getDocId
argument_list|()
condition|)
block|{
comment|// copy data to new buffer
name|os
operator|.
name|writeInt
argument_list|(
name|docId
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|delta
operator|=
name|is
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|address
operator|=
name|StorageAddress
operator|.
name|read
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeLong
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|StorageAddress
operator|.
name|write
argument_list|(
name|address
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|changed
operator|=
literal|true
expr_stmt|;
comment|// skip
name|is
operator|.
name|skip
argument_list|(
name|len
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"eof: "
operator|+
name|is
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
comment|//ndata = os.toByteArray();
if|if
condition|(
name|elementsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|os
operator|.
name|data
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not save element"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock on elements"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|elementPool
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|(
operator|(
name|NativeTextEngine
operator|)
name|textEngine
operator|)
operator|.
name|removeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing dom"
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|NodeList
name|children
init|=
name|doc
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|domDb
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|NodeImpl
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
operator|(
name|NodeImpl
operator|)
name|children
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Iterator
name|j
init|=
name|getDOMIterator
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|removeNodes
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing dom index"
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|IndexQuery
name|idx
init|=
operator|new
name|IndexQuery
argument_list|(
name|IndexQuery
operator|.
name|TRUNC_RIGHT
argument_list|,
name|ref
argument_list|)
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while removing doc"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"removed document."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|bte
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeNodes
parameter_list|(
name|Iterator
name|domIterator
parameter_list|)
block|{
specifier|final
name|Value
name|next
init|=
operator|(
name|Value
operator|)
name|domIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|null
condition|)
return|return;
specifier|final
name|byte
index|[]
name|data
init|=
name|next
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|final
name|short
name|type
init|=
name|Signatures
operator|.
name|getType
argument_list|(
name|data
index|[
name|next
operator|.
name|start
argument_list|()
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|int
name|children
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|next
operator|.
name|start
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|domIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
name|removeNodes
argument_list|(
name|domIterator
argument_list|)
expr_stmt|;
break|break;
default|default :
name|domIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeNode
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|String
name|currentPath
parameter_list|)
block|{
specifier|final
name|IndexPaths
name|idx
init|=
operator|(
name|IndexPaths
operator|)
name|idxPathMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|getDoctype
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
specifier|final
name|long
name|address
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|>
operator|-
literal|1
condition|)
name|domDb
operator|.
name|remove
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|domDb
operator|.
name|remove
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
specifier|final
name|NodeProxy
name|tempProxy
init|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
comment|// save element by calling ElementIndex
name|qname
operator|=
name|node
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ELEMENT
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|getIncludeAttributes
argument_list|()
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|idx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
comment|// if (idx == null || idx.match(currentPath))
name|textEngine
operator|.
name|storeText
argument_list|(
name|idx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|public
name|void
name|addDocument
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|DocumentImpl
name|doc
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
name|Value
name|name
decl_stmt|;
try|try
block|{
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|uee
argument_list|)
expr_stmt|;
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|storeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|doc
operator|.
name|write
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|long
name|address
init|=
name|collectionsDb
operator|.
name|append
argument_list|(
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not store collection data for "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"/db"
argument_list|)
condition|)
block|{
name|Collection
name|parent
init|=
name|collection
operator|.
name|getParent
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|parent
operator|.
name|update
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to lock collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|saveCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"database is read-only"
argument_list|)
throw|;
try|try
block|{
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|<
literal|0
condition|)
name|collection
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|Value
name|name
decl_stmt|;
try|try
block|{
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|uee
argument_list|)
expr_stmt|;
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|collection
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
specifier|final
name|long
name|addr
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not store collection data for "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"/db"
argument_list|)
condition|)
block|{
name|Collection
name|parent
init|=
name|collection
operator|.
name|getParent
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|parent
operator|.
name|update
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|collectionsDb
operator|.
name|getCollectionCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock for collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"database is read-only"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  Do a sequential search through the DOM-file. 	 * 	 *@param  context     Description of the Parameter 	 *@param  doc         Description of the Parameter 	 *@param  relation    Description of the Parameter 	 *@param  truncation  Description of the Parameter 	 *@param  expr        Description of the Parameter 	 *@return             Description of the Return Value 	 */
specifier|protected
name|NodeSet
name|scanSequential
parameter_list|(
name|NodeSet
name|context
parameter_list|,
name|DocumentSet
name|doc
parameter_list|,
name|int
name|relation
parameter_list|,
name|int
name|truncation
parameter_list|,
name|String
name|expr
parameter_list|)
block|{
name|ArraySet
name|resultNodeSet
init|=
operator|new
name|ArraySet
argument_list|(
name|context
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|NodeProxy
name|p
decl_stmt|;
name|String
name|content
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|128
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|long
name|filePos
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|NodeRef
name|nodeRef
decl_stmt|;
name|String
name|cmp
decl_stmt|;
name|Iterator
name|domIterator
init|=
literal|null
decl_stmt|;
name|Pattern
name|regexp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|relation
operator|==
name|Constants
operator|.
name|REGEXP
condition|)
try|try
block|{
name|regexp
operator|=
name|compiler
operator|.
name|compile
argument_list|(
name|expr
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|Perl5Compiler
operator|.
name|CASE_INSENSITIVE_MASK
argument_list|)
expr_stmt|;
name|truncation
operator|=
name|Constants
operator|.
name|REGEXP
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedPatternException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|context
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|NodeProxy
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
try|try
block|{
name|domDb
operator|.
name|setOwnerObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|content
operator|=
name|domDb
operator|.
name|getNodeValue
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire read lock on dom.dbx"
argument_list|)
expr_stmt|;
continue|continue;
block|}
finally|finally
block|{
name|domDb
operator|.
name|getLock
argument_list|()
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isCaseSensitive
argument_list|()
condition|)
name|cmp
operator|=
name|content
expr_stmt|;
else|else
block|{
name|cmp
operator|=
name|content
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("context = " + p.gid + "; context-length = " +
comment|//	(p.getContext() == null ? -1 : p.getContext().getSize()));
switch|switch
condition|(
name|truncation
condition|)
block|{
case|case
name|Constants
operator|.
name|TRUNC_LEFT
case|:
if|if
condition|(
name|cmp
operator|.
name|endsWith
argument_list|(
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|cmp
operator|.
name|startsWith
argument_list|(
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_BOTH
case|:
if|if
condition|(
operator|-
literal|1
operator|<
name|cmp
operator|.
name|indexOf
argument_list|(
name|expr
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TRUNC_NONE
case|:
if|if
condition|(
name|compare
argument_list|(
name|cmp
argument_list|,
name|expr
argument_list|,
name|relation
argument_list|)
condition|)
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|REGEXP
case|:
if|if
condition|(
name|regexp
operator|!=
literal|null
operator|&&
name|matcher
operator|.
name|contains
argument_list|(
name|cmp
argument_list|,
name|regexp
argument_list|)
condition|)
block|{
name|resultNodeSet
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|resultNodeSet
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|super
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
name|textEngine
operator|.
name|close
argument_list|()
expr_stmt|;
name|domDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|elementsDb
operator|.
name|close
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 *  Store a node into the database. This method is called by the parser to 	 *  write a node to the storage backend. 	 * 	 *@param  node         the node to be stored 	 *@param  currentPath  path expression which points to this node's 	 *      element-parent or to itself if it is an element (currently used by 	 *      the Broker to determine if a node's content should be 	 *      fulltext-indexed). 	 */
specifier|public
name|void
name|store
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|,
name|CharSequence
name|currentPath
parameter_list|)
block|{
comment|// first, check available memory
if|if
condition|(
name|nodesCount
operator|>
name|MEM_LIMIT_CHECK
condition|)
block|{
specifier|final
name|int
name|percent
init|=
operator|(
name|int
operator|)
operator|(
name|run
operator|.
name|freeMemory
argument_list|()
operator|/
operator|(
name|run
operator|.
name|totalMemory
argument_list|()
operator|/
literal|100
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|percent
operator|<
name|memMinFree
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total memory: "
operator|+
name|run
operator|.
name|totalMemory
argument_list|()
operator|+
literal|"; free: "
operator|+
name|run
operator|.
name|freeMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|IndexPaths
name|idx
init|=
operator|(
name|IndexPaths
operator|)
name|idxPathMap
operator|.
name|get
argument_list|(
name|doc
operator|.
name|getDoctype
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|gid
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
if|if
condition|(
name|gid
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal node: "
operator|+
name|gid
operator|+
literal|"; "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|short
name|nodeType
init|=
name|node
operator|.
name|getNodeType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|nodeName
init|=
name|node
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localName
init|=
name|node
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
specifier|final
name|int
name|depth
init|=
name|idx
operator|==
literal|null
condition|?
name|defaultIndexDepth
else|:
name|idx
operator|.
name|getIndexDepth
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|long
name|address
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeType
operator|==
name|Node
operator|.
name|TEXT_NODE
operator|||
name|nodeType
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|||
name|doc
operator|.
name|getTreeLevel
argument_list|(
name|gid
argument_list|)
operator|>
name|depth
condition|)
name|address
operator|=
name|domDb
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|address
operator|=
name|domDb
operator|.
name|put
argument_list|(
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|gid
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|<
literal|0
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"address is missing"
argument_list|)
expr_stmt|;
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
operator|++
name|nodesCount
expr_stmt|;
name|NodeProxy
name|tempProxy
init|=
literal|null
decl_stmt|;
name|QName
name|qname
decl_stmt|;
switch|switch
condition|(
name|nodeType
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
name|tempProxy
operator|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
name|tempProxy
operator|.
name|setHasIndex
argument_list|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
argument_list|)
expr_stmt|;
comment|// save element by calling ElementIndex
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|node
operator|.
name|getQName
argument_list|()
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
name|tempProxy
operator|=
operator|new
name|NodeProxy
argument_list|(
name|doc
argument_list|,
name|gid
argument_list|,
name|node
operator|.
name|getInternalAddress
argument_list|()
argument_list|)
expr_stmt|;
name|tempProxy
operator|.
name|setHasIndex
argument_list|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
argument_list|)
expr_stmt|;
name|qname
operator|=
operator|new
name|QName
argument_list|(
name|node
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|node
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|node
operator|.
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
comment|// check if attribute value should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|idx
operator|==
literal|null
operator|||
operator|(
name|idx
operator|.
name|getIncludeAttributes
argument_list|()
operator|&&
name|idx
operator|.
name|match
argument_list|(
name|currentPath
operator|+
literal|"/@"
operator|+
name|nodeName
argument_list|)
operator|)
condition|)
name|textEngine
operator|.
name|storeAttribute
argument_list|(
name|idx
argument_list|,
operator|(
name|AttrImpl
operator|)
name|node
argument_list|)
expr_stmt|;
comment|// if the attribute has type ID, store the ID-value
comment|// to the element index as well
if|if
condition|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getType
argument_list|()
operator|==
name|AttrImpl
operator|.
name|ID
condition|)
block|{
name|qname
operator|=
operator|new
name|QName
argument_list|(
operator|(
operator|(
name|AttrImpl
operator|)
name|node
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//LOG.debug("found ID: " + qname.getLocalName());
name|qname
operator|.
name|setNameType
argument_list|(
name|ElementValue
operator|.
name|ATTRIBUTE_ID
argument_list|)
expr_stmt|;
name|elementIndex
operator|.
name|addRow
argument_list|(
name|qname
argument_list|,
name|tempProxy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
comment|// check if this textual content should be fulltext-indexed
comment|// by calling IndexPaths.match(path)
if|if
condition|(
name|idx
operator|==
literal|null
operator|||
name|idx
operator|.
name|match
argument_list|(
name|currentPath
argument_list|)
condition|)
name|textEngine
operator|.
name|storeText
argument_list|(
name|idx
argument_list|,
operator|(
name|TextImpl
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|public
name|void
name|storeDocument
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|doc
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|doc
operator|.
name|getAddress
argument_list|()
operator|>
operator|-
literal|1
condition|)
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|setAddress
argument_list|(
name|domDb
operator|.
name|add
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|storeBinaryResource
parameter_list|(
specifier|final
name|BLOBDocument
name|blob
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|blob
operator|.
name|getPage
argument_list|()
operator|>
operator|-
literal|1
condition|)
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blob
operator|.
name|setPage
argument_list|(
name|domDb
operator|.
name|addBinary
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|byte
index|[]
name|getBinaryResourceData
parameter_list|(
specifier|final
name|BLOBDocument
name|blob
parameter_list|)
block|{
name|byte
index|[]
name|data
init|=
operator|(
name|byte
index|[]
operator|)
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
return|return
name|domDb
operator|.
name|getBinary
argument_list|(
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
decl_stmt|;
return|return
name|data
return|;
block|}
specifier|public
name|void
name|removeBinaryResource
parameter_list|(
specifier|final
name|BLOBDocument
name|blob
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"database is read-only"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|blob
operator|.
name|getCollection
argument_list|()
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"write access to collection denied; user="
operator|+
name|user
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|blob
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|user
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"permission to remove document denied"
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"removing binary resource "
operator|+
name|blob
operator|.
name|getDocId
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|domDb
operator|.
name|remove
argument_list|(
name|blob
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|domDb
operator|.
name|removeOverflowValue
argument_list|(
name|blob
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|readDocumentMetadata
parameter_list|(
specifier|final
name|DocumentImpl
name|doc
parameter_list|)
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
specifier|final
name|Value
name|val
init|=
name|domDb
operator|.
name|get
argument_list|(
name|doc
operator|.
name|getAddress
argument_list|()
argument_list|)
decl_stmt|;
name|doc
operator|.
name|deserialize
argument_list|(
name|val
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|sync
parameter_list|()
block|{
comment|// uncomment this to get statistics on page buffer usage
name|elementsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|domDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
try|try
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
try|try
block|{
name|domDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error while flushing dom.dbx"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|elementIndex
operator|.
name|sync
argument_list|()
expr_stmt|;
name|textEngine
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|dbe
parameter_list|)
block|{
name|dbe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|dbe
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|domDb
operator|.
name|closeDocument
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
specifier|final
name|NodeImpl
name|node
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
specifier|final
name|long
name|internalAddress
init|=
name|node
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
specifier|final
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<
name|internalAddress
condition|)
name|domDb
operator|.
name|update
argument_list|(
name|ref
argument_list|,
name|internalAddress
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|domDb
operator|.
name|update
argument_list|(
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
name|ByteArrayPool
operator|.
name|releaseByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while storing "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; gid = "
operator|+
name|node
operator|.
name|getGID
argument_list|()
operator|+
literal|"; address = "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|insertAfter
parameter_list|(
specifier|final
name|NodeImpl
name|previous
parameter_list|,
specifier|final
name|NodeImpl
name|node
parameter_list|)
block|{
specifier|final
name|byte
name|data
index|[]
init|=
name|node
operator|.
name|serialize
argument_list|()
decl_stmt|;
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|previous
operator|.
name|getOwnerDocument
argument_list|()
decl_stmt|;
operator|new
name|DOMTransaction
argument_list|(
name|this
argument_list|,
name|domDb
argument_list|)
block|{
specifier|public
name|Object
name|start
parameter_list|()
block|{
name|long
name|address
init|=
name|previous
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|>
operator|-
literal|1
condition|)
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|doc
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|NodeRef
name|ref
init|=
operator|new
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|previous
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
name|address
operator|=
name|domDb
operator|.
name|insertAfter
argument_list|(
name|doc
argument_list|,
name|ref
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setInternalAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NodeRef
extends|extends
name|Value
block|{
specifier|public
name|NodeRef
parameter_list|()
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|gid
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
literal|12
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|NodeRef
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
literal|4
index|]
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|getDocId
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|long
name|getGid
parameter_list|()
block|{
return|return
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
return|;
block|}
name|void
name|set
parameter_list|(
name|int
name|docId
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|docId
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|gid
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
literal|12
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

