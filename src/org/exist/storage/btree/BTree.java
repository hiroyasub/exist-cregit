begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
package|;
end_package

begin_comment
comment|/*  *  dbXML License, Version 1.0  *  *  Copyright (c) 1999-2001 The dbXML Group, L.L.C.  *  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.  *  *  2. Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in  *  the documentation and/or other materials provided with the  *  distribution.  *  *  3. The end-user documentation included with the redistribution,  *  if any, must include the following acknowledgment:  *  "This product includes software developed by  *  The dbXML Group (http://www.dbxml.com/)."  *  Alternately, this acknowledgment may appear in the software  *  itself, if and wherever such third-party acknowledgments normally  *  appear.  *  *  4. The names "dbXML" and "The dbXML Group" must not be used to  *  endorse or promote products derived from this software without  *  prior written permission. For written permission, please contact  *  info@dbxml.com.  *  *  5. Products derived from this software may not be called "dbXML",  *  nor may "dbXML" appear in their name, without prior written  *  permission of The dbXML Group.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *  DISCLAIMED.  IN NO EVENT SHALL THE DBXML GROUP OR ITS CONTRIBUTORS  *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BufferStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|CacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cacheable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|LRDCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|log
operator|.
name|LogEntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|log
operator|.
name|LogException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|log
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|log
operator|.
name|Loggable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_comment
comment|/**  *  BTree represents a Variable Magnitude Simple-Prefix B+Tree File. A BTree is  *  a bit flexible in that it can be used for set or map-based indexing.  *  HashFiler uses the BTree as a set for producing RecordSet entries. The  *  Indexers use BTree as a map for indexing entity and attribute values in  *  Documents.<br>  *<br>  *  For those who don't know how a Simple-Prefix B+Tree works, the primary  *  distinction is that instead of promoting actual keys to branch pages, when  *  leaves are split, a shortest-possible separator is generated at the pivot.  *  That separator is what is promoted to the parent branch (and continuing up  *  the list). As a result, actual keys and pointers can only be found at the  *  leaf level. This also affords the index the ability to ignore costly merging  *  and redistribution of pages when deletions occur. Deletions only affect leaf  *  pages in this implementation, and so it is entirely possible for a leaf page  *  to be completely empty after all of its keys have been removed.<br>  *<br>  *  Also, the Variable Magnitude attribute means that the btree attempts to  *  store as many values and pointers on one page as is possible.  */
end_comment

begin_class
specifier|public
class|class
name|BTree
extends|extends
name|Paged
block|{
comment|/** Used as return value, if a value was not found */
specifier|public
specifier|final
specifier|static
name|long
name|KEY_NOT_FOUND
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Type of BTreeNode/Page */
specifier|protected
specifier|final
specifier|static
name|byte
name|LEAF
init|=
literal|1
decl_stmt|;
comment|/** Type of BTreeNode/Page */
specifier|protected
specifier|final
specifier|static
name|byte
name|BRANCH
init|=
literal|2
decl_stmt|;
comment|/** Log entry type for an insert value operation */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_INSERT_VALUE
init|=
literal|0x20
decl_stmt|;
comment|/** Log entry type for creation of a new btree node */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_CREATE_BNODE
init|=
literal|0x21
decl_stmt|;
comment|/** Log entry type for a page update resulting from a page split */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_PAGE
init|=
literal|0x22
decl_stmt|;
comment|/** Log entry type for a parent page change resulting from a page split */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_SET_PARENT
init|=
literal|0x23
decl_stmt|;
comment|/** Log entry type for a value update */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_VALUE
init|=
literal|0x24
decl_stmt|;
comment|/** Log entry type for removing a value */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_VALUE
init|=
literal|0x25
decl_stmt|;
static|static
block|{
comment|// register the log entry types used for the btree
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_INSERT_VALUE
argument_list|,
name|InsertValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_VALUE
argument_list|,
name|UpdateValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_VALUE
argument_list|,
name|RemoveValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_CREATE_BNODE
argument_list|,
name|CreateBTNodeLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_PAGE
argument_list|,
name|UpdatePageLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_SET_PARENT
argument_list|,
name|SetParentLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|CacheManager
name|cacheManager
decl_stmt|;
comment|/** Cache of BTreeNode(s) */
specifier|protected
name|Cache
name|cache
decl_stmt|;
specifier|protected
name|int
name|growthThreshold
decl_stmt|;
comment|/** Size of BTreeNode cache */
specifier|protected
name|int
name|buffers
decl_stmt|;
comment|/** Fileheader of a BTree file */
specifier|private
name|BTreeFileHeader
name|fileHeader
decl_stmt|;
comment|/** The LogManager for writing the transaction log */
specifier|protected
name|LogManager
name|logManager
decl_stmt|;
specifier|protected
name|byte
name|fileId
decl_stmt|;
specifier|protected
name|boolean
name|isTransactional
decl_stmt|;
specifier|protected
name|BTree
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|byte
name|fileId
parameter_list|,
name|CacheManager
name|cacheManager
parameter_list|,
name|int
name|growthThreshold
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|cacheManager
operator|=
name|cacheManager
expr_stmt|;
name|this
operator|.
name|buffers
operator|=
name|cacheManager
operator|.
name|getDefaultInitialSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|growthThreshold
operator|=
name|growthThreshold
expr_stmt|;
name|this
operator|.
name|fileId
operator|=
name|fileId
expr_stmt|;
name|fileHeader
operator|=
operator|(
name|BTreeFileHeader
operator|)
name|getFileHeader
argument_list|()
expr_stmt|;
name|fileHeader
operator|.
name|setPageCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|setTotalCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|isTransactional
operator|=
name|pool
operator|.
name|isTransactional
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
condition|)
name|logManager
operator|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
operator|.
name|getLogManager
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BTree
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|byte
name|fileId
parameter_list|,
name|CacheManager
name|cacheManager
parameter_list|,
name|File
name|file
parameter_list|,
name|int
name|growthThreshold
parameter_list|)
block|{
name|this
argument_list|(
name|pool
argument_list|,
name|fileId
argument_list|,
name|cacheManager
argument_list|,
name|growthThreshold
argument_list|)
expr_stmt|;
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|open
parameter_list|(
name|short
name|expectedVersion
parameter_list|)
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|open
argument_list|(
name|expectedVersion
argument_list|)
condition|)
block|{
name|initCache
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
specifier|protected
name|boolean
name|create
parameter_list|(
name|short
name|fixedKeyLen
parameter_list|)
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|create
argument_list|()
condition|)
block|{
name|initCache
argument_list|()
expr_stmt|;
try|try
block|{
name|createRootNode
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can not create database file "
operator|+
name|getFile
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fileHeader
operator|.
name|setFixedKeyLen
argument_list|(
name|fixedKeyLen
argument_list|)
expr_stmt|;
try|try
block|{
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DBException
argument_list|(
literal|"Error while writing file header: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|initCache
parameter_list|()
block|{
name|cache
operator|=
operator|new
name|LRDCache
argument_list|(
name|cacheManager
operator|.
name|getDefaultInitialSize
argument_list|()
argument_list|,
literal|1.5
argument_list|,
name|growthThreshold
argument_list|)
expr_stmt|;
name|cache
operator|.
name|setFileName
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|cacheManager
operator|.
name|registerCache
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
comment|/** 	 *  addValue adds a Value to the BTree and associates a pointer with it. The 	 *  pointer can be used for referencing any type of data, it just so happens 	 *  that dbXML uses it for referencing pages of associated data in the BTree 	 *  file or other files. 	 * 	 *@param  value               The Value to add 	 *@param  pointer             The pointer to associate with it 	 *@return                     The previous value for the pointer (or -1) 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|long
name|addValue
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|addValue
argument_list|(
literal|null
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
return|;
block|}
specifier|public
name|long
name|addValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|getRootNode
argument_list|()
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
return|;
block|}
comment|/** 	 *  removeValue removes a Value from the BTree and returns the associated 	 *  pointer for it. 	 * 	 *@param  value               The Value to remove 	 *@return                     The pointer that was associated with it 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|long
name|removeValue
parameter_list|(
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|removeValue
argument_list|(
literal|null
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|public
name|long
name|removeValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|getRootNode
argument_list|()
operator|.
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *  findValue finds a Value in the BTree and returns the associated pointer 	 *  for it. 	 * 	 *@param  value               The Value to find 	 *@return                     The pointer that was associated with it 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|long
name|findValue
parameter_list|(
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|getRootNode
argument_list|()
operator|.
name|findValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/** 	 *  query performs a query against the BTree and performs callback 	 *  operations to report the search results. 	 * 	 *@param  query               The IndexQuery to use (or null for everything) 	 *@param  callback            The callback instance 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
block|{
name|Value
name|val1
init|=
name|query
operator|.
name|getValue
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
name|data1
index|[]
init|=
name|val1
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
name|data2
index|[]
init|=
operator|new
name|byte
index|[
name|data1
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data1
argument_list|,
literal|0
argument_list|,
name|data2
argument_list|,
literal|0
argument_list|,
name|data1
operator|.
name|length
argument_list|)
expr_stmt|;
name|data2
index|[
name|data2
operator|.
name|length
operator|-
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|query
operator|.
name|getOperator
argument_list|()
argument_list|,
name|val1
argument_list|,
operator|new
name|Value
argument_list|(
name|data2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getRootNode
argument_list|()
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Executes a query against the BTree and performs callback      *  operations to report the search results. This method takes an      *  additional prefix value. Only BTree keys starting with the specified      *  prefix are considered. Search through the tree is thus restricted to      *  a given key range.      *      *@param  query The IndexQuery to use (or null for everything)      *@param prefix a prefix value      *@param  callback The callback instance      *@exception  IOException      *@exception  BTreeException      */
specifier|public
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|Value
name|prefix
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|getRootNode
argument_list|()
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|remove
argument_list|(
literal|null
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
block|{
name|Value
name|val1
init|=
name|query
operator|.
name|getValue
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
name|data1
index|[]
init|=
name|val1
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
name|data2
index|[]
init|=
operator|new
name|byte
index|[
name|data1
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data1
argument_list|,
literal|0
argument_list|,
name|data2
argument_list|,
literal|0
argument_list|,
name|data1
operator|.
name|length
argument_list|)
expr_stmt|;
name|data2
index|[
name|data2
operator|.
name|length
operator|-
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|query
operator|.
name|getOperator
argument_list|()
argument_list|,
name|val1
argument_list|,
operator|new
name|Value
argument_list|(
name|data2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getRootNode
argument_list|()
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
specifier|private
name|BTreeNode
name|getBTreeNode
parameter_list|(
name|long
name|page
parameter_list|,
name|BTreeNode
name|parent
parameter_list|)
block|{
try|try
block|{
name|BTreeNode
name|node
init|=
operator|(
name|BTreeNode
operator|)
name|cache
operator|.
name|get
argument_list|(
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|Page
name|p
init|=
name|getPage
argument_list|(
name|page
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|node
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|int
name|increment
init|=
name|node
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|,
name|increment
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get btree node on page "
operator|+
name|page
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|BTreeNode
name|createBTreeNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|byte
name|status
parameter_list|,
name|BTreeNode
name|parent
parameter_list|)
block|{
try|try
block|{
name|Page
name|p
init|=
name|getFreePage
argument_list|()
decl_stmt|;
name|BTreeNode
name|node
init|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreateBTNodeLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|status
argument_list|,
name|p
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|parent
operator|!=
literal|null
condition|?
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
else|:
operator|-
literal|1
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|ph
operator|.
name|setStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|node
operator|.
name|setValues
argument_list|(
operator|new
name|Value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
operator|new
name|long
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|node
operator|.
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|node
operator|.
name|write
argument_list|()
expr_stmt|;
comment|//cache.add(node);
return|return
name|node
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to create a btree node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|protected
name|void
name|setRootNode
parameter_list|(
name|BTreeNode
name|rootNode
parameter_list|)
throws|throws
name|IOException
block|{
name|fileHeader
operator|.
name|setRootPage
argument_list|(
name|rootNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rootNode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|long
name|createRootNode
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
block|{
name|BTreeNode
name|root
init|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|LEAF
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|setRootNode
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
name|root
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
specifier|protected
name|BTreeNode
name|getRootNode
parameter_list|()
block|{
try|try
block|{
name|BTreeNode
name|node
init|=
operator|(
name|BTreeNode
operator|)
name|cache
operator|.
name|get
argument_list|(
name|fileHeader
operator|.
name|getRootPage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|Page
name|p
init|=
name|getPage
argument_list|(
name|fileHeader
operator|.
name|getRootPage
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|node
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get root btree node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|dump
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|BTreeNode
name|root
init|=
name|getRootNode
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ROOT = "
operator|+
name|root
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|.
name|dump
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#drop()      */
specifier|public
name|boolean
name|drop
parameter_list|()
throws|throws
name|DBException
block|{
return|return
name|getFile
argument_list|()
operator|.
name|delete
argument_list|()
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#flush()      */
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|DBException
block|{
name|cache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#close()      */
specifier|public
name|boolean
name|close
parameter_list|()
throws|throws
name|DBException
block|{
name|flush
argument_list|()
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|void
name|dumpValue
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
operator|new
name|String
argument_list|(
name|value
operator|.
name|getData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* --------------------------------------------------------------------------------- 	 * Methods used by recovery and transaction management 	 * --------------------------------------------------------------------------------- */
specifier|private
name|void
name|writeToLog
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|BTreeNode
name|node
parameter_list|)
block|{
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
name|node
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|boolean
name|requiresRedo
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|Page
name|page
parameter_list|)
block|{
return|return
name|loggable
operator|.
name|getLsn
argument_list|()
operator|>
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
return|;
block|}
specifier|protected
name|void
name|redoCreateBTNode
parameter_list|(
name|CreateBTNodeLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|parent
init|=
literal|null
decl_stmt|;
name|BTreeNode
name|node
init|=
operator|(
name|BTreeNode
operator|)
name|cache
operator|.
name|get
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
comment|// node is not yet loaded. Load it
try|try
block|{
name|Page
name|p
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
operator|||
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|p
argument_list|)
condition|)
block|{
comment|// node already found on disk: read it
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|node
operator|.
name|read
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// create a new node
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setStatus
argument_list|(
name|loggable
operator|.
name|status
argument_list|)
expr_stmt|;
name|node
operator|.
name|setValues
argument_list|(
operator|new
name|Value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
operator|new
name|long
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|node
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|parentPage
operator|=
name|loggable
operator|.
name|parentNum
expr_stmt|;
name|int
name|increment
init|=
name|node
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|,
name|increment
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LogException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|redoInsertValue
parameter_list|(
name|InsertValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|setValues
argument_list|(
name|insertArrayValue
argument_list|(
name|node
operator|.
name|values
argument_list|,
name|loggable
operator|.
name|key
argument_list|,
name|loggable
operator|.
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|insertArrayLong
argument_list|(
name|node
operator|.
name|ptrs
argument_list|,
name|loggable
operator|.
name|pointer
argument_list|,
name|loggable
operator|.
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|adjustDataLen
argument_list|(
name|loggable
operator|.
name|key
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoInsertValue
parameter_list|(
name|InsertValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
try|try
block|{
name|removeValue
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoUpdateValue
parameter_list|(
name|UpdateValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|ptrs
index|[
name|loggable
operator|.
name|idx
index|]
operator|=
name|loggable
operator|.
name|pointer
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoUpdateValue
parameter_list|(
name|UpdateValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
try|try
block|{
name|addValue
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|key
argument_list|,
name|loggable
operator|.
name|oldPointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoRemoveValue
parameter_list|(
name|RemoveValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|>
operator|-
literal|1
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
comment|//            StringWriter out = new StringWriter();
comment|//            out.write("Remove: " + loggable.idx + "; ");
comment|//            out.write("value: ");
comment|//            try {
comment|//                dumpValue(out, loggable.oldValue);
comment|//                out.write("\n");
comment|//                node.dump(out);
comment|//            } catch (BTreeException e) {
comment|//                // TODO Auto-generated catch block
comment|//                e.printStackTrace();
comment|//            } catch (IOException e) {
comment|//                // TODO Auto-generated catch block
comment|//                e.printStackTrace();
comment|//            }
comment|//            LOG.debug(out);
name|node
operator|.
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|node
operator|.
name|values
argument_list|,
name|loggable
operator|.
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|node
operator|.
name|ptrs
argument_list|,
name|loggable
operator|.
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemoveValue
parameter_list|(
name|RemoveValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
try|try
block|{
name|addValue
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|oldValue
argument_list|,
name|loggable
operator|.
name|oldPointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoUpdatePage
parameter_list|(
name|UpdatePageLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|setValues
argument_list|(
name|loggable
operator|.
name|values
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
name|loggable
operator|.
name|pointers
argument_list|)
expr_stmt|;
name|node
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoSetParent
parameter_list|(
name|SetParentLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|ph
operator|.
name|parentPage
operator|=
name|loggable
operator|.
name|parentNum
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|protected
specifier|final
class|class
name|BTreeNode
implements|implements
name|Cacheable
block|{
specifier|private
name|Page
name|page
decl_stmt|;
specifier|private
name|BTreePageHeader
name|ph
decl_stmt|;
specifier|private
name|Value
index|[]
name|values
init|=
literal|null
decl_stmt|;
specifier|private
name|long
index|[]
name|ptrs
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|refCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|timestamp
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|saved
init|=
literal|true
decl_stmt|;
specifier|private
name|int
name|currentDataLen
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|BTreeNode
parameter_list|(
name|Page
name|page
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|ph
operator|=
operator|(
name|BTreePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setParent
parameter_list|(
name|BTreeNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|ph
operator|.
name|parentPage
operator|=
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
expr_stmt|;
else|else
name|ph
operator|.
name|parentPage
operator|=
operator|-
literal|1
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|BTreeNode
name|getParent
parameter_list|()
block|{
if|if
condition|(
operator|-
literal|1
operator|<
name|ph
operator|.
name|parentPage
condition|)
block|{
return|return
name|getBTreeNode
argument_list|(
name|ph
operator|.
name|parentPage
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#getReferenceCount()          */
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#incReferenceCount()          */
specifier|public
name|int
name|incReferenceCount
parameter_list|()
block|{
if|if
condition|(
name|refCount
operator|<
name|Cacheable
operator|.
name|MAX_REF
condition|)
operator|++
name|refCount
expr_stmt|;
return|return
name|refCount
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#setReferenceCount(int)          */
specifier|public
name|void
name|setReferenceCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|refCount
operator|=
name|count
expr_stmt|;
block|}
comment|/** 		 * @see org.exist.storage.cache.Cacheable#setTimestamp(int) 		 */
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|int
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#allowUnload()          */
specifier|public
name|boolean
name|allowUnload
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** 		 * @see org.exist.storage.cache.Cacheable#getTimestamp() 		 */
specifier|public
name|int
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#sync()          */
specifier|public
name|boolean
name|sync
parameter_list|()
block|{
if|if
condition|(
name|isDirty
argument_list|()
condition|)
try|try
block|{
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
condition|)
name|logManager
operator|.
name|flushToLog
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IO error while writing page: "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#getKey()          */
specifier|public
name|long
name|getKey
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#decReferenceCount()          */
specifier|public
name|int
name|decReferenceCount
parameter_list|()
block|{
return|return
name|refCount
operator|>
literal|0
condition|?
operator|--
name|refCount
else|:
literal|0
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#isDirty()          */
specifier|public
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
operator|!
name|saved
return|;
block|}
specifier|public
name|int
name|getStatus
parameter_list|()
block|{
return|return
name|ph
operator|.
name|getStatus
argument_list|()
return|;
block|}
specifier|public
name|void
name|setValues
parameter_list|(
name|Value
index|[]
name|values
parameter_list|)
block|{
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
name|this
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
name|ph
operator|.
name|setValueCount
argument_list|(
operator|(
name|short
operator|)
name|values
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Value
index|[]
name|getValues
parameter_list|()
block|{
return|return
name|values
return|;
block|}
specifier|public
name|void
name|setPointers
parameter_list|(
name|long
index|[]
name|ptrs
parameter_list|)
block|{
name|this
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|ptrs
operator|=
name|ptrs
expr_stmt|;
block|}
comment|/** 		 * Returns the raw data size (in bytes) required by this node. 		 *  		 * @return 		 */
specifier|private
name|int
name|getDataLen
parameter_list|()
block|{
return|return
name|currentDataLen
operator|<
literal|0
condition|?
name|recalculateDataLen
argument_list|()
else|:
name|currentDataLen
return|;
block|}
comment|/** 		 * Recalculates the raw data size (in bytes) required by this node. 		 *  		 * @return 		 */
specifier|private
name|int
name|recalculateDataLen
parameter_list|()
block|{
name|currentDataLen
operator|=
name|ptrs
operator|==
literal|null
condition|?
literal|0
else|:
name|ptrs
operator|.
name|length
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
operator|<
literal|0
condition|)
name|currentDataLen
operator|+=
literal|2
operator|*
name|values
operator|.
name|length
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|currentDataLen
operator|+=
name|values
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
expr_stmt|;
return|return
name|currentDataLen
return|;
block|}
comment|/** 		 * Add the raw data size required to store the value to the internal 		 * data size of this node. 		 *   		 * @param value 		 */
specifier|private
name|void
name|adjustDataLen
parameter_list|(
name|Value
name|value
parameter_list|)
block|{
if|if
condition|(
name|currentDataLen
operator|<
literal|0
condition|)
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|currentDataLen
operator|+=
name|value
operator|.
name|getLength
argument_list|()
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
operator|<
literal|0
condition|)
name|currentDataLen
operator|+=
literal|2
expr_stmt|;
block|}
specifier|private
name|boolean
name|mustSplit
parameter_list|()
block|{
return|return
name|getDataLen
argument_list|()
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
return|;
block|}
specifier|public
name|long
index|[]
name|getPointers
parameter_list|()
block|{
return|return
name|ptrs
return|;
block|}
specifier|public
name|void
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
name|values
operator|=
operator|new
name|Value
index|[
name|ph
operator|.
name|getValueCount
argument_list|()
index|]
expr_stmt|;
name|short
name|keyLen
init|=
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
decl_stmt|;
name|short
name|valSize
init|=
name|keyLen
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keyLen
operator|<
literal|0
condition|)
block|{
name|valSize
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|values
index|[
name|i
index|]
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|valSize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valSize
expr_stmt|;
block|}
comment|//	Read in the pointers
specifier|final
name|int
name|ptrCount
init|=
name|ph
operator|.
name|getPointerCount
argument_list|()
decl_stmt|;
name|ptrs
operator|=
operator|new
name|long
index|[
name|ptrCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrCount
condition|;
name|i
operator|++
control|)
block|{
name|ptrs
index|[
name|i
index|]
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|write
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
specifier|final
name|int
name|keyLen
init|=
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keyLen
operator|<
literal|0
condition|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
name|values
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
argument_list|,
name|temp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|data
operator|=
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|data
operator|.
name|length
operator|>
name|temp
operator|.
name|length
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"calculated: "
operator|+
name|getDataLen
argument_list|()
operator|+
literal|"; required: "
operator|+
operator|(
name|p
operator|+
name|data
operator|.
name|length
operator|)
argument_list|)
throw|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
name|p
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|data
operator|.
name|length
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|ptrs
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
name|writeValue
argument_list|(
name|page
argument_list|,
operator|new
name|Value
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|BTreeNode
name|getChildNode
parameter_list|(
name|int
name|idx
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
operator|&&
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ptrs
operator|.
name|length
condition|)
return|return
name|getBTreeNode
argument_list|(
name|ptrs
index|[
name|idx
index|]
argument_list|,
name|this
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|()
expr_stmt|;
name|cache
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|removeValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|int
name|idx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|getChildNode
argument_list|(
name|idx
argument_list|)
operator|.
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
return|;
case|case
name|LEAF
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
return|return
name|KEY_NOT_FOUND
return|;
else|else
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|values
index|[
name|idx
index|]
argument_list|,
name|ptrs
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|long
name|oldPtr
init|=
name|ptrs
index|[
name|idx
index|]
decl_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
return|return
name|oldPtr
return|;
block|}
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In removeValue"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|long
name|addValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|idx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|getChildNode
argument_list|(
name|idx
argument_list|)
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
return|;
case|case
name|LEAF
case|:
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
comment|// Value was found... Overwrite
name|long
name|oldPtr
init|=
name|ptrs
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|UpdateValueLoggable
name|loggable
init|=
operator|new
name|UpdateValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|,
name|oldPtr
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|ptrs
index|[
name|idx
index|]
operator|=
name|pointer
expr_stmt|;
name|setPointers
argument_list|(
name|ptrs
argument_list|)
expr_stmt|;
comment|//write();
comment|//cache.add(this);
return|return
name|oldPtr
return|;
block|}
else|else
block|{
comment|// Value was not found
name|idx
operator|=
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|InsertValueLoggable
name|loggable
init|=
operator|new
name|InsertValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|setValues
argument_list|(
name|insertArrayValue
argument_list|(
name|values
argument_list|,
name|value
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|insertArrayLong
argument_list|(
name|ptrs
argument_list|,
name|pointer
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|adjustDataLen
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|//recalculateDataLen();
if|if
condition|(
name|mustSplit
argument_list|()
condition|)
block|{
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In addValue"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|promoteValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|,
name|long
name|rightPointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|int
name|idx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
expr_stmt|;
name|Value
index|[]
name|oldVals
init|=
operator|new
name|Value
index|[
name|values
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
literal|0
argument_list|,
name|oldVals
argument_list|,
literal|0
argument_list|,
name|values
operator|.
name|length
argument_list|)
expr_stmt|;
name|long
index|[]
name|oldPtrs
init|=
operator|new
name|long
index|[
name|ptrs
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
literal|0
argument_list|,
name|oldPtrs
argument_list|,
literal|0
argument_list|,
name|ptrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|insertArrayValue
argument_list|(
name|values
argument_list|,
name|value
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|insertArrayLong
argument_list|(
name|ptrs
argument_list|,
name|rightPointer
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|values
argument_list|,
name|ptrs
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|boolean
name|split
init|=
name|recalculateDataLen
argument_list|()
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|split
condition|)
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Value
name|getSeparator
parameter_list|(
name|Value
name|value1
parameter_list|,
name|Value
name|value2
parameter_list|)
block|{
name|int
name|idx
init|=
name|value1
operator|.
name|compareTo
argument_list|(
name|value2
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|abs
argument_list|(
name|idx
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value2
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|Value
argument_list|(
name|b
argument_list|)
return|;
block|}
specifier|public
name|void
name|split
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|Value
index|[]
name|leftVals
decl_stmt|;
name|Value
index|[]
name|rightVals
decl_stmt|;
name|long
index|[]
name|leftPtrs
decl_stmt|;
name|long
index|[]
name|rightPtrs
decl_stmt|;
name|Value
name|separator
decl_stmt|;
specifier|final
name|short
name|vc
init|=
name|ph
operator|.
name|getValueCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pivot
init|=
name|vc
operator|/
literal|2
decl_stmt|;
comment|// Split the node into two nodes
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|leftVals
operator|=
operator|new
name|Value
index|[
name|pivot
index|]
expr_stmt|;
name|leftPtrs
operator|=
operator|new
name|long
index|[
name|leftVals
operator|.
name|length
operator|+
literal|1
index|]
expr_stmt|;
name|rightVals
operator|=
operator|new
name|Value
index|[
name|vc
operator|-
operator|(
name|pivot
operator|+
literal|1
operator|)
index|]
expr_stmt|;
name|rightPtrs
operator|=
operator|new
name|long
index|[
name|rightVals
operator|.
name|length
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
literal|0
argument_list|,
name|leftVals
argument_list|,
literal|0
argument_list|,
name|leftVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
name|leftVals
operator|.
name|length
operator|+
literal|1
argument_list|,
name|rightVals
argument_list|,
literal|0
argument_list|,
name|rightVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|,
name|rightPtrs
argument_list|,
literal|0
argument_list|,
name|rightPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|separator
operator|=
name|values
index|[
name|leftVals
operator|.
name|length
index|]
expr_stmt|;
break|break;
case|case
name|LEAF
case|:
name|leftVals
operator|=
operator|new
name|Value
index|[
name|pivot
index|]
expr_stmt|;
name|leftPtrs
operator|=
operator|new
name|long
index|[
name|leftVals
operator|.
name|length
index|]
expr_stmt|;
name|rightVals
operator|=
operator|new
name|Value
index|[
name|vc
operator|-
name|pivot
index|]
expr_stmt|;
name|rightPtrs
operator|=
operator|new
name|long
index|[
name|rightVals
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
literal|0
argument_list|,
name|leftVals
argument_list|,
literal|0
argument_list|,
name|leftVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
name|leftVals
operator|.
name|length
argument_list|,
name|rightVals
argument_list|,
literal|0
argument_list|,
name|rightVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|,
name|rightPtrs
argument_list|,
literal|0
argument_list|,
name|rightPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|separator
operator|=
name|leftVals
index|[
name|leftVals
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In split"
argument_list|)
throw|;
block|}
comment|// Log the update of the current page
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|leftVals
argument_list|,
name|leftPtrs
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|setValues
argument_list|(
name|leftVals
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|leftPtrs
argument_list|)
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
comment|// Promote the pivot to the parent branch
name|BTreeNode
name|parent
init|=
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// This can only happen if this is the root
name|parent
operator|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|BRANCH
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Log change of the parent page
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|SetParentLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
specifier|final
name|BTreeNode
name|rNode
init|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|// Log update of the right node
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rightVals
argument_list|,
name|rightPtrs
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|rNode
argument_list|)
expr_stmt|;
block|}
name|rNode
operator|.
name|setValues
argument_list|(
name|rightVals
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|setPointers
argument_list|(
name|rightPtrs
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rNode
argument_list|)
expr_stmt|;
name|parent
operator|.
name|setValues
argument_list|(
operator|new
name|Value
index|[]
block|{
name|separator
block|}
argument_list|)
expr_stmt|;
name|parent
operator|.
name|setPointers
argument_list|(
operator|new
name|long
index|[]
block|{
name|page
operator|.
name|getPageNum
argument_list|()
block|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
block|}
argument_list|)
expr_stmt|;
comment|// Log update of the parent node
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|parent
operator|.
name|values
argument_list|,
name|parent
operator|.
name|ptrs
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|parent
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|setRootNode
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|rNode
operator|.
name|mustSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" right node requires second split: "
operator|+
name|rNode
operator|.
name|getDataLen
argument_list|()
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|BTreeNode
name|rNode
init|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|// Log update of the right node
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rightVals
argument_list|,
name|rightPtrs
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|rNode
argument_list|)
expr_stmt|;
block|}
name|rNode
operator|.
name|setValues
argument_list|(
name|rightVals
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|setPointers
argument_list|(
name|rightPtrs
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rNode
argument_list|)
expr_stmt|;
name|parent
operator|.
name|promoteValue
argument_list|(
name|transaction
argument_list|,
name|separator
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rNode
operator|.
name|mustSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" right node requires second split: "
operator|+
name|rNode
operator|.
name|getDataLen
argument_list|()
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
name|cache
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|mustSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"left node requires second split: "
operator|+
name|getDataLen
argument_list|()
argument_list|)
expr_stmt|;
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/////////////////////////////////////////////////////////////////
specifier|public
name|long
name|findValue
parameter_list|(
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|int
name|idx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
expr_stmt|;
name|BTreeNode
name|child
init|=
name|getChildNode
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"unexpected "
operator|+
name|idx
operator|+
literal|", "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": value '"
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|"' doesn't exist"
argument_list|)
throw|;
return|return
name|child
operator|.
name|findValue
argument_list|(
name|value
argument_list|)
return|;
case|case
name|LEAF
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
return|return
name|KEY_NOT_FOUND
return|;
comment|//throw new BTreeException("Value doesn't exist");
block|}
else|else
return|return
name|ptrs
index|[
name|idx
index|]
return|;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In findValue"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|dump
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|page
operator|.
name|getPageNum
argument_list|()
operator|==
name|fileHeader
operator|.
name|getRootPage
argument_list|()
condition|)
name|writer
operator|.
name|write
argument_list|(
literal|"ROOT: "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|?
literal|"BRANCH: "
else|:
literal|"LEAF: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|writer
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dumpValue
argument_list|(
name|writer
argument_list|,
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"-----------------------------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|BTreeNode
name|child
init|=
name|getChildNode
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|child
operator|.
name|dump
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// query is a BEAST of a method
comment|// --- added support for right truncated search terms (wolf)
specifier|public
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|ANY
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
condition|)
block|{
name|Value
index|[]
name|qvals
init|=
name|query
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|leftIdx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|qvals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|rightIdx
init|=
name|qvals
operator|.
name|length
operator|>
literal|1
condition|?
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|qvals
index|[
name|qvals
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
else|:
name|leftIdx
decl_stmt|;
name|boolean
name|pos
init|=
name|query
operator|.
name|getOperator
argument_list|()
operator|>=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|==
name|pos
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|EQ
case|:
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
name|i
operator|==
name|leftIdx
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
case|case
name|IndexQuery
operator|.
name|LT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|// If it's not implemented, we walk the tree
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LEAF
case|:
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|leftIdx
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|else if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
break|break;
block|}
break|break;
default|default :
comment|// If it's not implemented, it falls right through
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
else|else
comment|// No Query - Just Walk The Tree
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEAF
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
operator|||
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|Value
name|prefix
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|ANY
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
condition|)
block|{
name|Value
index|[]
name|qvals
init|=
name|query
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|leftIdx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|qvals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|pfxIdx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|boolean
name|pos
init|=
name|query
operator|.
name|getOperator
argument_list|()
operator|>=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pfxIdx
operator|<
literal|0
condition|)
name|pfxIdx
operator|=
operator|-
operator|(
name|pfxIdx
operator|+
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
name|getChildNode
argument_list|(
name|leftIdx
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|leftIdx
operator|&&
name|values
index|[
name|i
index|]
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<=
name|leftIdx
operator|&&
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<=
name|leftIdx
operator|&&
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|values
operator|.
name|length
operator|&&
name|values
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|prefix
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|values
operator|.
name|length
operator|&&
name|values
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|prefix
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|LEAF
case|:
if|if
condition|(
name|pfxIdx
operator|<
literal|0
condition|)
name|pfxIdx
operator|=
operator|-
operator|(
name|pfxIdx
operator|+
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|leftIdx
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<
name|leftIdx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<=
name|leftIdx
operator|&&
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|prefix
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|prefix
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
else|else
comment|// No Query - Just Walk The Tree
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEAF
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
operator|||
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|ANY
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
condition|)
block|{
name|Value
index|[]
name|qvals
init|=
name|query
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|leftIdx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|qvals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|rightIdx
init|=
name|qvals
operator|.
name|length
operator|>
literal|1
condition|?
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|values
argument_list|,
name|qvals
index|[
name|qvals
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
else|:
name|leftIdx
decl_stmt|;
name|boolean
name|pos
init|=
name|query
operator|.
name|getOperator
argument_list|()
operator|>=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|==
name|pos
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|EQ
case|:
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
name|i
operator|==
name|leftIdx
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
case|case
name|IndexQuery
operator|.
name|LT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|// If it's not implemented, we walk the tree
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LEAF
case|:
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|leftIdx
argument_list|,
name|values
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|leftIdx
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|leftIdx
argument_list|)
argument_list|)
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|leftIdx
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
break|break;
block|}
break|break;
default|default :
comment|// If it's not implemented, it falls right through
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
else|else
comment|// No Query - Just Walk The Tree
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ptrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|LEAF
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
operator|||
name|query
operator|.
name|testValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setValues
argument_list|(
name|deleteArrayValue
argument_list|(
name|values
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|ArrayUtils
operator|.
name|deleteArrayLong
argument_list|(
name|ptrs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
block|}
comment|////////////////////////////////////////////////////////////////////
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader()      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|()
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|PAGE_SIZE
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader(boolean)      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|boolean
name|read
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|read
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader(long)      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|)
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|pageCount
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader(long, int)      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|)
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createPageHeader()      */
specifier|public
name|PageHeader
name|createPageHeader
parameter_list|()
block|{
return|return
operator|new
name|BTreePageHeader
argument_list|()
return|;
block|}
specifier|public
name|BufferStats
name|getIndexBufferStats
parameter_list|()
block|{
return|return
operator|new
name|BufferStats
argument_list|(
name|cache
operator|.
name|getBuffers
argument_list|()
argument_list|,
name|cache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|,
name|cache
operator|.
name|getHits
argument_list|()
argument_list|,
name|cache
operator|.
name|getFails
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" INDEX "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|cache
operator|.
name|getBuffers
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|cache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|cache
operator|.
name|getHits
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|cache
operator|.
name|getFails
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
class|class
name|BTreeFileHeader
extends|extends
name|FileHeader
block|{
specifier|private
name|long
name|rootPage
init|=
literal|0
decl_stmt|;
specifier|private
name|short
name|fixedLen
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|BTreeFileHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|,
name|byte
name|blockSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|int
name|pageSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|boolean
name|read
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|read
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|super
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|rootPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|fixedLen
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
return|return
name|offset
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|super
operator|.
name|write
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|rootPage
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|fixedLen
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
return|return
name|offset
return|;
block|}
comment|/** 		 *  The root page of the storage tree 		 * 		 *@param  rootPage  The new rootPage value 		 */
specifier|public
specifier|final
name|void
name|setRootPage
parameter_list|(
name|long
name|rootPage
parameter_list|)
block|{
name|this
operator|.
name|rootPage
operator|=
name|rootPage
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 		 *  The root page of the storage tree 		 * 		 *@return    The rootPage value 		 */
specifier|public
specifier|final
name|long
name|getRootPage
parameter_list|()
block|{
return|return
name|rootPage
return|;
block|}
specifier|public
name|short
name|getFixedKeyLen
parameter_list|()
block|{
return|return
name|fixedLen
return|;
block|}
specifier|public
name|void
name|setFixedKeyLen
parameter_list|(
name|short
name|keyLen
parameter_list|)
block|{
name|this
operator|.
name|fixedLen
operator|=
name|keyLen
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
class|class
name|BTreePageHeader
extends|extends
name|PageHeader
block|{
specifier|private
name|short
name|valueCount
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|parentPage
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|BTreePageHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BTreePageHeader
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|//if (getStatus() == UNUSED)
comment|//	return;
name|parentPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|valueCount
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|2
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|parentPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|valueCount
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|2
return|;
block|}
specifier|public
specifier|final
name|void
name|setValueCount
parameter_list|(
name|short
name|valueCount
parameter_list|)
block|{
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 		 *  The number of values stored by this page 		 * 		 *@return    The valueCount value 		 */
specifier|public
specifier|final
name|short
name|getValueCount
parameter_list|()
block|{
return|return
name|valueCount
return|;
block|}
comment|/** 		 *  The number of pointers stored by this page 		 * 		 *@return    The pointerCount value 		 */
specifier|public
specifier|final
name|short
name|getPointerCount
parameter_list|()
block|{
if|if
condition|(
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
return|return
operator|(
name|short
operator|)
operator|(
name|valueCount
operator|+
literal|1
operator|)
return|;
else|else
return|return
name|valueCount
return|;
block|}
block|}
block|}
end_class

end_unit

