begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
package|;
end_package

begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-05 The eXist Project  *  http://exist-db.org  *    *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *    *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *    *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *    *  $Id$  *    *  This file is in part based on code from the dbXML Group. The original license  *  statement is included below:  *    *  -------------------------------------------------------------------------------------------------  *  dbXML License, Version 1.0  *  *  Copyright (c) 1999-2001 The dbXML Group, L.L.C.  *  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.  *  *  2. Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in  *  the documentation and/or other materials provided with the  *  distribution.  *  *  3. The end-user documentation included with the redistribution,  *  if any, must include the following acknowledgment:  *  "This product includes software developed by  *  The dbXML Group (http://www.dbxml.com/)."  *  Alternately, this acknowledgment may appear in the software  *  itself, if and wherever such third-party acknowledgments normally  *  appear.  *  *  4. The names "dbXML" and "The dbXML Group" must not be used to  *  endorse or promote products derived from this software without  *  prior written permission. For written permission, please contact  *  info@dbxml.com.  *  *  5. Products derived from this software may not be called "dbXML",  *  nor may "dbXML" appear in their name, without prior written  *  permission of The dbXML Group.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *  DISCLAIMED.  IN NO EVENT SHALL THE DBXML GROUP OR ITS CONTRIBUTORS  *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BrokerPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BufferStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|DefaultCacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|CacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cacheable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|LRDCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Journal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|LogEntryTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|LogException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|journal
operator|.
name|Loggable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|TransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|TerminatedException
import|;
end_import

begin_comment
comment|/**  *  A general purpose B+-tree which stores binary keys as instances of  *  {@link org.exist.storage.btree.Value}. The actual value data is not  *  stored in the B+tree itself. Instead, we use long pointers to record the  *  storage address of the value. This class has no methods to locate or  *  modify data records. Data handling is in the responsibilty of the   *  proper subclasses: {@link org.exist.storage.index.BFile} and  *  {@link org.exist.storage.dom.DOMFile}.  *    *  Both, branch and leaf nodes are represented by the inner class   *  {@link org.exist.storage.btree.BTree.BTreeNode}.  */
end_comment

begin_class
specifier|public
class|class
name|BTree
extends|extends
name|Paged
block|{
comment|/** Used as return value, if a value was not found */
specifier|public
specifier|final
specifier|static
name|long
name|KEY_NOT_FOUND
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Type of BTreeNode/Page */
specifier|protected
specifier|final
specifier|static
name|byte
name|LEAF
init|=
literal|1
decl_stmt|;
comment|/** Type of BTreeNode/Page */
specifier|protected
specifier|final
specifier|static
name|byte
name|BRANCH
init|=
literal|2
decl_stmt|;
comment|/** Log entry type for an insert value operation */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_INSERT_VALUE
init|=
literal|0x20
decl_stmt|;
comment|/** Log entry type for creation of a new btree node */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_CREATE_BNODE
init|=
literal|0x21
decl_stmt|;
comment|/** Log entry type for a page update resulting from a page split */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_PAGE
init|=
literal|0x22
decl_stmt|;
comment|/** Log entry type for a parent page change resulting from a page split */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_SET_PARENT
init|=
literal|0x23
decl_stmt|;
comment|/** Log entry type for a value update */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_UPDATE_VALUE
init|=
literal|0x24
decl_stmt|;
comment|/** Log entry type for removing a value */
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_REMOVE_VALUE
init|=
literal|0x25
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|LOG_SET_LINK
init|=
literal|0x26
decl_stmt|;
static|static
block|{
comment|// register the log entry types used for the btree
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_INSERT_VALUE
argument_list|,
name|InsertValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_VALUE
argument_list|,
name|UpdateValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_REMOVE_VALUE
argument_list|,
name|RemoveValueLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_CREATE_BNODE
argument_list|,
name|CreateBTNodeLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_UPDATE_PAGE
argument_list|,
name|UpdatePageLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_SET_PARENT
argument_list|,
name|SetParentLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
name|LogEntryTypes
operator|.
name|addEntryType
argument_list|(
name|LOG_SET_LINK
argument_list|,
name|SetPageLinkLoggable
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|DefaultCacheManager
name|cacheManager
decl_stmt|;
comment|/** Cache of BTreeNode(s) */
specifier|protected
name|Cache
name|cache
decl_stmt|;
specifier|protected
name|double
name|growthThreshold
decl_stmt|;
comment|/** Size of BTreeNode cache */
specifier|protected
name|int
name|buffers
decl_stmt|;
comment|/** Fileheader of a BTree file */
specifier|private
name|BTreeFileHeader
name|fileHeader
decl_stmt|;
comment|/** The LogManager for writing the transaction log */
specifier|protected
name|Journal
name|logManager
decl_stmt|;
specifier|protected
name|byte
name|fileId
decl_stmt|;
specifier|protected
name|boolean
name|isTransactional
decl_stmt|;
specifier|protected
name|BrokerPool
name|pool
decl_stmt|;
specifier|protected
name|BTree
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|byte
name|fileId
parameter_list|,
name|boolean
name|transactional
parameter_list|,
name|DefaultCacheManager
name|cacheManager
parameter_list|,
name|double
name|growthThreshold
parameter_list|)
throws|throws
name|DBException
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|cacheManager
operator|=
name|cacheManager
expr_stmt|;
name|this
operator|.
name|buffers
operator|=
name|cacheManager
operator|.
name|getDefaultInitialSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|growthThreshold
operator|=
name|growthThreshold
expr_stmt|;
name|this
operator|.
name|fileId
operator|=
name|fileId
expr_stmt|;
name|fileHeader
operator|=
operator|(
name|BTreeFileHeader
operator|)
name|getFileHeader
argument_list|()
expr_stmt|;
name|fileHeader
operator|.
name|setPageCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|setTotalCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|isTransactional
operator|=
name|transactional
operator|&&
name|pool
operator|.
name|isTransactional
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
condition|)
name|logManager
operator|=
name|pool
operator|.
name|getTransactionManager
argument_list|()
operator|.
name|getJournal
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BTree
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|byte
name|fileId
parameter_list|,
name|boolean
name|transactional
parameter_list|,
name|DefaultCacheManager
name|cacheManager
parameter_list|,
name|File
name|file
parameter_list|,
name|double
name|growthThreshold
parameter_list|)
throws|throws
name|DBException
block|{
name|this
argument_list|(
name|pool
argument_list|,
name|fileId
argument_list|,
name|transactional
argument_list|,
name|cacheManager
argument_list|,
name|growthThreshold
argument_list|)
expr_stmt|;
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|public
name|short
name|getFileVersion
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
comment|//		throw new RuntimeException("getFileVersion() called");
block|}
specifier|public
name|boolean
name|open
parameter_list|(
name|short
name|expectedVersion
parameter_list|)
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|open
argument_list|(
name|expectedVersion
argument_list|)
condition|)
block|{
name|initCache
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|create
parameter_list|(
name|short
name|fixedKeyLen
parameter_list|)
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|create
argument_list|()
condition|)
block|{
name|initCache
argument_list|()
expr_stmt|;
try|try
block|{
name|createRootNode
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can not create database file "
operator|+
name|getFile
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fileHeader
operator|.
name|setFixedKeyLen
argument_list|(
name|fixedKeyLen
argument_list|)
expr_stmt|;
try|try
block|{
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DBException
argument_list|(
literal|"Error while writing file header: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|initCache
parameter_list|()
block|{
name|cache
operator|=
operator|new
name|LRDCache
argument_list|(
name|cacheManager
operator|.
name|getDefaultInitialSize
argument_list|()
argument_list|,
literal|1.5
argument_list|,
name|growthThreshold
argument_list|,
name|CacheManager
operator|.
name|BTREE_CACHE
argument_list|)
expr_stmt|;
name|cache
operator|.
name|setFileName
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|cacheManager
operator|.
name|registerCache
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|closeAndRemove
parameter_list|()
block|{
name|super
operator|.
name|closeAndRemove
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|deregisterCache
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
comment|/** 	 *  addValue adds a Value to the BTree and associates a pointer with it. The 	 *  pointer can be used for referencing any type of data, it just so happens 	 *  that dbXML uses it for referencing pages of associated data in the BTree 	 *  file or other files. 	 * 	 *@param  value               The Value to add 	 *@param  pointer             The pointer to associate with it 	 *@return                     The previous value for the pointer (or -1) 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|long
name|addValue
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|addValue
argument_list|(
literal|null
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
return|;
block|}
specifier|public
name|long
name|addValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|getRootNode
argument_list|()
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
return|;
block|}
comment|/** 	 *  removeValue removes a Value from the BTree and returns the associated 	 *  pointer for it. 	 * 	 *@param  value               The Value to remove 	 *@return                     The pointer that was associated with it 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|long
name|removeValue
parameter_list|(
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|removeValue
argument_list|(
literal|null
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|public
name|long
name|removeValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|getRootNode
argument_list|()
operator|.
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *  findValue finds a Value in the BTree and returns the associated pointer 	 *  for it. 	 * 	 *@param  value               The Value to find 	 *@return                     The pointer that was associated with it 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|long
name|findValue
parameter_list|(
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
return|return
name|getRootNode
argument_list|()
operator|.
name|findValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/** 	 *  query performs a query against the BTree and performs callback 	 *  operations to report the search results. 	 * 	 *@param  query               The IndexQuery to use (or null for everything) 	 *@param  callback            The callback instance 	 *@exception  IOException     Description of the Exception 	 *@exception  BTreeException  Description of the Exception 	 */
specifier|public
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
block|{
name|Value
name|val1
init|=
name|query
operator|.
name|getValue
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
name|data1
index|[]
init|=
name|val1
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
name|data2
index|[]
init|=
operator|new
name|byte
index|[
name|data1
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data1
argument_list|,
literal|0
argument_list|,
name|data2
argument_list|,
literal|0
argument_list|,
name|data1
operator|.
name|length
argument_list|)
expr_stmt|;
name|data2
index|[
name|data2
operator|.
name|length
operator|-
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|query
operator|.
name|getOperator
argument_list|()
argument_list|,
name|val1
argument_list|,
operator|new
name|Value
argument_list|(
name|data2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getRootNode
argument_list|()
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|/**      *  Executes a query against the BTree and performs callback      *  operations to report the search results. This method takes an      *  additional prefix value. Only BTree keys starting with the specified      *  prefix are considered. Search through the tree is thus restricted to      *  a given key range.      *      *@param  query The IndexQuery to use (or null for everything)      *@param prefix a prefix value      *@param  callback The callback instance      *@exception  IOException      *@exception  BTreeException      */
specifier|public
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|Value
name|prefix
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|getRootNode
argument_list|()
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|prefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
name|remove
argument_list|(
literal|null
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|/**      * Search for keys matching the given {@link IndexQuery} and      * remove them from the node. Every match is reported       * to the specified {@link BTreeCallback}.      *       * @param query      * @param callback      * @throws IOException      * @throws BTreeException      * @throws TerminatedException      */
specifier|public
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
block|{
name|Value
name|val1
init|=
name|query
operator|.
name|getValue
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
name|data1
index|[]
init|=
name|val1
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
name|data2
index|[]
init|=
operator|new
name|byte
index|[
name|data1
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data1
argument_list|,
literal|0
argument_list|,
name|data2
argument_list|,
literal|0
argument_list|,
name|data1
operator|.
name|length
argument_list|)
expr_stmt|;
name|data2
index|[
name|data2
operator|.
name|length
operator|-
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
name|query
operator|=
operator|new
name|IndexQuery
argument_list|(
name|query
operator|.
name|getOperator
argument_list|()
argument_list|,
name|val1
argument_list|,
operator|new
name|Value
argument_list|(
name|data2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getRootNode
argument_list|()
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|removeSequential
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|BTreeNode
name|page
parameter_list|,
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|long
name|next
init|=
name|page
operator|.
name|ph
operator|.
name|getNextPage
argument_list|()
decl_stmt|;
while|while
condition|(
name|next
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|BTreeNode
name|nextPage
init|=
name|getBTreeNode
argument_list|(
name|next
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextPage
operator|.
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|test
init|=
name|query
operator|.
name|testValue
argument_list|(
name|nextPage
operator|.
name|keys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|NEQ
operator|&&
operator|!
name|test
condition|)
return|return;
if|if
condition|(
name|test
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|nextPage
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|nextPage
operator|.
name|keys
index|[
name|i
index|]
argument_list|,
name|nextPage
operator|.
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|nextPage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|nextPage
operator|.
name|keys
index|[
name|i
index|]
argument_list|,
name|nextPage
operator|.
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|decrementDataLen
argument_list|(
name|nextPage
operator|.
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
name|next
operator|=
name|nextPage
operator|.
name|ph
operator|.
name|getNextPage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Read a node from the given page.      *       * @param page      * @return The BTree node      */
specifier|private
name|BTreeNode
name|getBTreeNode
parameter_list|(
name|long
name|page
parameter_list|)
block|{
try|try
block|{
name|BTreeNode
name|node
init|=
operator|(
name|BTreeNode
operator|)
name|cache
operator|.
name|get
argument_list|(
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|Page
name|p
init|=
name|getPage
argument_list|(
name|page
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|node
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|int
name|increment
init|=
name|node
operator|.
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|,
name|increment
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get btree node on page "
operator|+
name|page
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Create a new node with the given status and parent.      *       * @param transaction      * @param status      * @param parent      * @return The BTree node      */
specifier|private
name|BTreeNode
name|createBTreeNode
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|byte
name|status
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|boolean
name|reuseDeleted
parameter_list|)
block|{
try|try
block|{
name|Page
name|p
init|=
name|getFreePage
argument_list|(
name|reuseDeleted
argument_list|)
decl_stmt|;
name|BTreeNode
name|node
init|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|loggable
init|=
operator|new
name|CreateBTNodeLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|status
argument_list|,
name|p
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|parent
operator|!=
literal|null
condition|?
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
else|:
name|Page
operator|.
name|NO_PAGE
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|ph
operator|.
name|setStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
operator|new
name|long
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|node
operator|.
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|node
operator|.
name|write
argument_list|()
expr_stmt|;
comment|//cache.add(node);
return|return
name|node
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to create a btree node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Set the root node of the tree.      *       * @param rootNode      * @throws IOException      */
specifier|protected
name|void
name|setRootNode
parameter_list|(
name|BTreeNode
name|rootNode
parameter_list|)
throws|throws
name|IOException
block|{
name|fileHeader
operator|.
name|setRootPage
argument_list|(
name|rootNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rootNode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create the root node.      *       * @param transaction      * @return The root node      * @throws IOException      */
specifier|protected
name|long
name|createRootNode
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
block|{
name|BTreeNode
name|root
init|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|LEAF
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|setRootNode
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
name|root
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/**      * @return the root node.      */
specifier|protected
name|BTreeNode
name|getRootNode
parameter_list|()
block|{
try|try
block|{
name|BTreeNode
name|node
init|=
operator|(
name|BTreeNode
operator|)
name|cache
operator|.
name|get
argument_list|(
name|fileHeader
operator|.
name|getRootPage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|Page
name|p
init|=
name|getPage
argument_list|(
name|fileHeader
operator|.
name|getRootPage
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|node
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get root btree node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Print a dump of the tree to the given writer. For debug only!      * @param writer      * @throws IOException      * @throws BTreeException      */
specifier|public
name|void
name|dump
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|BTreeNode
name|root
init|=
name|getRootNode
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ROOT = "
operator|+
name|root
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|.
name|dump
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TreeMetrics
name|treeStatistics
parameter_list|()
throws|throws
name|IOException
block|{
name|TreeMetrics
name|metrics
init|=
operator|new
name|TreeMetrics
argument_list|()
decl_stmt|;
name|BTreeNode
name|root
init|=
name|getRootNode
argument_list|()
decl_stmt|;
name|root
operator|.
name|treeStatistics
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
return|return
name|metrics
return|;
block|}
comment|/* Flush the dirty data to the disk and cleans up the cache. 	 * @see org.exist.storage.btree.Paged#flush() 	 * @return<code>true</code> if something had to be cleaned 	 */
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|DBException
block|{
name|boolean
name|flushed
init|=
name|cache
operator|.
name|flush
argument_list|()
decl_stmt|;
name|flushed
operator|=
name|flushed
operator||
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|flushed
return|;
block|}
comment|/*      * @see org.exist.storage.btree.Paged#close()      */
specifier|public
name|boolean
name|close
parameter_list|()
throws|throws
name|DBException
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
name|flush
argument_list|()
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|void
name|dumpValue
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|Value
name|value
parameter_list|,
name|int
name|status
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
comment|/* --------------------------------------------------------------------------------- 	 * Methods used by recovery and transaction management 	 * --------------------------------------------------------------------------------- */
specifier|private
name|void
name|writeToLog
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|BTreeNode
name|node
parameter_list|)
block|{
try|try
block|{
name|logManager
operator|.
name|writeToLog
argument_list|(
name|loggable
argument_list|)
expr_stmt|;
name|node
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|boolean
name|requiresRedo
parameter_list|(
name|Loggable
name|loggable
parameter_list|,
name|Page
name|page
parameter_list|)
block|{
return|return
name|loggable
operator|.
name|getLsn
argument_list|()
operator|>
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
return|;
block|}
specifier|protected
name|void
name|redoCreateBTNode
parameter_list|(
name|CreateBTNodeLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
operator|(
name|BTreeNode
operator|)
name|cache
operator|.
name|get
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
comment|// node is not yet loaded. Load it
try|try
block|{
name|Page
name|p
init|=
name|getPage
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
name|p
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
operator|||
name|p
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
operator|)
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|p
argument_list|)
condition|)
block|{
comment|// node already found on disk: read it
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|node
operator|.
name|read
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// create a new node
name|node
operator|=
operator|new
name|BTreeNode
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setStatus
argument_list|(
name|loggable
operator|.
name|status
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
operator|new
name|long
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|node
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|parentPage
operator|=
name|loggable
operator|.
name|parentNum
expr_stmt|;
name|int
name|increment
init|=
name|node
operator|.
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|,
name|increment
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LogException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|redoInsertValue
parameter_list|(
name|InsertValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|insertKey
argument_list|(
name|loggable
operator|.
name|key
argument_list|,
name|loggable
operator|.
name|idx
argument_list|)
expr_stmt|;
name|node
operator|.
name|insertPointer
argument_list|(
name|loggable
operator|.
name|pointer
argument_list|,
name|loggable
operator|.
name|pointerIdx
argument_list|)
expr_stmt|;
name|node
operator|.
name|adjustDataLen
argument_list|(
name|loggable
operator|.
name|idx
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoInsertValue
parameter_list|(
name|InsertValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
try|try
block|{
name|removeValue
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoUpdateValue
parameter_list|(
name|UpdateValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
if|if
condition|(
name|loggable
operator|.
name|idx
operator|>
name|node
operator|.
name|ptrs
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|node
operator|.
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|"; loggable.idx = "
operator|+
name|loggable
operator|.
name|idx
operator|+
literal|"; node.ptrs.length = "
operator|+
name|node
operator|.
name|ptrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
try|try
block|{
name|dump
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|writer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LogException
argument_list|(
literal|"Critical error during recovery"
argument_list|)
throw|;
block|}
name|node
operator|.
name|ptrs
index|[
name|loggable
operator|.
name|idx
index|]
operator|=
name|loggable
operator|.
name|pointer
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoUpdateValue
parameter_list|(
name|UpdateValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
try|try
block|{
name|addValue
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|key
argument_list|,
name|loggable
operator|.
name|oldPointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoRemoveValue
parameter_list|(
name|RemoveValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getLsn
argument_list|()
operator|!=
name|Page
operator|.
name|NO_PAGE
operator|&&
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|removeKey
argument_list|(
name|loggable
operator|.
name|idx
argument_list|)
expr_stmt|;
name|node
operator|.
name|removePointer
argument_list|(
name|loggable
operator|.
name|idx
argument_list|)
expr_stmt|;
name|node
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|undoRemoveValue
parameter_list|(
name|RemoveValueLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
try|try
block|{
name|addValue
argument_list|(
literal|null
argument_list|,
name|loggable
operator|.
name|oldValue
argument_list|,
name|loggable
operator|.
name|oldPointer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to undo: "
operator|+
name|loggable
operator|.
name|dump
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoUpdatePage
parameter_list|(
name|UpdatePageLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|prefix
operator|=
name|loggable
operator|.
name|prefix
expr_stmt|;
name|node
operator|.
name|keys
operator|=
name|loggable
operator|.
name|values
expr_stmt|;
name|node
operator|.
name|nKeys
operator|=
name|loggable
operator|.
name|values
operator|.
name|length
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setValueCount
argument_list|(
operator|(
name|short
operator|)
name|node
operator|.
name|nKeys
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPointers
argument_list|(
name|loggable
operator|.
name|pointers
argument_list|)
expr_stmt|;
name|node
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoSetParent
parameter_list|(
name|SetParentLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|ph
operator|.
name|parentPage
operator|=
name|loggable
operator|.
name|parentNum
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|redoSetPageLink
parameter_list|(
name|SetPageLinkLoggable
name|loggable
parameter_list|)
throws|throws
name|LogException
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|loggable
operator|.
name|pageNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresRedo
argument_list|(
name|loggable
argument_list|,
name|node
operator|.
name|page
argument_list|)
condition|)
block|{
name|node
operator|.
name|ph
operator|.
name|setNextPage
argument_list|(
name|loggable
operator|.
name|nextPage
argument_list|)
expr_stmt|;
name|node
operator|.
name|ph
operator|.
name|setLsn
argument_list|(
name|loggable
operator|.
name|getLsn
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**      * A node in the B+-tree. Every node is backed by a Page for      * storing the node's data. Both, branch and leaf nodes are represented      * by this class. Each node stores its keys as instances of {@link Value}      * and its values as pointers of type long.      *       *  If the node is a branch, the long pointers point to the child nodes      *  of the branch. If it is a leaf, the pointers contain the virtual storage      *  of the data section associated to the key.      *        * @author wolf      *      */
specifier|protected
specifier|final
class|class
name|BTreeNode
implements|implements
name|Cacheable
block|{
comment|/** defines the default size for the keys array */
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_INITIAL_ENTRIES
init|=
literal|32
decl_stmt|;
comment|/** the underlying Page object that stores the node's data */
specifier|private
name|Page
name|page
decl_stmt|;
specifier|private
name|BTreePageHeader
name|ph
decl_stmt|;
comment|/** stores the keys in this page */
specifier|private
name|Value
index|[]
name|keys
decl_stmt|;
specifier|private
name|Value
name|prefix
init|=
name|Value
operator|.
name|EMPTY_VALUE
decl_stmt|;
comment|/** the number of keys currently stored */
specifier|private
name|int
name|nKeys
init|=
literal|0
decl_stmt|;
comment|/**           * stores the page pointers to child nodes (for branches)          * or the storage address (for leaf nodes).          */
specifier|private
name|long
index|[]
name|ptrs
decl_stmt|;
comment|/** the number of pointers currently used */
specifier|private
name|int
name|nPtrs
init|=
literal|0
decl_stmt|;
comment|/** fields used by the Cacheable interface */
specifier|private
name|int
name|refCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|timestamp
init|=
literal|0
decl_stmt|;
comment|/** does this node need to be saved? */
specifier|private
name|boolean
name|saved
init|=
literal|true
decl_stmt|;
comment|/** the computed raw data size required by this node */
specifier|private
name|int
name|currentDataLen
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|BTreeNode
parameter_list|(
name|Page
name|page
parameter_list|,
name|boolean
name|newPage
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|ph
operator|=
operator|(
name|BTreePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|newPage
condition|)
block|{
name|keys
operator|=
operator|new
name|Value
index|[
name|DEFAULT_INITIAL_ENTRIES
index|]
expr_stmt|;
name|ptrs
operator|=
operator|new
name|long
index|[
name|DEFAULT_INITIAL_ENTRIES
operator|+
literal|1
index|]
expr_stmt|;
name|ph
operator|.
name|setValueCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**          * Set the link to the parent of this node.          *           * @param parent          */
specifier|public
name|void
name|setParent
parameter_list|(
name|BTreeNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|ph
operator|.
name|parentPage
operator|=
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
expr_stmt|;
else|else
name|ph
operator|.
name|parentPage
operator|=
name|Page
operator|.
name|NO_PAGE
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * @return the parent of this node.          */
specifier|public
name|BTreeNode
name|getParent
parameter_list|()
block|{
if|if
condition|(
name|ph
operator|.
name|parentPage
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
return|return
name|getBTreeNode
argument_list|(
name|ph
operator|.
name|parentPage
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#getReferenceCount()          */
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#incReferenceCount()          */
specifier|public
name|int
name|incReferenceCount
parameter_list|()
block|{
if|if
condition|(
name|refCount
operator|<
name|Cacheable
operator|.
name|MAX_REF
condition|)
operator|++
name|refCount
expr_stmt|;
return|return
name|refCount
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#setReferenceCount(int)          */
specifier|public
name|void
name|setReferenceCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|refCount
operator|=
name|count
expr_stmt|;
block|}
comment|/** 		 * @see org.exist.storage.cache.Cacheable#setTimestamp(int) 		 */
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|int
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#allowUnload()          */
specifier|public
name|boolean
name|allowUnload
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** 		 * @see org.exist.storage.cache.Cacheable#getTimestamp() 		 */
specifier|public
name|int
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#sync(boolean syncJournal)          */
specifier|public
name|boolean
name|sync
parameter_list|(
name|boolean
name|syncJournal
parameter_list|)
block|{
if|if
condition|(
name|isDirty
argument_list|()
condition|)
try|try
block|{
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTransactional
operator|&&
name|syncJournal
condition|)
name|logManager
operator|.
name|flushToLog
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IO error while writing page: "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#getKey()          */
specifier|public
name|long
name|getKey
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#decReferenceCount()          */
specifier|public
name|int
name|decReferenceCount
parameter_list|()
block|{
return|return
name|refCount
operator|>
literal|0
condition|?
operator|--
name|refCount
else|:
literal|0
return|;
block|}
comment|/**          * @see org.exist.storage.cache.Cacheable#isDirty()          */
specifier|public
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
operator|!
name|saved
return|;
block|}
comment|/**          * Set the keys of this node.          *           * @param vals          */
specifier|private
name|void
name|setValues
parameter_list|(
name|Value
index|[]
name|vals
parameter_list|)
block|{
name|keys
operator|=
name|vals
expr_stmt|;
name|nKeys
operator|=
name|vals
operator|.
name|length
expr_stmt|;
name|ph
operator|.
name|setValueCount
argument_list|(
operator|(
name|short
operator|)
name|nKeys
argument_list|)
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * Set the array of pointers of this node.          *           * @param pointers          */
specifier|private
name|void
name|setPointers
parameter_list|(
name|long
index|[]
name|pointers
parameter_list|)
block|{
name|ptrs
operator|=
name|pointers
expr_stmt|;
name|nPtrs
operator|=
name|pointers
operator|.
name|length
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/** 		 * Returns the raw data size (in bytes) required by this node. 		 *  		 * @return The data length 		 */
specifier|private
name|int
name|getDataLen
parameter_list|()
block|{
return|return
name|currentDataLen
operator|<
literal|0
condition|?
name|recalculateDataLen
argument_list|()
else|:
name|currentDataLen
return|;
block|}
comment|/** 		 * Recalculates the raw data size (in bytes) required by this node. 		 *  		 * @return the data length 		 */
specifier|private
name|int
name|recalculateDataLen
parameter_list|()
block|{
name|currentDataLen
operator|=
name|ptrs
operator|==
literal|null
condition|?
literal|0
else|:
name|nPtrs
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
operator|<
literal|0
condition|)
name|currentDataLen
operator|+=
literal|2
operator|*
name|nKeys
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
name|currentDataLen
operator|+=
name|prefix
operator|.
name|getLength
argument_list|()
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
condition|)
name|currentDataLen
operator|+=
name|nKeys
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
comment|// if this is a leaf page, we use prefix compression to store the keys,
comment|// so subtract the size of the prefix
name|int
name|prefix
init|=
name|keys
index|[
name|i
index|]
operator|.
name|commonPrefix
argument_list|(
name|keys
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|<
literal|0
operator|||
name|prefix
operator|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
name|prefix
operator|=
literal|0
expr_stmt|;
name|currentDataLen
operator|+=
name|keys
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
operator|-
name|prefix
expr_stmt|;
block|}
else|else
name|currentDataLen
operator|+=
name|keys
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
return|return
name|currentDataLen
return|;
block|}
comment|/**          * Decrements the raw data size of this node by the space          * required for storing removedValue.          *           * @param removedValue          * @return The new data length          */
specifier|private
name|int
name|decrementDataLen
parameter_list|(
name|Value
name|removedValue
parameter_list|)
block|{
return|return
name|recalculateDataLen
argument_list|()
return|;
block|}
comment|/** 		 * Add the raw data size required to store the value to the internal 		 * data size of this node. 		 *   		 */
specifier|private
name|void
name|adjustDataLen
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|currentDataLen
operator|<
literal|0
condition|)
block|{
name|recalculateDataLen
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
operator|&&
name|idx
operator|>
literal|0
condition|)
block|{
comment|// if this is a leaf page, we use prefix compression to store the keys,
comment|// so subtract the size of the prefix
name|int
name|prefix
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|<
name|nKeys
condition|)
block|{
comment|// recalculate the prefix length for the following value
name|prefix
operator|=
name|calculatePrefixLen
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|currentDataLen
operator|-=
name|keys
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|getLength
argument_list|()
operator|-
name|prefix
expr_stmt|;
name|prefix
operator|=
name|calculatePrefixLen
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|currentDataLen
operator|+=
name|keys
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|getLength
argument_list|()
operator|-
name|prefix
expr_stmt|;
block|}
comment|// calculate the prefix length for the new value
name|prefix
operator|=
name|calculatePrefixLen
argument_list|(
name|idx
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|currentDataLen
operator|+=
name|keys
index|[
name|idx
index|]
operator|.
name|getLength
argument_list|()
operator|-
name|prefix
expr_stmt|;
name|currentDataLen
operator|++
expr_stmt|;
comment|// add one byte for the prefix length
block|}
else|else
block|{
name|currentDataLen
operator|+=
name|keys
index|[
name|idx
index|]
operator|.
name|getLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
condition|)
name|currentDataLen
operator|++
expr_stmt|;
block|}
name|currentDataLen
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
operator|<
literal|0
condition|)
name|currentDataLen
operator|+=
literal|2
expr_stmt|;
block|}
specifier|private
name|int
name|calculatePrefixLen
parameter_list|(
name|int
name|idx0
parameter_list|,
name|int
name|idx1
parameter_list|)
block|{
name|int
name|prefix
decl_stmt|;
name|prefix
operator|=
name|keys
index|[
name|idx0
index|]
operator|.
name|commonPrefix
argument_list|(
name|keys
index|[
name|idx1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|<
literal|0
operator|||
name|prefix
operator|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
name|prefix
operator|=
literal|0
expr_stmt|;
return|return
name|prefix
return|;
block|}
specifier|private
name|boolean
name|mustSplit
parameter_list|()
block|{
if|if
condition|(
name|ph
operator|.
name|getValueCount
argument_list|()
operator|!=
name|nKeys
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Wrong value count"
argument_list|)
throw|;
return|return
name|getDataLen
argument_list|()
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
return|;
block|}
comment|/**          * Read the node from the underlying page.          *           * @throws IOException          */
specifier|private
name|void
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|page
operator|.
name|read
argument_list|()
decl_stmt|;
name|short
name|keyLen
init|=
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
decl_stmt|;
name|short
name|valSize
init|=
name|keyLen
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
comment|// it this is a branch node, read the common prefix
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
name|short
name|prefixSize
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|prefixSize
operator|==
literal|0
condition|)
block|{
name|prefix
operator|=
name|Value
operator|.
name|EMPTY_VALUE
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|prefixSize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|prefixSize
expr_stmt|;
block|}
block|}
name|nKeys
operator|=
name|ph
operator|.
name|getValueCount
argument_list|()
expr_stmt|;
name|keys
operator|=
operator|new
name|Value
index|[
operator|(
name|nKeys
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keyLen
operator|<
literal|0
condition|)
block|{
name|valSize
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
comment|// for leaf pages, we use prefix compression to increase the number of
comment|// keys that can be stored on one page. Each key is stored as follows:
comment|// [valSize, prefixLen, value], where prefixLen specifies the number of
comment|// leading bytes the key has in common with the previous key.
name|int
name|prefixLen
init|=
operator|(
name|data
index|[
name|p
operator|++
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|t
init|=
operator|new
name|byte
index|[
name|valSize
index|]
decl_stmt|;
if|if
condition|(
name|prefixLen
operator|>
literal|0
condition|)
comment|// copy prefixLen leading bytes from the previous key
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|data
argument_list|()
argument_list|,
name|keys
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|start
argument_list|()
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|prefixLen
argument_list|)
expr_stmt|;
comment|// read the remaining bytes
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|t
argument_list|,
name|prefixLen
argument_list|,
name|valSize
operator|-
name|prefixLen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valSize
operator|-
name|prefixLen
expr_stmt|;
name|keys
index|[
name|i
index|]
operator|=
operator|new
name|Value
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"prefixLen = "
operator|+
name|prefixLen
operator|+
literal|"; i = "
operator|+
name|i
operator|+
literal|"; nKeys = "
operator|+
name|nKeys
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|keys
index|[
name|i
index|]
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|valSize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valSize
expr_stmt|;
block|}
block|}
comment|//	Read in the pointers
name|nPtrs
operator|=
name|ph
operator|.
name|getPointerCount
argument_list|()
expr_stmt|;
name|ptrs
operator|=
operator|new
name|long
index|[
operator|(
name|nPtrs
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|ptrs
index|[
name|i
index|]
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
block|}
comment|/**          * Write the node to the underlying page.          *           * @throws IOException          */
specifier|private
name|void
name|write
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
if|if
condition|(
name|nKeys
operator|!=
name|ph
operator|.
name|getValueCount
argument_list|()
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"nkeys: "
operator|+
name|nKeys
operator|+
literal|" valueCount: "
operator|+
name|ph
operator|.
name|getValueCount
argument_list|()
argument_list|)
throw|;
comment|// if this is a branch node, write out the common prefix
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|,
name|temp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|data
argument_list|()
argument_list|,
name|prefix
operator|.
name|start
argument_list|()
argument_list|,
name|temp
argument_list|,
name|p
argument_list|,
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|+=
name|prefix
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|keyLen
init|=
name|fileHeader
operator|.
name|getFixedKeyLen
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keyLen
operator|<
literal|0
condition|)
block|{
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
name|keys
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
argument_list|,
name|temp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|LEAF
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
comment|// for leaf pages, we use prefix compression to increase the number of
comment|// keys that can be stored on one page. Each key is stored as follows:
comment|// [valSize, prefixLen, value], where prefixLen specifies the number of
comment|// leading bytes the key has in common with the previous key.
name|int
name|prefixLen
init|=
name|keys
index|[
name|i
index|]
operator|.
name|commonPrefix
argument_list|(
name|keys
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
comment|// determine the common prefix
if|if
condition|(
name|prefixLen
operator|<
literal|0
operator|||
name|prefixLen
operator|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
name|prefixLen
operator|=
literal|0
expr_stmt|;
comment|// store the length of the prefix
name|temp
index|[
name|p
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|prefixLen
expr_stmt|;
comment|// copy the remaining bytes, starting at prefixLen
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
index|[
name|i
index|]
operator|.
name|data
argument_list|()
argument_list|,
name|keys
index|[
name|i
index|]
operator|.
name|start
argument_list|()
operator|+
name|prefixLen
argument_list|,
name|temp
argument_list|,
name|p
argument_list|,
name|keys
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
operator|-
name|prefixLen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|keys
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
operator|-
name|prefixLen
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|keys
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|data
operator|.
name|length
operator|>
name|temp
operator|.
name|length
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"calculated: "
operator|+
name|getDataLen
argument_list|()
operator|+
literal|"; required: "
operator|+
operator|(
name|p
operator|+
name|data
operator|.
name|length
operator|)
argument_list|)
throw|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
name|p
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|data
operator|.
name|length
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|ptrs
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
name|writeValue
argument_list|(
name|page
argument_list|,
operator|new
name|Value
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|=
literal|true
expr_stmt|;
block|}
comment|/**          * Retrieve the child node at index idx.          *           * @param idx          * @return The BTree node          * @throws IOException          */
specifier|private
name|BTreeNode
name|getChildNode
parameter_list|(
name|int
name|idx
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
operator|&&
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|nPtrs
condition|)
return|return
name|getBTreeNode
argument_list|(
name|ptrs
index|[
name|idx
index|]
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
comment|/**          * Remove a key.          */
specifier|private
name|long
name|removeValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|key
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|int
name|idx
init|=
name|searchKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|idx
operator|=
name|idx
operator|<
literal|0
condition|?
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
else|:
name|idx
operator|+
literal|1
expr_stmt|;
return|return
name|getChildNode
argument_list|(
name|idx
argument_list|)
operator|.
name|removeValue
argument_list|(
name|transaction
argument_list|,
name|key
argument_list|)
return|;
case|case
name|LEAF
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
return|return
name|KEY_NOT_FOUND
return|;
else|else
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|keys
index|[
name|idx
index|]
argument_list|,
name|ptrs
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|long
name|oldPtr
init|=
name|ptrs
index|[
name|idx
index|]
decl_stmt|;
name|removeKey
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
return|return
name|oldPtr
return|;
block|}
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In removeValue"
argument_list|)
throw|;
block|}
block|}
comment|/**          * Add a key and the corresponding pointer to the node.          */
specifier|private
name|long
name|addValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|idx
init|=
name|searchKey
argument_list|(
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|idx
operator|=
name|idx
operator|<
literal|0
condition|?
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
else|:
name|idx
operator|+
literal|1
expr_stmt|;
return|return
name|getChildNode
argument_list|(
name|idx
argument_list|)
operator|.
name|addValue
argument_list|(
name|transaction
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|)
return|;
case|case
name|LEAF
case|:
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
comment|// Value was found... Overwrite
name|long
name|oldPtr
init|=
name|ptrs
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|UpdateValueLoggable
name|loggable
init|=
operator|new
name|UpdateValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|value
argument_list|,
name|pointer
argument_list|,
name|oldPtr
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|ptrs
index|[
name|idx
index|]
operator|=
name|pointer
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
comment|//write();
comment|//cache.add(this);
return|return
name|oldPtr
return|;
block|}
else|else
block|{
comment|// Value was not found
name|idx
operator|=
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|InsertValueLoggable
name|loggable
init|=
operator|new
name|InsertValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|value
argument_list|,
name|idx
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|insertKey
argument_list|(
name|value
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|insertPointer
argument_list|(
name|pointer
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|adjustDataLen
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//recalculateDataLen();
if|if
condition|(
name|mustSplit
argument_list|()
condition|)
block|{
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In addValue: "
operator|+
name|ph
operator|.
name|getStatus
argument_list|()
operator|+
literal|"; "
operator|+
name|page
operator|.
name|getPageInfo
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**          * Promote a key to the parent node. Called by {@link #split(Txn)}.          */
specifier|private
name|void
name|promoteValue
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|Value
name|value
parameter_list|,
name|BTreeNode
name|rightNode
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|int
name|idx
init|=
name|searchKey
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|idx
operator|=
name|idx
operator|<
literal|0
condition|?
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
else|:
name|idx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|InsertValueLoggable
name|loggable
init|=
operator|new
name|InsertValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
argument_list|,
name|value
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|rightNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|loggable
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|insertKey
argument_list|(
name|value
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|insertPointer
argument_list|(
name|rightNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|SetParentLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|rightNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|rightNode
argument_list|)
expr_stmt|;
block|}
name|rightNode
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|rightNode
operator|.
name|saved
operator|=
literal|false
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rightNode
argument_list|)
expr_stmt|;
comment|//            if (transaction != null&& isTransactional) {
comment|//                Loggable log = new UpdatePageLoggable(transaction, fileId, page.getPageNum(), prefix, keys, nKeys, ptrs, nPtrs);
comment|//                writeToLog(log, this);
comment|//            }
name|boolean
name|split
init|=
name|recalculateDataLen
argument_list|()
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|split
condition|)
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
comment|/**          * Split the node.          *          * @param transaction the current transaction          */
specifier|private
name|void
name|split
parameter_list|(
name|Txn
name|transaction
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|Value
index|[]
name|leftVals
decl_stmt|;
name|Value
index|[]
name|rightVals
decl_stmt|;
name|long
index|[]
name|leftPtrs
decl_stmt|;
name|long
index|[]
name|rightPtrs
decl_stmt|;
name|Value
name|separator
decl_stmt|;
specifier|final
name|short
name|vc
init|=
name|ph
operator|.
name|getValueCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pivot
init|=
name|vc
operator|/
literal|2
decl_stmt|;
comment|// Split the node into two nodes
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|leftVals
operator|=
operator|new
name|Value
index|[
name|pivot
index|]
expr_stmt|;
name|leftPtrs
operator|=
operator|new
name|long
index|[
name|leftVals
operator|.
name|length
operator|+
literal|1
index|]
expr_stmt|;
name|rightVals
operator|=
operator|new
name|Value
index|[
name|vc
operator|-
operator|(
name|pivot
operator|+
literal|1
operator|)
index|]
expr_stmt|;
name|rightPtrs
operator|=
operator|new
name|long
index|[
name|rightVals
operator|.
name|length
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
argument_list|,
literal|0
argument_list|,
name|leftVals
argument_list|,
literal|0
argument_list|,
name|leftVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
argument_list|,
name|leftVals
operator|.
name|length
operator|+
literal|1
argument_list|,
name|rightVals
argument_list|,
literal|0
argument_list|,
name|rightVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|,
name|rightPtrs
argument_list|,
literal|0
argument_list|,
name|rightPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|separator
operator|=
name|keys
index|[
name|leftVals
operator|.
name|length
index|]
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|t
init|=
operator|new
name|byte
index|[
name|prefix
operator|.
name|getLength
argument_list|()
operator|+
name|separator
operator|.
name|getLength
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|data
argument_list|()
argument_list|,
name|prefix
operator|.
name|start
argument_list|()
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|separator
operator|.
name|data
argument_list|()
argument_list|,
name|separator
operator|.
name|start
argument_list|()
argument_list|,
name|t
argument_list|,
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|,
name|separator
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|separator
operator|=
operator|new
name|Value
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEAF
case|:
name|leftVals
operator|=
operator|new
name|Value
index|[
name|pivot
index|]
expr_stmt|;
name|leftPtrs
operator|=
operator|new
name|long
index|[
name|leftVals
operator|.
name|length
index|]
expr_stmt|;
name|rightVals
operator|=
operator|new
name|Value
index|[
name|vc
operator|-
name|pivot
index|]
expr_stmt|;
name|rightPtrs
operator|=
operator|new
name|long
index|[
name|rightVals
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
argument_list|,
literal|0
argument_list|,
name|leftVals
argument_list|,
literal|0
argument_list|,
name|leftVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
argument_list|,
literal|0
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
argument_list|,
name|leftVals
operator|.
name|length
argument_list|,
name|rightVals
argument_list|,
literal|0
argument_list|,
name|rightVals
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|,
name|rightPtrs
argument_list|,
literal|0
argument_list|,
name|rightPtrs
operator|.
name|length
argument_list|)
expr_stmt|;
name|separator
operator|=
name|leftVals
index|[
name|leftVals
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getSeparator
argument_list|(
name|rightVals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In split"
argument_list|)
throw|;
block|}
comment|// Log the update of the current page
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|prefix
argument_list|,
name|leftVals
argument_list|,
name|leftVals
operator|.
name|length
argument_list|,
name|leftPtrs
argument_list|,
name|leftPtrs
operator|.
name|length
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|setValues
argument_list|(
name|leftVals
argument_list|)
expr_stmt|;
name|setPointers
argument_list|(
name|leftPtrs
argument_list|)
expr_stmt|;
name|recalculateDataLen
argument_list|()
expr_stmt|;
comment|// Promote the pivot to the parent branch
name|BTreeNode
name|parent
init|=
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// This can only happen if this is the root
name|parent
operator|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|BRANCH
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Log change of the parent page
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|SetParentLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
specifier|final
name|BTreeNode
name|rNode
init|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|,
name|parent
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rNode
operator|.
name|setValues
argument_list|(
name|rightVals
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|setPointers
argument_list|(
name|rightPtrs
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|setAsParent
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
name|rNode
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|rNode
operator|.
name|growPrefix
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|SetPageLinkLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|ph
operator|.
name|setNextPage
argument_list|(
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Log update of the right node
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rNode
operator|.
name|prefix
argument_list|,
name|rNode
operator|.
name|keys
argument_list|,
name|rNode
operator|.
name|nKeys
argument_list|,
name|rightPtrs
argument_list|,
name|rightPtrs
operator|.
name|length
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|rNode
argument_list|)
expr_stmt|;
block|}
name|rNode
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rNode
argument_list|)
expr_stmt|;
name|parent
operator|.
name|prefix
operator|=
name|separator
expr_stmt|;
name|parent
operator|.
name|setValues
argument_list|(
operator|new
name|Value
index|[]
block|{
name|Value
operator|.
name|EMPTY_VALUE
block|}
argument_list|)
expr_stmt|;
name|parent
operator|.
name|setPointers
argument_list|(
operator|new
name|long
index|[]
block|{
name|page
operator|.
name|getPageNum
argument_list|()
block|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
block|}
argument_list|)
expr_stmt|;
comment|// Log update of the parent node
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|parent
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|parent
operator|.
name|prefix
argument_list|,
name|parent
operator|.
name|keys
argument_list|,
name|parent
operator|.
name|keys
operator|.
name|length
argument_list|,
name|parent
operator|.
name|ptrs
argument_list|,
name|parent
operator|.
name|ptrs
operator|.
name|length
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|parent
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|setRootNode
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|rNode
operator|.
name|mustSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" right node requires second split: "
operator|+
name|rNode
operator|.
name|getDataLen
argument_list|()
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|BTreeNode
name|rNode
init|=
name|createBTreeNode
argument_list|(
name|transaction
argument_list|,
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|,
name|parent
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rNode
operator|.
name|setValues
argument_list|(
name|rightVals
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|setPointers
argument_list|(
name|rightPtrs
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|setAsParent
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
name|rNode
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|rNode
operator|.
name|growPrefix
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|SetPageLinkLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|ph
operator|.
name|getNextPage
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|log
operator|=
operator|new
name|SetPageLinkLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|rNode
operator|.
name|ph
operator|.
name|setNextPage
argument_list|(
name|ph
operator|.
name|getNextPage
argument_list|()
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextPage
argument_list|(
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Log update of the right node
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|UpdatePageLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|rNode
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|rNode
operator|.
name|prefix
argument_list|,
name|rNode
operator|.
name|keys
argument_list|,
name|rNode
operator|.
name|nKeys
argument_list|,
name|rightPtrs
argument_list|,
name|rightPtrs
operator|.
name|length
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|rNode
argument_list|)
expr_stmt|;
block|}
name|rNode
operator|.
name|recalculateDataLen
argument_list|()
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rNode
argument_list|)
expr_stmt|;
name|parent
operator|.
name|promoteValue
argument_list|(
name|transaction
argument_list|,
name|separator
argument_list|,
name|rNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rNode
operator|.
name|mustSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" right node requires second split: "
operator|+
name|rNode
operator|.
name|getDataLen
argument_list|()
argument_list|)
expr_stmt|;
name|rNode
operator|.
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
name|cache
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|mustSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"left node requires second split: "
operator|+
name|getDataLen
argument_list|()
argument_list|)
expr_stmt|;
name|split
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Set the parent-link in all child nodes to point to this node */
specifier|private
name|void
name|setAsParent
parameter_list|(
name|Txn
name|transaction
parameter_list|)
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|BTreeNode
name|node
init|=
name|getBTreeNode
argument_list|(
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|transaction
operator|!=
literal|null
operator|&&
name|isTransactional
condition|)
block|{
name|Loggable
name|log
init|=
operator|new
name|SetParentLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|node
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/////////////////////////////////////////////////////////////////
comment|/**          * Locate the given value in the keys and return the          * associated pointer.          */
specifier|private
name|long
name|findValue
parameter_list|(
name|Value
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|int
name|idx
init|=
name|searchKey
argument_list|(
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|idx
operator|=
name|idx
operator|<
literal|0
condition|?
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
else|:
name|idx
operator|+
literal|1
expr_stmt|;
name|BTreeNode
name|child
init|=
name|getChildNode
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"unexpected "
operator|+
name|idx
operator|+
literal|", "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": value '"
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|"' doesn't exist"
argument_list|)
throw|;
return|return
name|child
operator|.
name|findValue
argument_list|(
name|value
argument_list|)
return|;
case|case
name|LEAF
case|:
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
return|return
name|KEY_NOT_FOUND
return|;
comment|//throw new BTreeException("Value doesn't exist");
block|}
else|else
return|return
name|ptrs
index|[
name|idx
index|]
return|;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In findValue"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
try|try
block|{
name|dump
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
block|}
return|return
name|writer
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|treeStatistics
parameter_list|(
name|TreeMetrics
name|metrics
parameter_list|)
throws|throws
name|IOException
block|{
name|metrics
operator|.
name|addPage
argument_list|(
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|BTreeNode
name|child
init|=
name|getChildNode
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|child
operator|.
name|treeStatistics
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Prints out a debug view of the node to the given writer.          */
specifier|private
name|void
name|dump
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
if|if
condition|(
name|page
operator|.
name|getPageNum
argument_list|()
operator|==
name|fileHeader
operator|.
name|getRootPage
argument_list|()
condition|)
name|writer
operator|.
name|write
argument_list|(
literal|"ROOT: "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|?
literal|"BRANCH: "
else|:
literal|"LEAF: "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|saved
condition|?
literal|"SAVED: "
else|:
literal|"DIRTY: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"PREFIX: "
argument_list|)
expr_stmt|;
name|dumpValue
argument_list|(
name|writer
argument_list|,
name|prefix
argument_list|,
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|"NEXT: "
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|ph
operator|.
name|getNextPage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|writer
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dumpValue
argument_list|(
name|writer
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ph
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"-----------------------------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" POINTERS: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|ptrs
index|[
name|i
index|]
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|"-----------------------------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|BTreeNode
name|child
init|=
name|getChildNode
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|child
operator|.
name|dump
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Search for keys matching the given {@link IndexQuery} and          * report the to the specified {@link BTreeCallback}.          *           * @param query          * @param callback          * @throws IOException          * @throws BTreeException          * @throws TerminatedException 		 */
specifier|private
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|ANY
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
condition|)
block|{
name|Value
index|[]
name|qvals
init|=
name|query
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|leftIdx
init|=
name|searchKey
argument_list|(
name|qvals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|rightIdx
init|=
name|qvals
operator|.
name|length
operator|>
literal|1
condition|?
name|searchKey
argument_list|(
name|qvals
index|[
name|qvals
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
else|:
name|leftIdx
decl_stmt|;
name|boolean
name|pos
init|=
name|query
operator|.
name|getOperator
argument_list|()
operator|>=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|leftIdx
operator|=
name|leftIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
else|:
name|leftIdx
operator|+
literal|1
expr_stmt|;
name|rightIdx
operator|=
name|rightIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
else|:
name|rightIdx
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|==
name|pos
condition|)
block|{
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
break|break;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
name|getChildNode
argument_list|(
literal|0
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|EQ
case|:
name|getChildNode
argument_list|(
name|leftIdx
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
case|case
name|IndexQuery
operator|.
name|GT
case|:
name|getChildNode
argument_list|(
name|leftIdx
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|// If it's not implemented, we walk the tree
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LEAF
case|:
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|leftIdx
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|scanNextPage
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|rightIdx
operator|&&
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightIdx
operator|>=
name|nPtrs
condition|)
name|scanNextPage
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
case|case
name|IndexQuery
operator|.
name|GT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|scanNextPage
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|else if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
break|break;
block|}
break|break;
default|default :
comment|// If it's not implemented, it falls right through
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
else|else
comment|// No Query - Just Walk The Tree
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEAF
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
operator|||
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
comment|/**          * Search for keys matching the given {@link IndexQuery} and          * report the to the specified {@link BTreeCallback}. This specialized          * method only considers keys whose value starts with the specified keyPrefix.          *           * @param query          * @param callback          * @throws IOException          * @throws BTreeException          * @throws TerminatedException          */
specifier|private
name|void
name|query
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|Value
name|keyPrefix
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|ANY
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
condition|)
block|{
name|Value
index|[]
name|qvals
init|=
name|query
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|leftIdx
init|=
name|searchKey
argument_list|(
name|qvals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|pfxIdx
init|=
name|searchKey
argument_list|(
name|keyPrefix
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|leftIdx
operator|=
name|leftIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
else|:
name|leftIdx
operator|+
literal|1
expr_stmt|;
name|pfxIdx
operator|=
name|pfxIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|pfxIdx
operator|+
literal|1
operator|)
else|:
name|pfxIdx
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
name|getChildNode
argument_list|(
name|leftIdx
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
name|getChildNode
argument_list|(
name|pfxIdx
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<=
name|leftIdx
operator|&&
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<=
name|leftIdx
operator|&&
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
case|case
name|IndexQuery
operator|.
name|GT
case|:
name|getChildNode
argument_list|(
name|leftIdx
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LEAF
case|:
name|pfxIdx
operator|=
name|pfxIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|pfxIdx
operator|+
literal|1
operator|)
else|:
name|pfxIdx
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keys
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|keyPrefix
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|leftIdx
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|scanNextPage
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<
name|leftIdx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pfxIdx
init|;
name|i
operator|<=
name|leftIdx
operator|&&
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keys
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|keyPrefix
argument_list|)
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|scanNextPage
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
else|else
comment|// No Query - Just Walk The Tree
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEAF
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
operator|||
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|scanNextPage
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|Value
name|keyPrefix
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
block|{
name|long
name|next
init|=
name|ph
operator|.
name|getNextPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|BTreeNode
name|nextPage
init|=
name|getBTreeNode
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|nextPage
operator|.
name|scanSequential
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|scanSequential
parameter_list|(
name|IndexQuery
name|query
parameter_list|,
name|Value
name|keyPrefix
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|TerminatedException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keyPrefix
operator|!=
literal|null
operator|&&
name|keys
index|[
name|i
index|]
operator|.
name|comparePrefix
argument_list|(
name|keyPrefix
argument_list|)
operator|>
literal|0
condition|)
return|return;
name|boolean
name|test
init|=
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|NEQ
operator|&&
operator|!
name|test
condition|)
return|return;
if|if
condition|(
name|test
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|long
name|next
init|=
name|ph
operator|.
name|getNextPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|Page
operator|.
name|NO_PAGE
condition|)
block|{
name|BTreeNode
name|nextPage
init|=
name|getBTreeNode
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|nextPage
operator|.
name|scanSequential
argument_list|(
name|query
argument_list|,
name|keyPrefix
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Search for keys matching the given {@link IndexQuery} and          * remove them from the node. Every match is reported           * to the specified {@link BTreeCallback}.          *           * @param query          * @param callback          * @throws IOException          * @throws BTreeException          * @throws TerminatedException          */
specifier|private
name|void
name|remove
parameter_list|(
name|Txn
name|transaction
parameter_list|,
name|IndexQuery
name|query
parameter_list|,
name|BTreeCallback
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
throws|,
name|TerminatedException
block|{
if|if
condition|(
name|query
operator|!=
literal|null
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|ANY
operator|&&
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
condition|)
block|{
name|Value
index|[]
name|qvals
init|=
name|query
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|leftIdx
init|=
name|searchKey
argument_list|(
name|qvals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|rightIdx
init|=
name|qvals
operator|.
name|length
operator|>
literal|1
condition|?
name|searchKey
argument_list|(
name|qvals
index|[
name|qvals
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
else|:
name|leftIdx
decl_stmt|;
name|boolean
name|pos
init|=
name|query
operator|.
name|getOperator
argument_list|()
operator|>=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
name|leftIdx
operator|=
name|leftIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
else|:
name|leftIdx
operator|+
literal|1
expr_stmt|;
name|rightIdx
operator|=
name|rightIdx
operator|<
literal|0
condition|?
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
else|:
name|rightIdx
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|==
name|pos
condition|)
block|{
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
break|break;
block|}
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|EQ
case|:
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
name|i
operator|==
name|leftIdx
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
case|case
name|IndexQuery
operator|.
name|LT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|// If it's not implemented, we walk the tree
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
name|getChildNode
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|transaction
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LEAF
case|:
switch|switch
condition|(
name|query
operator|.
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|IndexQuery
operator|.
name|EQ
case|:
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|leftIdx
argument_list|,
name|keys
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|leftIdx
index|]
argument_list|,
name|ptrs
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|leftIdx
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|leftIdx
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|leftIdx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|NEQ
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|leftIdx
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|BWX
case|:
case|case
name|IndexQuery
operator|.
name|NBWX
case|:
case|case
name|IndexQuery
operator|.
name|BW
case|:
case|case
name|IndexQuery
operator|.
name|NBW
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|TRUNC_RIGHT
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<
name|rightIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|||
name|i
operator|>=
name|rightIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
name|leftIdx
init|;
name|i
operator|<
name|rightIdx
operator|&&
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rightIdx
operator|>=
name|nPtrs
condition|)
name|removeSequential
argument_list|(
name|transaction
argument_list|,
name|this
argument_list|,
name|query
argument_list|,
name|callback
argument_list|)
expr_stmt|;
break|break;
case|case
name|IndexQuery
operator|.
name|IN
case|:
case|case
name|IndexQuery
operator|.
name|NIN
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rightIdx
operator|<
literal|0
condition|)
name|rightIdx
operator|=
operator|-
operator|(
name|rightIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pos
operator|||
operator|(
name|i
operator|>=
name|leftIdx
operator|&&
name|i
operator|<=
name|rightIdx
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|LT
case|:
case|case
name|IndexQuery
operator|.
name|GEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
condition|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
break|break;
case|case
name|IndexQuery
operator|.
name|GT
case|:
case|case
name|IndexQuery
operator|.
name|LEQ
case|:
if|if
condition|(
name|leftIdx
operator|<
literal|0
condition|)
name|leftIdx
operator|=
operator|-
operator|(
name|leftIdx
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pos
operator|&&
operator|(
name|i
operator|>=
name|leftIdx
operator|)
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
operator|(
name|i
operator|<=
name|leftIdx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
if|else if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|==
name|IndexQuery
operator|.
name|TRUNC_RIGHT
condition|)
break|break;
block|}
break|break;
default|default :
comment|// If it's not implemented, it falls right through
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
break|break;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
else|else
comment|// No Query - Just Walk The Tree
switch|switch
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|BRANCH
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPtrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
break|break;
case|case
name|LEAF
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|query
operator|.
name|getOperator
argument_list|()
operator|!=
name|IndexQuery
operator|.
name|TRUNC_LEFT
operator|||
name|query
operator|.
name|testValue
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isTransactional
operator|&&
name|transaction
operator|!=
literal|null
condition|)
block|{
name|RemoveValueLoggable
name|log
init|=
operator|new
name|RemoveValueLoggable
argument_list|(
name|transaction
argument_list|,
name|fileId
argument_list|,
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|writeToLog
argument_list|(
name|log
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
name|callback
operator|.
name|indexInfo
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|ptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decrementDataLen
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|removeKey
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|removePointer
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
break|break;
default|default :
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"Invalid Page Type In query"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|growPrefix
parameter_list|()
block|{
if|if
condition|(
name|nKeys
operator|==
literal|1
condition|)
block|{
name|prefix
operator|=
name|keys
index|[
literal|0
index|]
expr_stmt|;
name|keys
index|[
literal|0
index|]
operator|=
name|Value
operator|.
name|EMPTY_VALUE
expr_stmt|;
return|return;
block|}
name|int
name|idx
decl_stmt|;
name|int
name|max
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|Value
name|first
init|=
name|keys
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
name|Value
name|value
init|=
name|keys
index|[
name|i
index|]
decl_stmt|;
name|idx
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|value
operator|.
name|compareTo
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|max
condition|)
name|max
operator|=
name|idx
expr_stmt|;
block|}
name|int
name|addChars
init|=
name|max
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|addChars
operator|>
literal|0
condition|)
block|{
comment|// create new prefix with the additional characters
name|byte
index|[]
name|pdata
init|=
operator|new
name|byte
index|[
name|prefix
operator|.
name|getLength
argument_list|()
operator|+
name|addChars
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|data
argument_list|()
argument_list|,
name|prefix
operator|.
name|start
argument_list|()
argument_list|,
name|pdata
argument_list|,
literal|0
argument_list|,
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
index|[
literal|0
index|]
operator|.
name|data
argument_list|()
argument_list|,
name|keys
index|[
literal|0
index|]
operator|.
name|start
argument_list|()
argument_list|,
name|pdata
argument_list|,
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|,
name|addChars
argument_list|)
expr_stmt|;
name|prefix
operator|=
operator|new
name|Value
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|// shrink the keys by addChars characters
name|Value
name|key
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|keys
index|[
name|i
index|]
expr_stmt|;
name|keys
index|[
name|i
index|]
operator|=
operator|new
name|Value
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|,
name|key
operator|.
name|start
argument_list|()
operator|+
name|addChars
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
name|addChars
argument_list|)
expr_stmt|;
block|}
name|recalculateDataLen
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|shrinkPrefix
parameter_list|(
name|int
name|newLen
parameter_list|)
block|{
name|int
name|diff
init|=
name|prefix
operator|.
name|getLength
argument_list|()
operator|-
name|newLen
decl_stmt|;
name|Value
index|[]
name|nv
init|=
operator|new
name|Value
index|[
name|nKeys
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nKeys
condition|;
name|i
operator|++
control|)
block|{
name|Value
name|value
init|=
name|keys
index|[
name|i
index|]
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|value
operator|.
name|getLength
argument_list|()
operator|+
name|diff
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|data
argument_list|()
argument_list|,
name|prefix
operator|.
name|start
argument_list|()
operator|+
name|newLen
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
operator|.
name|data
argument_list|()
argument_list|,
name|value
operator|.
name|start
argument_list|()
argument_list|,
name|ndata
argument_list|,
name|diff
argument_list|,
name|value
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|nv
index|[
name|i
index|]
operator|=
operator|new
name|Value
argument_list|(
name|ndata
argument_list|)
expr_stmt|;
block|}
name|keys
operator|=
name|nv
expr_stmt|;
name|prefix
operator|=
operator|new
name|Value
argument_list|(
name|prefix
operator|.
name|data
argument_list|()
argument_list|,
name|prefix
operator|.
name|start
argument_list|()
argument_list|,
name|newLen
argument_list|)
expr_stmt|;
block|}
comment|/**          * Insert a key into the array of keys.          * @param val          * @param idx          */
specifier|private
name|void
name|insertKey
parameter_list|(
name|Value
name|val
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
block|{
comment|// in a leaf page we might have to adjust the prefix
if|if
condition|(
name|nKeys
operator|==
literal|0
condition|)
block|{
name|prefix
operator|=
name|val
expr_stmt|;
name|val
operator|=
name|Value
operator|.
name|EMPTY_VALUE
expr_stmt|;
block|}
else|else
block|{
name|int
name|pfxLen
init|=
name|val
operator|.
name|checkPrefix
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfxLen
operator|<
name|prefix
operator|.
name|getLength
argument_list|()
condition|)
block|{
name|shrinkPrefix
argument_list|(
name|pfxLen
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
operator|new
name|Value
argument_list|(
name|val
operator|.
name|data
argument_list|()
argument_list|,
name|val
operator|.
name|start
argument_list|()
operator|+
name|pfxLen
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
operator|-
name|pfxLen
argument_list|)
expr_stmt|;
block|}
block|}
name|resizeKeys
argument_list|(
name|nKeys
operator|+
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
argument_list|,
name|idx
argument_list|,
name|keys
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|nKeys
operator|-
name|idx
argument_list|)
expr_stmt|;
name|keys
index|[
name|idx
index|]
operator|=
name|val
expr_stmt|;
name|ph
operator|.
name|setValueCount
argument_list|(
operator|(
name|short
operator|)
operator|++
name|nKeys
argument_list|)
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * Remove a key from the array of keys.          * @param idx          */
specifier|private
name|void
name|removeKey
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|keys
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|keys
argument_list|,
name|idx
argument_list|,
name|nKeys
operator|-
name|idx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setValueCount
argument_list|(
operator|(
name|short
operator|)
operator|--
name|nKeys
argument_list|)
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * Insert a pointer into the array of pointers.          *           * @param ptr          * @param idx          */
specifier|private
name|void
name|insertPointer
parameter_list|(
name|long
name|ptr
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|resizePtrs
argument_list|(
name|nPtrs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
name|idx
argument_list|,
name|ptrs
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|nPtrs
operator|-
name|idx
argument_list|)
expr_stmt|;
name|ptrs
index|[
name|idx
index|]
operator|=
name|ptr
expr_stmt|;
operator|++
name|nPtrs
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * Remove a pointer from the array of pointers.          * @param idx          */
specifier|private
name|void
name|removePointer
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|ptrs
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|ptrs
argument_list|,
name|idx
argument_list|,
name|nPtrs
operator|-
name|idx
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|nPtrs
expr_stmt|;
name|saved
operator|=
literal|false
expr_stmt|;
block|}
comment|/**          * Search for the given key in the keys of this node.          * @param key          * @return          */
specifier|private
name|int
name|searchKey
parameter_list|(
name|Value
name|key
parameter_list|)
block|{
if|if
condition|(
name|ph
operator|.
name|getStatus
argument_list|()
operator|==
name|BRANCH
operator|&&
name|prefix
operator|!=
literal|null
condition|)
block|{
comment|// if this is a leaf page, check the common prefix first
if|if
condition|(
name|key
operator|.
name|getLength
argument_list|()
operator|<
name|prefix
operator|.
name|getLength
argument_list|()
condition|)
return|return
name|key
operator|.
name|compareTo
argument_list|(
name|prefix
argument_list|)
operator|<=
literal|0
condition|?
operator|-
literal|1
else|:
operator|-
operator|(
name|nKeys
operator|+
literal|1
operator|)
return|;
specifier|final
name|int
name|pfxCmp
init|=
name|key
operator|.
name|comparePrefix
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfxCmp
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pfxCmp
operator|>
literal|0
condition|)
return|return
operator|-
operator|(
name|nKeys
operator|+
literal|1
operator|)
return|;
name|key
operator|=
operator|new
name|Value
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|,
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
operator|-
name|prefix
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|nKeys
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>
literal|1
decl_stmt|;
name|Value
name|midVal
init|=
name|keys
index|[
name|mid
index|]
decl_stmt|;
name|int
name|cmp
init|=
name|midVal
operator|.
name|compareTo
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
if|else if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
return|return
name|mid
return|;
comment|// key found
block|}
return|return
operator|-
operator|(
name|low
operator|+
literal|1
operator|)
return|;
comment|// key not found.
block|}
specifier|private
name|void
name|resizeKeys
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
name|int
name|oldCapacity
init|=
name|keys
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|minCapacity
operator|>
name|oldCapacity
condition|)
block|{
name|Value
name|oldData
index|[]
init|=
name|keys
decl_stmt|;
name|int
name|newCapacity
init|=
operator|(
name|oldCapacity
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCapacity
operator|<
name|minCapacity
condition|)
name|newCapacity
operator|=
name|minCapacity
expr_stmt|;
name|keys
operator|=
operator|new
name|Value
index|[
name|newCapacity
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
literal|0
argument_list|,
name|keys
argument_list|,
literal|0
argument_list|,
name|nKeys
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|resizePtrs
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
name|int
name|oldCapacity
init|=
name|ptrs
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|minCapacity
operator|>
name|oldCapacity
condition|)
block|{
name|long
index|[]
name|oldData
init|=
name|ptrs
decl_stmt|;
name|int
name|newCapacity
init|=
operator|(
name|oldCapacity
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCapacity
operator|<
name|minCapacity
condition|)
name|newCapacity
operator|=
name|minCapacity
expr_stmt|;
name|ptrs
operator|=
operator|new
name|long
index|[
name|newCapacity
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
literal|0
argument_list|,
name|ptrs
argument_list|,
literal|0
argument_list|,
name|nPtrs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|////////////////////////////////////////////////////////////////////
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader()      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|()
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|PAGE_SIZE
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader(boolean)      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|boolean
name|read
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|read
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader(long)      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|)
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|pageCount
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createFileHeader(long, int)      */
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|)
block|{
return|return
operator|new
name|BTreeFileHeader
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|)
return|;
block|}
comment|/**      * @see org.exist.storage.btree.Paged#createPageHeader()      */
specifier|public
name|PageHeader
name|createPageHeader
parameter_list|()
block|{
return|return
operator|new
name|BTreePageHeader
argument_list|()
return|;
block|}
specifier|public
name|BufferStats
name|getIndexBufferStats
parameter_list|()
block|{
return|return
operator|new
name|BufferStats
argument_list|(
name|cache
operator|.
name|getBuffers
argument_list|()
argument_list|,
name|cache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|,
name|cache
operator|.
name|getHits
argument_list|()
argument_list|,
name|cache
operator|.
name|getFails
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getPercentInstance
argument_list|()
decl_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" INDEX "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Buffers occupation : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|.
name|getBuffers
argument_list|()
operator|==
literal|0
operator|&&
name|cache
operator|.
name|getUsedBuffers
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
name|nf
operator|.
name|format
argument_list|(
name|cache
operator|.
name|getUsedBuffers
argument_list|()
operator|/
operator|(
name|float
operator|)
name|cache
operator|.
name|getBuffers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" ("
operator|+
name|cache
operator|.
name|getUsedBuffers
argument_list|()
operator|+
literal|" out of "
operator|+
name|cache
operator|.
name|getBuffers
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|//buf.append(cache.getBuffers()).append(" / ");
comment|//buf.append(cache.getUsedBuffers()).append(" / ");
name|buf
operator|.
name|append
argument_list|(
literal|" Cache efficiency : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|.
name|getHits
argument_list|()
operator|==
literal|0
operator|&&
name|cache
operator|.
name|getFails
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
name|nf
operator|.
name|format
argument_list|(
name|cache
operator|.
name|getHits
argument_list|()
operator|/
operator|(
name|float
operator|)
operator|(
name|cache
operator|.
name|getFails
argument_list|()
operator|+
name|cache
operator|.
name|getHits
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//buf.append(cache.getHits()).append(" / ");
comment|//buf.append(cache.getFails());
name|LOG
operator|.
name|info
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//        try {
comment|//            treeStatistics().toLogger();
comment|//        } catch (IOException e) {
comment|//        }
block|}
specifier|protected
class|class
name|BTreeFileHeader
extends|extends
name|FileHeader
block|{
specifier|private
name|long
name|rootPage
init|=
literal|0
decl_stmt|;
specifier|private
name|short
name|fixedLen
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|BTreeFileHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|,
name|byte
name|blockSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|int
name|pageSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreeFileHeader
parameter_list|(
name|boolean
name|read
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|read
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|super
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|rootPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|fixedLen
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
return|return
name|offset
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|super
operator|.
name|write
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|rootPage
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|fixedLen
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
return|return
name|offset
return|;
block|}
comment|/** 		 *  The root page of the storage tree 		 * 		 *@param  rootPage  The new rootPage value 		 */
specifier|public
specifier|final
name|void
name|setRootPage
parameter_list|(
name|long
name|rootPage
parameter_list|)
block|{
name|this
operator|.
name|rootPage
operator|=
name|rootPage
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 		 *  The root page of the storage tree 		 * 		 *@return    The rootPage value 		 */
specifier|public
specifier|final
name|long
name|getRootPage
parameter_list|()
block|{
return|return
name|rootPage
return|;
block|}
specifier|public
name|short
name|getFixedKeyLen
parameter_list|()
block|{
return|return
name|fixedLen
return|;
block|}
specifier|public
name|void
name|setFixedKeyLen
parameter_list|(
name|short
name|keyLen
parameter_list|)
block|{
name|this
operator|.
name|fixedLen
operator|=
name|keyLen
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
class|class
name|BTreePageHeader
extends|extends
name|PageHeader
block|{
specifier|private
name|short
name|valueCount
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|parentPage
init|=
name|Page
operator|.
name|NO_PAGE
decl_stmt|;
specifier|public
name|BTreePageHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BTreePageHeader
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|//if (getStatus() == UNUSED)
comment|//	return;
name|parentPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|valueCount
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|2
return|;
block|}
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|parentPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|valueCount
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|2
return|;
block|}
specifier|public
specifier|final
name|void
name|setValueCount
parameter_list|(
name|short
name|valueCount
parameter_list|)
block|{
name|this
operator|.
name|valueCount
operator|=
name|valueCount
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 		 *  The number of values stored by this page 		 * 		 *@return    The valueCount value 		 */
specifier|public
specifier|final
name|short
name|getValueCount
parameter_list|()
block|{
return|return
name|valueCount
return|;
block|}
comment|/** 		 *  The number of pointers stored by this page 		 * 		 *@return    The pointerCount value 		 */
specifier|public
specifier|final
name|short
name|getPointerCount
parameter_list|()
block|{
if|if
condition|(
name|getStatus
argument_list|()
operator|==
name|BRANCH
condition|)
return|return
operator|(
name|short
operator|)
operator|(
name|valueCount
operator|+
literal|1
operator|)
return|;
else|else
return|return
name|valueCount
return|;
block|}
block|}
block|}
end_class

end_unit

