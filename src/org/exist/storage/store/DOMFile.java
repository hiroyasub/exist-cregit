begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
package|;
end_package

begin_comment
comment|/*  * eXist Open Source Native XML Database   * Copyright (C) 2001-04, Wolfgang M. Meier  * (wolfgang@exist-db.org)  *   * This library is free software; you can redistribute it and/or modify it under  * the terms of the GNU Library General Public License as published by the Free  * Software Foundation; either version 2 of the License, or (at your option) any  * later version.  *   * This library is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  * FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more  * details.  *   * You should have received a copy of the GNU Library General Public License  * along with this program; if not, write to the Free Software Foundation, Inc.,  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *   * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|data
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTreeCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|filer
operator|.
name|BTreeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|indexer
operator|.
name|IndexQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|DocumentImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeIndexListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|NodeProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|BufferStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|NativeBroker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|Signatures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|Cacheable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|cache
operator|.
name|ClockCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Lockable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|hashtable
operator|.
name|Object2LongIdentityHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_comment
comment|/**  * This is the main storage for XML nodes. Nodes are stored in document order.  * Every document gets its own sequence of pages, which is bound to the  * writing thread to avoid conflicting writes. The page structure is as follows:  *   * | page header | (tid1 node-data, tid2 node-data, ..., tidn node-data) |  *   * node-data contains the raw binary data of the node as returned by {@link org.exist.dom.NodeImpl#serialize()}.  * Within a page, a node is identified by a unique id, called tuple id (tid). Every node   * can thus be located by a virtual address pointer, which consists of the page id and   * the tid. Both components are encoded in a long value (with additional bits used for  * optional flags). The address pointer is used to reference nodes from the indexes. It should   * thus remain unchanged during the life-time of a document.  *   * However, XUpdate requests may insert new nodes in the middle of a page. In these  * cases, the page will be split and the upper portion of the page is copied to a split page.  * The record in the original page will be replaced by a forward link, pointing to the new  * location of the node data in the split page.  *   * As a consequence, the class has to distinguish three different types of data records:  *   * 1) Ordinary record:  *   * | tid | length | data |  *   * 3) Relocated record:  *   * | tid | length | address pointer to original location | data |  *   * 2) Forward link:  *   * | tid | address pointer |  *   * tid and length each use two bytes (short), address pointers 8 bytes (long).  * The upper two bits of the tid are used to indicate the type of the record   * (see {@see org.exist.storage.store.ItemId}).  *   * @author Wolfgang Meier<wolfgang@exist-db.org>  */
end_comment

begin_class
specifier|public
class|class
name|DOMFile
extends|extends
name|BTree
implements|implements
name|Lockable
block|{
specifier|public
specifier|final
specifier|static
name|short
name|FILE_FORMAT_VERSION_ID
init|=
literal|2
decl_stmt|;
comment|// page types
specifier|public
specifier|final
specifier|static
name|byte
name|LOB
init|=
literal|21
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
name|RECORD
init|=
literal|20
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|short
name|OVERFLOW
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|Cache
name|dataCache
decl_stmt|;
specifier|private
name|DOMFileHeader
name|fileHeader
decl_stmt|;
specifier|private
name|Object
name|owner
init|=
literal|null
decl_stmt|;
specifier|private
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|Object2LongIdentityHashMap
name|pages
init|=
operator|new
name|Object2LongIdentityHashMap
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|public
name|DOMFile
parameter_list|(
name|int
name|buffers
parameter_list|,
name|int
name|dataBuffers
parameter_list|)
block|{
name|super
argument_list|(
name|buffers
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|"dom.dbx"
argument_list|)
expr_stmt|;
name|fileHeader
operator|=
operator|(
name|DOMFileHeader
operator|)
name|getFileHeader
argument_list|()
expr_stmt|;
name|fileHeader
operator|.
name|setPageCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|setTotalCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dataCache
operator|=
operator|new
name|ClockCache
argument_list|(
name|dataBuffers
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|setFileName
argument_list|(
literal|"dom.dbx"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DOMFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|this
argument_list|(
literal|256
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DOMFile
parameter_list|(
name|File
name|file
parameter_list|,
name|int
name|buffers
parameter_list|)
block|{
name|this
argument_list|(
name|buffers
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DOMFile
parameter_list|(
name|File
name|file
parameter_list|,
name|int
name|buffers
parameter_list|,
name|int
name|dataBuffers
parameter_list|)
block|{
name|this
argument_list|(
name|buffers
argument_list|,
name|dataBuffers
argument_list|)
expr_stmt|;
name|setFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|Cache
name|getPageBuffer
parameter_list|()
block|{
return|return
name|dataCache
return|;
block|}
comment|/**      * @return      */
specifier|public
name|short
name|getFileVersion
parameter_list|()
block|{
return|return
name|FILE_FORMAT_VERSION_ID
return|;
block|}
comment|/**      * Append a value to the current page.       *       * This method is called when storing a new document. Each writing      * thread gets its own sequence of pages for writing a document, so all      * document nodes are stored in sequential order. A new page will be allocated      * if the current page is full. If the value is larger than the page size, it will       * be written to an overflow page.      *       * @param value      *                   the value to append      * @return the virtual storage address of the value      */
specifier|public
name|long
name|add
parameter_list|(
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|// overflow value?
if|if
condition|(
name|value
operator|.
name|length
operator|+
literal|4
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
name|overflow
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|byte
index|[]
name|pnum
init|=
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|overflow
operator|.
name|getPageNum
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|pnum
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
return|return
name|add
argument_list|(
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Append a value to the current page. If overflowPage is      * true, the value will be saved into its own, reserved chain      * of pages. The current page will just contain a link to the first      * overflow page.      *       * @param value      * @param overflowPage      * @return      * @throws ReadOnlyException      */
specifier|private
name|long
name|add
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|boolean
name|overflowPage
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
specifier|final
name|int
name|valueLen
init|=
name|value
operator|.
name|length
decl_stmt|;
comment|// always append data to the end of the file
name|DOMPage
name|page
init|=
name|getCurrentPage
argument_list|()
decl_stmt|;
comment|// does value fit into current data page?
if|if
condition|(
name|page
operator|==
literal|null
operator|||
name|page
operator|.
name|len
operator|+
literal|4
operator|+
name|valueLen
operator|>
name|page
operator|.
name|data
operator|.
name|length
condition|)
block|{
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
name|DOMFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
name|page
operator|=
name|newPage
expr_stmt|;
name|setCurrentPage
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
block|}
comment|// save tuple identifier
specifier|final
name|DOMFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
specifier|final
name|short
name|tid
init|=
name|ph
operator|.
name|getNextTID
argument_list|()
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tid
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
literal|2
expr_stmt|;
comment|// save data length
comment|// overflow pages have length 0
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|overflowPage
condition|?
name|OVERFLOW
else|:
operator|(
name|short
operator|)
name|valueLen
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
literal|2
expr_stmt|;
comment|// save data
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|page
operator|.
name|data
argument_list|,
name|page
operator|.
name|len
argument_list|,
name|valueLen
argument_list|)
expr_stmt|;
name|page
operator|.
name|len
operator|+=
name|valueLen
expr_stmt|;
name|ph
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// create pointer from pageNum and offset into page
specifier|final
name|long
name|p
init|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
comment|/**      * Store a raw binary resource into the file. The data will always      * be written into an overflow page.      *       * @param value      * @return      */
specifier|public
name|long
name|addBinary
parameter_list|(
name|byte
index|[]
name|value
parameter_list|)
block|{
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
name|overflow
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|overflow
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/**      * Return binary data stored with {@link #addBinary(byte[])}.      *       * @param pageNum      * @return      */
specifier|public
name|byte
index|[]
name|getBinary
parameter_list|(
name|long
name|pageNum
parameter_list|)
block|{
return|return
name|getOverflowValue
argument_list|(
name|pageNum
argument_list|)
return|;
block|}
comment|/**      * Insert a new node after the specified node.      *       * @param key      * @param value      * @return      */
specifier|public
name|long
name|insertAfter
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|Value
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
try|try
block|{
specifier|final
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|insertAfter
argument_list|(
name|doc
argument_list|,
name|p
argument_list|,
name|value
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"key not found"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IO error"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Insert a new node after the node located at the specified address.      *       * If the previous node is in the middle of a page, the page is split. If the      * node is appended at the end and the page does not have enough room      * for the node, a new page is added to the page sequence.      *       * @param doc      *                   the document to which the new node belongs.      * @param address      *                   the storage address of the node after which the new value      *                   should be inserted.      * @param value      *                   the value of the new node.      * @return      */
specifier|public
name|long
name|insertAfter
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|long
name|address
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
comment|//check if we need an overflow page
name|boolean
name|isOverflow
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|length
operator|+
literal|4
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|()
decl_stmt|;
comment|//			LOG.debug("creating overflow page: " + overflow.getPageNum());
name|overflow
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|overflow
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|isOverflow
operator|=
literal|true
expr_stmt|;
block|}
comment|// locate the node to insert after
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|rec
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"page not found"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|OVERFLOW
condition|)
name|rec
operator|.
name|offset
operator|+=
literal|10
expr_stmt|;
else|else
name|rec
operator|.
name|offset
operator|=
name|rec
operator|.
name|offset
operator|+
name|l
operator|+
literal|2
expr_stmt|;
name|int
name|dataLen
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// insert in the middle of the page?
if|if
condition|(
name|rec
operator|.
name|offset
operator|<
name|dataLen
condition|)
block|{
if|if
condition|(
name|dataLen
operator|+
name|value
operator|.
name|length
operator|+
literal|4
operator|<
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|//                LOG
comment|//                        .debug("copying data in page " + rec.page.getPageNum()
comment|//                                + "; offset = " + rec.offset + "; dataLen = "
comment|//                                + dataLen);
comment|// new value fits into the page
name|int
name|end
init|=
name|rec
operator|.
name|offset
operator|+
name|value
operator|.
name|length
operator|+
literal|4
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|dataLen
operator|-
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|dataLen
operator|+
name|value
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// doesn't fit: split the page
name|rec
operator|=
name|splitDataPage
argument_list|(
name|doc
argument_list|,
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|offset
operator|+
name|value
operator|.
name|length
operator|+
literal|4
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|// still not enough free space: create a new page
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating additional page: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|=
name|newPage
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|value
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|rec
operator|.
name|offset
operator|+
name|value
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|dataLen
operator|=
name|rec
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|dataLen
operator|+
name|value
operator|.
name|length
operator|+
literal|4
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|// does value fit into page?
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating new page: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|=
name|newPage
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|value
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|dataLen
operator|+
name|value
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|// write the data
name|short
name|tid
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextTID
argument_list|()
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
operator|(
name|short
operator|)
name|tid
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|2
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|isOverflow
condition|?
literal|0
else|:
operator|(
name|short
operator|)
name|value
operator|.
name|length
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|2
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|value
operator|.
name|length
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
return|return
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
return|;
block|}
comment|/**      * Split a data page at the position indicated by the rec parameter.      *       * The portion of the page starting at rec.offset is moved into a new page.      * Every moved record is marked as relocated and a link is stored into      * the original page to point to the new record position.        *       * @param doc      * @param rec      */
specifier|private
name|RecordPos
name|splitDataPage
parameter_list|(
name|DocumentImpl
name|doc
parameter_list|,
name|RecordPos
name|rec
parameter_list|)
block|{
name|NodeIndexListener
name|idx
init|=
name|doc
operator|.
name|getIndexListener
argument_list|()
decl_stmt|;
name|int
name|oldDataLen
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|oldData
init|=
name|rec
operator|.
name|page
operator|.
name|data
decl_stmt|;
name|long
name|oldPageNum
init|=
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
decl_stmt|;
name|rec
operator|.
name|page
operator|.
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|rec
operator|.
name|offset
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DOMPage
name|firstSplitPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|DOMPage
name|nextSplitPage
init|=
name|firstSplitPage
decl_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextTID
argument_list|(
operator|(
name|short
operator|)
operator|(
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextTID
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|short
name|tid
decl_stmt|,
name|currentId
decl_stmt|,
name|currentLen
decl_stmt|;
name|long
name|backLink
decl_stmt|;
name|short
name|splitRecordCount
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"splitting "
operator|+
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": new: "
operator|+
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
name|rec
operator|.
name|offset
init|;
name|pos
operator|<
name|oldDataLen
condition|;
name|splitRecordCount
operator|++
control|)
block|{
comment|// read the current id
name|currentId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|tid
operator|=
name|ItemId
operator|.
name|getId
argument_list|(
name|currentId
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
comment|/* This is already a link, so we just copy it */
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|currentId
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|+=
literal|2
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|page
operator|.
name|len
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|+=
literal|8
expr_stmt|;
name|pos
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
comment|// read data length
name|currentLen
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|nextSplitPage
operator|.
name|len
operator|+
name|currentLen
operator|+
literal|12
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|// not enough room in the split page: append a new page
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextTID
argument_list|(
operator|(
name|short
operator|)
operator|(
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextTID
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating new split page: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
name|splitRecordCount
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextSplitPage
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|=
name|newPage
expr_stmt|;
name|splitRecordCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if the record has already been relocated, read the original storage              * address and update the link there.              */
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
name|backLink
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|8
expr_stmt|;
name|RecordPos
name|origRec
init|=
name|findRecord
argument_list|(
name|backLink
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|long
name|forwardLink
init|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|forwardLink
argument_list|,
name|origRec
operator|.
name|page
operator|.
name|data
argument_list|,
name|origRec
operator|.
name|offset
argument_list|)
expr_stmt|;
name|origRec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|origRec
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
else|else
name|backLink
operator|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|// set the relocated flag and save the item id
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|ItemId
operator|.
name|setIsRelocated
argument_list|(
name|currentId
argument_list|)
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|len
operator|+=
literal|2
expr_stmt|;
comment|//	save length field
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|currentLen
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|len
operator|+=
literal|2
expr_stmt|;
comment|// save link to the original page
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|backLink
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|len
operator|+=
literal|8
expr_stmt|;
comment|// now save the data if this is not an overflow record
if|if
condition|(
name|currentLen
operator|!=
name|OVERFLOW
condition|)
block|{
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
name|pos
argument_list|,
name|nextSplitPage
operator|.
name|data
argument_list|,
name|nextSplitPage
operator|.
name|len
argument_list|,
name|currentLen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"pos = "
operator|+
name|pos
operator|+
literal|"; len = "
operator|+
name|nextSplitPage
operator|.
name|len
operator|+
literal|"; currentLen = "
operator|+
name|currentLen
operator|+
literal|"; tid = "
operator|+
name|currentId
operator|+
literal|"; page = "
operator|+
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|nextSplitPage
operator|.
name|len
operator|+=
name|currentLen
expr_stmt|;
name|pos
operator|+=
name|currentLen
expr_stmt|;
block|}
comment|// report the split to the index listener
if|if
condition|(
name|idx
operator|!=
literal|null
condition|)
block|{
name|idx
operator|.
name|nodeChanged
argument_list|(
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|oldPageNum
argument_list|,
name|tid
argument_list|)
argument_list|,
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// save a link pointer in the original page if the record has not been
comment|// relocated before.
if|if
condition|(
operator|!
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
if|if
condition|(
name|rec
operator|.
name|page
operator|.
name|len
operator|+
literal|10
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|)
block|{
comment|// the link doesn't fit into the old page. Append a new page
name|DOMPage
name|newPage
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextTID
argument_list|(
operator|(
name|short
operator|)
operator|(
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextTID
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating new: "
operator|+
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|np
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
decl_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|newPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
name|countRecordsInPage
argument_list|(
name|rec
operator|.
name|page
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|newPage
argument_list|)
expr_stmt|;
name|newPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|=
name|newPage
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|ItemId
operator|.
name|setIsLink
argument_list|(
name|currentId
argument_list|)
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|+=
literal|2
expr_stmt|;
name|long
name|forwardLink
init|=
name|StorageAddress
operator|.
name|createPointer
argument_list|(
operator|(
name|int
operator|)
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|forwardLink
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextSplitPage
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|// if nothing has been copied to the last split page,
comment|// remove it
name|dataCache
operator|.
name|remove
argument_list|(
name|nextSplitPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextSplitPage
operator|==
name|firstSplitPage
condition|)
name|firstSplitPage
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|unlinkPages
argument_list|(
name|nextSplitPage
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to remove empty split page: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|nextSplitPage
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|nextSplitPage
operator|.
name|len
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
name|splitRecordCount
argument_list|)
expr_stmt|;
name|nextSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextSplitPage
argument_list|)
expr_stmt|;
name|firstSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextSplitPage
operator|!=
name|firstSplitPage
condition|)
block|{
name|firstSplitPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|firstSplitPage
argument_list|)
expr_stmt|;
block|}
name|long
name|next
init|=
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<
name|next
condition|)
block|{
name|DOMPage
name|nextPage
init|=
name|getCurrentPage
argument_list|(
name|nextSplitPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|nextPage
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|nextSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|nextPage
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|firstSplitPage
operator|!=
literal|null
condition|)
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|firstSplitPage
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setRecordCount
argument_list|(
name|countRecordsInPage
argument_list|(
name|rec
operator|.
name|page
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
name|rec
operator|.
name|page
operator|.
name|len
expr_stmt|;
return|return
name|rec
return|;
block|}
comment|/**      * Returns the number of records stored in a page.      *       * @param page      * @return      */
specifier|private
name|short
name|countRecordsInPage
parameter_list|(
name|DOMPage
name|page
parameter_list|)
block|{
name|short
name|count
init|=
literal|0
decl_stmt|;
name|short
name|currentId
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|dlen
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dlen
condition|;
name|count
operator|++
control|)
block|{
name|currentId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
name|pos
operator|+=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|vlen
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
literal|20
else|:
name|vlen
operator|+
literal|12
expr_stmt|;
block|}
else|else
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
literal|12
else|:
name|vlen
operator|+
literal|4
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" has "
operator|+
name|count
operator|+
literal|" records."
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
specifier|private
name|void
name|printPageContents
parameter_list|(
name|DOMPage
name|page
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|": "
argument_list|)
expr_stmt|;
name|short
name|count
init|=
literal|0
decl_stmt|;
name|short
name|currentId
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|dlen
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|dlen
condition|;
name|count
operator|++
control|)
block|{
name|currentId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|currentId
operator|+
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
name|pos
operator|+=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|vlen
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
literal|20
else|:
name|vlen
operator|+
literal|12
expr_stmt|;
block|}
else|else
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
literal|12
else|:
name|vlen
operator|+
literal|4
expr_stmt|;
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" has "
operator|+
name|count
operator|+
literal|" records."
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|close
parameter_list|()
throws|throws
name|DBException
block|{
name|flush
argument_list|()
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|create
parameter_list|()
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|create
argument_list|(
operator|(
name|short
operator|)
literal|12
argument_list|)
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|()
block|{
return|return
operator|new
name|DOMFileHeader
argument_list|(
literal|1024
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|boolean
name|read
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|DOMFileHeader
argument_list|(
name|read
argument_list|)
return|;
block|}
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|)
block|{
return|return
operator|new
name|DOMFileHeader
argument_list|(
name|pageCount
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
block|}
specifier|public
name|FileHeader
name|createFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|)
block|{
return|return
operator|new
name|DOMFileHeader
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|)
return|;
block|}
specifier|protected
name|Page
name|createNewPage
parameter_list|()
block|{
try|try
block|{
name|Page
name|page
init|=
name|getFreePage
argument_list|()
decl_stmt|;
name|DOMFilePageHeader
name|ph
init|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|ph
operator|.
name|setStatus
argument_list|(
name|RECORD
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextDataPage
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setPrevDataPage
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextTID
argument_list|(
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|//page.write();
return|return
name|page
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|protected
name|void
name|unlinkPages
parameter_list|(
name|Page
name|page
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|public
name|PageHeader
name|createPageHeader
parameter_list|()
block|{
return|return
operator|new
name|DOMFilePageHeader
argument_list|()
return|;
block|}
specifier|public
name|ArrayList
name|findKeys
parameter_list|(
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
specifier|final
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|KEYS
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
specifier|private
name|long
name|findNode
parameter_list|(
name|NodeImpl
name|node
parameter_list|,
name|long
name|target
parameter_list|,
name|Iterator
name|iter
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
specifier|final
name|long
name|firstChildId
init|=
name|XMLUtil
operator|.
name|getFirstChildId
argument_list|(
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getOwnerDocument
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChildId
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"first child not found: "
operator|+
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|final
name|long
name|lastChildId
init|=
name|firstChildId
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|long
name|p
decl_stmt|;
for|for
control|(
name|long
name|gid
init|=
name|firstChildId
init|;
name|gid
operator|<
name|lastChildId
condition|;
name|gid
operator|++
control|)
block|{
name|NodeImpl
name|child
init|=
operator|(
name|NodeImpl
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Next node missing. gid = "
operator|+
name|gid
operator|+
literal|"; last = "
operator|+
name|lastChildId
operator|+
literal|"; parent= "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"; count = "
operator|+
name|node
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|==
name|target
condition|)
block|{
return|return
operator|(
operator|(
name|NodeIterator
operator|)
name|iter
operator|)
operator|.
name|currentAddress
argument_list|()
return|;
block|}
name|child
operator|.
name|setGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findNode
argument_list|(
name|child
argument_list|,
name|target
argument_list|,
name|iter
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|p
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/**      * Find a node by searching for a known ancestor in the index. If an      * ancestor is found, it is traversed to locate the specified descendant      * node.      *       * @param lock      * @param node      * @return @throws      *              IOException      * @throws BTreeException      */
specifier|protected
name|long
name|findValue
parameter_list|(
name|Object
name|lock
parameter_list|,
name|NodeProxy
name|node
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
specifier|final
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|node
operator|.
name|getDoc
argument_list|()
decl_stmt|;
specifier|final
name|NativeBroker
operator|.
name|NodeRef
name|nodeRef
init|=
operator|new
name|NativeBroker
operator|.
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|node
operator|.
name|getGID
argument_list|()
argument_list|)
decl_stmt|;
comment|// first try to find the node in the index
specifier|final
name|long
name|p
init|=
name|findValue
argument_list|(
name|nodeRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
block|{
comment|// node not found in index: try to find the nearest available
comment|// ancestor and traverse it
name|long
name|id
init|=
name|node
operator|.
name|getGID
argument_list|()
decl_stmt|;
name|long
name|parentPointer
init|=
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|id
operator|=
name|XMLUtil
operator|.
name|getParentId
argument_list|(
name|doc
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|node
operator|.
name|gid
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|BTreeException
argument_list|(
literal|"node "
operator|+
name|node
operator|.
name|gid
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|NativeBroker
operator|.
name|NodeRef
name|parentRef
init|=
operator|new
name|NativeBroker
operator|.
name|NodeRef
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
try|try
block|{
name|parentPointer
operator|=
name|findValue
argument_list|(
name|parentRef
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
block|}
block|}
do|while
condition|(
name|parentPointer
operator|==
name|KEY_NOT_FOUND
condition|)
do|;
specifier|final
name|long
name|firstChildId
init|=
name|XMLUtil
operator|.
name|getFirstChildId
argument_list|(
name|doc
argument_list|,
name|id
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
name|iter
init|=
operator|new
name|NodeIterator
argument_list|(
name|lock
argument_list|,
name|this
argument_list|,
name|node
operator|.
name|doc
argument_list|,
name|parentPointer
argument_list|)
decl_stmt|;
specifier|final
name|NodeImpl
name|n
init|=
operator|(
name|NodeImpl
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|n
operator|.
name|setGID
argument_list|(
name|id
argument_list|)
expr_stmt|;
specifier|final
name|long
name|address
init|=
name|findNode
argument_list|(
name|n
argument_list|,
name|node
operator|.
name|gid
argument_list|,
name|iter
argument_list|)
decl_stmt|;
return|return
name|address
operator|==
literal|0
condition|?
name|KEY_NOT_FOUND
else|:
name|address
return|;
block|}
else|else
return|return
name|p
return|;
block|}
comment|/**      * Find matching nodes for the given query.      *       * @param query      *                   Description of the Parameter      * @return Description of the Return Value      * @exception IOException      *                        Description of the Exception      * @exception BTreeException      *                        Description of the Exception      */
specifier|public
name|ArrayList
name|findValues
parameter_list|(
name|IndexQuery
name|query
parameter_list|)
throws|throws
name|IOException
throws|,
name|BTreeException
block|{
name|FindCallback
name|cb
init|=
operator|new
name|FindCallback
argument_list|(
name|FindCallback
operator|.
name|VALUES
argument_list|)
decl_stmt|;
name|query
argument_list|(
name|query
argument_list|,
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getValues
argument_list|()
return|;
block|}
comment|/**      * Flush all buffers to disk.      *       * @return Description of the Return Value      * @exception DBException      *                        Description of the Exception      */
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|DBException
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
name|dataCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|pages
operator|.
name|remove
argument_list|(
name|owner
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|fileHeader
operator|.
name|isDirty
argument_list|()
condition|)
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"sync failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|DBException
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
name|dataCache
operator|.
name|flush
argument_list|()
expr_stmt|;
name|pages
operator|.
name|remove
argument_list|(
name|owner
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|fileHeader
operator|.
name|isDirty
argument_list|()
condition|)
name|fileHeader
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"sync failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
name|super
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" DATA "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dataCache
operator|.
name|getHits
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dataCache
operator|.
name|getFails
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BufferStats
name|getDataBufferStats
parameter_list|()
block|{
return|return
operator|new
name|BufferStats
argument_list|(
name|dataCache
operator|.
name|getBuffers
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getUsedBuffers
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getHits
argument_list|()
argument_list|,
name|dataCache
operator|.
name|getFails
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Retrieve a node by key      *       * @param key      * @return Description of the Return Value      */
specifier|public
name|Value
name|get
parameter_list|(
name|Value
name|key
parameter_list|)
block|{
try|try
block|{
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
literal|null
return|;
return|return
name|get
argument_list|(
name|p
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
return|return
literal|null
return|;
comment|// key not found
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Retrieve a node described by the given NodeProxy.      *       * @param node      *                   Description of the Parameter      * @return Description of the Return Value      */
specifier|public
name|Value
name|get
parameter_list|(
name|NodeProxy
name|node
parameter_list|)
block|{
try|try
block|{
name|long
name|p
init|=
name|findValue
argument_list|(
name|owner
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
literal|null
return|;
return|return
name|get
argument_list|(
name|p
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Retrieve node at virtual address p.      *       * @param p      *                   Description of the Parameter      * @return Description of the Return Value      */
specifier|public
name|Value
name|get
parameter_list|(
name|long
name|p
parameter_list|)
block|{
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|rec
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"object at "
operator|+
name|StorageAddress
operator|.
name|toString
argument_list|(
name|p
argument_list|)
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|dumpStack
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
name|Value
name|v
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|OVERFLOW
condition|)
block|{
name|long
name|pnum
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|getOverflowValue
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
name|v
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
name|v
operator|=
operator|new
name|Value
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|v
operator|.
name|setAddress
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
specifier|protected
name|byte
index|[]
name|getOverflowValue
parameter_list|(
name|long
name|pnum
parameter_list|)
block|{
try|try
block|{
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
return|return
name|overflow
operator|.
name|read
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while loading overflow value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|removeOverflowValue
parameter_list|(
name|long
name|pnum
parameter_list|)
block|{
try|try
block|{
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
name|overflow
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while removing overflow value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Retrieve the last page in the current sequence.      *       * @return The currentPage value      */
specifier|private
specifier|final
name|DOMPage
name|getCurrentPage
parameter_list|()
block|{
name|long
name|pnum
init|=
name|pages
operator|.
name|get
argument_list|(
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|pnum
operator|<
literal|0
condition|)
block|{
specifier|final
name|DOMPage
name|page
init|=
operator|new
name|DOMPage
argument_list|()
decl_stmt|;
name|pages
operator|.
name|put
argument_list|(
name|owner
argument_list|,
name|page
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
else|else
return|return
name|getCurrentPage
argument_list|(
name|pnum
argument_list|)
return|;
block|}
comment|/**      * Retrieve the page with page number p      *       * @param p      *                   Description of the Parameter      * @return The currentPage value      */
specifier|protected
specifier|final
name|DOMPage
name|getCurrentPage
parameter_list|(
name|long
name|p
parameter_list|)
block|{
name|DOMPage
name|page
init|=
operator|(
name|DOMPage
operator|)
name|dataCache
operator|.
name|get
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|page
operator|=
operator|new
name|DOMPage
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|page
return|;
block|}
specifier|public
name|void
name|closeDocument
parameter_list|()
block|{
name|pages
operator|.
name|remove
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
comment|/**      * Open the file.      *       * @return Description of the Return Value      * @exception DBException      *                        Description of the Exception      */
specifier|public
name|boolean
name|open
parameter_list|()
throws|throws
name|DBException
block|{
if|if
condition|(
name|super
operator|.
name|open
argument_list|(
name|FILE_FORMAT_VERSION_ID
argument_list|)
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
comment|/**      * Put a new key/value pair.      *       * @param key      *                   Description of the Parameter      * @param value      *                   Description of the Parameter      * @return Description of the Return Value      */
specifier|public
name|long
name|put
parameter_list|(
name|Value
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|long
name|p
init|=
name|add
argument_list|(
name|value
argument_list|)
decl_stmt|;
try|try
block|{
name|addValue
argument_list|(
name|key
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|p
return|;
block|}
comment|/**      * Physically remove a node. The data of the node will be removed from      * the page and the occupied space is freed.      */
specifier|public
name|void
name|remove
parameter_list|(
name|Value
name|key
parameter_list|)
block|{
try|try
block|{
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return;
name|remove
argument_list|(
name|key
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Remove the link at the specified position from the file.      *       * @param p      */
specifier|private
name|void
name|removeLink
parameter_list|(
name|long
name|p
parameter_list|)
block|{
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|DOMFilePageHeader
name|ph
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|rec
operator|.
name|offset
operator|+
literal|8
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|+
literal|8
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|-
literal|2
argument_list|,
name|rec
operator|.
name|page
operator|.
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|rec
operator|.
name|page
operator|.
name|len
operator|-
literal|10
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|rec
operator|.
name|page
operator|.
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ph
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
comment|//        LOG.debug("size = " + ph.getRecordCount());
if|if
condition|(
name|rec
operator|.
name|page
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"freeing page "
operator|+
name|rec
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|removePage
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
comment|//printPageContents(rec.page);
block|}
block|}
comment|/**      * Physically remove a node. The data of the node will be removed from      * the page and the occupied space is freed.      *       * @param p      */
specifier|public
name|void
name|remove
parameter_list|(
name|long
name|p
parameter_list|)
block|{
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|//        LOG.debug("removing value from " + rec.page.getPageNum());
name|int
name|startOffset
init|=
name|rec
operator|.
name|offset
operator|-
literal|2
decl_stmt|;
name|DOMFilePageHeader
name|ph
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot remove link ..."
argument_list|)
throw|;
block|}
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
block|{
name|long
name|backLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|removeLink
argument_list|(
name|backLink
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
name|l
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
name|OVERFLOW
condition|)
block|{
comment|// remove overflow value
name|long
name|pnum
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
try|try
block|{
name|OverflowDOMPage
name|overflow
init|=
operator|new
name|OverflowDOMPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
name|overflow
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while removing overflow page"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|l
operator|+=
literal|8
expr_stmt|;
block|}
name|int
name|end
init|=
name|startOffset
operator|+
literal|4
operator|+
name|l
decl_stmt|;
name|int
name|len
init|=
name|ph
operator|.
name|getDataLength
argument_list|()
decl_stmt|;
comment|// remove old value
name|System
operator|.
name|arraycopy
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|end
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|startOffset
argument_list|,
name|len
operator|-
name|end
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|len
operator|=
name|len
operator|-
name|l
operator|-
literal|4
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ph
operator|.
name|decRecordCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|page
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|removePage
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
name|rec
operator|.
name|page
operator|=
literal|null
expr_stmt|;
block|}
else|else
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
comment|/**      * Physically remove a node. The data of the node will be removed from      * the page and the occupied space is freed.       */
specifier|public
name|void
name|remove
parameter_list|(
name|Value
name|key
parameter_list|,
name|long
name|p
parameter_list|)
block|{
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
try|try
block|{
name|removeValue
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while removing node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while removing node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Remove the specified page. The page is added      * to the list of free pages.      *       * @param page      */
specifier|public
name|void
name|removePage
parameter_list|(
name|DOMPage
name|page
parameter_list|)
block|{
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|DOMFilePageHeader
name|ph
init|=
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|ph
operator|.
name|getNextDataPage
argument_list|()
operator|>
operator|-
literal|1
condition|)
block|{
name|DOMPage
name|next
init|=
name|getCurrentPage
argument_list|(
name|ph
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|next
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setPrevDataPage
argument_list|(
name|ph
operator|.
name|getPrevDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|next
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ph
operator|.
name|getPrevDataPage
argument_list|()
operator|>
operator|-
literal|1
condition|)
block|{
name|DOMPage
name|prev
init|=
name|getCurrentPage
argument_list|(
name|ph
operator|.
name|getPrevDataPage
argument_list|()
argument_list|)
decl_stmt|;
name|prev
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextDataPage
argument_list|(
name|ph
operator|.
name|getNextDataPage
argument_list|()
argument_list|)
expr_stmt|;
name|prev
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|ph
operator|.
name|setNextDataPage
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setDataLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setNextTID
argument_list|(
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ph
operator|.
name|setRecordCount
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeAll
parameter_list|(
name|long
name|p
parameter_list|)
block|{
name|long
name|pnum
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|<
name|pnum
condition|)
block|{
name|DOMPage
name|page
init|=
name|getCurrentPage
argument_list|(
name|pnum
argument_list|)
decl_stmt|;
name|pnum
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
expr_stmt|;
name|dataCache
operator|.
name|remove
argument_list|(
name|page
argument_list|)
expr_stmt|;
try|try
block|{
name|unlinkPages
argument_list|(
name|page
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while removing page: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set the last page in the sequence to which nodes are currently appended.      *       * @param page      *                   The new currentPage value      */
specifier|private
specifier|final
name|void
name|setCurrentPage
parameter_list|(
name|DOMPage
name|page
parameter_list|)
block|{
specifier|final
name|long
name|pnum
init|=
name|pages
operator|.
name|get
argument_list|(
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|pnum
operator|==
name|page
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
condition|)
return|return;
comment|//pages.remove(owner);
name|pages
operator|.
name|put
argument_list|(
name|owner
argument_list|,
name|page
operator|.
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the active Lock object for this file.      *       * @see org.exist.util.Lockable#getLock()      */
specifier|public
specifier|final
name|Lock
name|getLock
parameter_list|()
block|{
return|return
name|lock
return|;
block|}
comment|/**      * The current object owning this file.      *       * @param obj      *                   The new ownerObject value      */
specifier|public
specifier|final
name|void
name|setOwnerObject
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|owner
operator|=
name|obj
expr_stmt|;
block|}
specifier|public
specifier|final
name|void
name|releaseOwner
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|//pages.remove(obj);
block|}
comment|/**      * Update the key/value pair.      *       * @param key      *                   Description of the Parameter      * @param value      *                   Description of the Parameter      * @return Description of the Return Value      */
specifier|public
name|boolean
name|update
parameter_list|(
name|Value
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
try|try
block|{
name|long
name|p
init|=
name|findValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|KEY_NOT_FOUND
condition|)
return|return
literal|false
return|;
name|update
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|bte
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|bte
argument_list|)
expr_stmt|;
name|bte
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Update the key/value pair where the value is found at address p.      *       * @param key      *                   Description of the Parameter      * @param p      *                   Description of the Parameter      * @param value      *                   Description of the Parameter      */
specifier|public
name|void
name|update
parameter_list|(
name|long
name|p
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|length
operator|<
name|l
condition|)
block|{
comment|// value is smaller than before
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|value
operator|.
name|length
operator|+
literal|"< "
operator|+
name|l
operator|+
literal|": "
operator|+
operator|new
name|String
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|rec
operator|.
name|page
operator|.
name|page
operator|.
name|getPageInfo
argument_list|()
operator|+
literal|"; offset = "
operator|+
name|rec
operator|.
name|offset
operator|+
literal|"; data-len = "
operator|+
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
operator|+
literal|"; previous-page = "
operator|+
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getPrevDataPage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"shrinked"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|value
operator|.
name|length
operator|>
name|l
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"value too long: expected: "
operator|+
name|value
operator|.
name|length
operator|+
literal|"; got: "
operator|+
name|l
argument_list|)
throw|;
block|}
else|else
block|{
comment|// value length unchanged
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|rec
operator|.
name|page
operator|.
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Retrieve the string value of the specified node.      *       * @param proxy      * @return      */
specifier|public
name|String
name|getNodeValue
parameter_list|(
name|NodeProxy
name|proxy
parameter_list|)
block|{
try|try
block|{
name|long
name|address
init|=
name|proxy
operator|.
name|getInternalAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|<
literal|0
condition|)
name|address
operator|=
name|findValue
argument_list|(
name|this
argument_list|,
name|proxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|BTree
operator|.
name|KEY_NOT_FOUND
condition|)
return|return
literal|null
return|;
specifier|final
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|address
argument_list|)
decl_stmt|;
specifier|final
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|getNodeValue
argument_list|(
name|os
argument_list|,
name|rec
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
name|os
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|String
name|value
decl_stmt|;
try|try
block|{
name|value
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|value
operator|=
operator|new
name|String
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
catch|catch
parameter_list|(
name|BTreeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"btree error while reading node value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"io error while reading node value"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|getNodeValue
parameter_list|(
name|ByteArrayOutputStream
name|os
parameter_list|,
name|RecordPos
name|rec
parameter_list|,
name|boolean
name|firstCall
parameter_list|)
block|{
name|boolean
name|foundNext
init|=
literal|false
decl_stmt|;
do|do
block|{
if|if
condition|(
name|rec
operator|.
name|offset
operator|>
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
condition|)
block|{
specifier|final
name|long
name|nextPage
init|=
name|rec
operator|.
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextPage
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"bad link to next page"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rec
operator|.
name|page
operator|=
name|getCurrentPage
argument_list|(
name|nextPage
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|rec
operator|.
name|page
argument_list|)
expr_stmt|;
name|rec
operator|.
name|offset
operator|=
literal|2
expr_stmt|;
block|}
name|rec
operator|.
name|tid
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
block|{
name|rec
operator|.
name|offset
operator|+=
literal|10
expr_stmt|;
block|}
else|else
name|foundNext
operator|=
literal|true
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|foundNext
condition|)
do|;
name|short
name|len
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|rec
operator|.
name|tid
argument_list|)
condition|)
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
name|byte
index|[]
name|data
init|=
name|rec
operator|.
name|page
operator|.
name|data
decl_stmt|;
name|int
name|readOffset
init|=
name|rec
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|OVERFLOW
condition|)
block|{
specifier|final
name|long
name|op
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|data
operator|=
name|getOverflowValue
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|short
operator|)
name|data
operator|.
name|length
expr_stmt|;
name|readOffset
operator|=
literal|0
expr_stmt|;
name|rec
operator|.
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
specifier|final
name|short
name|type
init|=
name|Signatures
operator|.
name|getType
argument_list|(
name|data
index|[
name|readOffset
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node
operator|.
name|ELEMENT_NODE
case|:
specifier|final
name|int
name|children
init|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|readOffset
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|attrSizeType
init|=
operator|(
name|byte
operator|)
operator|(
operator|(
name|data
index|[
name|readOffset
index|]
operator|&
literal|0x0C
operator|)
operator|>>
literal|0x2
operator|)
decl_stmt|;
specifier|final
name|short
name|attributes
init|=
operator|(
name|short
operator|)
name|Signatures
operator|.
name|read
argument_list|(
name|attrSizeType
argument_list|,
name|data
argument_list|,
name|readOffset
operator|+
literal|5
argument_list|)
decl_stmt|;
name|rec
operator|.
name|offset
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|getNodeValue
argument_list|(
name|os
argument_list|,
name|rec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//if (children - attributes> 1)
comment|//	os.write((byte) 0x20);
block|}
return|return;
case|case
name|Node
operator|.
name|TEXT_NODE
case|:
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|readOffset
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|.
name|ATTRIBUTE_NODE
case|:
comment|// use attribute value if the context node is an attribute, i.e.
comment|// if this is the first call to the method
if|if
condition|(
name|firstCall
condition|)
block|{
specifier|final
name|byte
name|idSizeType
init|=
operator|(
name|byte
operator|)
operator|(
name|data
index|[
name|readOffset
index|]
operator|&
literal|0x3
operator|)
decl_stmt|;
specifier|final
name|boolean
name|hasNamespace
init|=
operator|(
name|data
index|[
name|readOffset
index|]
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
decl_stmt|;
name|int
name|next
init|=
name|Signatures
operator|.
name|getLength
argument_list|(
name|idSizeType
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|hasNamespace
condition|)
block|{
name|next
operator|+=
literal|2
expr_stmt|;
comment|// skip namespace id
specifier|final
name|short
name|prefixLen
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|readOffset
operator|+
name|next
argument_list|)
decl_stmt|;
name|next
operator|+=
name|prefixLen
operator|+
literal|2
expr_stmt|;
comment|// skip prefix
block|}
name|os
operator|.
name|write
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|readOffset
operator|+
name|next
argument_list|,
name|len
operator|-
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|rec
operator|.
name|offset
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
block|}
specifier|protected
name|RecordPos
name|findRecord
parameter_list|(
name|long
name|p
parameter_list|)
block|{
return|return
name|findRecord
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**          * Find a record within the page or the pages linked to it.          *           * @param p          * @return          */
specifier|protected
name|RecordPos
name|findRecord
parameter_list|(
name|long
name|p
parameter_list|,
name|boolean
name|skipLinks
parameter_list|)
block|{
name|long
name|pageNr
init|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|short
name|targetId
init|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|DOMPage
name|page
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|short
name|currentId
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|outerLoop
label|:
while|while
condition|(
name|pageNr
operator|>
operator|-
literal|1
condition|)
block|{
name|page
operator|=
name|getCurrentPage
argument_list|(
name|pageNr
argument_list|)
expr_stmt|;
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|dlen
condition|;
control|)
block|{
name|currentId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isLink
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
if|if
condition|(
name|ItemId
operator|.
name|getId
argument_list|(
name|currentId
argument_list|)
operator|==
name|targetId
condition|)
block|{
if|if
condition|(
operator|!
name|skipLinks
condition|)
return|return
operator|new
name|RecordPos
argument_list|(
name|pos
operator|+
literal|2
argument_list|,
name|page
argument_list|,
name|currentId
argument_list|)
return|;
name|long
name|forwardLink
init|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// load the link page
name|pageNr
operator|=
name|StorageAddress
operator|.
name|pageFromPointer
argument_list|(
name|forwardLink
argument_list|)
expr_stmt|;
name|targetId
operator|=
name|StorageAddress
operator|.
name|tidFromPointer
argument_list|(
name|forwardLink
argument_list|)
expr_stmt|;
comment|//                        LOG.debug("following link. page = "
comment|//                                + pageNr
comment|//                                + "; tid="
comment|//                                + targetId);
continue|continue
name|outerLoop
continue|;
block|}
else|else
block|{
name|pos
operator|+=
literal|10
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|ItemId
operator|.
name|getId
argument_list|(
name|currentId
argument_list|)
operator|==
name|targetId
condition|)
return|return
operator|new
name|RecordPos
argument_list|(
name|pos
operator|+
literal|2
argument_list|,
name|page
argument_list|,
name|currentId
argument_list|)
return|;
else|else
block|{
name|vlen
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|page
operator|.
name|data
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ItemId
operator|.
name|isRelocated
argument_list|(
name|currentId
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
literal|20
else|:
name|vlen
operator|+
literal|12
expr_stmt|;
block|}
else|else
name|pos
operator|+=
name|vlen
operator|==
name|OVERFLOW
condition|?
literal|12
else|:
name|vlen
operator|+
literal|4
expr_stmt|;
block|}
block|}
name|pageNr
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextDataPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|pageNr
operator|==
name|page
operator|.
name|getPageNum
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"illegal link to next page"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//            			LOG.debug(
comment|//            				owner.toString()
comment|//            					+ ": tid "
comment|//            					+ targetId
comment|//            					+ " not found on "
comment|//            					+ page.page.getPageInfo()
comment|//            					+ ". Loading "
comment|//            					+ pageNr);
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|final
class|class
name|DOMFileHeader
extends|extends
name|BTreeFileHeader
block|{
specifier|protected
name|LinkedList
name|reserved
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
specifier|public
name|DOMFileHeader
parameter_list|()
block|{
block|}
specifier|public
name|DOMFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DOMFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DOMFileHeader
parameter_list|(
name|long
name|pageCount
parameter_list|,
name|int
name|pageSize
parameter_list|,
name|byte
name|blockSize
parameter_list|)
block|{
name|super
argument_list|(
name|pageCount
argument_list|,
name|pageSize
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DOMFileHeader
parameter_list|(
name|boolean
name|read
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|read
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addReservedPage
parameter_list|(
name|long
name|page
parameter_list|)
block|{
name|reserved
operator|.
name|addFirst
argument_list|(
operator|new
name|Long
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|getReservedPage
parameter_list|()
block|{
if|if
condition|(
name|reserved
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
operator|(
name|Long
operator|)
name|reserved
operator|.
name|removeLast
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
specifier|public
name|void
name|read
parameter_list|(
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
name|raf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|read
argument_list|(
name|raf
argument_list|)
expr_stmt|;
comment|//lastDataPage = raf.readLong();
name|int
name|rp
init|=
name|raf
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|long
name|l
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rp
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|raf
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|reserved
operator|.
name|addFirst
argument_list|(
operator|new
name|Long
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|write
parameter_list|(
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
name|raf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|raf
argument_list|)
expr_stmt|;
comment|//raf.writeLong(lastDataPage);
name|raf
operator|.
name|writeInt
argument_list|(
name|reserved
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Long
name|l
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|reserved
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|l
operator|=
operator|(
name|Long
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|raf
operator|.
name|writeLong
argument_list|(
name|l
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
specifier|final
specifier|static
class|class
name|DOMFilePageHeader
extends|extends
name|BTreePageHeader
block|{
specifier|protected
name|int
name|dataLen
init|=
literal|0
decl_stmt|;
specifier|protected
name|long
name|nextDataPage
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|long
name|prevDataPage
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|short
name|tid
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|short
name|records
init|=
literal|0
decl_stmt|;
specifier|public
name|DOMFilePageHeader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|DOMFilePageHeader
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|decRecordCount
parameter_list|()
block|{
operator|--
name|records
expr_stmt|;
block|}
specifier|public
name|short
name|getNextTID
parameter_list|()
block|{
if|if
condition|(
operator|++
name|tid
operator|==
literal|0x5FFF
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"TID limit reached in dom.dbx!!!!!!!!!!!!!!!!!!!!!!!"
argument_list|)
throw|;
return|return
name|tid
return|;
block|}
specifier|public
name|void
name|setNextTID
parameter_list|(
name|short
name|tid
parameter_list|)
block|{
name|this
operator|.
name|tid
operator|=
name|tid
expr_stmt|;
block|}
specifier|public
name|int
name|getDataLength
parameter_list|()
block|{
return|return
name|dataLen
return|;
block|}
specifier|public
name|long
name|getNextDataPage
parameter_list|()
block|{
return|return
name|nextDataPage
return|;
block|}
specifier|public
name|long
name|getPrevDataPage
parameter_list|()
block|{
return|return
name|prevDataPage
return|;
block|}
specifier|public
name|short
name|getRecordCount
parameter_list|()
block|{
return|return
name|records
return|;
block|}
specifier|public
name|void
name|incRecordCount
parameter_list|()
block|{
name|records
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|records
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|dataLen
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|nextDataPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|prevDataPage
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|tid
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|2
return|;
block|}
specifier|public
name|void
name|setDataLength
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|dataLen
operator|=
name|len
expr_stmt|;
block|}
specifier|public
name|void
name|setNextDataPage
parameter_list|(
name|long
name|page
parameter_list|)
block|{
name|nextDataPage
operator|=
name|page
expr_stmt|;
block|}
specifier|public
name|void
name|setPrevDataPage
parameter_list|(
name|long
name|page
parameter_list|)
block|{
name|prevDataPage
operator|=
name|page
expr_stmt|;
block|}
specifier|public
name|void
name|setRecordCount
parameter_list|(
name|short
name|recs
parameter_list|)
block|{
name|records
operator|=
name|recs
expr_stmt|;
block|}
specifier|public
name|int
name|write
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|super
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|records
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|dataLen
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|nextDataPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|prevDataPage
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|tid
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
literal|2
return|;
block|}
block|}
specifier|protected
specifier|final
class|class
name|DOMPage
implements|implements
name|Cacheable
block|{
name|byte
index|[]
name|data
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|Page
name|page
decl_stmt|;
name|int
name|refCount
init|=
literal|0
decl_stmt|;
name|int
name|timestamp
init|=
literal|0
decl_stmt|;
name|boolean
name|saved
init|=
literal|true
decl_stmt|;
specifier|public
name|DOMPage
parameter_list|()
block|{
name|page
operator|=
name|createNewPage
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|byte
index|[
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|DOMPage
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
try|try
block|{
name|page
operator|=
name|getPage
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|DOMPage
parameter_list|(
name|Page
name|page
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|load
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#getKey()          */
specifier|public
name|long
name|getKey
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#getReferenceCount()          */
specifier|public
name|int
name|getReferenceCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
specifier|public
name|int
name|decReferenceCount
parameter_list|()
block|{
return|return
name|refCount
operator|>
literal|0
condition|?
operator|--
name|refCount
else|:
literal|0
return|;
block|}
specifier|public
name|int
name|incReferenceCount
parameter_list|()
block|{
if|if
condition|(
name|refCount
operator|<
name|Cacheable
operator|.
name|MAX_REF
condition|)
operator|++
name|refCount
expr_stmt|;
return|return
name|refCount
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#setReferenceCount(int)          */
specifier|public
name|void
name|setReferenceCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|refCount
operator|=
name|count
expr_stmt|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#setTimestamp(int)          */
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|int
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#getTimestamp()          */
specifier|public
name|int
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
specifier|public
name|DOMFilePageHeader
name|getPageHeader
parameter_list|()
block|{
return|return
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
return|;
block|}
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|page
operator|.
name|getPageNum
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
operator|!
name|saved
return|;
block|}
specifier|public
name|void
name|setDirty
parameter_list|(
name|boolean
name|dirty
parameter_list|)
block|{
name|saved
operator|=
operator|!
name|dirty
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setDirty
argument_list|(
name|dirty
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|load
parameter_list|(
name|Page
name|page
parameter_list|)
block|{
try|try
block|{
name|data
operator|=
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
name|DOMFilePageHeader
name|ph
init|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
name|len
operator|=
name|ph
operator|.
name|getDataLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
operator|+
literal|" data length == 0"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|saved
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|write
parameter_list|()
block|{
if|if
condition|(
name|page
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|DOMFilePageHeader
name|ph
init|=
operator|(
name|DOMFilePageHeader
operator|)
name|page
operator|.
name|getPageHeader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ph
operator|.
name|isDirty
argument_list|()
condition|)
return|return;
name|ph
operator|.
name|setDataLength
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
operator|new
name|Value
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|writeValue
argument_list|(
name|page
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//page.write();
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#release()          */
specifier|public
name|void
name|sync
parameter_list|()
block|{
if|if
condition|(
name|isDirty
argument_list|()
condition|)
name|write
argument_list|()
expr_stmt|;
block|}
comment|/*          * (non-Javadoc)          *           * @see org.exist.storage.cache.Cacheable#allowUnload()          */
specifier|public
name|boolean
name|allowUnload
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/*          * (non-Javadoc)          *           * @see java.lang.Object#equals(java.lang.Object)          */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|DOMPage
name|other
init|=
operator|(
name|DOMPage
operator|)
name|obj
decl_stmt|;
return|return
name|page
operator|.
name|equals
argument_list|(
name|other
operator|.
name|page
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|final
class|class
name|OverflowDOMPage
block|{
name|Page
name|firstPage
init|=
literal|null
decl_stmt|;
specifier|public
name|OverflowDOMPage
parameter_list|()
block|{
name|firstPage
operator|=
name|createNewPage
argument_list|()
expr_stmt|;
block|}
specifier|public
name|OverflowDOMPage
parameter_list|(
name|long
name|first
parameter_list|)
throws|throws
name|IOException
block|{
name|firstPage
operator|=
name|getPage
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
try|try
block|{
name|int
name|remaining
init|=
name|data
operator|.
name|length
decl_stmt|;
name|int
name|chunkSize
init|=
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
decl_stmt|;
name|Page
name|page
init|=
name|firstPage
decl_stmt|,
name|next
init|=
literal|null
decl_stmt|;
name|int
name|chunk
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
name|Value
name|value
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|chunkSize
operator|=
name|remaining
operator|>
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
condition|?
name|fileHeader
operator|.
name|getWorkSize
argument_list|()
else|:
name|remaining
expr_stmt|;
name|value
operator|=
operator|new
name|Value
argument_list|(
name|data
argument_list|,
name|pos
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|chunkSize
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|next
operator|=
name|createNewPage
argument_list|()
expr_stmt|;
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
name|next
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|setNextPage
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|page
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|chunkSize
expr_stmt|;
name|page
operator|=
name|next
expr_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while writing overflow page"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|byte
index|[]
name|read
parameter_list|()
block|{
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|Page
name|page
init|=
name|firstPage
decl_stmt|;
name|byte
index|[]
name|chunk
decl_stmt|;
name|long
name|np
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|chunk
operator|=
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|np
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextPage
argument_list|()
expr_stmt|;
name|page
operator|=
name|np
operator|>
operator|-
literal|1
condition|?
name|getPage
argument_list|(
name|np
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"io error while loading overflow page "
operator|+
name|firstPage
operator|.
name|getPageNum
argument_list|()
operator|+
literal|"; read: "
operator|+
name|count
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|count
expr_stmt|;
block|}
return|return
name|os
operator|.
name|toByteArray
argument_list|()
return|;
block|}
specifier|public
name|void
name|delete
parameter_list|()
throws|throws
name|IOException
block|{
name|Page
name|page
init|=
name|firstPage
decl_stmt|;
name|long
name|np
decl_stmt|;
while|while
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
name|page
operator|.
name|read
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"removing overflow page "
operator|+
name|page
operator|.
name|getPageNum
argument_list|()
argument_list|)
expr_stmt|;
name|np
operator|=
name|page
operator|.
name|getPageHeader
argument_list|()
operator|.
name|getNextPage
argument_list|()
expr_stmt|;
name|unlinkPages
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|=
name|np
operator|>
operator|-
literal|1
condition|?
name|getPage
argument_list|(
name|np
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
block|}
specifier|public
name|long
name|getPageNum
parameter_list|()
block|{
return|return
name|firstPage
operator|.
name|getPageNum
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|final
name|void
name|addToBuffer
parameter_list|(
name|DOMPage
name|page
parameter_list|)
block|{
name|dataCache
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
class|class
name|FindCallback
implements|implements
name|BTreeCallback
block|{
specifier|public
specifier|final
specifier|static
name|int
name|KEYS
init|=
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|int
name|VALUES
init|=
literal|0
decl_stmt|;
name|int
name|mode
init|=
name|VALUES
decl_stmt|;
name|ArrayList
name|values
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|public
name|FindCallback
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
specifier|public
name|ArrayList
name|getValues
parameter_list|()
block|{
return|return
name|values
return|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VALUES
case|:
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|int
name|dataStart
init|=
name|rec
operator|.
name|offset
operator|+
literal|2
decl_stmt|;
comment|//int l = (int) VariableByteCoding.decode( page.data,
comment|// offset );
comment|//int dataStart = VariableByteCoding.getSize( l );
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|dataStart
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|KEYS
case|:
name|values
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
specifier|private
specifier|final
class|class
name|RangeCallback
implements|implements
name|BTreeCallback
block|{
name|ArrayList
name|values
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|public
name|RangeCallback
parameter_list|()
block|{
block|}
specifier|public
name|ArrayList
name|getValues
parameter_list|()
block|{
return|return
name|values
return|;
block|}
specifier|public
name|boolean
name|indexInfo
parameter_list|(
name|Value
name|value
parameter_list|,
name|long
name|pointer
parameter_list|)
block|{
name|RecordPos
name|rec
init|=
name|findRecord
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|short
name|l
init|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|rec
operator|.
name|offset
argument_list|)
decl_stmt|;
name|int
name|dataStart
init|=
name|rec
operator|.
name|offset
operator|+
literal|2
decl_stmt|;
comment|//int l = (int) VariableByteCoding.decode( page.data, offset );
comment|//int dataStart = VariableByteCoding.getSize( l ) + offset;
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|(
name|rec
operator|.
name|page
operator|.
name|data
argument_list|,
name|dataStart
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
specifier|protected
specifier|final
specifier|static
class|class
name|RecordPos
block|{
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|DOMPage
name|page
init|=
literal|null
decl_stmt|;
name|short
name|tid
init|=
literal|0
decl_stmt|;
specifier|public
name|RecordPos
parameter_list|(
name|int
name|offset
parameter_list|,
name|DOMPage
name|page
parameter_list|,
name|short
name|tid
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|this
operator|.
name|tid
operator|=
name|tid
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

