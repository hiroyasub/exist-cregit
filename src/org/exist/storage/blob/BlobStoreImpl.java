begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2018 Adam Retter  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|blob
package|;
end_package

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple3
import|;
end_import

begin_import
import|import
name|net
operator|.
name|jcip
operator|.
name|annotations
operator|.
name|GuardedBy
import|;
end_import

begin_import
import|import
name|net
operator|.
name|jcip
operator|.
name|annotations
operator|.
name|ThreadSafe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|input
operator|.
name|CountingInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|backup
operator|.
name|RawDataBackup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|txn
operator|.
name|Txn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|DigestInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|DigestType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|crypto
operator|.
name|digest
operator|.
name|StreamableDigest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Channels
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SeekableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|StampedLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|evolvedbinary
operator|.
name|j8fu
operator|.
name|tuple
operator|.
name|Tuple
operator|.
name|Tuple
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardCopyOption
operator|.
name|ATOMIC_MOVE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardCopyOption
operator|.
name|REPLACE_EXISTING
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardOpenOption
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|HexEncoder
operator|.
name|bytesToHex
import|;
end_import

begin_comment
comment|/**  * De-duplicating store for BLOBs (Binary Large Objects).  *  * Each unqiue BLOBs is stored by checksum into a file on disk.  *  * For each BLOB a reference count is also kept. Adding a BLOB which is already present  * increments the reference count only, it does not require any additional storage.  * Removing a BLOB decrements its reference count, BLOBs are only removed when  * their reference count reaches zero.  *  * The persistent store file reflects the in-memory state of BlobStore.  * The persistent store file will grow for each unqiue blob added to  * the system, space is not reclaimed in the persistent file until  * {@link #compactPersistentReferences(Path)} is called, which typically  * happens the next time the blob store re-opened.  *  * Each unique blob typically takes up only 36 bytes in the  * persistent store file, but this can vary if a smaller or larger  * digestType is specified.  * On-line compaction of the persistent file could be added in  * future with relative ease if determined necessary.  *  * The persistent file for the blob store has the format:  *  * [fileHeader entry+]  *  * fileHeader:          [magicNumber blobStoreVersion].  * magicNumber:         4 bytes. See {@link #BLOB_STORE_MAGIC_NUMBER}.  * blobStoreVersion:    2 bytes. java.lang.short, see {@link #BLOB_STORE_VERSION}.  *  * entry:               [blobChecksum blobReferenceCount]  * blobChecksum:        n-bytes determined by the constructed {@link MessageDigest}.  * blobReferenceCount:  4 bytes. java.lang.int.  *  * @author Adam Retter<adam@evolvedbinary.com>  */
end_comment

begin_class
annotation|@
name|ThreadSafe
specifier|public
class|class
name|BlobStoreImpl
implements|implements
name|BlobStore
block|{
comment|/**      * Length in bytes of the reference count.      */
specifier|static
specifier|final
name|int
name|REFERENCE_COUNT_LEN
init|=
literal|4
decl_stmt|;
comment|/**      * File header length      */
specifier|static
specifier|final
name|int
name|BLOB_STORE_HEADER_LEN
init|=
literal|6
decl_stmt|;
comment|/**      * File header - magic number      */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|BLOB_STORE_MAGIC_NUMBER
init|=
block|{
literal|0x0E
block|,
literal|0x0D
block|,
literal|0x0B
block|,
literal|0x02
block|}
decl_stmt|;
comment|/**      * File header - blob store version      */
specifier|public
specifier|static
specifier|final
name|short
name|BLOB_STORE_VERSION
init|=
literal|1
decl_stmt|;
specifier|private
specifier|final
name|StampedLock
name|referencesLock
init|=
operator|new
name|StampedLock
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"referencesLock"
argument_list|)
specifier|private
name|Map
argument_list|<
name|BlobId
argument_list|,
name|BlobReference
argument_list|>
name|references
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|channelLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"channelLock"
argument_list|)
specifier|private
name|FileChannel
name|channel
init|=
literal|null
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"channelLock"
argument_list|)
specifier|private
specifier|final
name|ByteBuffer
name|bufEntry
decl_stmt|;
specifier|private
specifier|final
name|Path
name|persistentFile
decl_stmt|;
specifier|private
specifier|final
name|Path
name|blobDir
decl_stmt|;
specifier|private
specifier|final
name|Path
name|stagingDir
decl_stmt|;
specifier|private
specifier|final
name|DigestType
name|digestType
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|CLOSED
init|=
literal|1
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|CLOSING
init|=
literal|2
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|OPEN
init|=
literal|3
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|OPENING
init|=
literal|4
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|state
init|=
operator|new
name|AtomicInteger
argument_list|(
name|CLOSED
argument_list|)
decl_stmt|;
comment|/**      * @param persistentFile the file path for the persistent blob store metadata.      * @param blobDir        the directory to store BLOBs in.      * @param digestType     the message digest type to use for creating checksums of the BLOBs.      */
specifier|public
name|BlobStoreImpl
parameter_list|(
specifier|final
name|Path
name|persistentFile
parameter_list|,
specifier|final
name|Path
name|blobDir
parameter_list|,
specifier|final
name|DigestType
name|digestType
parameter_list|)
block|{
name|this
operator|.
name|persistentFile
operator|=
name|persistentFile
expr_stmt|;
name|this
operator|.
name|blobDir
operator|=
name|blobDir
expr_stmt|;
name|this
operator|.
name|stagingDir
operator|=
name|blobDir
operator|.
name|resolve
argument_list|(
literal|"staging"
argument_list|)
expr_stmt|;
name|this
operator|.
name|digestType
operator|=
name|digestType
expr_stmt|;
name|this
operator|.
name|bufEntry
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|digestType
operator|.
name|getDigestLengthBytes
argument_list|()
operator|+
name|REFERENCE_COUNT_LEN
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|open
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|.
name|get
argument_list|()
operator|==
name|OPEN
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|state
operator|.
name|compareAndSet
argument_list|(
name|CLOSED
argument_list|,
name|OPENING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlobStore is not open"
argument_list|)
throw|;
block|}
try|try
block|{
specifier|final
name|long
name|writeStamp
init|=
name|referencesLock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|channelLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|persistentFile
argument_list|)
condition|)
block|{
comment|// compact existing blob store file and then open
name|this
operator|.
name|references
operator|=
name|compactPersistentReferences
argument_list|(
name|persistentFile
argument_list|)
expr_stmt|;
name|this
operator|.
name|channel
operator|=
operator|(
name|FileChannel
operator|)
name|Files
operator|.
name|newByteChannel
argument_list|(
name|persistentFile
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// open existing blob store file
name|this
operator|.
name|references
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|channel
operator|=
operator|(
name|FileChannel
operator|)
name|Files
operator|.
name|newByteChannel
argument_list|(
name|persistentFile
argument_list|,
name|CREATE_NEW
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|writeFileHeader
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|channelLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|referencesLock
operator|.
name|unlockWrite
argument_list|(
name|writeStamp
argument_list|)
expr_stmt|;
block|}
name|Files
operator|.
name|createDirectories
argument_list|(
name|stagingDir
argument_list|)
expr_stmt|;
name|state
operator|.
name|set
argument_list|(
name|OPEN
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|state
operator|.
name|set
argument_list|(
name|CLOSED
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|.
name|get
argument_list|()
operator|==
name|CLOSED
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|state
operator|.
name|compareAndSet
argument_list|(
name|OPEN
argument_list|,
name|CLOSING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlobStore is not open"
argument_list|)
throw|;
block|}
name|channelLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|channel
operator|!=
literal|null
condition|)
block|{
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
name|channel
operator|=
literal|null
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|state
operator|.
name|set
argument_list|(
name|CLOSED
argument_list|)
expr_stmt|;
name|channelLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Compacts an existing Blob Store file.      *<p>      * Reads the existing Blob Store file and copies non zero reference      * entries to a new Blob Store file. We call this compaction.      * Once complete, the existing file is replaced with the new file.      *      * @param persistentFile an existing persistentFile to compact.      * @return An in-memory representation of the compacted Blob Store      * @throws IOException if an error occurs during compaction.      */
specifier|private
name|Map
argument_list|<
name|BlobId
argument_list|,
name|BlobReference
argument_list|>
name|compactPersistentReferences
parameter_list|(
specifier|final
name|Path
name|persistentFile
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Map
argument_list|<
name|BlobId
argument_list|,
name|BlobReference
argument_list|>
name|compactReferences
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|compactPersistentFile
init|=
name|persistentFile
operator|.
name|getParent
argument_list|()
operator|.
name|resolve
argument_list|(
name|persistentFile
operator|.
name|getFileName
argument_list|()
operator|+
literal|".new."
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|SeekableByteChannel
name|channel
init|=
name|Files
operator|.
name|newByteChannel
argument_list|(
name|persistentFile
argument_list|,
name|READ
argument_list|)
init|)
block|{
name|validateFileHeader
argument_list|(
name|persistentFile
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
init|(
specifier|final
name|SeekableByteChannel
name|compactChannel
init|=
name|Files
operator|.
name|newByteChannel
argument_list|(
name|compactPersistentFile
argument_list|,
name|CREATE_NEW
argument_list|,
name|APPEND
argument_list|)
init|)
block|{
name|long
name|position
init|=
name|writeFileHeader
argument_list|(
name|compactChannel
argument_list|)
decl_stmt|;
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|read
decl_stmt|;
while|while
condition|(
operator|(
name|read
operator|=
name|channel
operator|.
name|read
argument_list|(
name|bufEntry
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|bufEntry
operator|.
name|flip
argument_list|()
expr_stmt|;
specifier|final
name|byte
index|[]
name|id
init|=
operator|new
name|byte
index|[
name|digestType
operator|.
name|getDigestLengthBytes
argument_list|()
index|]
decl_stmt|;
name|bufEntry
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
specifier|final
name|BlobId
name|blobId
init|=
operator|new
name|BlobId
argument_list|(
name|id
argument_list|)
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|bufEntry
operator|.
name|getInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|deleteBlob
argument_list|(
name|blobId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compactReferences
operator|.
name|put
argument_list|(
name|blobId
argument_list|,
operator|new
name|BlobReference
argument_list|(
name|count
argument_list|,
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|flip
argument_list|()
expr_stmt|;
name|compactChannel
operator|.
name|write
argument_list|(
name|bufEntry
argument_list|)
expr_stmt|;
block|}
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|position
operator|+=
name|read
expr_stmt|;
block|}
block|}
block|}
comment|// replace the persistent file with the new compact persistent file
name|Files
operator|.
name|move
argument_list|(
name|compactPersistentFile
argument_list|,
name|persistentFile
argument_list|,
name|ATOMIC_MOVE
argument_list|,
name|REPLACE_EXISTING
argument_list|)
expr_stmt|;
return|return
name|compactReferences
return|;
block|}
comment|/**      * Writes the persistent file header      *      * @param channel the channel to write to      * @return the number of bytes written.      * @throws IOException if an error occurs whilst writing the header.      */
specifier|private
name|long
name|writeFileHeader
parameter_list|(
specifier|final
name|SeekableByteChannel
name|channel
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|start
init|=
name|channel
operator|.
name|position
argument_list|()
decl_stmt|;
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|(
name|bufEntry
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|flip
argument_list|()
expr_stmt|;
name|bufEntry
operator|.
name|limit
argument_list|(
name|BLOB_STORE_HEADER_LEN
argument_list|)
expr_stmt|;
name|channel
operator|.
name|write
argument_list|(
name|bufEntry
argument_list|)
expr_stmt|;
return|return
name|channel
operator|.
name|position
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**      * Writes the persistent file header      *      * @param buffer the buffer to write to      */
specifier|private
specifier|static
name|void
name|writeFileHeader
parameter_list|(
specifier|final
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|buffer
operator|.
name|put
argument_list|(
name|BLOB_STORE_MAGIC_NUMBER
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|putShort
argument_list|(
name|BLOB_STORE_VERSION
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates a file header.      *      * @param file    the file containing the header.      * @param channel the channel of the file to read from.      * @throws IOException if the header is invalid.      */
specifier|private
name|void
name|validateFileHeader
parameter_list|(
specifier|final
name|Path
name|file
parameter_list|,
specifier|final
name|SeekableByteChannel
name|channel
parameter_list|)
throws|throws
name|IOException
block|{
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bufEntry
operator|.
name|limit
argument_list|(
name|BLOB_STORE_HEADER_LEN
argument_list|)
expr_stmt|;
name|channel
operator|.
name|read
argument_list|(
name|bufEntry
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|flip
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|validMagic
init|=
name|bufEntry
operator|.
name|get
argument_list|()
operator|==
name|BLOB_STORE_MAGIC_NUMBER
index|[
literal|0
index|]
operator|&&
name|bufEntry
operator|.
name|get
argument_list|()
operator|==
name|BLOB_STORE_MAGIC_NUMBER
index|[
literal|1
index|]
operator|&&
name|bufEntry
operator|.
name|get
argument_list|()
operator|==
name|BLOB_STORE_MAGIC_NUMBER
index|[
literal|2
index|]
operator|&&
name|bufEntry
operator|.
name|get
argument_list|()
operator|==
name|BLOB_STORE_MAGIC_NUMBER
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|validMagic
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File was not recognised as a valid eXist-db Blob Store: "
operator|+
name|file
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// check the version of the blob store format
specifier|final
name|short
name|storedVersion
init|=
name|bufEntry
operator|.
name|getShort
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|validVersion
init|=
name|storedVersion
operator|==
name|BLOB_STORE_VERSION
decl_stmt|;
if|if
condition|(
operator|!
name|validVersion
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Blob Store file was version "
operator|+
name|storedVersion
operator|+
literal|", but required version "
operator|+
name|BLOB_STORE_VERSION
operator|+
literal|": "
operator|+
name|file
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Tuple2
argument_list|<
name|BlobId
argument_list|,
name|Long
argument_list|>
name|add
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|.
name|get
argument_list|()
operator|!=
name|OPEN
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlobStore is not open"
argument_list|)
throw|;
block|}
specifier|final
name|Tuple3
argument_list|<
name|Path
argument_list|,
name|Long
argument_list|,
name|MessageDigest
argument_list|>
name|staged
init|=
name|stage
argument_list|(
name|is
argument_list|)
decl_stmt|;
specifier|final
name|BlobId
name|blobId
init|=
operator|new
name|BlobId
argument_list|(
name|staged
operator|.
name|_3
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
comment|// get and lock the blobReference
specifier|final
name|long
name|writeStamp
init|=
name|referencesLock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
specifier|final
name|BlobReference
name|blobReference
init|=
name|references
operator|.
name|computeIfAbsent
argument_list|(
name|blobId
argument_list|,
name|k
lambda|->
operator|new
name|BlobReference
argument_list|()
argument_list|)
decl_stmt|;
comment|//TODO(AR) we could do optimistic read and optimistic read lock on the references before taking the write lock if there is no reference
comment|// lock handover writeStamp -> blobReference#lock
specifier|final
name|long
name|blobWriteStamp
init|=
name|blobReference
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|referencesLock
operator|.
name|unlockWrite
argument_list|(
name|writeStamp
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|blobReference
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|promote
argument_list|(
name|staged
argument_list|)
expr_stmt|;
name|blobReference
operator|.
name|count
operator|++
expr_stmt|;
name|storePersistentReferenceCount
argument_list|(
name|blobId
argument_list|,
name|blobReference
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blobReference
operator|.
name|count
operator|++
expr_stmt|;
name|updatePersistentReferenceCount
argument_list|(
name|blobId
argument_list|,
name|blobReference
argument_list|)
expr_stmt|;
name|unstage
argument_list|(
name|staged
argument_list|)
expr_stmt|;
comment|//TODO(AR) could be done asynchronously or scheduled on a background thread
block|}
return|return
name|Tuple
argument_list|(
name|blobId
argument_list|,
name|staged
operator|.
name|_2
argument_list|)
return|;
block|}
finally|finally
block|{
name|blobReference
operator|.
name|lock
operator|.
name|unlockWrite
argument_list|(
name|blobWriteStamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Stores a new reference count to the persistent blob store file.      *<p>      * Once the new reference count is written, it updates      * the {@link BlobReference#persistentOffset} with the      * location of the reference in the persistent file.      *      * @param blobId        the identifier of the blob.      * @param blobReference the reference details for the blob      * @throws IOException if an error occurs whilst writing the persistent file.      */
specifier|private
name|void
name|storePersistentReferenceCount
parameter_list|(
specifier|final
name|BlobId
name|blobId
parameter_list|,
specifier|final
name|BlobReference
name|blobReference
parameter_list|)
throws|throws
name|IOException
block|{
name|channelLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// move to the end of the file
specifier|final
name|long
name|offset
init|=
name|channel
operator|.
name|size
argument_list|()
decl_stmt|;
name|channel
operator|.
name|position
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bufEntry
operator|.
name|put
argument_list|(
name|blobId
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|putInt
argument_list|(
name|blobReference
operator|.
name|count
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|flip
argument_list|()
expr_stmt|;
name|channel
operator|.
name|write
argument_list|(
name|bufEntry
argument_list|)
expr_stmt|;
name|blobReference
operator|.
name|persistentOffset
operator|=
name|offset
expr_stmt|;
block|}
finally|finally
block|{
name|channelLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Updates a reference count in the persistent blob store file.      *      * @param blobId        the identifier of the blob.      * @param blobReference the reference details for the blob      * @throws IOException if an error occurs whilst writing the persistent file.      */
specifier|private
name|void
name|updatePersistentReferenceCount
parameter_list|(
specifier|final
name|BlobId
name|blobId
parameter_list|,
specifier|final
name|BlobReference
name|blobReference
parameter_list|)
throws|throws
name|IOException
block|{
name|channelLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|channel
operator|.
name|position
argument_list|(
name|blobReference
operator|.
name|persistentOffset
operator|+
name|blobId
operator|.
name|getId
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// offset + blobId#length
name|bufEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bufEntry
operator|.
name|putInt
argument_list|(
name|blobReference
operator|.
name|count
argument_list|)
expr_stmt|;
name|bufEntry
operator|.
name|flip
argument_list|()
expr_stmt|;
name|bufEntry
operator|.
name|limit
argument_list|(
name|REFERENCE_COUNT_LEN
argument_list|)
expr_stmt|;
name|channel
operator|.
name|write
argument_list|(
name|bufEntry
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|channelLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Stages a BLOB file.      *<p>      * Writes a BLOB to a file in the Blob Store staging area.      *      * @param is data stream for the BLOB.      * @return The file path, length and checksum of the staged BLOB      * @throws IOException if an error occurs whilst staging the BLOB.      */
specifier|private
name|Tuple3
argument_list|<
name|Path
argument_list|,
name|Long
argument_list|,
name|MessageDigest
argument_list|>
name|stage
parameter_list|(
specifier|final
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO(AR) use fast UUID
specifier|final
name|Path
name|stageFile
init|=
name|stagingDir
operator|.
name|resolve
argument_list|(
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CountingInputStream
name|cis
init|=
operator|new
name|CountingInputStream
argument_list|(
name|is
argument_list|)
decl_stmt|;
specifier|final
name|StreamableDigest
name|streamableDigest
init|=
name|digestType
operator|.
name|newStreamableDigest
argument_list|()
decl_stmt|;
specifier|final
name|DigestInputStream
name|dis
init|=
operator|new
name|DigestInputStream
argument_list|(
name|cis
argument_list|,
name|streamableDigest
argument_list|)
decl_stmt|;
name|Files
operator|.
name|copy
argument_list|(
name|dis
argument_list|,
name|stageFile
argument_list|)
expr_stmt|;
return|return
name|Tuple
argument_list|(
name|stageFile
argument_list|,
name|cis
operator|.
name|getByteCount
argument_list|()
argument_list|,
name|streamableDigest
operator|.
name|copyMessageDigest
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Un-stages a BLOB file.      *<p>      * Removes a BLOB file from the Blob Store staging area.      *      * @param staged the staged BLOB.      * @throws IOException if an error occurs whilst un-staging the BLOB.      */
specifier|private
name|void
name|unstage
parameter_list|(
specifier|final
name|Tuple3
argument_list|<
name|Path
argument_list|,
name|Long
argument_list|,
name|MessageDigest
argument_list|>
name|staged
parameter_list|)
throws|throws
name|IOException
block|{
name|Files
operator|.
name|delete
argument_list|(
name|staged
operator|.
name|_1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Promotes a staged BLOB file to the BLOB store.      *<p>      * Moves a staged BLOB file in the Blob Store staging area to      * the main Blob Store.      *      * @param staged the staged BLOB.      * @throws IOException if an error occurs whilst promoting the BLOB.      */
specifier|private
name|void
name|promote
parameter_list|(
specifier|final
name|Tuple3
argument_list|<
name|Path
argument_list|,
name|Long
argument_list|,
name|MessageDigest
argument_list|>
name|staged
parameter_list|)
throws|throws
name|IOException
block|{
name|Files
operator|.
name|move
argument_list|(
name|staged
operator|.
name|_1
argument_list|,
name|blobDir
operator|.
name|resolve
argument_list|(
name|staged
operator|.
name|_3
operator|.
name|toHexString
argument_list|()
argument_list|)
argument_list|,
name|ATOMIC_MOVE
argument_list|)
expr_stmt|;
block|}
comment|//    @Override
comment|//    @Nullable
comment|//    public InputStream get(final Txn transaction, final BlobId blobId) throws IOException {
comment|//        if (state.get() != OPEN) {
comment|//            throw new IOException("BlobStore is not open");
comment|//        }
comment|//
comment|//        // optimistic check of null blobReference
comment|//        long stamp = referencesLock.tryOptimisticRead();
comment|//        BlobReference blobReference = references.get(blobId);
comment|//        if (blobReference == null&& referencesLock.validate(stamp)) {
comment|//            return null;
comment|//        }
comment|//
comment|//        // pessimistic check of null blobReference
comment|//        stamp = referencesLock.readLock();
comment|//        blobReference = references.get(blobId);
comment|//        if (blobReference == null) {
comment|//            referencesLock.unlockRead(stamp);
comment|//            return null;
comment|//        }
comment|//
comment|//        // optimistic check of 0 blobReference#count
comment|//        long blobStamp = blobReference.lock.tryOptimisticRead();
comment|//        if (blobReference.count == 0&& blobReference.lock.validate(blobStamp)) {
comment|//            referencesLock.unlockRead(stamp);
comment|//            return null;
comment|//        }
comment|//
comment|//        // lock handover referencesLock -> blobReferences#Lock
comment|//        final long blobReadLock = blobReference.lock.readLock();
comment|//        referencesLock.unlockRead(stamp);
comment|//
comment|//        // pessimistic check of 0 blobReference#count
comment|//        if (blobReference.count == 0) {
comment|//            blobReference.lock.unlockRead(blobReadLock);
comment|//            return null;
comment|//        }
comment|//
comment|//        // get the blob
comment|//        final Path blobFile = blobDir.resolve(bytesToHex(blobId.getId()));
comment|//        try {
comment|//            final BlobReference blobReference1 = blobReference;
comment|//            return new OnCloseInputStream(Files.newInputStream(blobFile), () -> blobReference1.lock.unlockRead(blobReadLock));
comment|//        } catch (final IOException e) {
comment|//            blobReference.lock.unlockRead(blobReadLock);
comment|//            throw e;
comment|//        }
comment|//    }
annotation|@
name|Override
annotation|@
name|Nullable
specifier|public
name|InputStream
name|get
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BlobId
name|blobId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get the blob
specifier|final
name|LockedBlobFile
name|lockedBlobFile
init|=
name|getReadLockedBlobFile
argument_list|(
name|transaction
argument_list|,
name|blobId
argument_list|)
decl_stmt|;
comment|// blob file is unlocked either when the input stream is closed or an error occurs
try|try
block|{
return|return
operator|new
name|OnCloseInputStream
argument_list|(
name|Files
operator|.
name|newInputStream
argument_list|(
name|lockedBlobFile
operator|.
name|path
argument_list|)
argument_list|,
name|lockedBlobFile
operator|.
name|unlocker
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
name|lockedBlobFile
operator|.
name|unlocker
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// release the read lock
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|with
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BlobId
name|blobId
parameter_list|,
specifier|final
name|Function
argument_list|<
name|Path
argument_list|,
name|T
argument_list|>
name|fnFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get the blob
specifier|final
name|LockedBlobFile
name|lockedBlobFile
init|=
name|getReadLockedBlobFile
argument_list|(
name|transaction
argument_list|,
name|blobId
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|fnFile
operator|.
name|apply
argument_list|(
name|lockedBlobFile
operator|.
name|path
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockedBlobFile
operator|.
name|unlocker
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// release the read lock
block|}
block|}
specifier|private
name|LockedBlobFile
name|getReadLockedBlobFile
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BlobId
name|blobId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|.
name|get
argument_list|()
operator|!=
name|OPEN
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlobStore is not open"
argument_list|)
throw|;
block|}
comment|// optimistic check of null blobReference
name|long
name|stamp
init|=
name|referencesLock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
name|BlobReference
name|blobReference
init|=
name|references
operator|.
name|get
argument_list|(
name|blobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|blobReference
operator|==
literal|null
operator|&&
name|referencesLock
operator|.
name|validate
argument_list|(
name|stamp
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// pessimistic check of null blobReference
name|stamp
operator|=
name|referencesLock
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|blobReference
operator|=
name|references
operator|.
name|get
argument_list|(
name|blobId
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobReference
operator|==
literal|null
condition|)
block|{
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// optimistic check of 0 blobReference#count
name|long
name|blobStamp
init|=
name|blobReference
operator|.
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
if|if
condition|(
name|blobReference
operator|.
name|count
operator|==
literal|0
operator|&&
name|blobReference
operator|.
name|lock
operator|.
name|validate
argument_list|(
name|blobStamp
argument_list|)
condition|)
block|{
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// lock handover referencesLock -> blobReferences#Lock
specifier|final
name|long
name|blobReadLock
init|=
name|blobReference
operator|.
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
comment|// pessimistic check of 0 blobReference#count
if|if
condition|(
name|blobReference
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|blobReference
operator|.
name|lock
operator|.
name|unlockRead
argument_list|(
name|blobReadLock
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// get the blob
specifier|final
name|Path
name|blobFile
init|=
name|blobDir
operator|.
name|resolve
argument_list|(
name|bytesToHex
argument_list|(
name|blobId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|BlobReference
name|exportBlobReference
init|=
name|blobReference
decl_stmt|;
return|return
operator|new
name|LockedBlobFile
argument_list|(
name|blobFile
argument_list|,
parameter_list|()
lambda|->
name|exportBlobReference
operator|.
name|lock
operator|.
name|unlockRead
argument_list|(
name|blobReadLock
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|(
specifier|final
name|Txn
name|transaction
parameter_list|,
specifier|final
name|BlobId
name|blobId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|.
name|get
argument_list|()
operator|!=
name|OPEN
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlobStore is not open"
argument_list|)
throw|;
block|}
comment|// optimistic check of null blobReference
name|long
name|stamp
init|=
name|referencesLock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
name|BlobReference
name|blobReference
init|=
name|references
operator|.
name|get
argument_list|(
name|blobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|blobReference
operator|==
literal|null
operator|&&
name|referencesLock
operator|.
name|validate
argument_list|(
name|stamp
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// pessimistic check of null blobReference
name|stamp
operator|=
name|referencesLock
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|blobReference
operator|=
name|references
operator|.
name|get
argument_list|(
name|blobId
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobReference
operator|==
literal|null
condition|)
block|{
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// optimistic check of 0 blobReference#count
name|long
name|blobStamp
init|=
name|blobReference
operator|.
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
if|if
condition|(
name|blobReference
operator|.
name|count
operator|==
literal|0
operator|&&
name|blobReference
operator|.
name|lock
operator|.
name|validate
argument_list|(
name|blobStamp
argument_list|)
condition|)
block|{
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// lock handover referencesLock -> blobReferences#lock
specifier|final
name|long
name|blobReadLock
init|=
name|blobReference
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
comment|// pessimistic check of 0 blobReference#count
if|if
condition|(
name|blobReference
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|blobReference
operator|.
name|lock
operator|.
name|unlockWrite
argument_list|(
name|blobReadLock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// remove the blob
name|blobReference
operator|.
name|count
operator|--
expr_stmt|;
try|try
block|{
name|updatePersistentReferenceCount
argument_list|(
name|blobId
argument_list|,
name|blobReference
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobReference
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|deleteBlob
argument_list|(
name|blobId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|blobReference
operator|.
name|lock
operator|.
name|unlockWrite
argument_list|(
name|blobReadLock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Deletes a BLOB file from the Blob Store.      *      * @param blobId the identifier of the BLOB file to delete.      * @param always true if we should always be able to delete the file,      *               false if the file may not exist.      * @throws IOException if the file cannot be deleted, for example if {@code always}      *                     is set to true and the BLOB does not exist.      */
specifier|private
name|void
name|deleteBlob
parameter_list|(
specifier|final
name|BlobId
name|blobId
parameter_list|,
specifier|final
name|boolean
name|always
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|blobFile
init|=
name|blobDir
operator|.
name|resolve
argument_list|(
name|bytesToHex
argument_list|(
name|blobId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|always
condition|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|blobFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|blobFile
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|backupToArchive
parameter_list|(
specifier|final
name|RawDataBackup
name|backup
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|BlobId
argument_list|,
name|BlobReference
argument_list|>
name|referencesCopy
init|=
literal|null
decl_stmt|;
comment|// make a local copy of the references
name|long
name|stamp
init|=
name|referencesLock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
name|referencesCopy
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|references
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|referencesLock
operator|.
name|validate
argument_list|(
name|stamp
argument_list|)
condition|)
block|{
name|stamp
operator|=
name|referencesLock
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|referencesCopy
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|references
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|referencesLock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// export the blob files
specifier|final
name|Map
argument_list|<
name|BlobId
argument_list|,
name|Integer
argument_list|>
name|exportedBlobFiles
init|=
operator|new
name|HashMap
argument_list|<
name|BlobId
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|BlobId
argument_list|,
name|BlobReference
argument_list|>
name|blobReference
range|:
name|referencesCopy
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|BlobId
name|blobId
init|=
name|blobReference
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|BlobReference
name|reference
init|=
name|blobReference
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|stamp
operator|=
name|reference
operator|.
name|lock
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Path
name|blobFile
init|=
name|blobDir
operator|.
name|resolve
argument_list|(
name|bytesToHex
argument_list|(
name|blobId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// blob might have been removed in the meantime e.g. reference.count could be == 0
if|if
condition|(
name|reference
operator|.
name|count
operator|>
literal|0
condition|)
block|{
comment|// do not use try-with-resources here, closing the OutputStream will close the entire backup
specifier|final
name|OutputStream
name|os
init|=
name|backup
operator|.
name|newEntry
argument_list|(
name|persistentFile
operator|.
name|relativize
argument_list|(
name|blobFile
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|copy
argument_list|(
name|blobFile
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
name|exportedBlobFiles
operator|.
name|put
argument_list|(
name|blobId
argument_list|,
name|reference
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|reference
operator|.
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// export the blob.dbx
comment|// do not use try-with-resources here, closing the OutputStream will close the entire backup
specifier|final
name|WritableByteChannel
name|backupBlobChannel
init|=
name|Channels
operator|.
name|newChannel
argument_list|(
name|backup
operator|.
name|newEntry
argument_list|(
name|persistentFile
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|digestType
operator|.
name|getDigestLengthBytes
argument_list|()
operator|+
name|REFERENCE_COUNT_LEN
argument_list|)
decl_stmt|;
name|writeFileHeader
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|limit
argument_list|(
name|BLOB_STORE_HEADER_LEN
argument_list|)
expr_stmt|;
name|backupBlobChannel
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|BlobId
argument_list|,
name|Integer
argument_list|>
name|exportedBlobFile
range|:
name|exportedBlobFiles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|put
argument_list|(
name|exportedBlobFile
operator|.
name|getKey
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|putInt
argument_list|(
name|exportedBlobFile
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|backupBlobChannel
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|backup
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Value class which represents the reference      * count for a blob and the offset of its entry      * in the persistent file.      */
specifier|private
specifier|static
class|class
name|BlobReference
block|{
specifier|final
name|StampedLock
name|lock
init|=
operator|new
name|StampedLock
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
name|int
name|count
init|=
literal|0
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
name|long
name|persistentOffset
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|BlobReference
parameter_list|()
block|{
block|}
comment|/**          * @param count            the reference count          * @param persistentOffset the offset of the blob reference in the persistent file          */
specifier|public
name|BlobReference
parameter_list|(
specifier|final
name|int
name|count
parameter_list|,
specifier|final
name|long
name|persistentOffset
parameter_list|)
block|{
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|persistentOffset
operator|=
name|persistentOffset
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LockedBlobFile
block|{
specifier|final
name|Path
name|path
decl_stmt|;
specifier|final
name|Runnable
name|unlocker
decl_stmt|;
specifier|public
name|LockedBlobFile
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|Runnable
name|unlocker
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|unlocker
operator|=
name|unlocker
expr_stmt|;
block|}
block|}
comment|/**      * A FilterInputStream which executes an action when      * the underlying stream is closed.      */
specifier|public
specifier|static
class|class
name|OnCloseInputStream
extends|extends
name|FilterInputStream
block|{
specifier|private
specifier|final
name|Runnable
name|closeAction
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**          * @param in          An input stream.          * @param closeAction an action to run after the stream is closed.          */
specifier|public
name|OnCloseInputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|,
specifier|final
name|Runnable
name|closeAction
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeAction
operator|=
name|closeAction
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
try|try
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeAction
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

