begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist  Open  Source Native XML Database  *  *  Copyright  (C) 2000, Wolfgang Meier (meier@ifs. tu- darmstadt. de)  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|analysis
operator|.
name|TextToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * This class is responsible for the fulltext-indexing. Text-nodes are handed  * over to this class to be fulltext-indexed. Method storeText() is called by  * RelationalBroker whenever it finds a TextNode. Method  * getNodeIDsContaining() is used by the XPath-engine to process queries where  * a fulltext-operator is involved. The class keeps two database tables: table  * words stores the words found with their unique id. Table inv_idx contains  * the word occurrences for every word-id per document.  *  * @author wolf  *  */
end_comment

begin_class
specifier|public
class|class
name|RelationalTextEngine
extends|extends
name|TextSearchEngine
block|{
specifier|private
specifier|static
name|Category
name|LOG
init|=
name|Category
operator|.
name|getInstance
argument_list|(
name|RelationalTextEngine
operator|.
name|class
operator|.
name|getName
argument_list|(  )
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
name|RelationalBroker
operator|.
name|TableLock
name|wordsLock
init|=
operator|new
name|RelationalBroker
operator|.
name|TableLock
argument_list|(  )
decl_stmt|;
specifier|protected
specifier|static
name|Map
name|words
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|(  )
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
name|int
name|lastWordId
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|DBConnectionPool
name|pool
decl_stmt|;
specifier|protected
name|InvertedIndex
name|t_insert
decl_stmt|;
specifier|protected
name|PreparedStatement
name|m_insertWordStmt
decl_stmt|;
specifier|protected
name|PreparedStatement
name|m_getWordIdStmt
decl_stmt|;
specifier|protected
name|PreparedStatement
name|m_getNextWordId
decl_stmt|;
specifier|protected
name|PreparedStatement
name|m_getStmt
decl_stmt|;
specifier|protected
name|Statement
name|stmt
decl_stmt|;
specifier|protected
name|boolean
name|useCompression
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|indexNumbers
init|=
literal|false
decl_stmt|;
specifier|protected
name|String
name|enc
decl_stmt|;
specifier|protected
name|String
name|tmpDir
decl_stmt|;
specifier|protected
name|String
name|WORDS_FILE
init|=
literal|"words"
decl_stmt|;
specifier|protected
name|RelationalBroker
operator|.
name|TableOutputStream
name|s_words
decl_stmt|;
comment|/**      * Constructor for the RelationalTextEngine object      *      * @param broker Description of the Parameter      * @param config Description of the Parameter      * @param pool Description of the Parameter      */
specifier|public
name|RelationalTextEngine
parameter_list|(
name|DBBroker
name|broker
parameter_list|,
name|Configuration
name|config
parameter_list|,
name|DBConnectionPool
name|pool
parameter_list|)
block|{
name|super
argument_list|(
name|broker
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|Boolean
name|num
decl_stmt|;
name|String
name|pathSep
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tmpDir
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"tmpDir"
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|tmpDir
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|(
name|enc
operator|=
operator|(
name|String
operator|)
name|config
operator|.
name|getProperty
argument_list|(
literal|"encoding"
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|enc
operator|=
literal|"UTF8"
expr_stmt|;
name|t_insert
operator|=
operator|new
name|InvertedIndex
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|,
name|useCompression
argument_list|)
expr_stmt|;
name|Connection
name|con
init|=
name|pool
operator|.
name|get
argument_list|(  )
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|(  )
expr_stmt|;
name|m_getNextWordId
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select max(word_id) from words"
argument_list|)
expr_stmt|;
name|m_getWordIdStmt
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select word_id from words where wdata=?"
argument_list|)
expr_stmt|;
name|m_insertWordStmt
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"insert into words (word_id, wdata) values (?, ?)"
argument_list|)
expr_stmt|;
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Index  a text node      *      * @param idx IndexPaths object passed in by the broker      * @param text the text node to be indexed      */
specifier|public
name|void
name|storeText
parameter_list|(
name|IndexPaths
name|idx
parameter_list|,
name|TextImpl
name|text
parameter_list|)
block|{
name|DocumentImpl
name|doc
init|=
operator|(
name|DocumentImpl
operator|)
name|text
operator|.
name|getOwnerDocument
argument_list|(  )
decl_stmt|;
name|Integer
name|docId
init|=
operator|new
name|Integer
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|(  )
argument_list|)
decl_stmt|;
name|Long
name|gid
init|=
operator|new
name|Long
argument_list|(
name|text
operator|.
name|getGID
argument_list|(  )
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|setText
argument_list|(
name|text
operator|.
name|getData
argument_list|(  )
argument_list|)
expr_stmt|;
name|String
name|word
decl_stmt|;
name|TextToken
name|token
decl_stmt|;
name|ResultSet
name|rid
decl_stmt|;
name|int
name|word_id
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|broker
operator|.
name|getDatabaseType
argument_list|(  )
operator|!=
name|RelationalBroker
operator|.
name|MYSQL
condition|)
try|try
block|{
name|m_insertWordStmt
operator|.
name|getConnection
argument_list|(  )
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|sqe
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|null
operator|!=
operator|(
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|(  )
operator|)
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
literal|null
operator|&&
name|idx
operator|.
name|getIncludeAlphaNum
argument_list|(  )
operator|==
literal|false
operator|&&
operator|(
name|token
operator|.
name|getType
argument_list|(  )
operator|==
name|TextToken
operator|.
name|ALPHANUM
operator|)
condition|)
continue|continue;
name|word
operator|=
name|token
operator|.
name|getText
argument_list|(  )
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|stoplist
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|words
operator|.
name|containsKey
argument_list|(
name|word
argument_list|)
condition|)
name|word_id
operator|=
operator|(
operator|(
name|Integer
operator|)
name|words
operator|.
name|get
argument_list|(
name|word
argument_list|)
operator|)
operator|.
name|intValue
argument_list|(  )
expr_stmt|;
else|else
block|{
name|Object
name|lock
init|=
name|wordsLock
operator|.
name|acquire
argument_list|(  )
decl_stmt|;
try|try
block|{
name|m_getWordIdStmt
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|rid
operator|=
name|m_getWordIdStmt
operator|.
name|executeQuery
argument_list|(  )
expr_stmt|;
if|if
condition|(
operator|!
name|rid
operator|.
name|next
argument_list|(  )
condition|)
block|{
name|word_id
operator|=
name|getNextWordId
argument_list|(  )
expr_stmt|;
name|m_insertWordStmt
operator|.
name|setInt
argument_list|(
literal|1
argument_list|,
name|word_id
argument_list|)
expr_stmt|;
name|m_insertWordStmt
operator|.
name|setString
argument_list|(
literal|2
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|m_insertWordStmt
operator|.
name|executeUpdate
argument_list|(  )
expr_stmt|;
block|}
else|else
name|word_id
operator|=
name|rid
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rid
operator|.
name|close
argument_list|(  )
expr_stmt|;
comment|/*                      *  if(broker.getDatabaseType() != RelationalBroker.MYSQL)                      *  m_insertWordStmt.getConnection().setAutoCommit(false);                      */
name|words
operator|.
name|put
argument_list|(
name|word
argument_list|,
operator|new
name|Integer
argument_list|(
name|word_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"sql exception while storing cdata: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|wordsLock
operator|.
name|release
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|t_insert
operator|.
name|setDocId
argument_list|(
name|doc
operator|.
name|getDocId
argument_list|(  )
argument_list|)
expr_stmt|;
name|t_insert
operator|.
name|addRow
argument_list|(
name|word_id
argument_list|,
name|text
operator|.
name|getGID
argument_list|(  )
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Gets the nextWordId attribute of the RelationalTextEngine object      *      * @return The nextWordId value      */
specifier|private
name|int
name|getNextWordId
parameter_list|(  )
block|{
if|if
condition|(
name|lastWordId
operator|>
operator|-
literal|1
condition|)
block|{
operator|++
name|lastWordId
expr_stmt|;
return|return
name|lastWordId
return|;
block|}
try|try
block|{
name|ResultSet
name|r
init|=
name|m_getNextWordId
operator|.
name|executeQuery
argument_list|(  )
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|next
argument_list|(  )
condition|)
return|return
literal|0
return|;
name|int
name|wordId
init|=
name|r
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|lastWordId
operator|=
name|wordId
expr_stmt|;
return|return
name|wordId
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**      * Description of the Method      *      * @param docs Description of the Parameter      *      * @return Description of the Return Value      */
specifier|private
specifier|static
name|String
name|documentSet
parameter_list|(
name|DocumentSet
name|docs
parameter_list|)
block|{
name|StringBuffer
name|r
init|=
operator|new
name|StringBuffer
argument_list|(  )
decl_stmt|;
name|r
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|getLength
argument_list|(  )
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|r
operator|.
name|length
argument_list|(  )
operator|>
literal|1
condition|)
name|r
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|int
name|docId
init|=
operator|(
operator|(
name|DocumentImpl
operator|)
name|docs
operator|.
name|item
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getDocId
argument_list|(  )
decl_stmt|;
name|r
operator|.
name|append
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|r
operator|.
name|toString
argument_list|(  )
return|;
block|}
comment|/** 		 *  Find    all the nodes containing the search terms given by the array 		 * expr from the fulltext-index. 		 * 		 * @param the input document set 		 * @param array of regular expression search terms 		 * @return array containing a NodeSet for each of the search terms 		 * 		 */
specifier|public
name|NodeSet
index|[]
name|getNodesContaining
parameter_list|(
name|DocumentSet
name|docs
parameter_list|,
name|String
index|[]
name|expr
parameter_list|)
block|{
name|NodeSet
index|[]
name|result
init|=
literal|null
decl_stmt|;
comment|//result.setIsSorted(true);
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|(  )
decl_stmt|;
name|ArrayList
name|wordId
init|=
operator|new
name|ArrayList
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|Connection
name|con
init|=
name|pool
operator|.
name|get
argument_list|(  )
decl_stmt|;
try|try
block|{
comment|//Statement stmt = con.createStatement();
name|StringBuffer
name|sql
init|=
operator|new
name|StringBuffer
argument_list|(
literal|"select word_id from words where "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|sql
operator|.
name|append
argument_list|(
literal|" or "
argument_list|)
expr_stmt|;
name|sql
operator|.
name|append
argument_list|(
literal|"wdata like '"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stem
condition|)
name|sql
operator|.
name|append
argument_list|(
name|stemmer
operator|.
name|stem
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sql
operator|.
name|append
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sql
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|sql
operator|.
name|toString
argument_list|(  )
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sql
operator|.
name|toString
argument_list|(  )
argument_list|)
decl_stmt|;
name|Integer
name|current
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|(  )
condition|)
name|wordId
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|.
name|close
argument_list|(  )
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wordId
operator|.
name|size
argument_list|(  )
operator|==
literal|0
condition|)
block|{
name|result
operator|=
operator|new
name|NodeSet
index|[
literal|1
index|]
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|new
name|ArraySet
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
try|try
block|{
name|StringBuffer
name|sql
init|=
operator|new
name|StringBuffer
argument_list|(  )
decl_stmt|;
name|sql
operator|.
name|append
argument_list|(
literal|"select word_id, doc_id, data "
operator|+
literal|" from inv_idx where doc_id in "
argument_list|)
expr_stmt|;
name|sql
operator|.
name|append
argument_list|(
name|documentSet
argument_list|(
name|docs
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|.
name|append
argument_list|(
literal|"and "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|wordId
operator|.
name|size
argument_list|(  )
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|sql
operator|.
name|append
argument_list|(
literal|" or "
argument_list|)
expr_stmt|;
name|sql
operator|.
name|append
argument_list|(
literal|"word_id="
argument_list|)
expr_stmt|;
name|sql
operator|.
name|append
argument_list|(
name|wordId
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sql
operator|.
name|append
argument_list|(
literal|" order by word_id"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|sql
operator|.
name|toString
argument_list|(  )
argument_list|)
expr_stmt|;
name|ResultSet
name|r
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sql
operator|.
name|toString
argument_list|(  )
argument_list|)
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|last_word_id
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|;
name|short
name|doc_id
decl_stmt|;
name|long
name|gid
decl_stmt|;
name|result
operator|=
operator|new
name|NodeSet
index|[
name|wordId
operator|.
name|size
argument_list|(  )
index|]
expr_stmt|;
name|NodeSet
name|resultSet
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
while|while
condition|(
name|r
operator|.
name|next
argument_list|(  )
condition|)
block|{
name|id
operator|=
name|r
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|doc_id
operator|=
name|r
operator|.
name|getShort
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|r
operator|.
name|getBytes
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>
name|last_word_id
condition|)
block|{
name|result
index|[
operator|++
name|count
index|]
operator|=
operator|new
name|ArraySet
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|last_word_id
operator|=
name|id
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|gid
operator|=
name|ByteConversion
operator|.
name|byteToLong
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|count
index|]
operator|.
name|add
argument_list|(
operator|new
name|NodeProxy
argument_list|(
name|docs
operator|.
name|getDoc
argument_list|(
name|doc_id
argument_list|)
argument_list|,
name|gid
argument_list|,
name|Node
operator|.
name|TEXT_NODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|.
name|close
argument_list|(  )
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getNodeIdsContaining took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|(  )
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|s
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Description of the Method      */
specifier|public
name|void
name|flush
parameter_list|(  )
block|{
try|try
block|{
name|t_insert
operator|.
name|flush
argument_list|(  )
expr_stmt|;
if|if
condition|(
name|broker
operator|.
name|getDatabaseType
argument_list|(  )
operator|!=
name|RelationalBroker
operator|.
name|MYSQL
condition|)
name|m_insertWordStmt
operator|.
name|getConnection
argument_list|(  )
operator|.
name|commit
argument_list|(  )
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Description of the Method      */
specifier|public
name|void
name|close
parameter_list|(  )
block|{
try|try
block|{
name|flush
argument_list|(  )
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|(  )
expr_stmt|;
name|m_getWordIdStmt
operator|.
name|close
argument_list|(  )
expr_stmt|;
name|m_insertWordStmt
operator|.
name|close
argument_list|(  )
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This inner class is responsible for actually storing the list of      * occurrences.      *      * @author wolf      *      * @deprecated April 2, 2002      */
class|class
name|InvertedIndex
block|{
comment|/** Description of the Field */
specifier|protected
name|DBConnectionPool
name|pool
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|PreparedStatement
name|m_insert
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|PreparedStatement
name|m_get
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|PreparedStatement
name|m_update
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|Statement
name|stmt
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|HashMap
name|wordIds
init|=
operator|new
name|HashMap
argument_list|(  )
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|int
name|doc_id
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|boolean
name|compress
init|=
literal|false
decl_stmt|;
comment|/** Description of the Field */
specifier|protected
name|boolean
name|flushed
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|int
name|MAX_BUF
init|=
literal|100
decl_stmt|;
comment|/**          * Constructor for the InvertedIndex object          *          * @param doc_id Description of the Parameter          * @param pool Description of the Parameter          * @param compress Description of the Parameter          */
specifier|public
name|InvertedIndex
parameter_list|(
name|int
name|doc_id
parameter_list|,
name|DBConnectionPool
name|pool
parameter_list|,
name|boolean
name|compress
parameter_list|)
block|{
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|doc_id
operator|=
name|doc_id
expr_stmt|;
name|this
operator|.
name|compress
operator|=
name|compress
expr_stmt|;
name|Connection
name|con
init|=
name|pool
operator|.
name|get
argument_list|(  )
decl_stmt|;
try|try
block|{
name|m_insert
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"insert into inv_idx (doc_id, word_id, "
operator|+
literal|"data) values (?, ?, ?)"
argument_list|)
expr_stmt|;
name|m_get
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select word_id, data from inv_idx where "
operator|+
literal|"doc_id=? and word_id=?"
argument_list|)
expr_stmt|;
name|m_update
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"update inv_idx set data=? "
operator|+
literal|"where doc_id=? and word_id=?"
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|(  )
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|pool
operator|.
name|release
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
comment|/**          * Sets the docId attribute of the InvertedIndex object          *          * @param docId The new docId value          */
specifier|public
name|void
name|setDocId
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|doc_id
operator|!=
name|docId
condition|)
name|flush
argument_list|(  )
expr_stmt|;
name|this
operator|.
name|doc_id
operator|=
name|docId
expr_stmt|;
block|}
comment|/**          * Adds a feature to the Row attribute of the InvertedIndex object          *          * @param word_id The feature to be added to the Row attribute          * @param gid The feature to be added to the Row attribute          */
specifier|public
name|void
name|addRow
parameter_list|(
name|int
name|word_id
parameter_list|,
name|long
name|gid
parameter_list|)
block|{
name|Integer
name|id
init|=
operator|new
name|Integer
argument_list|(
name|word_id
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|b_buf
decl_stmt|;
if|if
condition|(
name|wordIds
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
name|b_buf
operator|=
operator|(
name|ByteArrayOutputStream
operator|)
name|wordIds
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
else|else
block|{
name|b_buf
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(  )
expr_stmt|;
name|wordIds
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|b_buf
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|longToByte
argument_list|(
name|gid
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b_buf
operator|.
name|write
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|(  )
decl_stmt|;
if|if
condition|(
name|run
operator|.
name|freeMemory
argument_list|(  )
operator|<
literal|500000
condition|)
block|{
name|flush
argument_list|(  )
expr_stmt|;
name|System
operator|.
name|gc
argument_list|(  )
expr_stmt|;
name|flushed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**          * Description of the Method          */
specifier|protected
name|void
name|lockTables
parameter_list|(  )
block|{
try|try
block|{
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"lock tables inv_idx write, words write"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not lock tables: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Description of the Method          */
specifier|protected
name|void
name|unlockTables
parameter_list|(  )
block|{
try|try
block|{
name|stmt
operator|.
name|executeUpdate
argument_list|(
literal|"unlock tables"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not lock tables: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Description of the Method          */
specifier|public
name|void
name|flush
parameter_list|(  )
block|{
if|if
condition|(
name|wordIds
operator|.
name|size
argument_list|(  )
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|broker
operator|.
name|getDatabaseType
argument_list|(  )
operator|==
name|RelationalBroker
operator|.
name|MYSQL
condition|)
name|lockTables
argument_list|(  )
expr_stmt|;
else|else
try|try
block|{
name|m_insert
operator|.
name|getConnection
argument_list|(  )
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|sqe
argument_list|)
expr_stmt|;
block|}
name|ProgressIndicator
name|progress
init|=
operator|new
name|ProgressIndicator
argument_list|(
name|wordIds
operator|.
name|size
argument_list|(  )
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|wordIds
operator|.
name|keySet
argument_list|(  )
operator|.
name|iterator
argument_list|(  )
init|;
name|i
operator|.
name|hasNext
argument_list|(  )
condition|;
name|count
operator|++
control|)
block|{
name|Integer
name|id
init|=
operator|(
name|Integer
operator|)
name|i
operator|.
name|next
argument_list|(  )
decl_stmt|;
name|ByteArrayOutputStream
name|b_buf
init|=
operator|(
name|ByteArrayOutputStream
operator|)
name|wordIds
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|b_buf
operator|.
name|toByteArray
argument_list|(  )
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|==
literal|0
condition|)
return|return;
name|flushWord
argument_list|(
name|id
operator|.
name|intValue
argument_list|(  )
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|progress
operator|.
name|setValue
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|setChanged
argument_list|(  )
expr_stmt|;
name|notifyObservers
argument_list|(
name|progress
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|broker
operator|.
name|getDatabaseType
argument_list|(  )
operator|!=
name|RelationalBroker
operator|.
name|MYSQL
condition|)
name|m_insert
operator|.
name|getConnection
argument_list|(  )
operator|.
name|commit
argument_list|(  )
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|sqe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|sqe
argument_list|)
expr_stmt|;
block|}
name|wordIds
operator|=
operator|new
name|HashMap
argument_list|(  )
expr_stmt|;
if|if
condition|(
name|broker
operator|.
name|getDatabaseType
argument_list|(  )
operator|==
name|RelationalBroker
operator|.
name|MYSQL
condition|)
name|unlockTables
argument_list|(  )
expr_stmt|;
block|}
comment|/**          * Description of the Method          *          * @param wordId Description of the Parameter          * @param data Description of the Parameter          */
specifier|private
name|void
name|flushWord
parameter_list|(
name|int
name|wordId
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|length
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|data
operator|.
name|length
operator|>
literal|16777215
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"word index longer than max blob size."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// if data has already been written to the table,
comment|// we may need to do updates.
if|if
condition|(
name|flushed
condition|)
block|{
try|try
block|{
name|m_get
operator|.
name|setInt
argument_list|(
literal|1
argument_list|,
name|doc_id
argument_list|)
expr_stmt|;
name|m_get
operator|.
name|setInt
argument_list|(
literal|2
argument_list|,
name|wordId
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|m_get
operator|.
name|executeQuery
argument_list|(  )
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|(  )
condition|)
block|{
name|byte
index|[]
name|oldData
decl_stmt|;
name|String
name|dstr
decl_stmt|;
name|oldData
operator|=
name|rs
operator|.
name|getBytes
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|byte
index|[]
name|newData
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
name|oldData
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldData
argument_list|,
literal|0
argument_list|,
name|newData
argument_list|,
literal|0
argument_list|,
name|oldData
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|newData
argument_list|,
name|oldData
operator|.
name|length
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|m_update
operator|.
name|setBytes
argument_list|(
literal|1
argument_list|,
name|newData
argument_list|)
expr_stmt|;
name|m_update
operator|.
name|setInt
argument_list|(
literal|2
argument_list|,
name|doc_id
argument_list|)
expr_stmt|;
name|m_update
operator|.
name|setInt
argument_list|(
literal|3
argument_list|,
name|wordId
argument_list|)
expr_stmt|;
name|m_update
operator|.
name|executeUpdate
argument_list|(  )
expr_stmt|;
comment|/*                          *  if(broker.getDatabaseType() != RelationalBroker.MYSQL)                          *  m_update.getConnection().commit();                          */
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|data
operator|==
literal|null
operator|)
operator|||
operator|(
name|data
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"no data"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// insert a new row
try|try
block|{
name|m_insert
operator|.
name|setInt
argument_list|(
literal|1
argument_list|,
name|doc_id
argument_list|)
expr_stmt|;
name|m_insert
operator|.
name|setInt
argument_list|(
literal|2
argument_list|,
name|wordId
argument_list|)
expr_stmt|;
name|m_insert
operator|.
name|setBytes
argument_list|(
literal|3
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|m_insert
operator|.
name|executeUpdate
argument_list|(  )
expr_stmt|;
comment|/*                  *  if(broker.getDatabaseType() != RelationalBroker.MYSQL)                  *  m_insert.getConnection().commit();                  */
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(  )
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

