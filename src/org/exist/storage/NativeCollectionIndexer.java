begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * eXist Open Source Native XML Database   *   * This library is free software; you can redistribute it and/or modify it under  * the terms of the GNU Library General Public License as published by the Free  * Software Foundation; either version 2 of the License, or (at your option) any  * later version.  *   * This library is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  * FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more  * details.  *   * You should have received a copy of the GNU Library General Public License  * along with this program; if not, write to the Free Software Foundation, Inc.,  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *   * $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|dbxml
operator|.
name|core
operator|.
name|data
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|collections
operator|.
name|CollectionCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|security
operator|.
name|PermissionDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|io
operator|.
name|VariableByteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|store
operator|.
name|CollectionStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ByteConversion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|ReadOnlyException
import|;
end_import

begin_comment
comment|/**  * Class which encapsulates the CollectionStore functionallity  * with some goodies.  */
end_comment

begin_class
specifier|final
class|class
name|NativeCollectionIndexer
block|{
comment|/**      * Temporary DBBroker instance.      */
specifier|private
name|DBBroker
name|broker
init|=
literal|null
decl_stmt|;
comment|/**      * Is any of the databases read-only?      */
specifier|private
name|boolean
name|readOnly
init|=
literal|false
decl_stmt|;
comment|/**      * The broker pool.      */
specifier|private
name|BrokerPool
name|pool
init|=
literal|null
decl_stmt|;
comment|/**      * The underlying native db.      */
specifier|private
name|CollectionStore
name|collectionsDb
init|=
literal|null
decl_stmt|;
comment|/**      * The Log4J logger.      */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NativeCollectionIndexer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Create a new NativeCollectionIndexer. The CollectionStore      * must be initialized when calling this constructor.      *       * Refactor note: currently, DBBroker is used here, but      * this should<b>not</b> be the case in future.      *        * @param pool broker pool to use      * @param broker the broker to use      * @param collectionsDb initialized collectionsDb      */
specifier|public
name|NativeCollectionIndexer
parameter_list|(
name|BrokerPool
name|pool
parameter_list|,
name|DBBroker
name|broker
parameter_list|,
name|CollectionStore
name|collectionsDb
parameter_list|)
block|{
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|collectionsDb
operator|=
name|collectionsDb
expr_stmt|;
name|this
operator|.
name|broker
operator|=
name|broker
expr_stmt|;
block|}
comment|/**      * Set read-only if any of the backend datastores      * are set read-only.      *       * @param readOnly true, if one backend db is read-only      */
specifier|public
name|void
name|setReadOnly
parameter_list|(
name|boolean
name|readOnly
parameter_list|)
block|{
name|this
operator|.
name|readOnly
operator|=
name|readOnly
expr_stmt|;
block|}
specifier|public
name|void
name|reloadCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Value
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|getAddress
argument_list|()
operator|==
operator|-
literal|1
condition|)
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|collection
operator|.
name|getAddress
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|collection
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Collection data not found for collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|collection
operator|.
name|read
argument_list|(
name|broker
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections.dbx"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Release the collection id assigned to a collection so it can be      * reused later.      *       * @param id      * @throws PermissionDeniedException      */
specifier|public
name|void
name|freeCollection
parameter_list|(
name|short
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//      LOG.debug("freeing collection " + id);
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_collection_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|2
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|///////////////////// exported DB METHODS
specifier|public
name|void
name|sync
parameter_list|(
name|int
name|syncEvent
parameter_list|)
throws|throws
name|DBException
block|{
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|printStatistics
parameter_list|()
block|{
name|collectionsDb
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|close
parameter_list|()
throws|throws
name|DBException
block|{
return|return
name|collectionsDb
operator|.
name|close
argument_list|()
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Value
name|key
parameter_list|)
throws|throws
name|ReadOnlyException
block|{
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|append
parameter_list|(
name|Value
name|key
parameter_list|,
name|ByteArray
name|value
parameter_list|)
throws|throws
name|ReadOnlyException
throws|,
name|IOException
block|{
return|return
name|collectionsDb
operator|.
name|append
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|public
name|Lock
name|getLock
parameter_list|()
block|{
return|return
name|collectionsDb
operator|.
name|getLock
argument_list|()
return|;
block|}
comment|///////////////////// DB METHODS
specifier|public
name|int
name|getNextDocId
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|int
name|nextDocId
decl_stmt|;
try|try
block|{
name|nextDocId
operator|=
name|getFreeDocId
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e1
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nextDocId
operator|>
operator|-
literal|1
condition|)
return|return
name|nextDocId
return|;
else|else
name|nextDocId
operator|=
literal|1
expr_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__next_doc_id"
argument_list|)
decl_stmt|;
name|Value
name|data
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|data
operator|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextDocId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|nextDocId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"database read-only"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextDocId
return|;
block|}
specifier|public
name|void
name|saveCollection
parameter_list|(
name|Collection
name|collection
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
name|pool
operator|.
name|getCollectionsCache
argument_list|()
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|<
literal|0
condition|)
name|collection
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|Value
name|name
decl_stmt|;
try|try
block|{
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|uee
argument_list|)
expr_stmt|;
name|name
operator|=
operator|new
name|Value
argument_list|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|VariableByteOutputStream
name|ostream
init|=
operator|new
name|VariableByteOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|collection
operator|.
name|write
argument_list|(
name|broker
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
specifier|final
name|long
name|addr
init|=
name|collectionsDb
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|ostream
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"could not store collection data for "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|collection
operator|.
name|setAddress
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ostream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"could not acquire lock for collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      *  get collection object If the collection does not yet exists, it is      *  created automatically.      *      *@param  name                           the collection's name      *@param  user                           Description of the Parameter      *@return                                The orCreateCollection value      *@exception  PermissionDeniedException  Description of the Exception      *@author=@author      */
specifier|public
name|Collection
name|getOrCreateCollection
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//      final long start = System.currentTimeMillis();
name|name
operator|=
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|name
operator|=
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
argument_list|)
condition|)
name|name
operator|=
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
try|try
block|{
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|String
name|temp
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
decl_stmt|;
name|Collection
name|sub
decl_stmt|;
name|Collection
name|current
init|=
name|openCollection
argument_list|(
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
argument_list|,
operator|-
literal|1L
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating root collection /db"
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|Collection
argument_list|(
name|collectionsDb
argument_list|,
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setPermissions
argument_list|(
literal|0777
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|temp
operator|=
name|tok
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|path
operator|=
name|path
operator|+
literal|"/"
operator|+
name|temp
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|hasSubcollection
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|current
operator|=
name|openCollection
argument_list|(
name|path
argument_list|,
operator|-
literal|1L
argument_list|,
name|Lock
operator|.
name|NO_LOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|current
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"permission denied to create collection "
operator|+
name|path
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"not allowed to write to collection"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"creating collection "
operator|+
name|path
argument_list|)
expr_stmt|;
name|sub
operator|=
operator|new
name|Collection
argument_list|(
name|collectionsDb
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setOwner
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|getPermissions
argument_list|()
operator|.
name|setGroup
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setId
argument_list|(
name|getNextCollectionId
argument_list|()
argument_list|)
expr_stmt|;
name|sub
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|addCollection
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|sub
expr_stmt|;
block|}
block|}
comment|//          LOG.debug("getOrCreateCollection took " +
comment|//              (System.currentTimeMillis() - start) + "ms.");
return|return
name|current
return|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      *  Get collection object. If the collection does not exist, null is      *  returned.      *      *@param  name  Description of the Parameter      *@return       The collection value      */
specifier|public
name|Collection
name|openCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|addr
parameter_list|,
name|int
name|lockMode
parameter_list|)
block|{
comment|//  final long start = System.currentTimeMillis();
name|name
operator|=
name|normalizeCollectionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
name|name
operator|=
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
argument_list|)
condition|)
name|name
operator|=
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|Collection
name|collection
init|=
name|collectionsCache
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
comment|//              LOG.debug("loading collection " + name);
name|VariableByteInput
name|is
init|=
literal|null
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|READ_LOCK
argument_list|)
expr_stmt|;
name|collection
operator|=
operator|new
name|Collection
argument_list|(
name|collectionsDb
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Value
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|=
name|collectionsDb
operator|.
name|getAsStream
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|collection
operator|.
name|read
argument_list|(
name|broker
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections.dbx"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lockMode
operator|!=
name|Lock
operator|.
name|NO_LOCK
condition|)
block|{
try|try
block|{
comment|//                  LOG.debug("acquiring lock on " + collection.getName());
name|collection
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|(
name|lockMode
argument_list|)
expr_stmt|;
comment|//                  LOG.debug("lock acquired");
block|}
catch|catch
parameter_list|(
name|LockException
name|e1
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not acquire lock on collection "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|collectionsCache
operator|.
name|add
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|//          LOG.debug(
comment|//              "loading collection "
comment|//                  + name
comment|//                  + " took "
comment|//                  + (System.currentTimeMillis() - start)
comment|//                  + "ms.");
return|return
name|collection
return|;
block|}
block|}
specifier|public
name|void
name|moveCollection
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|Collection
name|destination
parameter_list|,
name|String
name|newName
parameter_list|)
throws|throws
name|PermissionDeniedException
throws|,
name|LockException
block|{
if|if
condition|(
name|readOnly
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getId
argument_list|()
operator|==
name|destination
operator|.
name|getId
argument_list|()
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move collection to itself"
argument_list|)
throw|;
if|if
condition|(
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|NewNativeBroker
operator|.
name|ROOT_COLLECTION
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Cannot move the db root collection"
argument_list|)
throw|;
if|if
condition|(
operator|!
name|collection
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges to move collection "
operator|+
name|collection
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
operator|!
name|destination
operator|.
name|getPermissions
argument_list|()
operator|.
name|validate
argument_list|(
name|broker
operator|.
name|getUser
argument_list|()
argument_list|,
name|Permission
operator|.
name|WRITE
argument_list|)
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"Insufficient privileges on target collection "
operator|+
name|destination
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|newName
operator|==
literal|null
condition|)
block|{
name|int
name|p
init|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|newName
operator|=
name|collection
operator|.
name|getName
argument_list|()
operator|.
name|substring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newName
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|>
operator|-
literal|1
condition|)
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
literal|"New collection name is illegal (may not contain a '/')"
argument_list|)
throw|;
comment|// check if another collection with the same name exists at the destination
name|Collection
name|old
init|=
name|openCollection
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|,
operator|-
literal|1
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|broker
operator|.
name|removeCollection
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|old
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|name
init|=
name|collection
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|CollectionCache
name|collectionsCache
init|=
name|pool
operator|.
name|getCollectionsCache
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|collectionsCache
init|)
block|{
name|Collection
name|parent
init|=
name|openCollection
argument_list|(
name|collection
operator|.
name|getParentPath
argument_list|()
argument_list|,
operator|-
literal|1L
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|removeCollection
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|parent
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
name|Lock
name|lock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|collectionsCache
operator|.
name|remove
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|Value
name|key
decl_stmt|;
try|try
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|key
operator|=
operator|new
name|Value
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setName
argument_list|(
name|destination
operator|.
name|getName
argument_list|()
operator|+
literal|'/'
operator|+
name|newName
argument_list|)
expr_stmt|;
name|collection
operator|.
name|setCreationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|destination
operator|.
name|addCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|saveCollection
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|destination
condition|)
name|saveCollection
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|saveCollection
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|String
name|childName
decl_stmt|;
name|Collection
name|child
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|collection
operator|.
name|collectionIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|childName
operator|=
operator|(
name|String
operator|)
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|child
operator|=
name|openCollection
argument_list|(
name|name
operator|+
literal|'/'
operator|+
name|childName
argument_list|,
operator|-
literal|1L
argument_list|,
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Child collection "
operator|+
name|childName
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
name|moveCollection
argument_list|(
name|child
argument_list|,
name|collection
argument_list|,
name|childName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|child
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
specifier|final
specifier|static
name|String
name|normalizeCollectionName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'/'
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
name|i
operator|+
literal|1
operator|&&
name|name
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
else|else
name|out
operator|.
name|append
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Get the next available unique collection id.      *       * @return      * @throws ReadOnlyException      */
specifier|private
name|short
name|getNextCollectionId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|short
name|nextCollectionId
init|=
name|getFreeCollectionId
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextCollectionId
operator|>
operator|-
literal|1
condition|)
return|return
name|nextCollectionId
return|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__next_collection_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|data
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|nextCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|nextCollectionId
expr_stmt|;
block|}
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|shortToByte
argument_list|(
name|nextCollectionId
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|d
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|nextCollectionId
return|;
block|}
comment|/**      * Get the next free collection id. If a collection is removed, its collection id      * is released so it can be reused.      *       * @return      * @throws ReadOnlyException      */
specifier|private
name|short
name|getFreeCollectionId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|short
name|freeCollectionId
init|=
operator|-
literal|1
decl_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_collection_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeCollectionId
operator|=
name|ByteConversion
operator|.
name|byteToShort
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|//              LOG.debug("reusing collection id: " + freeCollectionId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|2
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|freeCollectionId
return|;
block|}
comment|/**      * Get the next unused document id. If a document is removed, its doc id is      * released, so it can be reused.      *       * @return      * @throws ReadOnlyException      */
specifier|private
name|int
name|getFreeDocId
parameter_list|()
throws|throws
name|ReadOnlyException
block|{
name|int
name|freeDocId
init|=
operator|-
literal|1
decl_stmt|;
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_doc_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|freeDocId
operator|=
name|ByteConversion
operator|.
name|byteToInt
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//              LOG.debug("reusing document id: " + freeDocId);
if|if
condition|(
name|data
operator|.
name|length
operator|-
literal|4
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|-
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|,
name|ndata
operator|.
name|length
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
name|collectionsDb
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return
name|freeDocId
return|;
block|}
comment|/**      * Release the document id reserved for a document so it      * can be reused.      *       * @param id      * @throws PermissionDeniedException      */
specifier|public
name|void
name|freeDocument
parameter_list|(
name|int
name|id
parameter_list|)
throws|throws
name|PermissionDeniedException
block|{
comment|//      LOG.debug("freeing document " + id);
name|Value
name|key
init|=
operator|new
name|Value
argument_list|(
literal|"__free_doc_id"
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|collectionsDb
operator|.
name|getLock
argument_list|()
decl_stmt|;
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|(
name|Lock
operator|.
name|WRITE_LOCK
argument_list|)
expr_stmt|;
name|Value
name|value
init|=
name|collectionsDb
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|value
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ndata
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
operator|+
literal|4
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ndata
argument_list|,
literal|4
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|ndata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ndata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteConversion
operator|.
name|intToByte
argument_list|(
name|id
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|collectionsDb
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to acquire lock on collections store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReadOnlyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PermissionDeniedException
argument_list|(
name|NewNativeBroker
operator|.
name|DATABASE_IS_READ_ONLY
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

