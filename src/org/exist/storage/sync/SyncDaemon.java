begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Class taken from Doug Lea's concurrency package. Mainly used to periodically trigger  * a sync to disk for all database brokers. However, other actions could be added as well.  *   * File: ClockDaemon.java  *  * Originally written by Doug Lea and released into the public domain.  * This may be used for any purposes whatsoever without acknowledgment.  * Thanks for the assistance and support of Sun Microsystems Labs,  * and everyone contributing, testing, and using this code.  *  * History:  * Date       Who                What  * 29Aug1998  dl               created initial public version  * 17dec1998  dl               null out thread after shutdown  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|sync
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|Heap
import|;
end_import

begin_comment
comment|/**  * A general-purpose time-based daemon, vaguely similar in functionality  * to common system-level utilities such as<code>at</code>   * (and the associated crond) in Unix.  * Objects of this class maintain a single thread and a task queue  * that may be used to execute Runnable commands in any of three modes --  * absolute (run at a given time), relative (run after a given delay),  * and periodic (cyclically run with a given delay).  *<p>  * All commands are executed by the single background thread.   * The thread is not actually started until the first   * request is encountered. Also, if the  * thread is stopped for any reason, one is started upon encountering  * the next request,  or<code>restart()</code> is invoked.   *<p>  * If you would instead like commands run in their own threads, you can  * use as arguments Runnable commands that start their own threads  * (or perhaps wrap within ThreadedExecutors).   *<p>  * You can also use multiple  * daemon objects, each using a different background thread. However,  * one of the reasons for using a time daemon is to pool together  * processing of infrequent tasks using a single background thread.  *<p>  * Background threads are created using a ThreadFactory. The  * default factory does<em>not</em>  * automatically<code>setDaemon</code> status.  *<p>  * The class uses Java timed waits for scheduling. These can vary  * in precision across platforms, and provide no real-time guarantees  * about meeting deadlines.  *<p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package.</a>]  **/
end_comment

begin_class
specifier|public
class|class
name|SyncDaemon
block|{
comment|/** tasks are maintained in a standard priority queue **/
specifier|protected
specifier|final
name|Heap
name|heap_
init|=
operator|new
name|Heap
argument_list|(
literal|5
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
class|class
name|TaskNode
implements|implements
name|Comparable
block|{
specifier|final
name|Runnable
name|command
decl_stmt|;
comment|// The command to run
specifier|final
name|long
name|period
decl_stmt|;
comment|// The cycle period, or -1 if not periodic
specifier|private
name|long
name|timeToRun_
decl_stmt|;
comment|// The time to run command
comment|// Cancellation does not immediately remove node, it just
comment|// sets up lazy deletion bit, so is thrown away when next
comment|// encountered in run loop
specifier|private
name|boolean
name|cancelled_
init|=
literal|false
decl_stmt|;
comment|// Access to cancellation status and and run time needs sync
comment|// since they can be written and read in different threads
specifier|synchronized
name|void
name|setCancelled
parameter_list|()
block|{
name|cancelled_
operator|=
literal|true
expr_stmt|;
block|}
specifier|synchronized
name|boolean
name|getCancelled
parameter_list|()
block|{
return|return
name|cancelled_
return|;
block|}
specifier|synchronized
name|void
name|setTimeToRun
parameter_list|(
name|long
name|w
parameter_list|)
block|{
name|timeToRun_
operator|=
name|w
expr_stmt|;
block|}
specifier|synchronized
name|long
name|getTimeToRun
parameter_list|()
block|{
return|return
name|timeToRun_
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
name|long
name|a
init|=
name|getTimeToRun
argument_list|()
decl_stmt|;
name|long
name|b
init|=
operator|(
operator|(
name|TaskNode
operator|)
operator|(
name|other
operator|)
operator|)
operator|.
name|getTimeToRun
argument_list|()
decl_stmt|;
return|return
operator|(
name|a
operator|<
name|b
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|a
operator|==
name|b
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
name|TaskNode
parameter_list|(
name|long
name|w
parameter_list|,
name|Runnable
name|c
parameter_list|,
name|long
name|p
parameter_list|)
block|{
name|timeToRun_
operator|=
name|w
expr_stmt|;
name|command
operator|=
name|c
expr_stmt|;
name|period
operator|=
name|p
expr_stmt|;
block|}
name|TaskNode
parameter_list|(
name|long
name|w
parameter_list|,
name|Runnable
name|c
parameter_list|)
block|{
name|this
argument_list|(
name|w
argument_list|,
name|c
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Execute the given command at the given time.    * @param date -- the absolute time to run the command, expressed    * as a java.util.Date.    * @param command -- the command to run at the given time.    * @return taskID -- an opaque reference that can be used to cancel execution request    **/
specifier|public
name|Object
name|executeAt
parameter_list|(
name|Date
name|date
parameter_list|,
name|Runnable
name|command
parameter_list|)
block|{
name|TaskNode
name|task
init|=
operator|new
name|TaskNode
argument_list|(
name|date
operator|.
name|getTime
argument_list|()
argument_list|,
name|command
argument_list|)
decl_stmt|;
name|heap_
operator|.
name|insert
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|restart
argument_list|()
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**     * Excecute the given command after waiting for the given delay.    *<p>    *<b>Sample Usage.</b>    * You can use a ClockDaemon to arrange timeout callbacks to break out    * of stuck IO. For example (code sketch):    *<pre>    * class X {   ...    *     *   ClockDaemon timer = ...    *   Thread readerThread;    *   FileInputStream datafile;    *     *   void startReadThread() {    *     datafile = new FileInputStream("data", ...);    *     *     readerThread = new Thread(new Runnable() {    *      public void run() {    *        for(;;) {    *          // try to gracefully exit before blocking    *         if (Thread.currentThread().isInterrupted()) {    *           quietlyWrapUpAndReturn();    *         }    *         else {    *           try {    *             int c = datafile.read();    *             if (c == -1) break;    *             else process(c);    *           }    *           catch (IOException ex) {    *            cleanup();    *            return;    *          }    *       }    *     } };    *    *    readerThread.start();    *    *    // establish callback to cancel after 60 seconds    *    timer.executeAfterDelay(60000, new Runnable() {    *      readerThread.interrupt();    // try to interrupt thread    *      datafile.close(); // force thread to lose its input file     *    });    *   }     * }    *</pre>    * @param millisecondsToDelay -- the number of milliseconds    * from now to run the command.    * @param command -- the command to run after the delay.    * @return taskID -- an opaque reference that can be used to cancel execution request    **/
specifier|public
name|Object
name|executeAfterDelay
parameter_list|(
name|long
name|millisecondsToDelay
parameter_list|,
name|Runnable
name|command
parameter_list|)
block|{
name|long
name|runtime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|millisecondsToDelay
decl_stmt|;
name|TaskNode
name|task
init|=
operator|new
name|TaskNode
argument_list|(
name|runtime
argument_list|,
name|command
argument_list|)
decl_stmt|;
name|heap_
operator|.
name|insert
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|restart
argument_list|()
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**     * Execute the given command every<code>period</code> milliseconds.    * If<code>startNow</code> is true, execution begins immediately,    * otherwise, it begins after the first<code>period</code> delay.    *<p>    *<b>Sample Usage</b>. Here is one way    * to update Swing components acting as progress indicators for    * long-running actions.    *<pre>    * class X {    *   JLabel statusLabel = ...;    *    *   int percentComplete = 0;    *   synchronized int  getPercentComplete() { return percentComplete; }    *   synchronized void setPercentComplete(int p) { percentComplete = p; }    *    *   ClockDaemon cd = ...;    *     *   void startWorking() {    *     Runnable showPct = new Runnable() {    *       public void run() {    *          SwingUtilities.invokeLater(new Runnable() {    *            public void run() {    *              statusLabel.setText(getPercentComplete() + "%");    *            }     *          }     *       }     *     };    *    *     final Object updater = cd.executePeriodically(500, showPct, true);    *    *     Runnable action = new Runnable() {    *       public void run() {    *         for (int i = 0; i< 100; ++i) {    *           work();    *           setPercentComplete(i);    *         }    *         cd.cancel(updater);    *       }    *     };    *    *     new Thread(action).start();    *   }    * }      *</pre>    * @param period -- the period, in milliseconds. Periods are    *  measured from start-of-task to the next start-of-task. It is    * generally a bad idea to use a period that is shorter than     * the expected task duration.    * @param command -- the command to run at each cycle    * @param startNow -- true if the cycle should start with execution    * of the task now. Otherwise, the cycle starts with a delay of    *<code>period</code> milliseconds.    * @exception IllegalArgumentException if period less than or equal to zero.    * @return taskID -- an opaque reference that can be used to cancel execution request    **/
specifier|public
name|Object
name|executePeriodically
parameter_list|(
name|long
name|period
parameter_list|,
name|Runnable
name|command
parameter_list|,
name|boolean
name|startNow
parameter_list|)
block|{
if|if
condition|(
name|period
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
name|long
name|firstTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|startNow
condition|)
name|firstTime
operator|+=
name|period
expr_stmt|;
name|TaskNode
name|task
init|=
operator|new
name|TaskNode
argument_list|(
name|firstTime
argument_list|,
name|command
argument_list|,
name|period
argument_list|)
decl_stmt|;
name|heap_
operator|.
name|insert
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|restart
argument_list|()
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**     * Cancel a scheduled task that has not yet been run.     * The task will be cancelled    * upon the<em>next</em> opportunity to run it. This has no effect if    * this is a one-shot task that has already executed.    * Also, if an execution is in progress, it will complete normally.    * (It may however be interrupted via getThread().interrupt()).    * But if it is a periodic task, future iterations are cancelled.     * @param taskID -- a task reference returned by one of    * the execute commands    * @exception ClassCastException if the taskID argument is not     * of the type returned by an execute command.    **/
specifier|public
specifier|static
name|void
name|cancel
parameter_list|(
name|Object
name|taskID
parameter_list|)
block|{
operator|(
operator|(
name|TaskNode
operator|)
name|taskID
operator|)
operator|.
name|setCancelled
argument_list|()
expr_stmt|;
block|}
comment|/** The thread used to process commands **/
specifier|protected
name|Thread
name|thread_
decl_stmt|;
comment|/**    * Return the thread being used to process commands, or    * null if there is no such thread. You can use this    * to invoke any special methods on the thread, for    * example, to interrupt it.    **/
specifier|public
specifier|synchronized
name|Thread
name|getThread
parameter_list|()
block|{
return|return
name|thread_
return|;
block|}
comment|/** set thread_ to null to indicate termination **/
specifier|protected
specifier|synchronized
name|void
name|clearThread
parameter_list|()
block|{
name|thread_
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Start (or restart) a thread to process commands, or wake    * up an existing thread if one is already running. This    * method can be invoked if the background thread crashed    * due to an unrecoverable exception in an executed command.    **/
specifier|public
specifier|synchronized
name|void
name|restart
parameter_list|()
block|{
if|if
condition|(
name|thread_
operator|==
literal|null
condition|)
block|{
name|thread_
operator|=
operator|new
name|Thread
argument_list|(
name|runLoop_
argument_list|)
expr_stmt|;
name|thread_
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
name|notify
argument_list|()
expr_stmt|;
block|}
comment|/**    * Cancel all tasks and interrupt the background thread executing    * the current task, if any.    * A new background thread will be started if new execution    * requests are encountered. If the currently executing task    * does not repsond to interrupts, the current thread may persist, even    * if a new thread is started via restart().    **/
specifier|public
specifier|synchronized
name|void
name|shutDown
parameter_list|()
block|{
name|heap_
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|thread_
operator|!=
literal|null
condition|)
name|thread_
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|thread_
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Return the next task to execute, or null if thread is interrupted **/
specifier|protected
specifier|synchronized
name|TaskNode
name|nextTask
parameter_list|()
block|{
comment|// Note: This code assumes that there is only one run loop thread
try|try
block|{
while|while
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// Using peek simplifies dealing with spurious wakeups
name|TaskNode
name|task
init|=
operator|(
name|TaskNode
operator|)
operator|(
name|heap_
operator|.
name|peek
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|task
operator|==
literal|null
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|when
init|=
name|task
operator|.
name|getTimeToRun
argument_list|()
decl_stmt|;
if|if
condition|(
name|when
operator|>
name|now
condition|)
block|{
comment|// false alarm wakeup
name|wait
argument_list|(
name|when
operator|-
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|task
operator|=
operator|(
name|TaskNode
operator|)
operator|(
name|heap_
operator|.
name|extract
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|task
operator|.
name|getCancelled
argument_list|()
condition|)
block|{
comment|// Skip if cancelled by
if|if
condition|(
name|task
operator|.
name|period
operator|>
literal|0
condition|)
block|{
comment|// If periodic, requeue
name|task
operator|.
name|setTimeToRun
argument_list|(
name|now
operator|+
name|task
operator|.
name|period
argument_list|)
expr_stmt|;
name|heap_
operator|.
name|insert
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
return|return
name|task
return|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
block|}
comment|// fall through
return|return
literal|null
return|;
comment|// on interrupt
block|}
comment|/**    * The runloop is isolated in its own Runnable class    * just so that the main     * class need not implement Runnable,  which would    * allow others to directly invoke run, which is not supported.    **/
specifier|protected
class|class
name|RunLoop
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|TaskNode
name|task
init|=
name|nextTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
name|task
operator|.
name|command
operator|.
name|run
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
finally|finally
block|{
name|clearThread
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|protected
specifier|final
name|RunLoop
name|runLoop_
decl_stmt|;
comment|/**     * Create a new ClockDaemon     **/
specifier|public
name|SyncDaemon
parameter_list|()
block|{
name|runLoop_
operator|=
operator|new
name|RunLoop
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

