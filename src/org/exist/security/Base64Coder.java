begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|security
package|;
end_package

begin_comment
comment|/************************************************************************** * * A Base64 Encoder/Decoder. * * This class is used to encode and decode data in Base64 format * as described in RFC 1521. * *<p> * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br> * License: This is "Open Source" software and released under the<a href="http://www.gnu.org/licenses/lgpl.html" target="_top">GNU/LGPL</a> license. * It is provided "as is" without warranty of any kind. Please contact the author for other licensing arrangements.<br> * Home page:<a href="http://www.source-code.biz" target="_top">www.source-code.biz</a><br> * *<p> * Version history:<br> * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br> * 2005-08-11 chdh: Lincense changed from GPL to LGPL. * **************************************************************************/
end_comment

begin_class
specifier|public
class|class
name|Base64Coder
block|{
comment|// Mapping table from 6-bit nibbles to Base64 characters.
specifier|private
specifier|static
name|char
index|[]
name|map1
init|=
operator|new
name|char
index|[
literal|64
index|]
decl_stmt|;
static|static
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
name|c
init|=
literal|'A'
init|;
name|c
operator|<=
literal|'Z'
condition|;
name|c
operator|++
control|)
name|map1
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
for|for
control|(
name|char
name|c
init|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
name|map1
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
for|for
control|(
name|char
name|c
init|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
name|map1
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|map1
index|[
name|i
operator|++
index|]
operator|=
literal|'+'
expr_stmt|;
name|map1
index|[
name|i
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
comment|// Mapping table from Base64 characters to 6-bit nibbles.
specifier|private
specifier|static
name|byte
index|[]
name|map2
init|=
operator|new
name|byte
index|[
literal|128
index|]
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|map2
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|map2
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|map2
index|[
name|map1
index|[
name|i
index|]
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
block|}
comment|/** * Encodes a string into Base64 format. * No blanks or line breaks are inserted. * @param s  a String to be encoded. * @return   A String with the Base64 encoded data. */
specifier|public
specifier|static
name|String
name|encode
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|encode
argument_list|(
name|s
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** * Encodes a byte array into Base64 format. * No blanks or line breaks are inserted. * @param in  an array containing the data bytes to be encoded. * @return    A character array with the Base64 encoded data. */
specifier|public
specifier|static
name|char
index|[]
name|encode
parameter_list|(
name|byte
index|[]
name|in
parameter_list|)
block|{
name|int
name|iLen
init|=
name|in
operator|.
name|length
decl_stmt|;
name|int
name|oDataLen
init|=
operator|(
name|iLen
operator|*
literal|4
operator|+
literal|2
operator|)
operator|/
literal|3
decl_stmt|;
comment|// output length without padding
name|int
name|oLen
init|=
operator|(
operator|(
name|iLen
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|*
literal|4
decl_stmt|;
comment|// output length including padding
name|char
index|[]
name|out
init|=
operator|new
name|char
index|[
name|oLen
index|]
decl_stmt|;
name|int
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|op
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ip
operator|<
name|iLen
condition|)
block|{
name|int
name|i0
init|=
name|in
index|[
name|ip
operator|++
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|i1
init|=
name|ip
operator|<
name|iLen
condition|?
name|in
index|[
name|ip
operator|++
index|]
operator|&
literal|0xff
else|:
literal|0
decl_stmt|;
name|int
name|i2
init|=
name|ip
operator|<
name|iLen
condition|?
name|in
index|[
name|ip
operator|++
index|]
operator|&
literal|0xff
else|:
literal|0
decl_stmt|;
name|int
name|o0
init|=
name|i0
operator|>>>
literal|2
decl_stmt|;
name|int
name|o1
init|=
operator|(
operator|(
name|i0
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|i1
operator|>>>
literal|4
operator|)
decl_stmt|;
name|int
name|o2
init|=
operator|(
operator|(
name|i1
operator|&
literal|0xf
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|i2
operator|>>>
literal|6
operator|)
decl_stmt|;
name|int
name|o3
init|=
name|i2
operator|&
literal|0x3F
decl_stmt|;
name|out
index|[
name|op
operator|++
index|]
operator|=
name|map1
index|[
name|o0
index|]
expr_stmt|;
name|out
index|[
name|op
operator|++
index|]
operator|=
name|map1
index|[
name|o1
index|]
expr_stmt|;
name|out
index|[
name|op
index|]
operator|=
name|op
operator|<
name|oDataLen
condition|?
name|map1
index|[
name|o2
index|]
else|:
literal|'='
expr_stmt|;
name|op
operator|++
expr_stmt|;
name|out
index|[
name|op
index|]
operator|=
name|op
operator|<
name|oDataLen
condition|?
name|map1
index|[
name|o3
index|]
else|:
literal|'='
expr_stmt|;
name|op
operator|++
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
comment|/** * Decodes a Base64 string. * @param s  a Base64 String to be decoded. * @return   A String containing the decoded data. * @throws   IllegalArgumentException if the input is not valid Base64 encoded data. */
specifier|public
specifier|static
name|String
name|decode
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|decode
argument_list|(
name|s
operator|.
name|toCharArray
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** * Decodes Base64 data. * No blanks or line breaks are allowed within the Base64 encoded data. * @param in  a character array containing the Base64 encoded data. * @return    An array containing the decoded data bytes. * @throws    IllegalArgumentException if the input is not valid Base64 encoded data. */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
name|char
index|[]
name|in
parameter_list|)
block|{
name|int
name|iLen
init|=
name|in
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|iLen
operator|%
literal|4
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Length of Base64 encoded input string is not a multiple of 4."
argument_list|)
throw|;
while|while
condition|(
name|iLen
operator|>
literal|0
operator|&&
name|in
index|[
name|iLen
operator|-
literal|1
index|]
operator|==
literal|'='
condition|)
name|iLen
operator|--
expr_stmt|;
name|int
name|oLen
init|=
operator|(
name|iLen
operator|*
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|byte
index|[]
name|out
init|=
operator|new
name|byte
index|[
name|oLen
index|]
decl_stmt|;
name|int
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|op
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ip
operator|<
name|iLen
condition|)
block|{
name|int
name|i0
init|=
name|in
index|[
name|ip
operator|++
index|]
decl_stmt|;
name|int
name|i1
init|=
name|in
index|[
name|ip
operator|++
index|]
decl_stmt|;
name|int
name|i2
init|=
name|ip
operator|<
name|iLen
condition|?
name|in
index|[
name|ip
operator|++
index|]
else|:
literal|'A'
decl_stmt|;
name|int
name|i3
init|=
name|ip
operator|<
name|iLen
condition|?
name|in
index|[
name|ip
operator|++
index|]
else|:
literal|'A'
decl_stmt|;
if|if
condition|(
name|i0
operator|>
literal|127
operator|||
name|i1
operator|>
literal|127
operator|||
name|i2
operator|>
literal|127
operator|||
name|i3
operator|>
literal|127
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal character in Base64 encoded data."
argument_list|)
throw|;
name|int
name|b0
init|=
name|map2
index|[
name|i0
index|]
decl_stmt|;
name|int
name|b1
init|=
name|map2
index|[
name|i1
index|]
decl_stmt|;
name|int
name|b2
init|=
name|map2
index|[
name|i2
index|]
decl_stmt|;
name|int
name|b3
init|=
name|map2
index|[
name|i3
index|]
decl_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0
operator|||
name|b1
operator|<
literal|0
operator|||
name|b2
operator|<
literal|0
operator|||
name|b3
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal character in Base64 encoded data."
argument_list|)
throw|;
name|int
name|o0
init|=
operator|(
name|b0
operator|<<
literal|2
operator|)
operator||
operator|(
name|b1
operator|>>>
literal|4
operator|)
decl_stmt|;
name|int
name|o1
init|=
operator|(
operator|(
name|b1
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|b2
operator|>>>
literal|2
operator|)
decl_stmt|;
name|int
name|o2
init|=
operator|(
operator|(
name|b2
operator|&
literal|3
operator|)
operator|<<
literal|6
operator|)
operator||
name|b3
decl_stmt|;
name|out
index|[
name|op
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|o0
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|oLen
condition|)
name|out
index|[
name|op
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|o1
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|oLen
condition|)
name|out
index|[
name|op
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|o2
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|decode
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

