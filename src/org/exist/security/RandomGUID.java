begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2002-2004 the original author or authors.  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not  * use this file except in compliance with the License. You may obtain a copy of  * the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  *  * This class is taken from the spring framework.  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|security
package|;
end_package

begin_comment
comment|/*  * RandomGUID from http://www.javaexchange.com/aboutRandomGUID.html  * @version 1.2.1 11/05/02  * @author Marc A. Mnich  *  * From www.JavaExchange.com, Open Software licensing  *  * 11/05/02 -- Performance enhancement from Mike Dubman.  *             Moved InetAddr.getLocal to static block.  Mike has measured  *             a 10 fold improvement in run time.  * 01/29/02 -- Bug fix: Improper seeding of nonsecure Random object  *             caused duplicate GUIDs to be produced.  Random object  *             is now only created once per JVM.  * 01/19/02 -- Modified random seeding and added new constructor  *             to allow secure random feature.  * 01/14/02 -- Added random function seeding with JVM run time  */
end_comment

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_comment
comment|/**  * Globally unique identifier generator.  *  *<p>  * In the multitude of java GUID generators, I found none that guaranteed  * randomness. GUIDs are guaranteed to be globally unique by using ethernet  * MACs, IP addresses, time elements, and sequential numbers. GUIDs are not  * expected to be random and most often are easy/possible to guess given a  * sample from a given generator. SQL Server, for example generates GUID that  * are unique but sequencial within a given instance.  *<p>  * GUIDs can be used as security devices to hide things such as files within a  * filesystem where listings are unavailable (e.g. files that are served up from  * a Web server with indexing turned off). This may be desireable in cases where  * standard authentication is not appropriate. In this scenario, the RandomGuids  * are used as directories. Another example is the use of GUIDs for primary keys  * in a database where you want to ensure that the keys are secret. Random GUIDs  * can then be used in a URL to prevent hackers (or users) from accessing  * records by guessing or simply by incrementing sequential numbers.  *<p>  * There are many other possiblities of using GUIDs in the realm of security and  * encryption where the element of randomness is important. This class was  * written for these purposes but can also be used as a general purpose GUID  * generator as well.  *<p>  * RandomGuid generates truly random GUIDs by using the system's IP address  * (name/IP), system time in milliseconds (as an integer), and a very large  * random number joined together in a single String that is passed through an  * MD5 hash. The IP address and system time make the MD5 seed globally unique  * and the random number guarantees that the generated GUIDs will have no  * discernable pattern and cannot be guessed given any number of previously  * generated GUIDs. It is generally not possible to access the seed information  * (IP, time, random number) from the resulting GUIDs as the MD5 hash algorithm  * provides one way encryption.  *<p>  *<b>Security of RandomGuid</b>: RandomGuid can be called one of two ways --  * with the basic java Random number generator or a cryptographically strong  * random generator (SecureRandom). The choice is offered because the secure  * random generator takes about 3.5 times longer to generate its random numbers  * and this performance hit may not be worth the added security especially  * considering the basic generator is seeded with a cryptographically strong  * random seed.  *<p>  * Seeding the basic generator in this way effectively decouples the random  * numbers from the time component making it virtually impossible to predict the  * random number component even if one had absolute knowledge of the System  * time. Thanks to Ashutosh Narhari for the suggestion of using the static  * method to prime the basic random generator.  *<p>  * Using the secure random option, this class complies with the statistical  * random number generator tests specified in FIPS 140-2, Security Requirements  * for Cryptographic Modules, secition 4.9.1.  *<p>  * I converted all the pieces of the seed to a String before handing it over to  * the MD5 hash so that you could print it out to make sure it contains the data  * you expect to see and to give a nice warm fuzzy. If you need better  * performance, you may want to stick to byte[] arrays.  *<p>  * I believe that it is important that the algorithm for generating random GUIDs  * be open for inspection and modification. This class is free for all uses.  *  * @version 1.2.1 11/05/02  * @author Marc A. Mnich  */
end_comment

begin_class
specifier|public
class|class
name|RandomGUID
extends|extends
name|Object
block|{
specifier|private
specifier|static
name|Random
name|random
decl_stmt|;
specifier|private
specifier|static
name|SecureRandom
name|secureRandom
decl_stmt|;
specifier|private
specifier|static
name|String
name|id
decl_stmt|;
specifier|private
name|String
name|valueBeforeMD5
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|valueAfterMD5
init|=
literal|""
decl_stmt|;
comment|/*          * Static block to take care of one time secureRandom seed. It takes a few          * seconds to initialize SecureRandom. You might want to consider removing          * this static block or replacing it with a "time since first loaded" seed          * to reduce this time. This block will run only once per JVM instance.          */
static|static
block|{
name|secureRandom
operator|=
operator|new
name|SecureRandom
argument_list|()
expr_stmt|;
name|long
name|secureInitializer
init|=
name|secureRandom
operator|.
name|nextLong
argument_list|()
decl_stmt|;
name|random
operator|=
operator|new
name|Random
argument_list|(
name|secureInitializer
argument_list|)
expr_stmt|;
try|try
block|{
name|id
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Default constructor. With no specification of security option, this      * constructor defaults to lower security, high performance.      */
specifier|public
name|RandomGUID
parameter_list|()
block|{
name|getRandomGuid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor with security option. Setting secure true enables each random      * number generated to be cryptographically strong. Secure false defaults to      * the standard Random function seeded with a single cryptographically      * strong random number.      */
specifier|public
name|RandomGUID
parameter_list|(
name|boolean
name|secure
parameter_list|)
block|{
name|getRandomGuid
argument_list|(
name|secure
argument_list|)
expr_stmt|;
block|}
comment|/**      * Method to generate the random GUID      */
specifier|private
name|void
name|getRandomGuid
parameter_list|(
name|boolean
name|secure
parameter_list|)
block|{
name|MessageDigest
name|md5
init|=
literal|null
decl_stmt|;
name|StringBuffer
name|sbValueBeforeMD5
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|md5
operator|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Error: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|long
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|rand
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|secure
condition|)
block|{
name|rand
operator|=
name|secureRandom
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rand
operator|=
name|random
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
comment|// This StringBuffer can be a long as you need; the MD5
comment|// hash will always return 128 bits. You can change
comment|// the seed to include anything you want here.
comment|// You could even stream a file through the MD5 making
comment|// the odds of guessing it at least as great as that
comment|// of guessing the contents of the file!
name|sbValueBeforeMD5
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|sbValueBeforeMD5
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sbValueBeforeMD5
operator|.
name|append
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|time
argument_list|)
argument_list|)
expr_stmt|;
name|sbValueBeforeMD5
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sbValueBeforeMD5
operator|.
name|append
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|rand
argument_list|)
argument_list|)
expr_stmt|;
name|valueBeforeMD5
operator|=
name|sbValueBeforeMD5
operator|.
name|toString
argument_list|()
expr_stmt|;
name|md5
operator|.
name|update
argument_list|(
name|valueBeforeMD5
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|array
init|=
name|md5
operator|.
name|digest
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|array
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|int
name|b
init|=
name|array
index|[
name|j
index|]
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0x10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toHexString
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|valueAfterMD5
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Error:"
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Convert to the standard format for GUID (Useful for SQL Server      * UniqueIdentifiers, etc.) Example: C2FEEEAC-CFCD-11D1-8B05-00600806D9B6      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|raw
init|=
name|valueAfterMD5
operator|.
name|toUpperCase
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|raw
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|raw
operator|.
name|substring
argument_list|(
literal|8
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|raw
operator|.
name|substring
argument_list|(
literal|12
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|raw
operator|.
name|substring
argument_list|(
literal|16
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|raw
operator|.
name|substring
argument_list|(
literal|20
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

