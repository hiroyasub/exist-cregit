begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|regex
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|FastStringBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|UTF16CharacterSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
operator|.
name|StringValue
import|;
end_import

begin_comment
comment|/**  * This class translates XML Schema regex syntax into JDK 1.5 regex syntax. This differs from the JDK 1.4  * translator because JDK 1.5 handles non-BMP characters (wide characters) in places where JDK 1.4 does not,  * for example in a range such as [X-Y]. This enables much of the code from the 1.4 translator to be  * removed.  * Author: James Clark, Thai Open Source Software Center Ltd. See statement at end of file.  * Modified by Michael Kay (a) to integrate the code into Saxon, and (b) to support XPath additions  * to the XML Schema regex syntax. This version also removes most of the complexities of handling non-BMP  * characters, since JDK 1.5 handles these natively.  *   * Copied from Saxon-HE 9.2 package net.sf.saxon.regex.  */
end_comment

begin_class
specifier|public
class|class
name|JDK15RegexTranslator
extends|extends
name|RegexTranslator
block|{
name|int
name|XML10
init|=
literal|10
decl_stmt|;
comment|/**      * Translates XML Schema and XPath regexes into<code>java.util.regex</code> regexes.      *      * @see java.util.regex.Pattern      * @see<a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema Part 2</a>      */
specifier|public
specifier|static
specifier|final
name|CharClass
index|[]
name|categoryCharClasses
init|=
operator|new
name|CharClass
index|[
name|RegexData
operator|.
name|categories
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CharClass
index|[]
name|subCategoryCharClasses
init|=
operator|new
name|CharClass
index|[
name|RegexData
operator|.
name|subCategories
operator|.
name|length
argument_list|()
operator|/
literal|2
index|]
decl_stmt|;
comment|/**      * CharClass for each block name in specialBlockNames.      */
specifier|public
specifier|static
specifier|final
name|CharClass
index|[]
name|specialBlockCharClasses
init|=
block|{
operator|new
name|CharRange
argument_list|(
literal|0x10300
argument_list|,
literal|0x1032F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x10330
argument_list|,
literal|0x1034F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x10400
argument_list|,
literal|0x1044F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x1D000
argument_list|,
literal|0x1D0FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x1D100
argument_list|,
literal|0x1D1FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x1D400
argument_list|,
literal|0x1D7FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x20000
argument_list|,
literal|0x2A6D6
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x2F800
argument_list|,
literal|0x2FA1F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0xE0000
argument_list|,
literal|0xE007F
argument_list|)
block|,
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|CharRange
argument_list|(
literal|0xE000
argument_list|,
literal|0xF8FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0xF0000
argument_list|,
literal|0xFFFFD
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x100000
argument_list|,
literal|0x10FFFD
argument_list|)
block|}
argument_list|)
block|,
name|Empty
operator|.
name|getInstance
argument_list|()
block|,
name|Empty
operator|.
name|getInstance
argument_list|()
block|,
name|Empty
operator|.
name|getInstance
argument_list|()
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|DOT_SCHEMA
init|=
operator|new
name|Complement
argument_list|(
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|SingleChar
argument_list|(
literal|'\n'
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\r'
argument_list|)
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_d
init|=
operator|new
name|Property
argument_list|(
literal|"Nd"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_D
init|=
operator|new
name|Complement
argument_list|(
name|ESC_d
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_W
init|=
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
name|computeCategoryCharClass
argument_list|(
literal|'P'
argument_list|)
block|,
name|computeCategoryCharClass
argument_list|(
literal|'Z'
argument_list|)
block|,
name|computeCategoryCharClass
argument_list|(
literal|'C'
argument_list|)
block|}
argument_list|)
decl_stmt|;
comment|//was: new Property("P"), new Property("Z"), new Property("C") }
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_w
init|=
operator|new
name|Complement
argument_list|(
name|ESC_W
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_s
init|=
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|SingleChar
argument_list|(
literal|' '
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\n'
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\r'
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\t'
argument_list|)
block|}
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_S
init|=
operator|new
name|Complement
argument_list|(
name|ESC_s
argument_list|)
decl_stmt|;
comment|//    private static final CharClass ESC_i = makeCharClass(RegexData.NMSTRT_CATEGORIES,
comment|//            RegexData.NMSTRT_INCLUDES,
comment|//            RegexData.NMSTRT_EXCLUDE_RANGES);
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_i_10
init|=
name|makeNameCharClass
argument_list|(
name|XMLCharacterData
operator|.
name|NAME_START_10_MASK
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_i_11
init|=
name|makeNameCharClass
argument_list|(
name|XMLCharacterData
operator|.
name|NAME_START_11_MASK
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_I_10
init|=
operator|new
name|Complement
argument_list|(
name|ESC_i_10
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_I_11
init|=
operator|new
name|Complement
argument_list|(
name|ESC_i_11
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_c_10
init|=
name|makeNameCharClass
argument_list|(
name|XMLCharacterData
operator|.
name|NAME_10_MASK
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_c_11
init|=
name|makeNameCharClass
argument_list|(
name|XMLCharacterData
operator|.
name|NAME_11_MASK
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_C_10
init|=
operator|new
name|Complement
argument_list|(
name|ESC_c_10
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharClass
name|ESC_C_11
init|=
operator|new
name|Complement
argument_list|(
name|ESC_c_11
argument_list|)
decl_stmt|;
comment|//    private static final CharClass ESC_I = new Complement(ESC_i);
comment|//    private static final CharClass ESC_c = makeCharClass(RegexData.NMCHAR_CATEGORIES,
comment|//            RegexData.NMCHAR_INCLUDES,
comment|//            RegexData.NMCHAR_EXCLUDE_RANGES);
comment|//
comment|//    private static final CharClass ESC_C = new Complement(ESC_c);
specifier|private
name|JDK15RegexTranslator
parameter_list|()
block|{
block|}
comment|/**      * Translates a regular expression in the syntax of XML Schemas Part 2 into a regular      * expression in the syntax of<code>java.util.regex.Pattern</code>.  The translation      * assumes that the string to be matched against the regex uses surrogate pairs correctly.      * If the string comes from XML content, a conforming XML parser will automatically      * check this; if the string comes from elsewhere, it may be necessary to check      * surrogate usage before matching.      * @param xmlVersion set to {@link net.sf.saxon.Configuration#XML10} for XML 1.0      * or {@link net.sf.saxon.Configuration#XML11} for XML 1.1      * @param regExp a String containing a regular expression in the syntax of XML Schemas Part 2      * @param xpath  a boolean indicating whether the XPath 2.0 F+O extensions to the schema      *               regex syntax are permitted      * @param ignoreWhitespace true if whitespace is to be ignored ('x' flag)      * @param caseBlind true if case is to be ignored ('i' flag)      * @return a JDK 1.5 regular expression      * @throws RegexSyntaxException if<code>regexp</code> is not a regular expression in the      *                              syntax of XML Schemas Part 2, or XPath 2.0, as appropriate      * @see java.util.regex.Pattern      * @see<a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema Part 2</a>      */
specifier|public
specifier|static
name|String
name|translate
parameter_list|(
name|CharSequence
name|regExp
parameter_list|,
name|int
name|xmlVersion
parameter_list|,
name|boolean
name|xpath
parameter_list|,
name|boolean
name|ignoreWhitespace
parameter_list|,
name|boolean
name|caseBlind
parameter_list|)
throws|throws
name|RegexSyntaxException
block|{
comment|//System.err.println("Input regex: " + regexp);
name|JDK15RegexTranslator
name|tr
init|=
operator|new
name|JDK15RegexTranslator
argument_list|()
decl_stmt|;
name|tr
operator|.
name|regExp
operator|=
name|regExp
expr_stmt|;
name|tr
operator|.
name|length
operator|=
name|regExp
operator|.
name|length
argument_list|()
expr_stmt|;
name|tr
operator|.
name|xmlVersion
operator|=
name|xmlVersion
expr_stmt|;
name|tr
operator|.
name|isXPath
operator|=
name|xpath
expr_stmt|;
name|tr
operator|.
name|ignoreWhitespace
operator|=
name|ignoreWhitespace
expr_stmt|;
name|tr
operator|.
name|caseBlind
operator|=
name|caseBlind
expr_stmt|;
name|tr
operator|.
name|advance
argument_list|()
expr_stmt|;
name|tr
operator|.
name|translateTop
argument_list|()
expr_stmt|;
comment|//System.err.println("Output regex: " + tr.result.toString());
return|return
name|tr
operator|.
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|static
specifier|abstract
class|class
name|CharClass
block|{
specifier|protected
name|CharClass
parameter_list|()
block|{
block|}
specifier|abstract
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
function_decl|;
specifier|abstract
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
function_decl|;
name|int
name|getSingleChar
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|static
specifier|abstract
class|class
name|SimpleCharClass
extends|extends
name|CharClass
block|{
name|SimpleCharClass
parameter_list|()
block|{
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|inClassOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"[^"
argument_list|)
expr_stmt|;
name|inClassOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
specifier|abstract
name|void
name|inClassOutput
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
function_decl|;
block|}
specifier|static
class|class
name|SingleChar
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|int
name|c
decl_stmt|;
specifier|private
name|boolean
name|isEscaped
init|=
literal|false
decl_stmt|;
name|SingleChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
name|SingleChar
parameter_list|(
name|int
name|c
parameter_list|,
name|boolean
name|isEscaped
parameter_list|)
block|{
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|this
operator|.
name|isEscaped
operator|=
name|isEscaped
expr_stmt|;
block|}
name|int
name|getSingleChar
parameter_list|()
block|{
return|return
name|c
return|;
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|inClassOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|inClassOutput
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
if|if
condition|(
name|isJavaMetaChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\x20"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|buf
operator|.
name|appendWideChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|static
class|class
name|Empty
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|static
specifier|final
name|Empty
name|instance
init|=
operator|new
name|Empty
argument_list|()
decl_stmt|;
specifier|private
name|Empty
parameter_list|()
block|{
block|}
specifier|static
name|Empty
name|getInstance
parameter_list|()
block|{
return|return
name|instance
return|;
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\\x00"
argument_list|)
expr_stmt|;
comment|// no character matches
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"[^\\x00]"
argument_list|)
expr_stmt|;
comment|// every character matches
block|}
name|void
name|inClassOutput
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"BMP output botch"
argument_list|)
throw|;
block|}
block|}
specifier|static
class|class
name|CharRange
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|int
name|lower
decl_stmt|;
specifier|private
specifier|final
name|int
name|upper
decl_stmt|;
name|CharRange
parameter_list|(
name|int
name|lower
parameter_list|,
name|int
name|upper
parameter_list|)
block|{
name|this
operator|.
name|lower
operator|=
name|lower
expr_stmt|;
name|this
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
block|}
name|void
name|inClassOutput
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
if|if
condition|(
name|isJavaMetaChar
argument_list|(
name|lower
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|appendWideChar
argument_list|(
name|lower
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isJavaMetaChar
argument_list|(
name|upper
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|appendWideChar
argument_list|(
name|upper
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Property
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
name|Property
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
name|void
name|inClassOutput
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\\p{"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\\P{"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Subtraction
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|CharClass
name|cc1
decl_stmt|;
specifier|private
specifier|final
name|CharClass
name|cc2
decl_stmt|;
name|Subtraction
parameter_list|(
name|CharClass
name|cc1
parameter_list|,
name|CharClass
name|cc2
parameter_list|)
block|{
comment|// min corresponds to intersection
comment|// complement corresponds to negation
name|this
operator|.
name|cc1
operator|=
name|cc1
expr_stmt|;
name|this
operator|.
name|cc2
operator|=
name|cc2
expr_stmt|;
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|cc1
operator|.
name|output
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"&&"
argument_list|)
expr_stmt|;
name|cc2
operator|.
name|outputComplement
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|cc1
operator|.
name|outputComplement
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cc2
operator|.
name|output
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Union
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|List
name|members
decl_stmt|;
name|Union
parameter_list|(
name|CharClass
index|[]
name|v
parameter_list|)
block|{
name|this
argument_list|(
name|toList
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|List
name|toList
parameter_list|(
name|CharClass
index|[]
name|v
parameter_list|)
block|{
name|List
name|members
init|=
operator|new
name|ArrayList
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|v
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|members
operator|.
name|add
argument_list|(
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|members
return|;
block|}
name|Union
parameter_list|(
name|List
name|members
parameter_list|)
block|{
name|this
operator|.
name|members
operator|=
name|members
expr_stmt|;
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|CharClass
name|cc
init|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|cc
operator|.
name|output
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|int
name|len
init|=
name|members
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|CharClass
name|cc
init|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cc
operator|instanceof
name|SimpleCharClass
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"[^"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
operator|(
operator|(
name|SimpleCharClass
operator|)
name|cc
operator|)
operator|.
name|inClassOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|CharClass
name|cc
init|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cc
operator|instanceof
name|SimpleCharClass
operator|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"&&"
argument_list|)
expr_stmt|;
block|}
name|cc
operator|.
name|outputComplement
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
condition|)
block|{
comment|// empty union, so the complement is everything
name|buf
operator|.
name|append
argument_list|(
literal|"[\u0001-"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|appendWideChar
argument_list|(
name|UTF16CharacterSet
operator|.
name|NONBMP_MAX
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
class|class
name|BackReference
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|int
name|i
decl_stmt|;
name|BackReference
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|this
operator|.
name|i
operator|=
name|i
expr_stmt|;
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|inClassOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|inClassOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|inClassOutput
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"(?:\\"
operator|+
name|i
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// terminate the back-reference with a syntactic separator
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"(?:)"
argument_list|)
expr_stmt|;
comment|// matches a zero-length string, while allowing a quantifier
block|}
block|}
block|}
specifier|static
class|class
name|Complement
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|CharClass
name|cc
decl_stmt|;
name|Complement
parameter_list|(
name|CharClass
name|cc
parameter_list|)
block|{
name|this
operator|.
name|cc
operator|=
name|cc
expr_stmt|;
block|}
name|void
name|output
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|cc
operator|.
name|outputComplement
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplement
parameter_list|(
name|FastStringBuffer
name|buf
parameter_list|)
block|{
name|cc
operator|.
name|output
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|boolean
name|translateAtom
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
name|RegexData
operator|.
name|EOS
case|:
if|if
condition|(
operator|!
name|eos
condition|)
break|break;
comment|// else fall through
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'|'
case|:
case|case
literal|']'
case|:
return|return
literal|false
return|;
case|case
literal|'('
case|:
name|copyCurChar
argument_list|()
expr_stmt|;
name|int
name|thisCapture
init|=
operator|++
name|currentCapture
decl_stmt|;
name|translateRegExp
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|captures
operator|.
name|add
argument_list|(
name|thisCapture
argument_list|)
expr_stmt|;
name|copyCurChar
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'\\'
case|:
name|advance
argument_list|()
expr_stmt|;
name|parseEsc
argument_list|()
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'['
case|:
name|inCharClassExpr
operator|=
literal|true
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
name|parseCharClassExpr
argument_list|()
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'.'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
comment|// under XPath, "." has the same meaning as in JDK 1.5
break|break;
block|}
else|else
block|{
comment|// under XMLSchema, "." means anything except \n or \r, which is different from the XPath/JDK rule
name|DOT_SCHEMA
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
literal|'$'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|caseBlind
condition|)
block|{
name|int
name|thisChar
init|=
name|absorbSurrogatePair
argument_list|()
decl_stmt|;
name|int
index|[]
name|variants
init|=
name|CaseVariants
operator|.
name|getCaseVariants
argument_list|(
name|thisChar
argument_list|)
decl_stmt|;
if|if
condition|(
name|variants
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|CharClass
index|[]
name|chars
init|=
operator|new
name|CharClass
index|[
name|variants
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|chars
index|[
literal|0
index|]
operator|=
operator|new
name|SingleChar
argument_list|(
name|thisChar
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|variants
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|chars
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|new
name|SingleChar
argument_list|(
name|variants
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Union
name|union
init|=
operator|new
name|Union
argument_list|(
name|chars
argument_list|)
decl_stmt|;
name|union
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// else fall through
block|}
comment|// else fall through
block|}
name|copyCurChar
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|CharClass
name|makeNameCharClass
parameter_list|(
name|byte
name|mask
parameter_list|)
block|{
name|List
name|ranges
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|// Add colon to the set of characters matched
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
literal|':'
argument_list|)
argument_list|)
expr_stmt|;
comment|// Plus all the characters from the NCName tables
name|IntRangeSet
name|members
init|=
name|XMLCharacterData
operator|.
name|getCategory
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|int
name|used
init|=
name|members
operator|.
name|getNumberOfRanges
argument_list|()
decl_stmt|;
name|int
index|[]
name|startPoints
init|=
name|members
operator|.
name|getStartPoints
argument_list|()
decl_stmt|;
name|int
index|[]
name|endPoints
init|=
name|members
operator|.
name|getEndPoints
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|startPoints
index|[
name|i
index|]
operator|==
name|endPoints
index|[
name|i
index|]
condition|)
block|{
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|startPoints
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|startPoints
index|[
name|i
index|]
argument_list|,
name|endPoints
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Union
argument_list|(
name|ranges
argument_list|)
return|;
block|}
comment|//    private static CharClass makeCharClass(String categories, String includes, String excludeRanges) {
comment|//        List includeList = new ArrayList(5);
comment|//        for (int i = 0, len = categories.length(); i< len; i += 2)
comment|//            includeList.add(new Property(categories.substring(i, i + 2)));
comment|//        for (int i = 0, len = includes.length(); i< len; i++) {
comment|//            int j = i + 1;
comment|//            for (; j< len&& includes.charAt(j) - includes.charAt(i) == j - i; j++)
comment|//                ;
comment|//            --j;
comment|//            if (i == j - 1)
comment|//                --j;
comment|//            if (i == j)
comment|//                includeList.add(new SingleChar(includes.charAt(i)));
comment|//            else
comment|//                includeList.add(new CharRange(includes.charAt(i), includes.charAt(j)));
comment|//            i = j;
comment|//        }
comment|//        List excludeList = new ArrayList(5);
comment|//        for (int i = 0, len = excludeRanges.length(); i< len; i += 2) {
comment|//            char min = excludeRanges.charAt(i);
comment|//            char max = excludeRanges.charAt(i + 1);
comment|//            if (min == max)
comment|//                excludeList.add(new SingleChar(min));
comment|//            else if (min == max - 1) {
comment|//                excludeList.add(new SingleChar(min));
comment|//                excludeList.add(new SingleChar(max));
comment|//            } else
comment|//                excludeList.add(new CharRange(min, max));
comment|//        }
comment|//        return new Subtraction(new Union(includeList), new Union(excludeList));
comment|//    }
specifier|private
name|CharClass
name|parseEsc
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
literal|'n'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SingleChar
argument_list|(
literal|'\n'
argument_list|,
literal|true
argument_list|)
return|;
case|case
literal|'r'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SingleChar
argument_list|(
literal|'\r'
argument_list|,
literal|true
argument_list|)
return|;
case|case
literal|'t'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SingleChar
argument_list|(
literal|'\t'
argument_list|,
literal|true
argument_list|)
return|;
case|case
literal|'\\'
case|:
case|case
literal|'|'
case|:
case|case
literal|'.'
case|:
case|case
literal|'-'
case|:
case|case
literal|'^'
case|:
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
break|break;
case|case
literal|'s'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_s
return|;
case|case
literal|'S'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_S
return|;
case|case
literal|'i'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|xmlVersion
operator|==
name|XML10
condition|?
name|ESC_i_10
else|:
name|ESC_i_11
operator|)
return|;
case|case
literal|'I'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|xmlVersion
operator|==
name|XML10
condition|?
name|ESC_I_10
else|:
name|ESC_I_11
operator|)
return|;
case|case
literal|'c'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|xmlVersion
operator|==
name|XML10
condition|?
name|ESC_c_10
else|:
name|ESC_c_11
operator|)
return|;
case|case
literal|'C'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|xmlVersion
operator|==
name|XML10
condition|?
name|ESC_C_10
else|:
name|ESC_C_11
operator|)
return|;
case|case
literal|'d'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_d
return|;
case|case
literal|'D'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_D
return|;
case|case
literal|'w'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_w
return|;
case|case
literal|'W'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_W
return|;
case|case
literal|'p'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|parseProp
argument_list|()
return|;
case|case
literal|'P'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|Complement
argument_list|(
name|parseProp
argument_list|()
argument_list|)
return|;
case|case
literal|'0'
case|:
throw|throw
name|makeException
argument_list|(
literal|"backreference cannot start with digit zero"
argument_list|)
throw|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
if|if
condition|(
name|inCharClassExpr
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"back-reference not allowed within []"
argument_list|)
throw|;
block|}
name|int
name|backRef
init|=
operator|(
name|curChar
operator|-
literal|'0'
operator|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
name|int
name|c1
init|=
literal|"0123456789"
operator|.
name|indexOf
argument_list|(
name|curChar
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|int
name|backRef2
init|=
name|backRef
operator|*
literal|10
operator|+
name|c1
decl_stmt|;
if|if
condition|(
name|backRef2
operator|>
name|currentCapture
condition|)
block|{
break|break;
block|}
else|else
block|{
name|backRef
operator|=
name|backRef2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|captures
operator|.
name|contains
argument_list|(
name|backRef
argument_list|)
condition|)
block|{
name|String
name|explanation
init|=
operator|(
name|backRef
operator|>
name|currentCapture
condition|?
literal|"(no such group)"
else|:
literal|"(group not yet closed)"
operator|)
decl_stmt|;
throw|throw
name|makeException
argument_list|(
literal|"invalid backreference \\"
operator|+
name|backRef
operator|+
literal|" "
operator|+
name|explanation
argument_list|)
throw|;
block|}
return|return
operator|new
name|BackReference
argument_list|(
name|backRef
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|makeException
argument_list|(
literal|"digit not allowed after \\"
argument_list|)
throw|;
block|}
case|case
literal|'$'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
break|break;
block|}
comment|// otherwise fall through
default|default:
throw|throw
name|makeException
argument_list|(
literal|"invalid escape sequence"
argument_list|)
throw|;
block|}
name|CharClass
name|tem
init|=
operator|new
name|SingleChar
argument_list|(
name|curChar
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
specifier|private
name|CharClass
name|parseProp
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|expect
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|start
init|=
name|pos
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'}'
condition|)
break|break;
if|if
condition|(
operator|!
name|isAsciiAlnum
argument_list|(
name|curChar
argument_list|)
operator|&&
name|curChar
operator|!=
literal|'-'
condition|)
name|expect
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|CharSequence
name|propertyNameCS
init|=
name|regExp
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignoreWhitespace
operator|&&
operator|!
name|inCharClassExpr
condition|)
block|{
name|propertyNameCS
operator|=
name|StringValue
operator|.
name|collapseWhitespace
argument_list|(
name|propertyNameCS
argument_list|)
expr_stmt|;
block|}
name|String
name|propertyName
init|=
name|propertyNameCS
operator|.
name|toString
argument_list|()
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|propertyName
operator|.
name|length
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
throw|throw
name|makeException
argument_list|(
literal|"empty property name"
argument_list|)
throw|;
case|case
literal|2
case|:
name|int
name|sci
init|=
name|RegexData
operator|.
name|subCategories
operator|.
name|indexOf
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sci
operator|<
literal|0
operator|||
name|sci
operator|%
literal|2
operator|==
literal|1
condition|)
throw|throw
name|makeException
argument_list|(
literal|"unknown category"
argument_list|)
throw|;
return|return
name|getSubCategoryCharClass
argument_list|(
name|sci
operator|/
literal|2
argument_list|)
return|;
case|case
literal|1
case|:
name|int
name|ci
init|=
name|RegexData
operator|.
name|categories
operator|.
name|indexOf
argument_list|(
name|propertyName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ci
operator|<
literal|0
condition|)
throw|throw
name|makeException
argument_list|(
literal|"unknown category"
argument_list|,
name|propertyName
argument_list|)
throw|;
return|return
name|getCategoryCharClass
argument_list|(
name|ci
argument_list|)
return|;
default|default:
if|if
condition|(
operator|!
name|propertyName
operator|.
name|startsWith
argument_list|(
literal|"Is"
argument_list|)
condition|)
break|break;
name|String
name|blockName
init|=
name|propertyName
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RegexData
operator|.
name|specialBlockNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|blockName
operator|.
name|equals
argument_list|(
name|RegexData
operator|.
name|specialBlockNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|specialBlockCharClasses
index|[
name|i
index|]
return|;
if|if
condition|(
operator|!
name|isBlock
argument_list|(
name|blockName
argument_list|)
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid block name"
argument_list|,
name|blockName
argument_list|)
throw|;
return|return
operator|new
name|Property
argument_list|(
literal|"In"
operator|+
name|blockName
argument_list|)
return|;
block|}
throw|throw
name|makeException
argument_list|(
literal|"invalid property name"
argument_list|,
name|propertyName
argument_list|)
throw|;
block|}
specifier|private
name|CharClass
name|parseCharClassExpr
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|boolean
name|compl
decl_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'^'
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
name|compl
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|compl
operator|=
literal|false
expr_stmt|;
block|}
name|List
name|members
init|=
operator|new
name|ArrayList
argument_list|(
literal|10
argument_list|)
decl_stmt|;
comment|//boolean firstOrLast = true;
do|do
block|{
name|CharClass
name|lower
init|=
name|parseCharClassEscOrXmlChar
argument_list|()
decl_stmt|;
name|members
operator|.
name|add
argument_list|(
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|']'
operator|||
name|eos
condition|)
block|{
name|addCaseVariant
argument_list|(
name|lower
argument_list|,
name|members
argument_list|)
expr_stmt|;
break|break;
block|}
comment|//firstOrLast = isLastInGroup();
if|if
condition|(
name|curChar
operator|==
literal|'-'
condition|)
block|{
name|char
name|next
init|=
name|regExp
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|'['
condition|)
block|{
comment|// hyphen denotes subtraction
name|addCaseVariant
argument_list|(
name|lower
argument_list|,
name|members
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
break|break;
block|}
if|else if
condition|(
name|next
operator|==
literal|']'
condition|)
block|{
comment|// hyphen denotes a regular character - no need to do anything
name|addCaseVariant
argument_list|(
name|lower
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// hyphen denotes a character range
name|advance
argument_list|()
expr_stmt|;
name|CharClass
name|upper
init|=
name|parseCharClassEscOrXmlChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|lower
operator|.
name|getSingleChar
argument_list|()
operator|<
literal|0
operator|||
name|upper
operator|.
name|getSingleChar
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"the ends of a range must be single characters"
argument_list|)
throw|;
block|}
if|if
condition|(
name|lower
operator|.
name|getSingleChar
argument_list|()
operator|>
name|upper
operator|.
name|getSingleChar
argument_list|()
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"invalid range (start> end)"
argument_list|)
throw|;
block|}
if|if
condition|(
name|lower
operator|instanceof
name|SingleChar
operator|&&
name|lower
operator|.
name|getSingleChar
argument_list|()
operator|==
literal|'-'
operator|&&
operator|!
operator|(
operator|(
name|SingleChar
operator|)
name|lower
operator|)
operator|.
name|isEscaped
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"range cannot start with unescaped hyphen"
argument_list|)
throw|;
block|}
if|if
condition|(
name|upper
operator|instanceof
name|SingleChar
operator|&&
name|upper
operator|.
name|getSingleChar
argument_list|()
operator|==
literal|'-'
operator|&&
operator|!
operator|(
operator|(
name|SingleChar
operator|)
name|upper
operator|)
operator|.
name|isEscaped
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"range cannot end with unescaped hyphen"
argument_list|)
throw|;
block|}
name|members
operator|.
name|set
argument_list|(
name|members
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
operator|new
name|CharRange
argument_list|(
name|lower
operator|.
name|getSingleChar
argument_list|()
argument_list|,
name|upper
operator|.
name|getSingleChar
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|caseBlind
condition|)
block|{
comment|// Special-case A-Z and a-z
if|if
condition|(
name|lower
operator|.
name|getSingleChar
argument_list|()
operator|==
literal|'a'
operator|&&
name|upper
operator|.
name|getSingleChar
argument_list|()
operator|==
literal|'z'
condition|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
literal|'A'
argument_list|,
literal|'Z'
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|CaseVariants
operator|.
name|ROMAN_VARIANTS
operator|.
name|length
condition|;
name|v
operator|++
control|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|CaseVariants
operator|.
name|ROMAN_VARIANTS
index|[
name|v
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|lower
operator|.
name|getSingleChar
argument_list|()
operator|==
literal|'A'
operator|&&
name|upper
operator|.
name|getSingleChar
argument_list|()
operator|==
literal|'Z'
condition|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
literal|'a'
argument_list|,
literal|'z'
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|CaseVariants
operator|.
name|ROMAN_VARIANTS
operator|.
name|length
condition|;
name|v
operator|++
control|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|CaseVariants
operator|.
name|ROMAN_VARIANTS
index|[
name|v
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|k
init|=
name|lower
operator|.
name|getSingleChar
argument_list|()
init|;
name|k
operator|<=
name|upper
operator|.
name|getSingleChar
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
name|int
index|[]
name|variants
init|=
name|CaseVariants
operator|.
name|getCaseVariants
argument_list|(
name|k
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|variants
operator|.
name|length
condition|;
name|v
operator|++
control|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|variants
index|[
name|v
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// look for a subtraction
if|if
condition|(
name|curChar
operator|==
literal|'-'
operator|&&
name|regExp
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
operator|==
literal|'['
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
comment|//expect('[');
break|break;
block|}
block|}
block|}
else|else
block|{
name|addCaseVariant
argument_list|(
name|lower
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|curChar
operator|!=
literal|']'
condition|)
do|;
if|if
condition|(
name|eos
condition|)
block|{
name|expect
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|CharClass
name|result
decl_stmt|;
if|if
condition|(
name|members
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|result
operator|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|new
name|Union
argument_list|(
name|members
argument_list|)
expr_stmt|;
if|if
condition|(
name|compl
condition|)
name|result
operator|=
operator|new
name|Complement
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'['
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
name|result
operator|=
operator|new
name|Subtraction
argument_list|(
name|result
argument_list|,
name|parseCharClassExpr
argument_list|()
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|inCharClassExpr
operator|=
literal|false
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|void
name|addCaseVariant
parameter_list|(
name|CharClass
name|lower
parameter_list|,
name|List
name|members
parameter_list|)
block|{
if|if
condition|(
name|caseBlind
condition|)
block|{
name|int
index|[]
name|variants
init|=
name|CaseVariants
operator|.
name|getCaseVariants
argument_list|(
name|lower
operator|.
name|getSingleChar
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|variants
operator|.
name|length
condition|;
name|v
operator|++
control|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|variants
index|[
name|v
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|CharClass
name|parseCharClassEscOrXmlChar
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
name|RegexData
operator|.
name|EOS
case|:
if|if
condition|(
name|eos
condition|)
name|expect
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|parseEsc
argument_list|()
return|;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
throw|throw
name|makeException
argument_list|(
literal|"character must be escaped"
argument_list|,
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|curChar
block|}
argument_list|)
argument_list|)
throw|;
case|case
literal|'-'
case|:
break|break;
block|}
name|CharClass
name|tem
init|=
operator|new
name|SingleChar
argument_list|(
name|absorbSurrogatePair
argument_list|()
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
specifier|private
specifier|static
specifier|synchronized
name|CharClass
name|getCategoryCharClass
parameter_list|(
name|int
name|ci
parameter_list|)
block|{
if|if
condition|(
name|categoryCharClasses
index|[
name|ci
index|]
operator|==
literal|null
condition|)
name|categoryCharClasses
index|[
name|ci
index|]
operator|=
name|computeCategoryCharClass
argument_list|(
name|RegexData
operator|.
name|categories
operator|.
name|charAt
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|categoryCharClasses
index|[
name|ci
index|]
return|;
block|}
specifier|private
specifier|static
specifier|synchronized
name|CharClass
name|getSubCategoryCharClass
parameter_list|(
name|int
name|sci
parameter_list|)
block|{
if|if
condition|(
name|subCategoryCharClasses
index|[
name|sci
index|]
operator|==
literal|null
condition|)
name|subCategoryCharClasses
index|[
name|sci
index|]
operator|=
name|computeSubCategoryCharClass
argument_list|(
name|RegexData
operator|.
name|subCategories
operator|.
name|substring
argument_list|(
name|sci
operator|*
literal|2
argument_list|,
operator|(
name|sci
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|subCategoryCharClasses
index|[
name|sci
index|]
return|;
block|}
specifier|private
specifier|static
name|CharClass
name|computeCategoryCharClass
parameter_list|(
name|char
name|code
parameter_list|)
block|{
name|List
name|classes
init|=
operator|new
name|ArrayList
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|classes
operator|.
name|add
argument_list|(
operator|new
name|Property
argument_list|(
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|code
block|}
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ci
init|=
name|RegexData
operator|.
name|CATEGORY_NAMES
operator|.
name|indexOf
argument_list|(
name|code
argument_list|)
init|;
name|ci
operator|>=
literal|0
condition|;
name|ci
operator|=
name|RegexData
operator|.
name|CATEGORY_NAMES
operator|.
name|indexOf
argument_list|(
name|code
argument_list|,
name|ci
operator|+
literal|1
argument_list|)
control|)
block|{
name|int
index|[]
name|addRanges
init|=
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|ci
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addRanges
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|addRanges
index|[
name|i
index|]
argument_list|,
name|addRanges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|'P'
condition|)
name|classes
operator|.
name|add
argument_list|(
name|makeCharClass
argument_list|(
name|RegexData
operator|.
name|CATEGORY_Pi
operator|+
name|RegexData
operator|.
name|CATEGORY_Pf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'L'
condition|)
block|{
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Ll
argument_list|)
argument_list|)
expr_stmt|;
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Lu
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|'C'
condition|)
block|{
comment|// JDK 1.4 leaves Cn out of C?
name|classes
operator|.
name|add
argument_list|(
operator|new
name|Subtraction
argument_list|(
operator|new
name|Property
argument_list|(
literal|"Cn"
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Lu
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Ll
argument_list|)
block|}
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|List
name|assignedRanges
init|=
operator|new
name|ArrayList
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RegexData
operator|.
name|CATEGORY_RANGES
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|+=
literal|2
control|)
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|classes
operator|.
name|add
argument_list|(
operator|new
name|Subtraction
argument_list|(
operator|new
name|CharRange
argument_list|(
name|UTF16CharacterSet
operator|.
name|NONBMP_MIN
argument_list|,
name|UTF16CharacterSet
operator|.
name|NONBMP_MAX
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
name|assignedRanges
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|classes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
operator|(
name|CharClass
operator|)
name|classes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
return|return
operator|new
name|Union
argument_list|(
name|classes
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|CharClass
name|computeSubCategoryCharClass
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|CharClass
name|base
init|=
operator|new
name|Property
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|sci
init|=
name|RegexData
operator|.
name|CATEGORY_NAMES
operator|.
name|indexOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sci
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Cn"
argument_list|)
condition|)
block|{
comment|// Unassigned
name|List
name|assignedRanges
init|=
operator|new
name|ArrayList
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Lu
argument_list|)
argument_list|)
expr_stmt|;
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Ll
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RegexData
operator|.
name|CATEGORY_RANGES
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|+=
literal|2
control|)
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Subtraction
argument_list|(
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
name|base
block|,
operator|new
name|CharRange
argument_list|(
name|UTF16CharacterSet
operator|.
name|NONBMP_MIN
argument_list|,
name|UTF16CharacterSet
operator|.
name|NONBMP_MAX
argument_list|)
block|}
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
name|assignedRanges
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Pi"
argument_list|)
condition|)
return|return
name|makeCharClass
argument_list|(
name|RegexData
operator|.
name|CATEGORY_Pi
argument_list|)
return|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Pf"
argument_list|)
condition|)
return|return
name|makeCharClass
argument_list|(
name|RegexData
operator|.
name|CATEGORY_Pf
argument_list|)
return|;
return|return
name|base
return|;
block|}
name|List
name|classes
init|=
operator|new
name|ArrayList
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|classes
operator|.
name|add
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|int
index|[]
name|addRanges
init|=
name|RegexData
operator|.
name|CATEGORY_RANGES
index|[
name|sci
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addRanges
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|addRanges
index|[
name|i
index|]
argument_list|,
name|addRanges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Lu"
argument_list|)
condition|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Lu
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Ll"
argument_list|)
condition|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_ADD_Ll
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Nl"
argument_list|)
condition|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_CHANGE_No_to_Nl_MIN
argument_list|,
name|RegexData
operator|.
name|UNICODE_3_1_CHANGE_No_to_Nl_MAX
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"No"
argument_list|)
condition|)
return|return
operator|new
name|Subtraction
argument_list|(
operator|new
name|Union
argument_list|(
name|classes
argument_list|)
argument_list|,
operator|new
name|CharRange
argument_list|(
name|RegexData
operator|.
name|UNICODE_3_1_CHANGE_No_to_Nl_MIN
argument_list|,
name|RegexData
operator|.
name|UNICODE_3_1_CHANGE_No_to_Nl_MAX
argument_list|)
argument_list|)
return|;
return|return
operator|new
name|Union
argument_list|(
name|classes
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|CharClass
name|makeCharClass
parameter_list|(
name|String
name|members
parameter_list|)
block|{
name|List
name|list
init|=
operator|new
name|ArrayList
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|list
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|members
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Union
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**      * Main method for testing. Outputs to System.err the Java translation of a supplied      * regular expression      * @param args command line arguments      *        arg[0] a regular expression      *        arg[1] = xpath to invoke the XPath rules      * @throws RegexSyntaxException      */
comment|//    public static void main(String[] args) throws RegexSyntaxException {
comment|//        String s = translate(args[0], 11, args[1].equals("xpath"), false, true);
comment|//        System.err.println(StringValue.diagnosticDisplay(s));
comment|//        try {
comment|//            Pattern.compile(s);
comment|//        } catch (Exception err) {
comment|//            System.err.println("Error: " + err.getMessage());
comment|//        }
comment|//        System.err.println();
comment|//    }
comment|//}
block|}
end_class

begin_comment
comment|/* Copyright (c) 2001-2003 Thai Open Source Software Center Ltd All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.      Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in     the documentation and/or other materials provided with the     distribution.      Neither the name of the Thai Open Source Software Center Ltd nor     the names of its contributors may be used to endorse or promote     products derived from this software without specific prior written     permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The contents of this file are subject to the Mozilla Public License Version 1.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License. You may obtain a copy of the
end_comment

begin_comment
comment|// License at http://www.mozilla.org/MPL/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Software distributed under the License is distributed on an "AS IS" basis,
end_comment

begin_comment
comment|// WITHOUT WARRANTY OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing rights and limitations under the License.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Original Code is: all this file except changes marked.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Initial Developer of the Original Code is James Clark
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Portions created by (your name) are Copyright (C) (your legal entity). All Rights Reserved.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Contributor(s): Michael Kay
end_comment

begin_comment
comment|//
end_comment

end_unit

