begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|regex
package|;
end_package

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|saxon
operator|.
name|trans
operator|.
name|Err
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|saxon
operator|.
name|charcode
operator|.
name|UTF16CharacterSet
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|saxon
operator|.
name|om
operator|.
name|FastStringBuffer
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|saxon
operator|.
name|sort
operator|.
name|IntHashSet
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|saxon
operator|.
name|value
operator|.
name|Whitespace
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Abstract superclass for the various regex translators, which differ according to the target platform.  *   * Copied from Saxon-HE 9.2 package net.sf.saxon.regex without change.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RegexTranslator
block|{
specifier|protected
name|CharSequence
name|regExp
decl_stmt|;
specifier|protected
name|int
name|xmlVersion
decl_stmt|;
specifier|protected
name|boolean
name|isXPath
decl_stmt|;
specifier|protected
name|boolean
name|ignoreWhitespace
decl_stmt|;
specifier|protected
name|boolean
name|inCharClassExpr
decl_stmt|;
specifier|protected
name|boolean
name|caseBlind
decl_stmt|;
specifier|protected
name|int
name|pos
init|=
literal|0
decl_stmt|;
specifier|protected
name|int
name|length
decl_stmt|;
specifier|protected
name|char
name|curChar
decl_stmt|;
specifier|protected
name|boolean
name|eos
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|currentCapture
init|=
literal|0
decl_stmt|;
specifier|protected
name|IntHashSet
name|captures
init|=
operator|new
name|IntHashSet
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|FastStringBuffer
name|result
init|=
operator|new
name|FastStringBuffer
argument_list|(
name|FastStringBuffer
operator|.
name|SMALL
argument_list|)
decl_stmt|;
specifier|protected
name|void
name|translateTop
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|translateRegExp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|eos
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"expected end of string"
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|translateRegExp
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|translateBranch
argument_list|()
expr_stmt|;
while|while
condition|(
name|curChar
operator|==
literal|'|'
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
name|translateBranch
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|translateBranch
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
while|while
condition|(
name|translateAtom
argument_list|()
condition|)
name|translateQuantifier
argument_list|()
expr_stmt|;
block|}
specifier|protected
specifier|abstract
name|boolean
name|translateAtom
parameter_list|()
throws|throws
name|RegexSyntaxException
function_decl|;
specifier|protected
name|void
name|translateQuantifier
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
name|copyCurChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|copyCurChar
argument_list|()
expr_stmt|;
name|translateQuantity
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|copyCurChar
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|curChar
operator|==
literal|'?'
operator|&&
name|isXPath
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|translateQuantity
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|String
name|lower
init|=
name|parseQuantExact
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|lowerValue
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|lowerValue
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|lower
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// JDK 1.4 cannot handle ranges bigger than this
name|result
operator|.
name|append
argument_list|(
literal|""
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curChar
operator|==
literal|','
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|curChar
operator|!=
literal|'}'
condition|)
block|{
name|String
name|upper
init|=
name|parseQuantExact
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|upperValue
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|upper
argument_list|)
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerValue
operator|<
literal|0
operator|||
name|upperValue
operator|<
name|lowerValue
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid range in quantifier"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|""
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerValue
operator|<
literal|0
operator|&&
operator|new
name|BigDecimal
argument_list|(
name|lower
argument_list|)
operator|.
name|compareTo
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|upper
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid range in quantifier"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|protected
name|CharSequence
name|parseQuantExact
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|FastStringBuffer
name|buf
init|=
operator|new
name|FastStringBuffer
argument_list|(
name|FastStringBuffer
operator|.
name|TINY
argument_list|)
decl_stmt|;
do|do
block|{
if|if
condition|(
literal|"0123456789"
operator|.
name|indexOf
argument_list|(
name|curChar
argument_list|)
operator|<
literal|0
condition|)
throw|throw
name|makeException
argument_list|(
literal|"expected digit in quantifier"
argument_list|)
throw|;
name|buf
operator|.
name|append
argument_list|(
name|curChar
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|curChar
operator|!=
literal|','
operator|&&
name|curChar
operator|!=
literal|'}'
condition|)
do|;
return|return
name|buf
return|;
block|}
specifier|protected
name|void
name|copyCurChar
parameter_list|()
block|{
name|result
operator|.
name|append
argument_list|(
name|curChar
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
name|int
name|NONE
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|SOME
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|ALL
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SURROGATES1_CLASS
init|=
literal|"[\uD800-\uDBFF]"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SURROGATES2_CLASS
init|=
literal|"[\uDC00-\uDFFF]"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|NOT_ALLOWED_CLASS
init|=
literal|"[\u0000&&[^\u0000]]"
decl_stmt|;
comment|/**      * A Range represents a range of consecutive Unicode codepoints      */
specifier|public
specifier|static
specifier|final
class|class
name|Range
implements|implements
name|Comparable
block|{
specifier|private
specifier|final
name|int
name|min
decl_stmt|;
specifier|private
specifier|final
name|int
name|max
decl_stmt|;
comment|/**          * Create a range of unicode codepoints          * @param min the first codepoint in the range          * @param max the last codepoint in the range          */
specifier|public
name|Range
parameter_list|(
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|this
operator|.
name|min
operator|=
name|min
expr_stmt|;
name|this
operator|.
name|max
operator|=
name|max
expr_stmt|;
block|}
comment|/**          * Get the start of the range          * @return the first codepoint in the range          */
specifier|public
name|int
name|getMin
parameter_list|()
block|{
return|return
name|min
return|;
block|}
comment|/**          * Get the end of the range          * @return the last codepoint in the range          */
specifier|public
name|int
name|getMax
parameter_list|()
block|{
return|return
name|max
return|;
block|}
comment|/**          * Compare this range with another range for ordering purposes. If the two ranges have different          * start points, the order is the order of the start points; otherwise it is the order of the end          * points.          * @param o the other range          * @return -1 if this range comes first, +1 if the other range comes first, 0 if they are equal          * (start and end both equal)          */
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Range
name|other
init|=
operator|(
name|Range
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|other
operator|.
name|min
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|min
operator|>
name|other
operator|.
name|min
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|max
operator|>
name|other
operator|.
name|max
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|max
operator|<
name|other
operator|.
name|max
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
specifier|protected
name|void
name|advance
parameter_list|()
block|{
if|if
condition|(
name|pos
operator|<
name|length
condition|)
block|{
name|curChar
operator|=
name|regExp
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignoreWhitespace
operator|&&
operator|!
name|inCharClassExpr
condition|)
block|{
while|while
condition|(
name|Whitespace
operator|.
name|isWhitespace
argument_list|(
name|curChar
argument_list|)
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|pos
operator|++
expr_stmt|;
name|curChar
operator|=
name|RegexData
operator|.
name|EOS
expr_stmt|;
name|eos
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|protected
name|int
name|absorbSurrogatePair
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
if|if
condition|(
name|UTF16CharacterSet
operator|.
name|isSurrogate
argument_list|(
name|curChar
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|UTF16CharacterSet
operator|.
name|isHighSurrogate
argument_list|(
name|curChar
argument_list|)
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid surrogate pair"
argument_list|)
throw|;
name|char
name|c1
init|=
name|curChar
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|UTF16CharacterSet
operator|.
name|isLowSurrogate
argument_list|(
name|curChar
argument_list|)
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid surrogate pair"
argument_list|)
throw|;
return|return
name|UTF16CharacterSet
operator|.
name|combinePair
argument_list|(
name|c1
argument_list|,
name|curChar
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|curChar
return|;
block|}
block|}
specifier|protected
name|void
name|recede
parameter_list|()
block|{
comment|// The caller must ensure we don't fall off the start of the expression
if|if
condition|(
name|eos
condition|)
block|{
name|curChar
operator|=
name|regExp
operator|.
name|charAt
argument_list|(
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|=
name|length
expr_stmt|;
name|eos
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|curChar
operator|=
name|regExp
operator|.
name|charAt
argument_list|(
operator|(
operator|--
name|pos
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoreWhitespace
operator|&&
operator|!
name|inCharClassExpr
condition|)
block|{
while|while
condition|(
name|Whitespace
operator|.
name|isWhitespace
argument_list|(
name|curChar
argument_list|)
condition|)
block|{
name|recede
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|void
name|expect
parameter_list|(
name|char
name|c
parameter_list|)
throws|throws
name|RegexSyntaxException
block|{
if|if
condition|(
name|curChar
operator|!=
name|c
condition|)
block|{
throw|throw
name|makeException
argument_list|(
literal|"expected"
argument_list|,
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|c
block|}
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|RegexSyntaxException
name|makeException
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|new
name|RegexSyntaxException
argument_list|(
literal|"Error at character "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
operator|+
literal|" in regular expression "
operator|+
name|Err
operator|.
name|wrap
argument_list|(
name|regExp
argument_list|,
name|Err
operator|.
name|VALUE
argument_list|)
operator|+
literal|": "
operator|+
name|key
argument_list|)
return|;
block|}
specifier|protected
name|RegexSyntaxException
name|makeException
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|arg
parameter_list|)
block|{
return|return
operator|new
name|RegexSyntaxException
argument_list|(
literal|"Error at character "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
operator|+
literal|" in regular expression "
operator|+
name|Err
operator|.
name|wrap
argument_list|(
name|regExp
argument_list|,
name|Err
operator|.
name|VALUE
argument_list|)
operator|+
literal|": "
operator|+
name|key
operator|+
literal|" ("
operator|+
name|arg
operator|+
literal|')'
argument_list|)
return|;
block|}
specifier|protected
specifier|static
name|boolean
name|isJavaMetaChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'^'
case|:
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'|'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
case|case
literal|'.'
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|protected
specifier|static
name|String
name|highSurrogateRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|FastStringBuffer
name|highRanges
init|=
operator|new
name|FastStringBuffer
argument_list|(
name|ranges
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|ranges
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|min1
init|=
name|UTF16CharacterSet
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|min2
init|=
name|UTF16CharacterSet
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max1
init|=
name|UTF16CharacterSet
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max2
init|=
name|UTF16CharacterSet
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|min2
operator|!=
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MIN
condition|)
block|{
name|min1
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|max2
operator|!=
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MAX
condition|)
block|{
name|max1
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|max1
operator|>=
name|min1
condition|)
block|{
name|highRanges
operator|.
name|append
argument_list|(
name|min1
argument_list|)
expr_stmt|;
name|highRanges
operator|.
name|append
argument_list|(
name|max1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|highRanges
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
specifier|static
name|String
name|lowSurrogateRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|FastStringBuffer
name|lowRanges
init|=
operator|new
name|FastStringBuffer
argument_list|(
name|ranges
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|ranges
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|min1
init|=
name|UTF16CharacterSet
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|min2
init|=
name|UTF16CharacterSet
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max1
init|=
name|UTF16CharacterSet
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max2
init|=
name|UTF16CharacterSet
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|min1
operator|==
name|max1
condition|)
block|{
if|if
condition|(
name|min2
operator|!=
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MIN
operator|||
name|max2
operator|!=
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MAX
condition|)
block|{
name|lowRanges
operator|.
name|append
argument_list|(
name|min1
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|min2
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|max2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|min2
operator|!=
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MIN
condition|)
block|{
name|lowRanges
operator|.
name|append
argument_list|(
name|min1
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|min2
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max2
operator|!=
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MAX
condition|)
block|{
name|lowRanges
operator|.
name|append
argument_list|(
name|max1
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|UTF16CharacterSet
operator|.
name|SURROGATE2_MIN
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|max2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|lowRanges
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
specifier|static
name|void
name|sortRangeList
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|ranges
argument_list|)
expr_stmt|;
name|int
name|toIndex
init|=
literal|0
decl_stmt|;
name|int
name|fromIndex
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|ranges
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|fromIndex
operator|<
name|len
condition|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
name|int
name|min
init|=
name|r
operator|.
name|getMin
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|r
operator|.
name|getMax
argument_list|()
decl_stmt|;
while|while
condition|(
operator|++
name|fromIndex
operator|<
name|len
condition|)
block|{
name|Range
name|r2
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|.
name|getMin
argument_list|()
operator|>
name|max
operator|+
literal|1
condition|)
break|break;
if|if
condition|(
name|r2
operator|.
name|getMax
argument_list|()
operator|>
name|max
condition|)
name|max
operator|=
name|r2
operator|.
name|getMax
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
name|r
operator|.
name|getMax
argument_list|()
condition|)
name|r
operator|=
operator|new
name|Range
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|ranges
operator|.
name|set
argument_list|(
name|toIndex
operator|++
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
name|toIndex
condition|)
name|ranges
operator|.
name|remove
argument_list|(
operator|--
name|len
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|static
name|boolean
name|isBlock
parameter_list|(
name|String
name|name
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RegexData
operator|.
name|blockNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|RegexData
operator|.
name|blockNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|protected
specifier|static
name|boolean
name|isAsciiAlnum
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
operator|||
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
operator|||
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
return|;
block|}
block|}
end_class

begin_comment
comment|//
end_comment

begin_comment
comment|// The contents of this file are subject to the Mozilla Public License Version 1.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License. You may obtain a copy of the
end_comment

begin_comment
comment|// License at http://www.mozilla.org/MPL/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Software distributed under the License is distributed on an "AS IS" basis,
end_comment

begin_comment
comment|// WITHOUT WARRANTY OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing rights and limitations under the License.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Original Code is: all this file
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Initial Developer of the Original Code is Michael H. Kay.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Contributor(s):
end_comment

begin_comment
comment|//
end_comment

end_unit

