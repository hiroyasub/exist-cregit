begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  eXist Open Source Native XML Database  *  Copyright (C) 2001-06 Wolfgang M. Meier  *  wolfgang@exist-db.org  *  http://exist.sourceforge.net  *    *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *    *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU Lesser General Public License for more details.  *    *  You should have received a copy of the GNU Lesser General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *    *  $Id$  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|value
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|Collator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xmldb
operator|.
name|XmldbURI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|XPathException
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|security
operator|.
name|action
operator|.
name|GetPropertyAction
import|;
end_import

begin_comment
comment|/**  * @author Wolfgang Meier (wolfgang@exist-db.org)  */
end_comment

begin_class
specifier|public
class|class
name|AnyURIValue
extends|extends
name|AtomicValue
block|{
specifier|static
name|BitSet
name|needEncoding
decl_stmt|;
specifier|static
specifier|final
name|int
name|caseDiff
init|=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
decl_stmt|;
static|static
block|{
name|needEncoding
operator|=
operator|new
name|BitSet
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0x00
init|;
name|i
operator|<=
literal|0x1F
condition|;
name|i
operator|++
control|)
block|{
name|needEncoding
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|needEncoding
operator|.
name|set
argument_list|(
literal|0x7F
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|0x20
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|needEncoding
operator|.
name|set
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
name|AnyURIValue
name|EMPTY_URI
init|=
operator|new
name|AnyURIValue
argument_list|()
decl_stmt|;
comment|/* Very important - this string does not need to be a valid uri. 	 *  	 * From XML Linking (see below for link), with some wording changes: 	 * The value of the [anyURI] must be a URI reference as defined in 	 * [IETF RFC 2396], or must result in a URI reference after the escaping 	 * procedure described below is applied. The procedure is applied when 	 * passing the URI reference to a URI resolver. 	 *  	 * Some characters are disallowed in URI references, even if they are 	 * allowed in XML; the disallowed characters include all non-ASCII 	 * characters, plus the excluded characters listed in Section 2.4 of 	 * [IETF RFC 2396], except for the number sign (#) and percent sign (%) 	 * and the square bracket characters re-allowed in [IETF RFC 2732]. 	 * Disallowed characters must be escaped as follows: 	 * 1. Each disallowed character is converted to UTF-8 [IETF RFC 2279] 	 *    as one or more bytes. 	 * 2. Any bytes corresponding to a disallowed character are escaped 	 *    with the URI escaping mechanism (that is, converted to %HH, 	 *    where HH is the hexadecimal notation of the byte value). 	 * 3. The original character is replaced by the resulting character 	 *    sequence. 	 *  	 * See Section 5.4 of XML Linking: 	 * http://www.w3.org/TR/2000/PR-xlink-20001220/#link-locators 	 */
specifier|private
name|String
name|uri
decl_stmt|;
name|AnyURIValue
parameter_list|()
block|{
name|this
operator|.
name|uri
operator|=
literal|""
expr_stmt|;
block|}
specifier|public
name|AnyURIValue
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|this
operator|.
name|uri
operator|=
name|uri
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|public
name|AnyURIValue
parameter_list|(
name|XmldbURI
name|uri
parameter_list|)
block|{
name|this
operator|.
name|uri
operator|=
name|uri
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|public
name|AnyURIValue
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|XPathException
block|{
try|try
block|{
operator|new
name|URI
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
try|try
block|{
name|XmldbURI
operator|.
name|xmldbUriFor
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"Type error: the given string '"
operator|+
name|s
operator|+
literal|"' cannot be cast to "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|uri
operator|=
name|s
expr_stmt|;
block|}
comment|//TODO: TEST TEST TEST!
comment|// basically copied from URLEncoder.encode
specifier|protected
specifier|static
name|String
name|escape
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
try|try
block|{
name|boolean
name|needToChange
init|=
literal|false
decl_stmt|;
name|boolean
name|wroteUnencodedChar
init|=
literal|false
decl_stmt|;
name|int
name|maxBytesPerChar
init|=
literal|10
decl_stmt|;
comment|// rather arbitrary limit, but safe for now
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|uri
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|buf
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|maxBytesPerChar
argument_list|)
decl_stmt|;
name|OutputStreamWriter
name|writer
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|buf
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uri
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
operator|(
name|int
operator|)
name|uri
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
operator|||
name|needEncoding
operator|.
name|get
argument_list|(
name|c
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|wroteUnencodedChar
condition|)
block|{
comment|// Fix for 4407610
name|writer
operator|=
operator|new
name|OutputStreamWriter
argument_list|(
name|buf
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|wroteUnencodedChar
operator|=
literal|false
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 						 * If this character represents the start of a Unicode 						 * surrogate pair, then pass in two characters. It's not 						 * clear what should be done if a bytes reserved in the  						 * surrogate pairs range occurs outside of a legal 						 * surrogate pair. For now, just treat it as if it were  						 * any other character. 						 */
if|if
condition|(
name|c
operator|>=
literal|0xD800
operator|&&
name|c
operator|<=
literal|0xDBFF
condition|)
block|{
comment|/* 							 System.out.println(Integer.toHexString(c)  							 + " is high surrogate"); 							 */
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|uri
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|d
init|=
operator|(
name|int
operator|)
name|uri
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* 								 System.out.println("\tExamining "  								 + Integer.toHexString(d)); 								 */
if|if
condition|(
name|d
operator|>=
literal|0xDC00
operator|&&
name|d
operator|<=
literal|0xDFFF
condition|)
block|{
comment|/* 									 System.out.println("\t"  									 + Integer.toHexString(d)  									 + " is low surrogate"); 									 */
name|writer
operator|.
name|write
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
name|writer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|byte
index|[]
name|ba
init|=
name|buf
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ba
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|out
operator|.
name|append
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|char
name|ch
init|=
name|Character
operator|.
name|forDigit
argument_list|(
operator|(
name|ba
index|[
name|j
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
literal|16
argument_list|)
decl_stmt|;
comment|// converting to use uppercase letter as part of
comment|// the hex value if ch is a letter.
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|ch
operator|-=
name|caseDiff
expr_stmt|;
block|}
name|out
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|Character
operator|.
name|forDigit
argument_list|(
name|ba
index|[
name|j
index|]
operator|&
literal|0xF
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|ch
operator|-=
name|caseDiff
expr_stmt|;
block|}
name|out
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|needToChange
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|wroteUnencodedChar
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
operator|(
name|needToChange
condition|?
name|out
operator|.
name|toString
argument_list|()
else|:
name|uri
operator|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.AtomicValue#getType() 	 */
specifier|public
name|int
name|getType
parameter_list|()
block|{
return|return
name|Type
operator|.
name|ANY_URI
return|;
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.Sequence#getStringValue() 	 */
specifier|public
name|String
name|getStringValue
parameter_list|()
throws|throws
name|XPathException
block|{
return|return
name|uri
return|;
block|}
specifier|public
name|boolean
name|effectiveBooleanValue
parameter_list|()
throws|throws
name|XPathException
block|{
return|return
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|uri
argument_list|)
return|;
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.Sequence#convertTo(int) 	 */
specifier|public
name|AtomicValue
name|convertTo
parameter_list|(
name|int
name|requiredType
parameter_list|)
throws|throws
name|XPathException
block|{
switch|switch
condition|(
name|requiredType
condition|)
block|{
case|case
name|Type
operator|.
name|ITEM
case|:
case|case
name|Type
operator|.
name|ATOMIC
case|:
case|case
name|Type
operator|.
name|ANY_URI
case|:
return|return
name|this
return|;
case|case
name|Type
operator|.
name|STRING
case|:
return|return
operator|new
name|StringValue
argument_list|(
name|uri
argument_list|)
return|;
case|case
name|Type
operator|.
name|UNTYPED_ATOMIC
case|:
return|return
operator|new
name|UntypedAtomicValue
argument_list|(
name|getStringValue
argument_list|()
argument_list|)
return|;
default|default :
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"Type error: cannot cast xs:anyURI to "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|requiredType
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.AtomicValue#compareTo(int, org.exist.xquery.value.AtomicValue) 	 */
specifier|public
name|boolean
name|compareTo
parameter_list|(
name|Collator
name|collator
parameter_list|,
name|int
name|operator
parameter_list|,
name|AtomicValue
name|other
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|other
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|ANY_URI
condition|)
block|{
name|String
name|otherURI
init|=
name|other
operator|.
name|getStringValue
argument_list|()
decl_stmt|;
name|int
name|cmp
init|=
name|uri
operator|.
name|compareTo
argument_list|(
name|otherURI
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|operator
condition|)
block|{
case|case
name|Constants
operator|.
name|EQ
case|:
return|return
name|cmp
operator|==
literal|0
return|;
case|case
name|Constants
operator|.
name|NEQ
case|:
return|return
name|cmp
operator|!=
literal|0
return|;
default|default :
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"Type error: cannot apply operator "
operator|+
name|Constants
operator|.
name|OPS
index|[
name|operator
index|]
operator|+
literal|" to xs:anyURI"
argument_list|)
throw|;
block|}
block|}
else|else
return|return
name|compareTo
argument_list|(
name|collator
argument_list|,
name|operator
argument_list|,
name|other
operator|.
name|convertTo
argument_list|(
name|Type
operator|.
name|ANY_URI
argument_list|)
argument_list|)
return|;
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.AtomicValue#compareTo(org.exist.xquery.value.AtomicValue) 	 */
specifier|public
name|int
name|compareTo
parameter_list|(
name|Collator
name|collator
parameter_list|,
name|AtomicValue
name|other
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|other
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|ANY_URI
condition|)
block|{
name|String
name|otherURI
init|=
name|other
operator|.
name|getStringValue
argument_list|()
decl_stmt|;
return|return
name|uri
operator|.
name|compareTo
argument_list|(
name|otherURI
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|compareTo
argument_list|(
name|collator
argument_list|,
name|other
operator|.
name|convertTo
argument_list|(
name|Type
operator|.
name|ANY_URI
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.AtomicValue#max(org.exist.xquery.value.AtomicValue) 	 */
specifier|public
name|AtomicValue
name|max
parameter_list|(
name|Collator
name|collator
parameter_list|,
name|AtomicValue
name|other
parameter_list|)
throws|throws
name|XPathException
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"max is not supported for values of type xs:anyURI"
argument_list|)
throw|;
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.AtomicValue#min(org.exist.xquery.value.AtomicValue) 	 */
specifier|public
name|AtomicValue
name|min
parameter_list|(
name|Collator
name|collator
parameter_list|,
name|AtomicValue
name|other
parameter_list|)
throws|throws
name|XPathException
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"min is not supported for values of type xs:anyURI"
argument_list|)
throw|;
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.Item#conversionPreference(java.lang.Class) 	 */
specifier|public
name|int
name|conversionPreference
parameter_list|(
name|Class
name|javaClass
parameter_list|)
block|{
if|if
condition|(
name|javaClass
operator|.
name|isAssignableFrom
argument_list|(
name|AnyURIValue
operator|.
name|class
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|javaClass
operator|==
name|XmldbURI
operator|.
name|class
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|javaClass
operator|==
name|URI
operator|.
name|class
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|javaClass
operator|==
name|URL
operator|.
name|class
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|javaClass
operator|==
name|String
operator|.
name|class
operator|||
name|javaClass
operator|==
name|CharSequence
operator|.
name|class
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|javaClass
operator|==
name|Object
operator|.
name|class
condition|)
return|return
literal|20
return|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
comment|/* (non-Javadoc) 	 * @see org.exist.xquery.value.Item#toJavaObject(java.lang.Class) 	 */
specifier|public
name|Object
name|toJavaObject
parameter_list|(
name|Class
name|target
parameter_list|)
throws|throws
name|XPathException
block|{
if|if
condition|(
name|target
operator|.
name|isAssignableFrom
argument_list|(
name|AnyURIValue
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
if|else if
condition|(
name|target
operator|==
name|XmldbURI
operator|.
name|class
condition|)
block|{
return|return
name|toXmldbURI
argument_list|()
return|;
block|}
if|else if
condition|(
name|target
operator|==
name|URI
operator|.
name|class
condition|)
block|{
return|return
name|toURI
argument_list|()
return|;
block|}
if|else if
condition|(
name|target
operator|==
name|URL
operator|.
name|class
condition|)
block|{
try|try
block|{
return|return
operator|new
name|URL
argument_list|(
name|uri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"failed to convert "
operator|+
name|uri
operator|+
literal|" into a Java URL: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|else if
condition|(
name|target
operator|==
name|String
operator|.
name|class
operator|||
name|target
operator|==
name|CharSequence
operator|.
name|class
condition|)
return|return
name|uri
return|;
if|else if
condition|(
name|target
operator|==
name|Object
operator|.
name|class
condition|)
return|return
name|uri
return|;
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"cannot convert value of type "
operator|+
name|Type
operator|.
name|getTypeName
argument_list|(
name|getType
argument_list|()
argument_list|)
operator|+
literal|" to Java object of type "
operator|+
name|target
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
specifier|public
name|XmldbURI
name|toXmldbURI
parameter_list|()
throws|throws
name|XPathException
block|{
try|try
block|{
return|return
name|XmldbURI
operator|.
name|xmldbUriFor
argument_list|(
name|uri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"failed to convert "
operator|+
name|uri
operator|+
literal|" into an XmldbURI: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|URI
name|toURI
parameter_list|()
throws|throws
name|XPathException
block|{
try|try
block|{
return|return
operator|new
name|URI
argument_list|(
name|uri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathException
argument_list|(
literal|"failed to convert "
operator|+
name|uri
operator|+
literal|" into an XmldbURI: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

