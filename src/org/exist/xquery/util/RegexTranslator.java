begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|XMLChar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|xquery
operator|.
name|Constants
import|;
end_import

begin_comment
comment|/**  * This class translates XML Schema regex syntax into JDK 1.4 regex syntax.  * Copied from Saxon package net.sf.saxon.type without change. The original   * author is James Clark. See license.  */
end_comment

begin_class
specifier|public
class|class
name|RegexTranslator
block|{
comment|/**      * Translates XML Schema regexes into<code>java.util.regex</code> regexes.      *      * @see java.util.regex.Pattern      * @see<a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema Part 2</a>      */
specifier|private
specifier|final
name|String
name|regExp
decl_stmt|;
specifier|private
name|boolean
name|isXPath
decl_stmt|;
specifier|private
name|int
name|pos
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|length
decl_stmt|;
specifier|private
name|char
name|curChar
decl_stmt|;
specifier|private
name|boolean
name|eos
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|String
name|categories
init|=
literal|"LMNPZSC"
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
index|[]
name|categoryCharClasses
init|=
operator|new
name|CharClass
index|[
name|categories
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|String
name|subCategories
init|=
literal|"LuLlLtLmLoMnMcMeNdNlNoPcPdPsPePiPfPoZsZlZpSmScSkSoCcCfCoCn"
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
index|[]
name|subCategoryCharClasses
init|=
operator|new
name|CharClass
index|[
name|subCategories
operator|.
name|length
argument_list|()
operator|/
literal|2
index|]
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|int
name|NONBMP_MIN
init|=
literal|0x10000
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|int
name|NONBMP_MAX
init|=
literal|0x10FFFF
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|char
name|SURROGATE2_MIN
init|=
literal|'\uDC00'
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|char
name|SURROGATE2_MAX
init|=
literal|'\uDFFF'
decl_stmt|;
comment|//static final Localizer localizer = new Localizer(RegexTranslator.class);
specifier|static
specifier|private
specifier|final
name|String
index|[]
name|blockNames
init|=
block|{
literal|"BasicLatin"
block|,
literal|"Latin-1Supplement"
block|,
literal|"LatinExtended-A"
block|,
literal|"LatinExtended-B"
block|,
literal|"IPAExtensions"
block|,
literal|"SpacingModifierLetters"
block|,
literal|"CombiningDiacriticalMarks"
block|,
literal|"Greek"
block|,
literal|"Cyrillic"
block|,
literal|"Armenian"
block|,
literal|"Hebrew"
block|,
literal|"Arabic"
block|,
literal|"Syriac"
block|,
literal|"Thaana"
block|,
literal|"Devanagari"
block|,
literal|"Bengali"
block|,
literal|"Gurmukhi"
block|,
literal|"Gujarati"
block|,
literal|"Oriya"
block|,
literal|"Tamil"
block|,
literal|"Telugu"
block|,
literal|"Kannada"
block|,
literal|"Malayalam"
block|,
literal|"Sinhala"
block|,
literal|"Thai"
block|,
literal|"Lao"
block|,
literal|"Tibetan"
block|,
literal|"Myanmar"
block|,
literal|"Georgian"
block|,
literal|"HangulJamo"
block|,
literal|"Ethiopic"
block|,
literal|"Cherokee"
block|,
literal|"UnifiedCanadianAboriginalSyllabics"
block|,
literal|"Ogham"
block|,
literal|"Runic"
block|,
literal|"Khmer"
block|,
literal|"Mongolian"
block|,
literal|"LatinExtendedAdditional"
block|,
literal|"GreekExtended"
block|,
literal|"GeneralPunctuation"
block|,
literal|"SuperscriptsandSubscripts"
block|,
literal|"CurrencySymbols"
block|,
literal|"CombiningMarksforSymbols"
block|,
literal|"LetterlikeSymbols"
block|,
literal|"NumberForms"
block|,
literal|"Arrows"
block|,
literal|"MathematicalOperators"
block|,
literal|"MiscellaneousTechnical"
block|,
literal|"ControlPictures"
block|,
literal|"OpticalCharacterRecognition"
block|,
literal|"EnclosedAlphanumerics"
block|,
literal|"BoxDrawing"
block|,
literal|"BlockElements"
block|,
literal|"GeometricShapes"
block|,
literal|"MiscellaneousSymbols"
block|,
literal|"Dingbats"
block|,
literal|"BraillePatterns"
block|,
literal|"CJKRadicalsSupplement"
block|,
literal|"KangxiRadicals"
block|,
literal|"IdeographicDescriptionCharacters"
block|,
literal|"CJKSymbolsandPunctuation"
block|,
literal|"Hiragana"
block|,
literal|"Katakana"
block|,
literal|"Bopomofo"
block|,
literal|"HangulCompatibilityJamo"
block|,
literal|"Kanbun"
block|,
literal|"BopomofoExtended"
block|,
literal|"EnclosedCJKLettersandMonths"
block|,
literal|"CJKCompatibility"
block|,
literal|"CJKUnifiedIdeographsExtensionA"
block|,
literal|"CJKUnifiedIdeographs"
block|,
literal|"YiSyllables"
block|,
literal|"YiRadicals"
block|,
literal|"HangulSyllables"
block|,
comment|// surrogates excluded because there are never any *characters* with codes in surrogate range
comment|// "PrivateUse", excluded because 3.1 adds non-BMP ranges
literal|"CJKCompatibilityIdeographs"
block|,
literal|"AlphabeticPresentationForms"
block|,
literal|"ArabicPresentationForms-A"
block|,
literal|"CombiningHalfMarks"
block|,
literal|"CJKCompatibilityForms"
block|,
literal|"SmallFormVariants"
block|,
literal|"ArabicPresentationForms-B"
block|,
literal|"Specials"
block|,
literal|"HalfwidthandFullwidthForms"
block|,
literal|"Specials"
block|}
decl_stmt|;
comment|/**      * Names of blocks including ranges outside the BMP.      */
specifier|static
specifier|private
specifier|final
name|String
index|[]
name|specialBlockNames
init|=
block|{
literal|"OldItalic"
block|,
literal|"Gothic"
block|,
literal|"Deseret"
block|,
literal|"ByzantineMusicalSymbols"
block|,
literal|"MusicalSymbols"
block|,
literal|"MathematicalAlphanumericSymbols"
block|,
literal|"CJKUnifiedIdeographsExtensionB"
block|,
literal|"CJKCompatibilityIdeographsSupplement"
block|,
literal|"Tags"
block|,
literal|"PrivateUse"
block|,
literal|"HighSurrogates"
block|,
literal|"HighPrivateUseSurrogates"
block|,
literal|"LowSurrogates"
block|,     }
decl_stmt|;
comment|// This file was automatically generated by CategoriesGen
specifier|static
specifier|final
name|String
name|CATEGORY_NAMES
init|=
literal|"NoLoMnCfLlNlPoLuMcNdSoSmCo"
decl_stmt|;
specifier|static
specifier|final
name|int
index|[]
index|[]
name|CATEGORY_RANGES
init|=
block|{
block|{
comment|// No
literal|0x10107
block|,
literal|0x10133
block|,
literal|0x10320
block|,
literal|0x10323
block|}
block|,
block|{
comment|// Lo
literal|0x10000
block|,
literal|0x1000b
block|,
literal|0x1000d
block|,
literal|0x10026
block|,
literal|0x10028
block|,
literal|0x1003a
block|,
literal|0x1003c
block|,
literal|0x1003d
block|,
literal|0x1003f
block|,
literal|0x1004d
block|,
literal|0x10050
block|,
literal|0x1005d
block|,
literal|0x10080
block|,
literal|0x100fa
block|,
literal|0x10300
block|,
literal|0x1031e
block|,
literal|0x10330
block|,
literal|0x10349
block|,
literal|0x10380
block|,
literal|0x1039d
block|,
literal|0x10450
block|,
literal|0x1049d
block|,
literal|0x10800
block|,
literal|0x10805
block|,
literal|0x10808
block|,
literal|0x10808
block|,
literal|0x1080a
block|,
literal|0x10835
block|,
literal|0x10837
block|,
literal|0x10838
block|,
literal|0x1083c
block|,
literal|0x1083c
block|,
literal|0x1083f
block|,
literal|0x1083f
block|,
literal|0x20000
block|,
literal|0x2a6d6
block|,
literal|0x2f800
block|,
literal|0x2fa1d
block|}
block|,
block|{
comment|// Mn
literal|0x1d167
block|,
literal|0x1d169
block|,
literal|0x1d17b
block|,
literal|0x1d182
block|,
literal|0x1d185
block|,
literal|0x1d18b
block|,
literal|0x1d1aa
block|,
literal|0x1d1ad
block|,
literal|0xe0100
block|,
literal|0xe01ef
block|}
block|,
block|{
comment|// Cf
literal|0x1d173
block|,
literal|0x1d17a
block|,
literal|0xe0001
block|,
literal|0xe0001
block|,
literal|0xe0020
block|,
literal|0xe007f
block|}
block|,
block|{
comment|// Ll
literal|0x10428
block|,
literal|0x1044f
block|,
literal|0x1d41a
block|,
literal|0x1d433
block|,
literal|0x1d44e
block|,
literal|0x1d454
block|,
literal|0x1d456
block|,
literal|0x1d467
block|,
literal|0x1d482
block|,
literal|0x1d49b
block|,
literal|0x1d4b6
block|,
literal|0x1d4b9
block|,
literal|0x1d4bb
block|,
literal|0x1d4bb
block|,
literal|0x1d4bd
block|,
literal|0x1d4c3
block|,
literal|0x1d4c5
block|,
literal|0x1d4cf
block|,
literal|0x1d4ea
block|,
literal|0x1d503
block|,
literal|0x1d51e
block|,
literal|0x1d537
block|,
literal|0x1d552
block|,
literal|0x1d56b
block|,
literal|0x1d586
block|,
literal|0x1d59f
block|,
literal|0x1d5ba
block|,
literal|0x1d5d3
block|,
literal|0x1d5ee
block|,
literal|0x1d607
block|,
literal|0x1d622
block|,
literal|0x1d63b
block|,
literal|0x1d656
block|,
literal|0x1d66f
block|,
literal|0x1d68a
block|,
literal|0x1d6a3
block|,
literal|0x1d6c2
block|,
literal|0x1d6da
block|,
literal|0x1d6dc
block|,
literal|0x1d6e1
block|,
literal|0x1d6fc
block|,
literal|0x1d714
block|,
literal|0x1d716
block|,
literal|0x1d71b
block|,
literal|0x1d736
block|,
literal|0x1d74e
block|,
literal|0x1d750
block|,
literal|0x1d755
block|,
literal|0x1d770
block|,
literal|0x1d788
block|,
literal|0x1d78a
block|,
literal|0x1d78f
block|,
literal|0x1d7aa
block|,
literal|0x1d7c2
block|,
literal|0x1d7c4
block|,
literal|0x1d7c9
block|}
block|,
block|{
comment|// Nl
literal|0x1034a
block|,
literal|0x1034a
block|}
block|,
block|{
comment|// Po
literal|0x10100
block|,
literal|0x10101
block|,
literal|0x1039f
block|,
literal|0x1039f
block|}
block|,
block|{
comment|// Lu
literal|0x10400
block|,
literal|0x10427
block|,
literal|0x1d400
block|,
literal|0x1d419
block|,
literal|0x1d434
block|,
literal|0x1d44d
block|,
literal|0x1d468
block|,
literal|0x1d481
block|,
literal|0x1d49c
block|,
literal|0x1d49c
block|,
literal|0x1d49e
block|,
literal|0x1d49f
block|,
literal|0x1d4a2
block|,
literal|0x1d4a2
block|,
literal|0x1d4a5
block|,
literal|0x1d4a6
block|,
literal|0x1d4a9
block|,
literal|0x1d4ac
block|,
literal|0x1d4ae
block|,
literal|0x1d4b5
block|,
literal|0x1d4d0
block|,
literal|0x1d4e9
block|,
literal|0x1d504
block|,
literal|0x1d505
block|,
literal|0x1d507
block|,
literal|0x1d50a
block|,
literal|0x1d50d
block|,
literal|0x1d514
block|,
literal|0x1d516
block|,
literal|0x1d51c
block|,
literal|0x1d538
block|,
literal|0x1d539
block|,
literal|0x1d53b
block|,
literal|0x1d53e
block|,
literal|0x1d540
block|,
literal|0x1d544
block|,
literal|0x1d546
block|,
literal|0x1d546
block|,
literal|0x1d54a
block|,
literal|0x1d550
block|,
literal|0x1d56c
block|,
literal|0x1d585
block|,
literal|0x1d5a0
block|,
literal|0x1d5b9
block|,
literal|0x1d5d4
block|,
literal|0x1d5ed
block|,
literal|0x1d608
block|,
literal|0x1d621
block|,
literal|0x1d63c
block|,
literal|0x1d655
block|,
literal|0x1d670
block|,
literal|0x1d689
block|,
literal|0x1d6a8
block|,
literal|0x1d6c0
block|,
literal|0x1d6e2
block|,
literal|0x1d6fa
block|,
literal|0x1d71c
block|,
literal|0x1d734
block|,
literal|0x1d756
block|,
literal|0x1d76e
block|,
literal|0x1d790
block|,
literal|0x1d7a8
block|}
block|,
block|{
comment|// Mc
literal|0x1d165
block|,
literal|0x1d166
block|,
literal|0x1d16d
block|,
literal|0x1d172
block|}
block|,
block|{
comment|// Nd
literal|0x104a0
block|,
literal|0x104a9
block|,
literal|0x1d7ce
block|,
literal|0x1d7ff
block|}
block|,
block|{
comment|// So
literal|0x10102
block|,
literal|0x10102
block|,
literal|0x10137
block|,
literal|0x1013f
block|,
literal|0x1d000
block|,
literal|0x1d0f5
block|,
literal|0x1d100
block|,
literal|0x1d126
block|,
literal|0x1d12a
block|,
literal|0x1d164
block|,
literal|0x1d16a
block|,
literal|0x1d16c
block|,
literal|0x1d183
block|,
literal|0x1d184
block|,
literal|0x1d18c
block|,
literal|0x1d1a9
block|,
literal|0x1d1ae
block|,
literal|0x1d1dd
block|,
literal|0x1d300
block|,
literal|0x1d356
block|}
block|,
block|{
comment|// Sm
literal|0x1d6c1
block|,
literal|0x1d6c1
block|,
literal|0x1d6db
block|,
literal|0x1d6db
block|,
literal|0x1d6fb
block|,
literal|0x1d6fb
block|,
literal|0x1d715
block|,
literal|0x1d715
block|,
literal|0x1d735
block|,
literal|0x1d735
block|,
literal|0x1d74f
block|,
literal|0x1d74f
block|,
literal|0x1d76f
block|,
literal|0x1d76f
block|,
literal|0x1d789
block|,
literal|0x1d789
block|,
literal|0x1d7a9
block|,
literal|0x1d7a9
block|,
literal|0x1d7c3
block|,
literal|0x1d7c3
block|}
block|,
block|{
comment|// Co
literal|0xf0000
block|,
literal|0xffffd
block|,
literal|0x100000
block|,
literal|0x10fffd
block|}
block|}
decl_stmt|;
comment|// end of generated code
comment|/**      * CharClass for each block name in specialBlockNames.      */
specifier|static
specifier|private
specifier|final
name|CharClass
index|[]
name|specialBlockCharClasses
init|=
block|{
operator|new
name|CharRange
argument_list|(
literal|0x10300
argument_list|,
literal|0x1032F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x10330
argument_list|,
literal|0x1034F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x10400
argument_list|,
literal|0x1044F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x1D000
argument_list|,
literal|0x1D0FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x1D100
argument_list|,
literal|0x1D1FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x1D400
argument_list|,
literal|0x1D7FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x20000
argument_list|,
literal|0x2A6D6
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x2F800
argument_list|,
literal|0x2FA1F
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0xE0000
argument_list|,
literal|0xE007F
argument_list|)
block|,
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|CharRange
argument_list|(
literal|0xE000
argument_list|,
literal|0xF8FF
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0xF0000
argument_list|,
literal|0xFFFFD
argument_list|)
block|,
operator|new
name|CharRange
argument_list|(
literal|0x100000
argument_list|,
literal|0x10FFFD
argument_list|)
block|}
argument_list|)
block|,
name|Empty
operator|.
name|getInstance
argument_list|()
block|,
name|Empty
operator|.
name|getInstance
argument_list|()
block|,
name|Empty
operator|.
name|getInstance
argument_list|()
block|}
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|DOT
init|=
operator|new
name|Complement
argument_list|(
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|SingleChar
argument_list|(
literal|'\n'
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\r'
argument_list|)
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_d
init|=
operator|new
name|Property
argument_list|(
literal|"Nd"
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_D
init|=
operator|new
name|Complement
argument_list|(
name|ESC_d
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_W
init|=
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|Property
argument_list|(
literal|"P"
argument_list|)
block|,
operator|new
name|Property
argument_list|(
literal|"Z"
argument_list|)
block|,
operator|new
name|Property
argument_list|(
literal|"C"
argument_list|)
block|}
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_w
init|=
operator|new
name|Complement
argument_list|(
name|ESC_W
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_s
init|=
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|SingleChar
argument_list|(
literal|' '
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\n'
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\r'
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
literal|'\t'
argument_list|)
block|}
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_b
init|=
operator|new
name|Escape
argument_list|(
literal|'b'
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_B
init|=
operator|new
name|Escape
argument_list|(
literal|'B'
argument_list|)
decl_stmt|;
comment|// This file was automatically generated by NamingExceptionsGen
comment|// class NamingExceptions {
specifier|static
specifier|final
name|String
name|NMSTRT_INCLUDES
init|=
literal|"\u003A\u005F\u02BB\u02BC\u02BD\u02BE\u02BF\u02C0\u02C1\u0559"
operator|+
literal|"\u06E5\u06E6\u212E"
decl_stmt|;
specifier|static
specifier|final
name|String
name|NMSTRT_EXCLUDE_RANGES
init|=
literal|"\u00AA\u00BA\u0132\u0133\u013F\u0140\u0149\u0149\u017F\u017F"
operator|+
literal|"\u01C4\u01CC\u01F1\u01F3\u01F6\u01F9\u0218\u0233\u02A9\u02AD"
operator|+
literal|"\u03D7\u03D7\u03DB\u03DB\u03DD\u03DD\u03DF\u03DF\u03E1\u03E1"
operator|+
literal|"\u0400\u0400\u040D\u040D\u0450\u0450\u045D\u045D\u048C\u048F"
operator|+
literal|"\u04EC\u04ED\u0587\u0587\u06B8\u06B9\u06BF\u06BF\u06CF\u06CF"
operator|+
literal|"\u06FA\u07A5\u0950\u0950\u0AD0\u0AD0\u0D85\u0DC6\u0E2F\u0E2F"
operator|+
literal|"\u0EAF\u0EAF\u0EDC\u0F00\u0F6A\u1055\u1101\u1101\u1104\u1104"
operator|+
literal|"\u1108\u1108\u110A\u110A\u110D\u110D\u1113\u113B\u113D\u113D"
operator|+
literal|"\u113F\u113F\u1141\u114B\u114D\u114D\u114F\u114F\u1151\u1153"
operator|+
literal|"\u1156\u1158\u1162\u1162\u1164\u1164\u1166\u1166\u1168\u1168"
operator|+
literal|"\u116A\u116C\u116F\u1171\u1174\u1174\u1176\u119D\u119F\u11A2"
operator|+
literal|"\u11A9\u11AA\u11AC\u11AD\u11B0\u11B6\u11B9\u11B9\u11BB\u11BB"
operator|+
literal|"\u11C3\u11EA\u11EC\u11EF\u11F1\u11F8\u1200\u18A8\u207F\u2124"
operator|+
literal|"\u2128\u2128\u212C\u212D\u212F\u217F\u2183\u3006\u3038\u303A"
operator|+
literal|"\u3131\u4DB5\uA000\uA48C\uF900\uFFDC"
decl_stmt|;
specifier|static
specifier|final
name|String
name|NMSTRT_CATEGORIES
init|=
literal|"LlLuLoLtNl"
decl_stmt|;
specifier|static
specifier|final
name|String
name|NMCHAR_INCLUDES
init|=
literal|"\u002D\u002E\u003A\u005F\u00B7\u0387\u212E"
decl_stmt|;
specifier|static
specifier|final
name|String
name|NMCHAR_EXCLUDE_RANGES
init|=
literal|"\u00AA\u00B5\u00BA\u00BA\u0132\u0133\u013F\u0140\u0149\u0149"
operator|+
literal|"\u017F\u017F\u01C4\u01CC\u01F1\u01F3\u01F6\u01F9\u0218\u0233"
operator|+
literal|"\u02A9\u02B8\u02E0\u02EE\u0346\u034E\u0362\u037A\u03D7\u03D7"
operator|+
literal|"\u03DB\u03DB\u03DD\u03DD\u03DF\u03DF\u03E1\u03E1\u0400\u0400"
operator|+
literal|"\u040D\u040D\u0450\u0450\u045D\u045D\u0488\u048F\u04EC\u04ED"
operator|+
literal|"\u0587\u0587\u0653\u0655\u06B8\u06B9\u06BF\u06BF\u06CF\u06CF"
operator|+
literal|"\u06FA\u07B0\u0950\u0950\u0AD0\u0AD0\u0D82\u0DF3\u0E2F\u0E2F"
operator|+
literal|"\u0EAF\u0EAF\u0EDC\u0F00\u0F6A\u0F6A\u0F96\u0F96\u0FAE\u0FB0"
operator|+
literal|"\u0FB8\u0FB8\u0FBA\u1059\u1101\u1101\u1104\u1104\u1108\u1108"
operator|+
literal|"\u110A\u110A\u110D\u110D\u1113\u113B\u113D\u113D\u113F\u113F"
operator|+
literal|"\u1141\u114B\u114D\u114D\u114F\u114F\u1151\u1153\u1156\u1158"
operator|+
literal|"\u1162\u1162\u1164\u1164\u1166\u1166\u1168\u1168\u116A\u116C"
operator|+
literal|"\u116F\u1171\u1174\u1174\u1176\u119D\u119F\u11A2\u11A9\u11AA"
operator|+
literal|"\u11AC\u11AD\u11B0\u11B6\u11B9\u11B9\u11BB\u11BB\u11C3\u11EA"
operator|+
literal|"\u11EC\u11EF\u11F1\u11F8\u1200\u18A9\u207F\u207F\u20DD\u20E0"
operator|+
literal|"\u20E2\u2124\u2128\u2128\u212C\u212D\u212F\u217F\u2183\u2183"
operator|+
literal|"\u3006\u3006\u3038\u303A\u3131\u4DB5\uA000\uA48C\uF900\uFFDC"
decl_stmt|;
specifier|static
specifier|final
name|String
name|NMCHAR_CATEGORIES
init|=
literal|"LlLuLoLtNlMcMeMnLmNd"
decl_stmt|;
comment|// end of generated code
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_S
init|=
operator|new
name|Complement
argument_list|(
name|ESC_s
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_i
init|=
name|makeCharClass
argument_list|(
name|NMSTRT_CATEGORIES
argument_list|,
name|NMSTRT_INCLUDES
argument_list|,
name|NMSTRT_EXCLUDE_RANGES
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_I
init|=
operator|new
name|Complement
argument_list|(
name|ESC_i
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_c
init|=
name|makeCharClass
argument_list|(
name|NMCHAR_CATEGORIES
argument_list|,
name|NMCHAR_INCLUDES
argument_list|,
name|NMCHAR_EXCLUDE_RANGES
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|CharClass
name|ESC_C
init|=
operator|new
name|Complement
argument_list|(
name|ESC_c
argument_list|)
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|char
name|EOS
init|=
literal|'\0'
decl_stmt|;
specifier|private
name|RegexTranslator
parameter_list|(
name|String
name|regExp
parameter_list|)
block|{
name|this
operator|.
name|regExp
operator|=
name|regExp
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|regExp
operator|.
name|length
argument_list|()
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
comment|/**      * Translates a regular expression in the syntax of XML Schemas Part 2 into a regular      * expression in the syntax of<code>java.util.regex.Pattern</code>.  The translation      * assumes that the string to be matched against the regex uses surrogate pairs correctly.      * If the string comes from XML content, a conforming XML parser will automatically      * check this; if the string comes from elsewhere, it may be necessary to check      * surrogate usage before matching.      *      * @param regexp a String containing a regular expression in the syntax of XML Schemas Part 2      * @param xpath a boolean indicating whether the XPath 2.0 F+O extensions to the schema      * regex syntax are permitted      * @return a String containing a regular expression in the syntax of java.util.regex.Pattern      * @throws RegexSyntaxException if<code>regexp</code> is not a regular expression in the      * syntax of XML Schemas Part 2      * @see java.util.regex.Pattern      * @see<a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema Part 2</a>      */
specifier|static
specifier|public
name|String
name|translate
parameter_list|(
name|String
name|regexp
parameter_list|,
name|boolean
name|xpath
parameter_list|)
throws|throws
name|RegexSyntaxException
block|{
name|RegexTranslator
name|tr
init|=
operator|new
name|RegexTranslator
argument_list|(
name|regexp
argument_list|)
decl_stmt|;
name|tr
operator|.
name|isXPath
operator|=
name|xpath
expr_stmt|;
name|tr
operator|.
name|translateTop
argument_list|()
expr_stmt|;
return|return
name|tr
operator|.
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|advance
parameter_list|()
block|{
if|if
condition|(
name|pos
operator|<
name|length
condition|)
name|curChar
operator|=
name|regExp
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
else|else
block|{
name|pos
operator|++
expr_stmt|;
name|curChar
operator|=
name|EOS
expr_stmt|;
name|eos
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|translateTop
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|translateRegExp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|eos
condition|)
throw|throw
name|makeException
argument_list|(
literal|"expected end of string"
argument_list|)
throw|;
block|}
specifier|private
name|void
name|translateRegExp
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|translateBranch
argument_list|()
expr_stmt|;
while|while
condition|(
name|curChar
operator|==
literal|'|'
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
name|translateBranch
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|translateBranch
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
while|while
condition|(
name|translateAtom
argument_list|()
condition|)
name|translateQuantifier
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|translateQuantifier
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
name|copyCurChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|copyCurChar
argument_list|()
expr_stmt|;
name|translateQuantity
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|copyCurChar
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|curChar
operator|==
literal|'?'
operator|&&
name|isXPath
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|translateQuantity
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|String
name|lower
init|=
name|parseQuantExact
argument_list|()
decl_stmt|;
name|int
name|lowerValue
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|lowerValue
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|lower
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// JDK 1.4 cannot handle ranges bigger than this
name|result
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curChar
operator|==
literal|','
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|curChar
operator|!=
literal|'}'
condition|)
block|{
name|String
name|upper
init|=
name|parseQuantExact
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|upperValue
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|upper
argument_list|)
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerValue
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
operator|||
name|upperValue
operator|<
name|lowerValue
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid quantity range"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|result
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerValue
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
operator|&&
operator|new
name|BigDecimal
argument_list|(
name|lower
argument_list|)
operator|.
name|compareTo
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|upper
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid quantity range"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|String
name|parseQuantExact
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
do|do
block|{
if|if
condition|(
literal|"0123456789"
operator|.
name|indexOf
argument_list|(
name|curChar
argument_list|)
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
throw|throw
name|makeException
argument_list|(
literal|"expected digit"
argument_list|)
throw|;
name|buf
operator|.
name|append
argument_list|(
name|curChar
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|curChar
operator|!=
literal|','
operator|&&
name|curChar
operator|!=
literal|'}'
condition|)
do|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|copyCurChar
parameter_list|()
block|{
name|result
operator|.
name|append
argument_list|(
name|curChar
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
specifier|static
specifier|final
name|int
name|NONE
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
specifier|final
name|int
name|SOME
init|=
literal|0
decl_stmt|;
specifier|static
specifier|final
name|int
name|ALL
init|=
literal|1
decl_stmt|;
specifier|static
specifier|final
name|String
name|SURROGATES1_CLASS
init|=
literal|"[\uD800-\uDBFF]"
decl_stmt|;
specifier|static
specifier|final
name|String
name|SURROGATES2_CLASS
init|=
literal|"[\uDC00-\uDFFF]"
decl_stmt|;
specifier|static
specifier|final
name|String
name|NOT_ALLOWED_CLASS
init|=
literal|"[\u0000&&[^\u0000]]"
decl_stmt|;
specifier|static
specifier|final
class|class
name|Range
implements|implements
name|Comparable
block|{
specifier|private
specifier|final
name|int
name|min
decl_stmt|;
specifier|private
specifier|final
name|int
name|max
decl_stmt|;
name|Range
parameter_list|(
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|this
operator|.
name|min
operator|=
name|min
expr_stmt|;
name|this
operator|.
name|max
operator|=
name|max
expr_stmt|;
block|}
name|int
name|getMin
parameter_list|()
block|{
return|return
name|min
return|;
block|}
name|int
name|getMax
parameter_list|()
block|{
return|return
name|max
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Range
name|other
init|=
operator|(
name|Range
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|min
operator|<
name|other
operator|.
name|min
condition|)
return|return
name|Constants
operator|.
name|INFERIOR
return|;
if|if
condition|(
name|this
operator|.
name|min
operator|>
name|other
operator|.
name|min
condition|)
return|return
name|Constants
operator|.
name|SUPERIOR
return|;
if|if
condition|(
name|this
operator|.
name|max
operator|>
name|other
operator|.
name|max
condition|)
return|return
name|Constants
operator|.
name|INFERIOR
return|;
if|if
condition|(
name|this
operator|.
name|max
operator|<
name|other
operator|.
name|max
condition|)
return|return
name|Constants
operator|.
name|SUPERIOR
return|;
return|return
name|Constants
operator|.
name|EQUAL
return|;
block|}
block|}
specifier|static
specifier|abstract
class|class
name|CharClass
block|{
specifier|private
specifier|final
name|int
name|containsBmp
decl_stmt|;
comment|// if it contains ALL and containsBmp != NONE, then the generated class for containsBmp must
comment|// contain all the high surrogates
specifier|private
specifier|final
name|int
name|containsNonBmp
decl_stmt|;
specifier|protected
name|CharClass
parameter_list|(
name|int
name|containsBmp
parameter_list|,
name|int
name|containsNonBmp
parameter_list|)
block|{
name|this
operator|.
name|containsBmp
operator|=
name|containsBmp
expr_stmt|;
name|this
operator|.
name|containsNonBmp
operator|=
name|containsNonBmp
expr_stmt|;
block|}
name|int
name|getContainsBmp
parameter_list|()
block|{
return|return
name|containsBmp
return|;
block|}
name|int
name|getContainsNonBmp
parameter_list|()
block|{
return|return
name|containsNonBmp
return|;
block|}
specifier|final
name|void
name|output
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
switch|switch
condition|(
name|containsNonBmp
condition|)
block|{
case|case
name|NONE
case|:
if|if
condition|(
name|containsBmp
operator|==
name|NONE
condition|)
name|buf
operator|.
name|append
argument_list|(
name|NOT_ALLOWED_CLASS
argument_list|)
expr_stmt|;
else|else
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALL
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"(?:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsBmp
operator|==
name|NONE
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|SURROGATES1_CLASS
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|SURROGATES2_CLASS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|SURROGATES2_CLASS
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOME
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"(?:"
argument_list|)
expr_stmt|;
name|boolean
name|needSep
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|containsBmp
operator|!=
name|NONE
condition|)
block|{
name|needSep
operator|=
literal|true
expr_stmt|;
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|List
name|ranges
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|addNonBmpRanges
argument_list|(
name|ranges
argument_list|)
expr_stmt|;
name|sortRangeList
argument_list|(
name|ranges
argument_list|)
expr_stmt|;
name|String
name|hi
init|=
name|highSurrogateRanges
argument_list|(
name|ranges
argument_list|)
decl_stmt|;
if|if
condition|(
name|hi
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|needSep
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
else|else
name|needSep
operator|=
literal|true
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|hi
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|char
name|min
init|=
name|hi
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|max
init|=
name|hi
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|==
name|max
condition|)
name|buf
operator|.
name|append
argument_list|(
name|min
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|min
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|SURROGATES2_CLASS
argument_list|)
expr_stmt|;
block|}
name|String
name|lo
init|=
name|lowSurrogateRanges
argument_list|(
name|ranges
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|lo
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|needSep
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
else|else
name|needSep
operator|=
literal|true
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|lo
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|char
name|min
init|=
name|lo
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
name|max
init|=
name|lo
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|==
name|max
operator|&&
operator|(
name|i
operator|+
literal|3
operator|>=
name|len
operator|||
name|lo
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|3
argument_list|)
operator|!=
name|lo
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|)
condition|)
name|buf
operator|.
name|append
argument_list|(
name|min
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|min
operator|==
name|max
condition|)
name|buf
operator|.
name|append
argument_list|(
name|min
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|min
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|3
operator|>=
name|len
operator|||
name|lo
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|3
argument_list|)
operator|!=
name|lo
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
break|break;
name|i
operator|+=
literal|3
expr_stmt|;
name|min
operator|=
name|lo
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
name|lo
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|needSep
condition|)
name|buf
operator|.
name|append
argument_list|(
name|NOT_ALLOWED_CLASS
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|static
name|String
name|highSurrogateRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|StringBuilder
name|highRanges
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|ranges
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|min1
init|=
name|XMLChar
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|min2
init|=
name|XMLChar
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max1
init|=
name|XMLChar
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max2
init|=
name|XMLChar
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|min2
operator|!=
name|SURROGATE2_MIN
condition|)
name|min1
operator|++
expr_stmt|;
if|if
condition|(
name|max2
operator|!=
name|SURROGATE2_MAX
condition|)
name|max1
operator|--
expr_stmt|;
if|if
condition|(
name|max1
operator|>=
name|min1
condition|)
block|{
name|highRanges
operator|.
name|append
argument_list|(
name|min1
argument_list|)
expr_stmt|;
name|highRanges
operator|.
name|append
argument_list|(
name|max1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|highRanges
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|static
name|String
name|lowSurrogateRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|StringBuilder
name|lowRanges
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|ranges
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|min1
init|=
name|XMLChar
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|min2
init|=
name|XMLChar
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max1
init|=
name|XMLChar
operator|.
name|highSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|max2
init|=
name|XMLChar
operator|.
name|lowSurrogate
argument_list|(
name|r
operator|.
name|getMax
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|min1
operator|==
name|max1
condition|)
block|{
if|if
condition|(
name|min2
operator|!=
name|SURROGATE2_MIN
operator|||
name|max2
operator|!=
name|SURROGATE2_MAX
condition|)
block|{
name|lowRanges
operator|.
name|append
argument_list|(
name|min1
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|min2
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|max2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|min2
operator|!=
name|SURROGATE2_MIN
condition|)
block|{
name|lowRanges
operator|.
name|append
argument_list|(
name|min1
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|min2
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|SURROGATE2_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max2
operator|!=
name|SURROGATE2_MAX
condition|)
block|{
name|lowRanges
operator|.
name|append
argument_list|(
name|max1
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|SURROGATE2_MIN
argument_list|)
expr_stmt|;
name|lowRanges
operator|.
name|append
argument_list|(
name|max2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|lowRanges
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|abstract
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
function_decl|;
specifier|abstract
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
function_decl|;
name|int
name|singleChar
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
name|void
name|addNonBmpRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
block|}
specifier|static
name|void
name|sortRangeList
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|ranges
argument_list|)
expr_stmt|;
name|int
name|toIndex
init|=
literal|0
decl_stmt|;
name|int
name|fromIndex
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|ranges
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|fromIndex
operator|<
name|len
condition|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
name|int
name|min
init|=
name|r
operator|.
name|getMin
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|r
operator|.
name|getMax
argument_list|()
decl_stmt|;
while|while
condition|(
operator|++
name|fromIndex
operator|<
name|len
condition|)
block|{
name|Range
name|r2
init|=
operator|(
name|Range
operator|)
name|ranges
operator|.
name|get
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|.
name|getMin
argument_list|()
operator|>
name|max
operator|+
literal|1
condition|)
break|break;
if|if
condition|(
name|r2
operator|.
name|getMax
argument_list|()
operator|>
name|max
condition|)
name|max
operator|=
name|r2
operator|.
name|getMax
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
name|r
operator|.
name|getMax
argument_list|()
condition|)
name|r
operator|=
operator|new
name|Range
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|ranges
operator|.
name|set
argument_list|(
name|toIndex
operator|++
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
name|toIndex
condition|)
name|ranges
operator|.
name|remove
argument_list|(
operator|--
name|len
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
specifier|abstract
class|class
name|SimpleCharClass
extends|extends
name|CharClass
block|{
name|SimpleCharClass
parameter_list|(
name|int
name|containsBmp
parameter_list|,
name|int
name|containsNonBmp
parameter_list|)
block|{
name|super
argument_list|(
name|containsBmp
argument_list|,
name|containsNonBmp
argument_list|)
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
comment|// must not call if containsBmp == ALL
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|getContainsBmp
argument_list|()
operator|==
name|NONE
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|"[\u0000-\uFFFF]"
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"[^"
argument_list|)
expr_stmt|;
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
block|}
specifier|abstract
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
function_decl|;
block|}
specifier|static
class|class
name|SingleChar
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|char
name|c
decl_stmt|;
name|SingleChar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|super
argument_list|(
name|SOME
argument_list|,
name|NONE
argument_list|)
expr_stmt|;
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
name|int
name|singleChar
parameter_list|()
block|{
return|return
name|c
return|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|isJavaMetaChar
argument_list|(
name|c
argument_list|)
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|WideSingleChar
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|int
name|c
decl_stmt|;
name|WideSingleChar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|super
argument_list|(
name|NONE
argument_list|,
name|SOME
argument_list|)
expr_stmt|;
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"BMP output botch"
argument_list|)
throw|;
block|}
name|int
name|singleChar
parameter_list|()
block|{
return|return
name|c
return|;
block|}
name|void
name|addNonBmpRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|c
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Empty
extends|extends
name|SimpleCharClass
block|{
specifier|static
specifier|private
specifier|final
name|Empty
name|instance
init|=
operator|new
name|Empty
argument_list|()
decl_stmt|;
specifier|private
name|Empty
parameter_list|()
block|{
name|super
argument_list|(
name|NONE
argument_list|,
name|NONE
argument_list|)
expr_stmt|;
block|}
specifier|static
name|Empty
name|getInstance
parameter_list|()
block|{
return|return
name|instance
return|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"BMP output botch"
argument_list|)
throw|;
block|}
block|}
specifier|static
class|class
name|CharRange
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|int
name|lower
decl_stmt|;
specifier|private
specifier|final
name|int
name|upper
decl_stmt|;
name|CharRange
parameter_list|(
name|int
name|lower
parameter_list|,
name|int
name|upper
parameter_list|)
block|{
name|super
argument_list|(
name|lower
operator|<
name|NONBMP_MIN
condition|?
name|SOME
else|:
name|NONE
argument_list|,
comment|// don't use ALL here, because that requires that the BMP class contains high surrogates
name|upper
operator|>=
name|NONBMP_MIN
condition|?
name|SOME
else|:
name|NONE
argument_list|)
expr_stmt|;
name|this
operator|.
name|lower
operator|=
name|lower
expr_stmt|;
name|this
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|lower
operator|>=
name|NONBMP_MIN
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"BMP output botch"
argument_list|)
throw|;
if|if
condition|(
name|isJavaMetaChar
argument_list|(
operator|(
name|char
operator|)
name|lower
argument_list|)
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|lower
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
operator|<
name|NONBMP_MIN
condition|)
block|{
if|if
condition|(
name|isJavaMetaChar
argument_list|(
operator|(
name|char
operator|)
name|upper
argument_list|)
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|upper
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|.
name|append
argument_list|(
literal|'\uFFFF'
argument_list|)
expr_stmt|;
block|}
name|void
name|addNonBmpRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
if|if
condition|(
name|upper
operator|>=
name|NONBMP_MIN
condition|)
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|lower
operator|<
name|NONBMP_MIN
condition|?
name|NONBMP_MIN
else|:
name|lower
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Property
extends|extends
name|SimpleCharClass
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
name|Property
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|SOME
argument_list|,
name|NONE
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\\p{"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\\P{"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Subtraction
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|CharClass
name|cc1
decl_stmt|;
specifier|private
specifier|final
name|CharClass
name|cc2
decl_stmt|;
name|Subtraction
parameter_list|(
name|CharClass
name|cc1
parameter_list|,
name|CharClass
name|cc2
parameter_list|)
block|{
comment|// min corresponds to intersection
comment|// complement corresponds to negation
name|super
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|cc1
operator|.
name|getContainsBmp
argument_list|()
argument_list|,
operator|-
name|cc2
operator|.
name|getContainsBmp
argument_list|()
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|cc1
operator|.
name|getContainsNonBmp
argument_list|()
argument_list|,
operator|-
name|cc2
operator|.
name|getContainsNonBmp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|cc1
operator|=
name|cc1
expr_stmt|;
name|this
operator|.
name|cc2
operator|=
name|cc2
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|cc1
operator|.
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"&&"
argument_list|)
expr_stmt|;
name|cc2
operator|.
name|outputComplementBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|cc1
operator|.
name|outputComplementBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cc2
operator|.
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|addNonBmpRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|List
name|posList
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|cc1
operator|.
name|addNonBmpRanges
argument_list|(
name|posList
argument_list|)
expr_stmt|;
name|List
name|negList
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|cc2
operator|.
name|addNonBmpRanges
argument_list|(
name|negList
argument_list|)
expr_stmt|;
name|sortRangeList
argument_list|(
name|posList
argument_list|)
expr_stmt|;
name|sortRangeList
argument_list|(
name|negList
argument_list|)
expr_stmt|;
name|Iterator
name|negIter
init|=
name|negList
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Range
name|negRange
decl_stmt|;
if|if
condition|(
name|negIter
operator|.
name|hasNext
argument_list|()
condition|)
name|negRange
operator|=
operator|(
name|Range
operator|)
name|negIter
operator|.
name|next
argument_list|()
expr_stmt|;
else|else
name|negRange
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|posList
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Range
name|posRange
init|=
operator|(
name|Range
operator|)
name|posList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|negRange
operator|!=
literal|null
operator|&&
name|negRange
operator|.
name|getMax
argument_list|()
operator|<
name|posRange
operator|.
name|getMin
argument_list|()
condition|)
block|{
if|if
condition|(
name|negIter
operator|.
name|hasNext
argument_list|()
condition|)
name|negRange
operator|=
operator|(
name|Range
operator|)
name|negIter
operator|.
name|next
argument_list|()
expr_stmt|;
else|else
name|negRange
operator|=
literal|null
expr_stmt|;
block|}
comment|// if negRange != null, negRange.max>= posRange.min
name|int
name|min
init|=
name|posRange
operator|.
name|getMin
argument_list|()
decl_stmt|;
while|while
condition|(
name|negRange
operator|!=
literal|null
operator|&&
name|negRange
operator|.
name|getMin
argument_list|()
operator|<=
name|posRange
operator|.
name|getMax
argument_list|()
condition|)
block|{
if|if
condition|(
name|min
operator|<
name|negRange
operator|.
name|getMin
argument_list|()
condition|)
block|{
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|min
argument_list|,
name|negRange
operator|.
name|getMin
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|min
operator|=
name|negRange
operator|.
name|getMax
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|posRange
operator|.
name|getMax
argument_list|()
condition|)
break|break;
if|if
condition|(
name|negIter
operator|.
name|hasNext
argument_list|()
condition|)
name|negRange
operator|=
operator|(
name|Range
operator|)
name|negIter
operator|.
name|next
argument_list|()
expr_stmt|;
else|else
name|negRange
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|<=
name|posRange
operator|.
name|getMax
argument_list|()
condition|)
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|min
argument_list|,
name|posRange
operator|.
name|getMax
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
class|class
name|Union
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|List
name|members
decl_stmt|;
name|Union
parameter_list|(
name|CharClass
index|[]
name|v
parameter_list|)
block|{
name|this
argument_list|(
name|toList
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|private
name|List
name|toList
parameter_list|(
name|CharClass
index|[]
name|v
parameter_list|)
block|{
name|List
name|members
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|v
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|members
operator|.
name|add
argument_list|(
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|members
return|;
block|}
name|Union
parameter_list|(
name|List
name|members
parameter_list|)
block|{
name|super
argument_list|(
name|computeContainsBmp
argument_list|(
name|members
argument_list|)
argument_list|,
name|computeContainsNonBmp
argument_list|(
name|members
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|members
operator|=
name|members
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|CharClass
name|cc
init|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cc
operator|.
name|getContainsBmp
argument_list|()
operator|!=
name|NONE
condition|)
block|{
if|if
condition|(
name|cc
operator|instanceof
name|SimpleCharClass
condition|)
operator|(
operator|(
name|SimpleCharClass
operator|)
name|cc
operator|)
operator|.
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|cc
operator|.
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|int
name|len
init|=
name|members
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|CharClass
name|cc
init|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cc
operator|.
name|getContainsBmp
argument_list|()
operator|!=
name|NONE
operator|&&
name|cc
operator|instanceof
name|SimpleCharClass
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"[^"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
operator|(
operator|(
name|SimpleCharClass
operator|)
name|cc
operator|)
operator|.
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|CharClass
name|cc
init|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cc
operator|.
name|getContainsBmp
argument_list|()
operator|!=
name|NONE
operator|&&
operator|!
operator|(
name|cc
operator|instanceof
name|SimpleCharClass
operator|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
name|buf
operator|.
name|append
argument_list|(
literal|"&&"
argument_list|)
expr_stmt|;
comment|// can't have any members that are ALL, because that would make this ALL, which violates
comment|// the precondition for outputComplementBmp
name|cc
operator|.
name|outputComplementBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
literal|true
condition|)
comment|// all members are NONE, so this is NONE, so complement is everything
name|buf
operator|.
name|append
argument_list|(
literal|"[\u0000-\uFFFF]"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|void
name|addNonBmpRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|addNonBmpRanges
argument_list|(
name|ranges
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|computeContainsBmp
parameter_list|(
name|List
name|members
parameter_list|)
block|{
name|int
name|ret
init|=
name|NONE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|ret
operator|=
name|Math
operator|.
name|max
argument_list|(
name|ret
argument_list|,
operator|(
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getContainsBmp
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
specifier|static
name|int
name|computeContainsNonBmp
parameter_list|(
name|List
name|members
parameter_list|)
block|{
name|int
name|ret
init|=
name|NONE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|ret
operator|=
name|Math
operator|.
name|max
argument_list|(
name|ret
argument_list|,
operator|(
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getContainsNonBmp
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
specifier|static
class|class
name|BackReference
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|int
name|i
decl_stmt|;
name|BackReference
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|super
argument_list|(
name|SOME
argument_list|,
name|NONE
argument_list|)
expr_stmt|;
name|this
operator|.
name|i
operator|=
name|i
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|Escape
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|char
name|ch
decl_stmt|;
name|Escape
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
name|super
argument_list|(
name|SOME
argument_list|,
name|NONE
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|inClassOutputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|inClassOutputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Thrown when an syntactically incorrect regular expression is detected.      */
specifier|static
specifier|public
class|class
name|RegexSyntaxException
extends|extends
name|Exception
block|{
specifier|private
specifier|final
name|int
name|position
decl_stmt|;
comment|/**          * Represents an unknown position within a string containing a regular expression.          */
specifier|static
specifier|public
specifier|final
name|int
name|UNKNOWN_POSITION
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|RegexSyntaxException
parameter_list|(
name|String
name|detail
parameter_list|)
block|{
name|this
argument_list|(
name|detail
argument_list|,
name|UNKNOWN_POSITION
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RegexSyntaxException
parameter_list|(
name|String
name|detail
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|super
argument_list|(
name|detail
argument_list|)
expr_stmt|;
name|this
operator|.
name|position
operator|=
name|position
expr_stmt|;
block|}
comment|/**          * Returns the index into the regular expression where the error was detected          * or<code>UNKNOWN_POSITION</code> if this is unknown.          *          * @return the index into the regular expression where the error was detected,          * or<code>UNKNOWNN_POSITION</code> if this is unknown          */
specifier|public
name|int
name|getPosition
parameter_list|()
block|{
return|return
name|position
return|;
block|}
block|}
comment|//    public static class Localizer {
comment|//        private final Class cls;
comment|//        private ResourceBundle bundle;
comment|//
comment|//        public Localizer(Class cls) {
comment|//            this.cls = cls;
comment|//        }
comment|//
comment|//        public String message(String key) {
comment|//            return MessageFormat.format(getBundle().getString(key), new Object[]{});
comment|//        }
comment|//
comment|//        public String message(String key, Object arg) {
comment|//            return MessageFormat.format(getBundle().getString(key),
comment|//                                        new Object[]{arg});
comment|//        }
comment|//
comment|//        public String message(String key, Object arg1, Object arg2) {
comment|//            return MessageFormat.format(getBundle().getString(key),
comment|//                                        new Object[]{arg1, arg2});
comment|//        }
comment|//
comment|//        public String message(String key, Object[] args) {
comment|//            return MessageFormat.format(getBundle().getString(key), args);
comment|//        }
comment|//
comment|//        private ResourceBundle getBundle() {
comment|//            if (bundle == null) {
comment|//                String s = cls.getName();
comment|//                int i = s.lastIndexOf('.');
comment|//                if (i> 0)
comment|//                    s = s.substring(0, i + 1);
comment|//                else
comment|//                    s = "";
comment|//                bundle = ResourceBundle.getBundle(s + "resources.Messages");
comment|//            }
comment|//            return bundle;
comment|//        }
comment|//    }
specifier|static
class|class
name|Complement
extends|extends
name|CharClass
block|{
specifier|private
specifier|final
name|CharClass
name|cc
decl_stmt|;
name|Complement
parameter_list|(
name|CharClass
name|cc
parameter_list|)
block|{
name|super
argument_list|(
operator|-
name|cc
operator|.
name|getContainsBmp
argument_list|()
argument_list|,
operator|-
name|cc
operator|.
name|getContainsNonBmp
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|cc
operator|=
name|cc
expr_stmt|;
block|}
name|void
name|outputBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|cc
operator|.
name|outputComplementBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|outputComplementBmp
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|cc
operator|.
name|outputBmp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|void
name|addNonBmpRanges
parameter_list|(
name|List
name|ranges
parameter_list|)
block|{
name|List
name|tem
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|cc
operator|.
name|addNonBmpRanges
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|sortRangeList
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|int
name|c
init|=
name|NONBMP_MIN
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|tem
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Range
name|r
init|=
operator|(
name|Range
operator|)
name|tem
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getMin
argument_list|()
operator|>
name|c
condition|)
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|c
argument_list|,
name|r
operator|.
name|getMin
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|r
operator|.
name|getMax
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|NONBMP_MAX
operator|+
literal|1
condition|)
name|ranges
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|c
argument_list|,
name|NONBMP_MAX
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|translateAtom
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
name|EOS
case|:
if|if
condition|(
operator|!
name|eos
condition|)
break|break;
comment|// fall through
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'|'
case|:
case|case
literal|']'
case|:
return|return
literal|false
return|;
case|case
literal|'('
case|:
name|copyCurChar
argument_list|()
expr_stmt|;
name|translateRegExp
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|copyCurChar
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'\\'
case|:
name|advance
argument_list|()
expr_stmt|;
name|parseEsc
argument_list|()
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'['
case|:
name|advance
argument_list|()
expr_stmt|;
name|parseCharClassExpr
argument_list|()
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'.'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
comment|// TODO: in XPath, modify "." so that it matches a surrogate pair
break|break;
block|}
else|else
block|{
name|DOT
operator|.
name|output
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
literal|'$'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
name|copyCurChar
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
block|}
name|copyCurChar
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|static
specifier|private
name|CharClass
name|makeCharClass
parameter_list|(
name|String
name|categories
parameter_list|,
name|String
name|includes
parameter_list|,
name|String
name|excludeRanges
parameter_list|)
block|{
name|List
name|includeList
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|categories
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
name|includeList
operator|.
name|add
argument_list|(
operator|new
name|Property
argument_list|(
name|categories
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|includes
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|i
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|len
operator|&&
name|includes
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|-
name|includes
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
name|j
operator|-
name|i
condition|;
name|j
operator|++
control|)
empty_stmt|;
operator|--
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
operator|-
literal|1
condition|)
operator|--
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
name|includeList
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|includes
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|includeList
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|includes
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|,
name|includes
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
name|List
name|excludeList
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|excludeRanges
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|char
name|min
init|=
name|excludeRanges
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|max
init|=
name|excludeRanges
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|==
name|max
condition|)
name|excludeList
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|min
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|min
operator|==
name|max
operator|-
literal|1
condition|)
block|{
name|excludeList
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|excludeList
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Subtraction
argument_list|(
operator|new
name|Union
argument_list|(
name|includeList
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
name|excludeList
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|CharClass
name|parseEsc
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
literal|'n'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SingleChar
argument_list|(
literal|'\n'
argument_list|)
return|;
case|case
literal|'r'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SingleChar
argument_list|(
literal|'\r'
argument_list|)
return|;
case|case
literal|'t'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SingleChar
argument_list|(
literal|'\t'
argument_list|)
return|;
case|case
literal|'\\'
case|:
case|case
literal|'|'
case|:
case|case
literal|'.'
case|:
case|case
literal|'-'
case|:
case|case
literal|'^'
case|:
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
break|break;
case|case
literal|'s'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_s
return|;
case|case
literal|'S'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_S
return|;
case|case
literal|'i'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_i
return|;
case|case
literal|'I'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_I
return|;
case|case
literal|'c'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_c
return|;
case|case
literal|'C'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_C
return|;
case|case
literal|'d'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_d
return|;
case|case
literal|'D'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_D
return|;
case|case
literal|'w'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_w
return|;
case|case
literal|'W'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_W
return|;
case|case
literal|'b'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_b
return|;
case|case
literal|'B'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|ESC_B
return|;
case|case
literal|'p'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|parseProp
argument_list|()
return|;
case|case
literal|'P'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|Complement
argument_list|(
name|parseProp
argument_list|()
argument_list|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
name|char
name|c
init|=
name|curChar
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|BackReference
argument_list|(
name|c
operator|-
literal|'0'
argument_list|)
return|;
comment|// TODO: test multi-digit back-references
block|}
else|else
block|{
throw|throw
name|makeException
argument_list|(
literal|"digit not allowed after \\"
argument_list|)
throw|;
block|}
case|case
literal|'$'
case|:
if|if
condition|(
name|isXPath
condition|)
block|{
break|break;
block|}
comment|// otherwise fall through
default|default:
throw|throw
name|makeException
argument_list|(
literal|"bad escape sequence"
argument_list|)
throw|;
block|}
name|CharClass
name|tem
init|=
operator|new
name|SingleChar
argument_list|(
name|curChar
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
specifier|private
name|CharClass
name|parseProp
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|expect
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|start
init|=
name|pos
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'}'
condition|)
break|break;
if|if
condition|(
operator|!
name|isAsciiAlnum
argument_list|(
name|curChar
argument_list|)
operator|&&
name|curChar
operator|!=
literal|'-'
condition|)
name|expect
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|String
name|propertyName
init|=
name|regExp
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|propertyName
operator|.
name|length
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
throw|throw
name|makeException
argument_list|(
literal|"empty property name"
argument_list|)
throw|;
case|case
literal|2
case|:
name|int
name|sci
init|=
name|subCategories
operator|.
name|indexOf
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sci
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
operator|||
name|sci
operator|%
literal|2
operator|==
literal|1
condition|)
throw|throw
name|makeException
argument_list|(
literal|"bad category"
argument_list|)
throw|;
return|return
name|getSubCategoryCharClass
argument_list|(
name|sci
operator|/
literal|2
argument_list|)
return|;
case|case
literal|1
case|:
name|int
name|ci
init|=
name|categories
operator|.
name|indexOf
argument_list|(
name|propertyName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ci
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
throw|throw
name|makeException
argument_list|(
literal|"bad category"
argument_list|,
name|propertyName
argument_list|)
throw|;
return|return
name|getCategoryCharClass
argument_list|(
name|ci
argument_list|)
return|;
default|default:
if|if
condition|(
operator|!
name|propertyName
operator|.
name|startsWith
argument_list|(
literal|"Is"
argument_list|)
condition|)
break|break;
name|String
name|blockName
init|=
name|propertyName
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|specialBlockNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|blockName
operator|.
name|equals
argument_list|(
name|specialBlockNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|specialBlockCharClasses
index|[
name|i
index|]
return|;
if|if
condition|(
operator|!
name|isBlock
argument_list|(
name|blockName
argument_list|)
condition|)
throw|throw
name|makeException
argument_list|(
literal|"bad block name"
argument_list|,
name|blockName
argument_list|)
throw|;
return|return
operator|new
name|Property
argument_list|(
literal|"In"
operator|+
name|blockName
argument_list|)
return|;
block|}
throw|throw
name|makeException
argument_list|(
literal|"bad property name"
argument_list|,
name|propertyName
argument_list|)
throw|;
block|}
specifier|static
specifier|private
name|boolean
name|isBlock
parameter_list|(
name|String
name|name
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|blockNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
specifier|static
specifier|private
name|boolean
name|isAsciiAlnum
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
return|return
literal|true
return|;
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
return|return
literal|true
return|;
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|expect
parameter_list|(
name|char
name|c
parameter_list|)
throws|throws
name|RegexSyntaxException
block|{
if|if
condition|(
name|curChar
operator|!=
name|c
condition|)
throw|throw
name|makeException
argument_list|(
literal|"expected"
argument_list|,
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|c
block|}
argument_list|)
argument_list|)
throw|;
block|}
specifier|private
name|CharClass
name|parseCharClassExpr
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
name|boolean
name|compl
decl_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'^'
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
name|compl
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|compl
operator|=
literal|false
expr_stmt|;
name|List
name|members
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
do|do
block|{
name|CharClass
name|lower
init|=
name|parseCharClassEscOrXmlChar
argument_list|()
decl_stmt|;
name|members
operator|.
name|add
argument_list|(
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'-'
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'['
condition|)
break|break;
name|CharClass
name|upper
init|=
name|parseCharClassEscOrXmlChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|lower
operator|.
name|singleChar
argument_list|()
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
operator|||
name|upper
operator|.
name|singleChar
argument_list|()
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
throw|throw
name|makeException
argument_list|(
literal|"multi_range"
argument_list|)
throw|;
if|if
condition|(
name|lower
operator|.
name|singleChar
argument_list|()
operator|>
name|upper
operator|.
name|singleChar
argument_list|()
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid_range"
argument_list|)
throw|;
name|members
operator|.
name|set
argument_list|(
name|members
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
operator|new
name|CharRange
argument_list|(
name|lower
operator|.
name|singleChar
argument_list|()
argument_list|,
name|upper
operator|.
name|singleChar
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'-'
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|curChar
operator|!=
literal|']'
condition|)
do|;
name|CharClass
name|result
decl_stmt|;
if|if
condition|(
name|members
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|result
operator|=
operator|(
name|CharClass
operator|)
name|members
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|new
name|Union
argument_list|(
name|members
argument_list|)
expr_stmt|;
if|if
condition|(
name|compl
condition|)
name|result
operator|=
operator|new
name|Complement
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|curChar
operator|==
literal|'['
condition|)
block|{
name|advance
argument_list|()
expr_stmt|;
name|result
operator|=
operator|new
name|Subtraction
argument_list|(
name|result
argument_list|,
name|parseCharClassExpr
argument_list|()
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|advance
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|CharClass
name|parseCharClassEscOrXmlChar
parameter_list|()
throws|throws
name|RegexSyntaxException
block|{
switch|switch
condition|(
name|curChar
condition|)
block|{
case|case
name|EOS
case|:
if|if
condition|(
name|eos
condition|)
name|expect
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|advance
argument_list|()
expr_stmt|;
return|return
name|parseEsc
argument_list|()
return|;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'-'
case|:
throw|throw
name|makeException
argument_list|(
literal|"should_quote"
argument_list|,
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|curChar
block|}
argument_list|)
argument_list|)
throw|;
block|}
name|CharClass
name|tem
decl_stmt|;
if|if
condition|(
name|XMLChar
operator|.
name|isSurrogate
argument_list|(
name|curChar
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|XMLChar
operator|.
name|isHighSurrogate
argument_list|(
name|curChar
argument_list|)
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid_surrogate"
argument_list|)
throw|;
name|char
name|c1
init|=
name|curChar
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|XMLChar
operator|.
name|isLowSurrogate
argument_list|(
name|curChar
argument_list|)
condition|)
throw|throw
name|makeException
argument_list|(
literal|"invalid_surrogate"
argument_list|)
throw|;
name|tem
operator|=
operator|new
name|WideSingleChar
argument_list|(
name|XMLChar
operator|.
name|supplemental
argument_list|(
name|c1
argument_list|,
name|curChar
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
operator|new
name|SingleChar
argument_list|(
name|curChar
argument_list|)
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
specifier|private
name|RegexSyntaxException
name|makeException
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|new
name|RegexSyntaxException
argument_list|(
literal|"Error at character "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
operator|+
literal|" in regular expression: "
operator|+
name|key
argument_list|)
return|;
block|}
specifier|private
name|RegexSyntaxException
name|makeException
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|arg
parameter_list|)
block|{
return|return
operator|new
name|RegexSyntaxException
argument_list|(
literal|"Error at character "
operator|+
operator|(
name|pos
operator|-
literal|1
operator|)
operator|+
literal|" in regular expression: "
operator|+
name|key
operator|+
literal|" ("
operator|+
name|arg
operator|+
literal|")"
argument_list|)
return|;
block|}
specifier|static
specifier|private
name|boolean
name|isJavaMetaChar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'^'
case|:
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'|'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
case|case
literal|'.'
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|static
specifier|private
specifier|synchronized
name|CharClass
name|getCategoryCharClass
parameter_list|(
name|int
name|ci
parameter_list|)
block|{
if|if
condition|(
name|categoryCharClasses
index|[
name|ci
index|]
operator|==
literal|null
condition|)
name|categoryCharClasses
index|[
name|ci
index|]
operator|=
name|computeCategoryCharClass
argument_list|(
name|categories
operator|.
name|charAt
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|categoryCharClasses
index|[
name|ci
index|]
return|;
block|}
specifier|static
specifier|private
specifier|synchronized
name|CharClass
name|getSubCategoryCharClass
parameter_list|(
name|int
name|sci
parameter_list|)
block|{
if|if
condition|(
name|subCategoryCharClasses
index|[
name|sci
index|]
operator|==
literal|null
condition|)
name|subCategoryCharClasses
index|[
name|sci
index|]
operator|=
name|computeSubCategoryCharClass
argument_list|(
name|subCategories
operator|.
name|substring
argument_list|(
name|sci
operator|*
literal|2
argument_list|,
operator|(
name|sci
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|subCategoryCharClasses
index|[
name|sci
index|]
return|;
block|}
specifier|static
specifier|private
specifier|final
name|char
name|UNICODE_3_1_ADD_Lu
init|=
literal|'\u03F4'
decl_stmt|;
comment|// added in 3.1
specifier|static
specifier|private
specifier|final
name|char
name|UNICODE_3_1_ADD_Ll
init|=
literal|'\u03F5'
decl_stmt|;
comment|// added in 3.1
comment|// 3 characters changed from No to Nl between 3.0 and 3.1
specifier|static
specifier|private
specifier|final
name|char
name|UNICODE_3_1_CHANGE_No_to_Nl_MIN
init|=
literal|'\u16EE'
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|char
name|UNICODE_3_1_CHANGE_No_to_Nl_MAX
init|=
literal|'\u16F0'
decl_stmt|;
specifier|static
specifier|private
specifier|final
name|String
name|CATEGORY_Pi
init|=
literal|"\u00AB\u2018\u201B\u201C\u201F\u2039"
decl_stmt|;
comment|// Java doesn't know about category Pi
specifier|static
specifier|private
specifier|final
name|String
name|CATEGORY_Pf
init|=
literal|"\u00BB\u2019\u201D\u203A"
decl_stmt|;
comment|// Java doesn't know about category Pf
specifier|static
specifier|private
name|CharClass
name|computeCategoryCharClass
parameter_list|(
name|char
name|code
parameter_list|)
block|{
name|List
name|classes
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|classes
operator|.
name|add
argument_list|(
operator|new
name|Property
argument_list|(
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|code
block|}
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ci
init|=
name|CATEGORY_NAMES
operator|.
name|indexOf
argument_list|(
name|code
argument_list|)
init|;
name|ci
operator|>=
literal|0
condition|;
name|ci
operator|=
name|CATEGORY_NAMES
operator|.
name|indexOf
argument_list|(
name|code
argument_list|,
name|ci
operator|+
literal|1
argument_list|)
control|)
block|{
name|int
index|[]
name|addRanges
init|=
name|CATEGORY_RANGES
index|[
name|ci
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addRanges
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|addRanges
index|[
name|i
index|]
argument_list|,
name|addRanges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|'P'
condition|)
name|classes
operator|.
name|add
argument_list|(
name|makeCharClass
argument_list|(
name|CATEGORY_Pi
operator|+
name|CATEGORY_Pf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'L'
condition|)
block|{
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Ll
argument_list|)
argument_list|)
expr_stmt|;
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Lu
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|'C'
condition|)
block|{
comment|// JDK 1.4 leaves Cn out of C?
name|classes
operator|.
name|add
argument_list|(
operator|new
name|Subtraction
argument_list|(
operator|new
name|Property
argument_list|(
literal|"Cn"
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Lu
argument_list|)
block|,
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Ll
argument_list|)
block|}
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|List
name|assignedRanges
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CATEGORY_RANGES
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|CATEGORY_RANGES
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|+=
literal|2
control|)
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|classes
operator|.
name|add
argument_list|(
operator|new
name|Subtraction
argument_list|(
operator|new
name|CharRange
argument_list|(
name|NONBMP_MIN
argument_list|,
name|NONBMP_MAX
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
name|assignedRanges
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|classes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
operator|(
name|CharClass
operator|)
name|classes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
return|return
operator|new
name|Union
argument_list|(
name|classes
argument_list|)
return|;
block|}
specifier|static
specifier|private
name|CharClass
name|computeSubCategoryCharClass
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|CharClass
name|base
init|=
operator|new
name|Property
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|sci
init|=
name|CATEGORY_NAMES
operator|.
name|indexOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sci
operator|==
name|Constants
operator|.
name|STRING_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Cn"
argument_list|)
condition|)
block|{
comment|// Unassigned
name|List
name|assignedRanges
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Lu
argument_list|)
argument_list|)
expr_stmt|;
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Ll
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CATEGORY_RANGES
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|CATEGORY_RANGES
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|+=
literal|2
control|)
name|assignedRanges
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|CATEGORY_RANGES
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Subtraction
argument_list|(
operator|new
name|Union
argument_list|(
operator|new
name|CharClass
index|[]
block|{
name|base
block|,
operator|new
name|CharRange
argument_list|(
name|NONBMP_MIN
argument_list|,
name|NONBMP_MAX
argument_list|)
block|}
argument_list|)
argument_list|,
operator|new
name|Union
argument_list|(
name|assignedRanges
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Pi"
argument_list|)
condition|)
return|return
name|makeCharClass
argument_list|(
name|CATEGORY_Pi
argument_list|)
return|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Pf"
argument_list|)
condition|)
return|return
name|makeCharClass
argument_list|(
name|CATEGORY_Pf
argument_list|)
return|;
return|return
name|base
return|;
block|}
name|List
name|classes
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|classes
operator|.
name|add
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|int
index|[]
name|addRanges
init|=
name|CATEGORY_RANGES
index|[
name|sci
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addRanges
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|addRanges
index|[
name|i
index|]
argument_list|,
name|addRanges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Lu"
argument_list|)
condition|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Lu
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Ll"
argument_list|)
condition|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|UNICODE_3_1_ADD_Ll
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Nl"
argument_list|)
condition|)
name|classes
operator|.
name|add
argument_list|(
operator|new
name|CharRange
argument_list|(
name|UNICODE_3_1_CHANGE_No_to_Nl_MIN
argument_list|,
name|UNICODE_3_1_CHANGE_No_to_Nl_MAX
argument_list|)
argument_list|)
expr_stmt|;
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"No"
argument_list|)
condition|)
return|return
operator|new
name|Subtraction
argument_list|(
operator|new
name|Union
argument_list|(
name|classes
argument_list|)
argument_list|,
operator|new
name|CharRange
argument_list|(
name|UNICODE_3_1_CHANGE_No_to_Nl_MIN
argument_list|,
name|UNICODE_3_1_CHANGE_No_to_Nl_MAX
argument_list|)
argument_list|)
return|;
return|return
operator|new
name|Union
argument_list|(
name|classes
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|CharClass
name|makeCharClass
parameter_list|(
name|String
name|members
parameter_list|)
block|{
name|List
name|list
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|members
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|list
operator|.
name|add
argument_list|(
operator|new
name|SingleChar
argument_list|(
name|members
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Union
argument_list|(
name|list
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|RegexSyntaxException
block|{
name|String
name|s
init|=
name|translate
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"xpath"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|len
init|=
name|s
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0x20
operator|&&
name|c
operator|<=
literal|0x7e
condition|)
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|"\\u"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|12
init|;
name|shift
operator|>=
literal|0
condition|;
name|shift
operator|-=
literal|4
control|)
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|"0123456789ABCDEF"
operator|.
name|charAt
argument_list|(
operator|(
name|c
operator|>>
name|shift
operator|)
operator|&
literal|0xF
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|//}
block|}
end_class

begin_comment
comment|//
end_comment

begin_comment
comment|// The contents of this file are subject to the Mozilla Public License Version 1.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License. You may obtain a copy of the
end_comment

begin_comment
comment|// License at http://www.mozilla.org/MPL/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Software distributed under the License is distributed on an "AS IS" basis,
end_comment

begin_comment
comment|// WITHOUT WARRANTY OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing rights and limitations under the License.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Original Code is: all this file except changes marked.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The Initial Developer of the Original Code is James Clark
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Portions created by (your name) are Copyright (C) (your legal entity). All Rights Reserved.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Contributor(s): Michael Kay
end_comment

begin_comment
comment|//
end_comment

end_unit

