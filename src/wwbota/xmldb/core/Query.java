begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  $Header$  * Copyright J.M. Vanel 2003 - under GNU Public Licence.  */
end_comment

begin_package
package|package
name|wwbota
operator|.
name|xmldb
operator|.
name|core
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_comment
comment|/**  *<p>  * Utility to translate a simple Query ï¿½ la Google into an XPath constraints string.  * Modelizes a Query on an XML database.  *</p>  *<p>  * Basic use:  *</p>  *<pre>  * import wwbota.xmldb.core.*;  * Query q = Database.createQuery();  * StringBuffer comment = new StringBuffer();  * q.setPlainQuery(&quot;leaves:glabrous petals:5,yellow&quot;, comment);  * q.setXPathPrefix( "/ * / *" );  * q.setRubricXPath( " * [@*[local-name()='source']] / * / *" );  * String xpath = q.getXPath();  * // launch xpath query to XML database  * // add comment to the response page  *</pre>  *<p>  *</p>  */
end_comment

begin_class
specifier|public
class|class
name|Query
block|{
comment|///////////////////////////////////////
comment|// attributes
comment|/** 	 *<p> 	 * Represents ... 	 *</p> 	 */
specifier|private
name|String
name|XPath
decl_stmt|;
comment|/** 	 *<p> 	 * A query in extended google style, e.g.: 	 *</p> 	 *<p> 	 *&lt;tt&gt;family:Rosaceae basal_leaves:glabrous petals:5,yellow&lt;/tt&gt; 	 *</p> 	 *<p> 	 * where&quot;petals&quot; is an XML tag name, and&quot;5&quot; and&quot;yellow&quot; are strings 	 * wanted inside of&lt;petal&gt; .&quot;basal_leaves:glabrous&quot; means : 	 *</p> 	 *<p> 	 * tag&lt;basal&gt; or attribute&quot;basal&quot; present, or attribute 	 * value&quot;basal&quot;, contained in tag&lt;leaf&gt;, and containing 	 * string&quot;glabrous&quot;. 	 *</p> 	 *  	 */
specifier|private
name|String
name|plainQuery
decl_stmt|;
specifier|private
name|String
name|XPathPrefix
init|=
literal|"/*/*"
decl_stmt|;
specifier|private
name|String
name|XPathConstraints
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|rubricXPath
init|=
literal|"tr[@*[local-name()='source']] / td / *"
decl_stmt|;
comment|///////////////////////////////////////
comment|// associations
comment|/** 	 *<p> 	 * {@link Criterium} objects. 	 *</p> 	 */
specifier|public
name|Collection
name|criterium
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|// of type Criterium
comment|/** 	 *<p> 	 * {@link Species} objects (unused now). 	 *</p> 	 */
specifier|public
name|Collection
name|results
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|// of type Species
comment|/** 	 *<p> 	 *  	 *</p> 	 */
specifier|public
name|Database
name|database
decl_stmt|;
comment|///////////////////////////////////////
comment|// access methods for associations
comment|/** {@link Criterium} objects */
specifier|public
name|Collection
name|getCriteriums
parameter_list|()
block|{
return|return
name|criterium
return|;
block|}
specifier|public
name|void
name|addCriterium
parameter_list|(
name|Criterium
name|criterium
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|criterium
operator|.
name|contains
argument_list|(
name|criterium
argument_list|)
condition|)
block|{
name|this
operator|.
name|criterium
operator|.
name|add
argument_list|(
name|criterium
argument_list|)
expr_stmt|;
name|criterium
operator|.
name|setQuery
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeCriterium
parameter_list|(
name|Criterium
name|criterium
parameter_list|)
block|{
name|boolean
name|removed
init|=
name|this
operator|.
name|criterium
operator|.
name|remove
argument_list|(
name|criterium
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
condition|)
name|criterium
operator|.
name|setQuery
argument_list|(
operator|(
name|Query
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Collection
name|getResultss
parameter_list|()
block|{
return|return
name|results
return|;
block|}
specifier|public
name|void
name|addResults
parameter_list|(
name|Species
name|species
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|results
operator|.
name|contains
argument_list|(
name|species
argument_list|)
condition|)
name|this
operator|.
name|results
operator|.
name|add
argument_list|(
name|species
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeResults
parameter_list|(
name|Species
name|species
parameter_list|)
block|{
name|this
operator|.
name|results
operator|.
name|remove
argument_list|(
name|species
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Database
name|getDatabase
parameter_list|()
block|{
return|return
name|database
return|;
block|}
specifier|public
name|void
name|setDatabase
parameter_list|(
name|Database
name|database
parameter_list|)
block|{
name|this
operator|.
name|database
operator|=
name|database
expr_stmt|;
block|}
comment|///////////////////////////////////////
comment|// operations
comment|/** 	 *<p> 	 * Decodes a plain text query (Google style) such as: 	 * "family:Rosaceae basal_leaves:glabrous petals:5,yellow", 	 * and updates accordingly the XPath query. 	 * It is possible to call setPlainQuery() and setXPathPrefix() in any order, before calling getXPath() or getXPathConstraints(). 	 * TODO: "basal_leaves:glabrous" 	 *</p><p> 	 * @param comment ... 	 *</p><p> 	 *  	 *</p> 	 */
specifier|public
name|void
name|setPlainQuery
parameter_list|(
name|String
name|plainQuery
parameter_list|,
name|java
operator|.
name|lang
operator|.
name|StringBuffer
name|comment
parameter_list|)
block|{
name|this
operator|.
name|plainQuery
operator|=
name|plainQuery
expr_stmt|;
name|XPathConstraints
operator|=
literal|""
expr_stmt|;
comment|// XPath = "/flora/table/tr[//stem[contains(.,'compact')]]";
comment|// suppress initial blank(s):
name|plainQuery
operator|=
name|plainQuery
operator|.
name|replaceFirst
argument_list|(
literal|"^ +"
comment|/*regex*/
argument_list|,
literal|""
comment|/*replacement*/
argument_list|)
expr_stmt|;
name|String
index|[]
name|criteriaStrings
init|=
name|plainQuery
operator|.
name|split
argument_list|(
literal|" +"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|criteriaStrings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|crit
init|=
name|criteriaStrings
index|[
name|i
index|]
decl_stmt|;
name|Criterium
index|[]
name|criteria
init|=
name|makeCriteria
argument_list|(
name|crit
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|criteria
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Criterium
name|criter
init|=
name|criteria
index|[
name|j
index|]
decl_stmt|;
name|XPathConstraints
operator|+=
name|criter
operator|.
name|getXPath
argument_list|()
expr_stmt|;
name|criter
operator|.
name|setRubricXPath
argument_list|(
name|getRubricXPath
argument_list|()
argument_list|)
expr_stmt|;
name|addCriterium
argument_list|(
name|criter
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: check the existence of the Organs in the database
name|comment
operator|.
name|append
argument_list|(
literal|"\""
operator|+
name|plainQuery
operator|+
literal|"\" was a very beautiful query!"
argument_list|)
expr_stmt|;
block|}
comment|// end setPlainQuery
comment|/**      * @param crit something without spaces like "petal:5,yellow" or just "petal:",  or just "edible". */
specifier|private
name|Criterium
index|[]
name|makeCriteria
parameter_list|(
name|String
name|crit
parameter_list|)
block|{
name|String
index|[]
name|s
init|=
name|crit
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|String
name|tagName
init|=
literal|"*"
decl_stmt|;
comment|// just "edible"
name|String
name|contains
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|crit
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
operator|>
operator|-
literal|1
condition|)
name|tagName
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
comment|// "petal:yellow" or just "petal:"
else|else
name|contains
operator|=
name|crit
expr_stmt|;
name|Organ
name|org
init|=
name|Metadata
operator|.
name|createOrgan
argument_list|(
name|tagName
argument_list|)
decl_stmt|;
name|Criterium
index|[]
name|returnValue
init|=
operator|new
name|Criterium
index|[
literal|1
index|]
decl_stmt|;
comment|// We can have a plain Organ with no ":" after or nothing after the ":"
if|if
condition|(
name|s
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|String
name|constraintsString
init|=
name|s
index|[
literal|1
index|]
decl_stmt|;
comment|// We really have something after the ":"
name|contains
operator|=
name|constraintsString
expr_stmt|;
comment|// Do we have something like "petals:5,yellow" ?
name|String
index|[]
name|constraints
init|=
name|constraintsString
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|constraints
operator|.
name|length
operator|>
literal|1
condition|)
name|returnValue
operator|=
operator|new
name|Criterium
index|[
name|constraints
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|constraints
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|returnValue
index|[
name|i
index|]
operator|=
operator|new
name|Criterium
argument_list|(
name|org
argument_list|,
name|constraints
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Criterium
name|c
init|=
operator|new
name|Criterium
argument_list|(
name|org
argument_list|,
name|contains
argument_list|)
decl_stmt|;
name|returnValue
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
name|returnValue
return|;
block|}
specifier|public
specifier|static
specifier|final
name|String
name|testSimpleQuery
init|=
literal|"family:Rosaceae  petals:5,yellow spine: edible "
decl_stmt|;
specifier|public
specifier|static
name|boolean
name|test
parameter_list|(
name|Query
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|==
literal|null
condition|)
name|q
operator|=
operator|new
name|Query
argument_list|()
expr_stmt|;
name|StringBuffer
name|comment
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|q
operator|.
name|setPlainQuery
argument_list|(
name|testSimpleQuery
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|String
name|correctXPathQuery
init|=
name|q
operator|.
name|getXPathPrefix
argument_list|()
operator|+
literal|"[.//family[contains(.,'Rosaceae')]][.//petals[contains(.,'5')]][.//petals[contains(.,'yellow')]][.//spine][.//*[contains(.,'edible')]]"
decl_stmt|;
name|boolean
name|res
init|=
name|q
operator|.
name|getXPath
argument_list|()
operator|.
name|equals
argument_list|(
name|correctXPathQuery
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Query.q.getXPath(): "
operator|+
name|q
operator|.
name|getXPath
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"     correct: "
operator|+
name|correctXPathQuery
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/** 	 * get absolute XPath ( == XPathPrefix + XPathConstraints ). 	 */
specifier|public
name|String
name|getXPath
parameter_list|()
block|{
return|return
name|XPathPrefix
operator|+
name|XPathConstraints
return|;
block|}
specifier|public
name|String
name|getPlainQuery
parameter_list|()
block|{
return|return
name|plainQuery
return|;
block|}
specifier|public
name|void
name|setXPathPrefix
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|XPathPrefix
operator|=
name|s
expr_stmt|;
block|}
specifier|public
name|String
name|getXPathPrefix
parameter_list|()
block|{
return|return
name|XPathPrefix
return|;
block|}
specifier|public
name|String
name|getXPathConstraints
parameter_list|()
block|{
return|return
name|XPathConstraints
return|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|boolean
name|res
init|=
name|Query
operator|.
name|test
argument_list|(
operator|new
name|Query
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Query.test(): "
operator|+
name|res
argument_list|)
expr_stmt|;
block|}
comment|/** This property is the relative XPath match for a rubric or Organ, e.g. 		species 		or : 		flora/* 	 * Used in highlight of XML:DB search result; CAUTION: must be called before setPlainQuery() . 	*/
specifier|public
name|void
name|setRubricXPath
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|rubricXPath
operator|=
name|s
expr_stmt|;
block|}
specifier|public
name|String
name|getRubricXPath
parameter_list|()
block|{
return|return
name|rubricXPath
return|;
block|}
comment|/** A human-readable account of the Query;         *   application should prepend something like "You have asked for a taxon containing " . 	*/
specifier|public
name|String
name|getExplanation
parameter_list|()
block|{
name|String
name|returnValue
init|=
literal|""
decl_stmt|;
name|Iterator
name|it
init|=
name|getCriteriums
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Criterium
name|crit
init|=
operator|(
name|Criterium
operator|)
operator|(
name|it
operator|.
name|next
argument_list|()
operator|)
decl_stmt|;
name|returnValue
operator|+=
name|crit
operator|.
name|getExplanation
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|returnValue
operator|+=
literal|", "
expr_stmt|;
block|}
return|return
name|returnValue
return|;
block|}
block|}
end_class

begin_comment
comment|// end Query
end_comment

end_unit

