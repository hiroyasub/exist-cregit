begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* eXist Open Source Native XML Database  *  Copyright (C) 2001-2014 The eXist Project  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License  * as published by the Free Software Foundation; either version 2  * of the License, or (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  *  * $Id:  */
end_comment

begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|dom
package|;
end_package

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|memtree
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|dom
operator|.
name|QName
operator|.
name|IllegalQNameException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|exist
operator|.
name|util
operator|.
name|hashtable
operator|.
name|Object2ObjectHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * @author Adam Retter<adam.retter@googlemail.com>  */
end_comment

begin_class
specifier|public
class|class
name|NamedNodeMapImpl
implements|implements
name|NamedNodeMap
block|{
comment|// NamedNodeMap is used by attributes, and it is often
comment|// rare that an element has more then 10 attributes
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_SIZE
init|=
literal|10
decl_stmt|;
specifier|private
specifier|final
name|IndexedHashMap
argument_list|<
name|QName
argument_list|,
name|Node
argument_list|>
name|namedNodes
init|=
operator|new
name|IndexedHashMap
argument_list|<>
argument_list|(
name|DEFAULT_SIZE
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Document
name|ownerDocument
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|attributesOnly
decl_stmt|;
specifier|public
name|NamedNodeMapImpl
parameter_list|(
specifier|final
name|Document
name|ownerDocument
parameter_list|,
specifier|final
name|boolean
name|attributesOnly
parameter_list|)
block|{
name|this
operator|.
name|ownerDocument
operator|=
name|ownerDocument
expr_stmt|;
name|this
operator|.
name|attributesOnly
operator|=
name|attributesOnly
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Node
name|getNamedItem
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
try|try
block|{
return|return
name|getNamedItem
argument_list|(
operator|new
name|QName
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|QName
operator|.
name|IllegalQNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DOMException
argument_list|(
name|DOMException
operator|.
name|INVALID_CHARACTER_ERR
argument_list|,
literal|"Invalid name"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Node
name|getNamedItemNS
parameter_list|(
specifier|final
name|String
name|namespaceURI
parameter_list|,
specifier|final
name|String
name|localName
parameter_list|)
throws|throws
name|DOMException
block|{
return|return
name|getNamedItem
argument_list|(
operator|new
name|QName
argument_list|(
name|localName
argument_list|,
name|namespaceURI
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|Node
name|getNamedItem
parameter_list|(
specifier|final
name|QName
name|qname
parameter_list|)
block|{
return|return
name|namedNodes
operator|.
name|get
argument_list|(
name|qname
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Node
name|setNamedItem
parameter_list|(
specifier|final
name|Node
name|arg
parameter_list|)
throws|throws
name|DOMException
block|{
try|try
block|{
return|return
name|setNamedItem
argument_list|(
operator|new
name|QName
argument_list|(
name|arg
operator|.
name|getNodeName
argument_list|()
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|QName
operator|.
name|IllegalQNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DOMException
argument_list|(
name|DOMException
operator|.
name|INVALID_CHARACTER_ERR
argument_list|,
literal|"Invalid name"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Node
name|setNamedItemNS
parameter_list|(
specifier|final
name|Node
name|arg
parameter_list|)
throws|throws
name|DOMException
block|{
return|return
name|setNamedItem
argument_list|(
operator|new
name|QName
argument_list|(
name|arg
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|arg
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
block|}
comment|/**      * Adds an INode to the NamedNodeMap      *      * The INode#getQName method is called      * to get the name for the map item      *      * @return The previous node of the same name if it exists      */
specifier|public
name|Node
name|setNamedItem
parameter_list|(
specifier|final
name|INode
name|arg
parameter_list|)
throws|throws
name|DOMException
block|{
return|return
name|setNamedItem
argument_list|(
name|arg
operator|.
name|getQName
argument_list|()
argument_list|,
name|arg
argument_list|)
return|;
block|}
specifier|private
name|Node
name|setNamedItem
parameter_list|(
specifier|final
name|QName
name|qname
parameter_list|,
specifier|final
name|Node
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|(
name|arg
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|DOCUMENT_NODE
operator|&&
name|arg
operator|!=
name|ownerDocument
operator|)
operator|||
name|arg
operator|.
name|getOwnerDocument
argument_list|()
operator|!=
name|ownerDocument
condition|)
block|{
throw|throw
operator|new
name|DOMException
argument_list|(
name|DOMException
operator|.
name|WRONG_DOCUMENT_ERR
argument_list|,
literal|"Owning document IDs do not match"
argument_list|)
throw|;
block|}
comment|// NOTE the Type.Namespace is needed below to cope with eXist-db's {@link org.exist.dom.memtree.NamespaceNode}
if|if
condition|(
name|attributesOnly
operator|&&
operator|(
name|arg
operator|.
name|getNodeType
argument_list|()
operator|!=
name|Node
operator|.
name|ATTRIBUTE_NODE
operator|&&
name|arg
operator|.
name|getNodeType
argument_list|()
operator|!=
name|NodeImpl
operator|.
name|NAMESPACE_NODE
operator|)
condition|)
block|{
throw|throw
operator|new
name|DOMException
argument_list|(
name|DOMException
operator|.
name|HIERARCHY_REQUEST_ERR
argument_list|,
literal|"This map is for attributes, but setNamedItem was called on a: "
operator|+
name|arg
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|namedNodes
operator|.
name|put
argument_list|(
name|qname
argument_list|,
name|arg
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Node
name|removeNamedItem
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|DOMException
block|{
try|try
block|{
return|return
name|removeNamedItem
argument_list|(
operator|new
name|QName
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IllegalQNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DOMException
argument_list|(
name|DOMException
operator|.
name|INVALID_CHARACTER_ERR
argument_list|,
literal|"Invalid name"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Node
name|removeNamedItemNS
parameter_list|(
specifier|final
name|String
name|namespaceURI
parameter_list|,
specifier|final
name|String
name|localName
parameter_list|)
throws|throws
name|DOMException
block|{
return|return
name|removeNamedItem
argument_list|(
operator|new
name|QName
argument_list|(
name|localName
argument_list|,
name|namespaceURI
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|Node
name|removeNamedItem
parameter_list|(
specifier|final
name|QName
name|qname
parameter_list|)
throws|throws
name|DOMException
block|{
specifier|final
name|Node
name|previous
init|=
name|namedNodes
operator|.
name|remove
argument_list|(
name|qname
argument_list|)
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
literal|null
condition|)
block|{
return|return
name|previous
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|DOMException
argument_list|(
name|DOMException
operator|.
name|NOT_FOUND_ERR
argument_list|,
literal|"No such named value is present in the map"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Node
name|item
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|namedNodes
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|namedNodes
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|namedNodes
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
specifier|static
specifier|final
class|class
name|IndexedHashMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
specifier|private
specifier|final
name|Object2ObjectHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|K
argument_list|>
name|keys
decl_stmt|;
specifier|public
name|IndexedHashMap
parameter_list|(
specifier|final
name|int
name|initialSize
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
operator|new
name|Object2ObjectHashMap
argument_list|<>
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|keys
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|final
name|V
name|put
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
specifier|final
name|V
name|value
parameter_list|)
block|{
specifier|final
name|V
name|current
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|current
return|;
block|}
specifier|public
specifier|final
name|V
name|get
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|V
name|get
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * @return The removed value or null if there is          *  no value for the key in the nap          */
specifier|public
specifier|final
name|V
name|remove
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
if|if
condition|(
name|keys
operator|.
name|remove
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|keys
operator|.
name|size
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

