begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|exist
operator|.
name|storage
operator|.
name|btree
package|;
end_package

begin_comment
comment|/*  * dbXML License, Version 1.0  *  *  * Copyright (c) 1999-2001 The dbXML Group, L.L.C.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by  *        The dbXML Group (http://www.dbxml.com/)."  *    Alternately, this acknowledgment may appear in the software  *    itself, if and wherever such third-party acknowledgments normally  *    appear.  *  * 4. The names "dbXML" and "The dbXML Group" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    info@dbxml.com.  *  * 5. Products derived from this software may not be called "dbXML",  *    nor may "dbXML" appear in their name, without prior written  *    permission of The dbXML Group.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE DBXML GROUP OR ITS CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id$  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * IndexQuery represents the most primitive form of index querying.  * Instances of this object should be created by QueryResolvers and  * cached in Query instances.  */
end_comment

begin_class
specifier|public
class|class
name|IndexQuery
block|{
comment|// No Operator
specifier|public
specifier|static
specifier|final
name|int
name|ANY
init|=
literal|0
decl_stmt|;
comment|// Any And All Matches
comment|// Singleton Operators
specifier|public
specifier|static
specifier|final
name|int
name|EQ
init|=
literal|1
decl_stmt|;
comment|// Equal To
specifier|public
specifier|static
specifier|final
name|int
name|NEQ
init|=
operator|-
literal|1
decl_stmt|;
comment|// Not Equal To
specifier|public
specifier|static
specifier|final
name|int
name|GT
init|=
literal|2
decl_stmt|;
comment|// Greater Than
specifier|public
specifier|static
specifier|final
name|int
name|LEQ
init|=
operator|-
literal|2
decl_stmt|;
comment|// Less Than Or Equal To
specifier|public
specifier|static
specifier|final
name|int
name|LT
init|=
literal|3
decl_stmt|;
comment|// Less Than
specifier|public
specifier|static
specifier|final
name|int
name|GEQ
init|=
operator|-
literal|3
decl_stmt|;
comment|// Greater Than Or Equal To
comment|// Range Operators
specifier|public
specifier|static
specifier|final
name|int
name|BW
init|=
literal|4
decl_stmt|;
comment|// Between (Inclusive)
specifier|public
specifier|static
specifier|final
name|int
name|NBW
init|=
operator|-
literal|4
decl_stmt|;
comment|// Not Between (Inclusive)
specifier|public
specifier|static
specifier|final
name|int
name|BWX
init|=
literal|5
decl_stmt|;
comment|// Between (Exclusive)
specifier|public
specifier|static
specifier|final
name|int
name|NBWX
init|=
operator|-
literal|5
decl_stmt|;
comment|// Not Between (Exclusive)
comment|// Set Operators
specifier|public
specifier|static
specifier|final
name|int
name|IN
init|=
literal|6
decl_stmt|;
comment|// In The Set
specifier|public
specifier|static
specifier|final
name|int
name|NIN
init|=
operator|-
literal|6
decl_stmt|;
comment|// Not In The Set
comment|// Truncation Operator
specifier|public
specifier|static
specifier|final
name|int
name|TRUNC_RIGHT
init|=
literal|7
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|TRUNC_LEFT
init|=
literal|8
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|REGEXP
init|=
literal|9
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|RANGE
init|=
literal|10
decl_stmt|;
specifier|protected
name|int
name|op
decl_stmt|;
specifier|protected
name|Value
index|[]
name|vals
decl_stmt|;
specifier|public
name|IndexQuery
parameter_list|()
block|{
name|op
operator|=
name|ANY
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|int
name|op
parameter_list|,
name|Value
index|[]
name|vals
parameter_list|)
block|{
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|this
operator|.
name|vals
operator|=
name|vals
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|Value
index|[]
name|vals
parameter_list|)
block|{
name|this
argument_list|(
name|IN
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|int
name|op
parameter_list|,
name|Value
name|val1
parameter_list|)
block|{
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|vals
operator|=
operator|new
name|Value
index|[]
block|{
name|val1
block|}
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|Value
name|val1
parameter_list|)
block|{
name|this
argument_list|(
name|EQ
argument_list|,
name|val1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|int
name|op
parameter_list|,
name|Value
name|val1
parameter_list|,
name|Value
name|val2
parameter_list|)
block|{
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|vals
operator|=
operator|new
name|Value
index|[]
block|{
name|val1
block|,
name|val2
block|}
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|Value
name|val1
parameter_list|,
name|Value
name|val2
parameter_list|)
block|{
name|this
argument_list|(
name|IN
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|int
name|op
parameter_list|,
name|String
name|val1
parameter_list|)
block|{
name|this
argument_list|(
name|op
argument_list|,
operator|new
name|Value
argument_list|(
name|val1
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|String
name|val1
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|Value
argument_list|(
name|val1
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|int
name|op
parameter_list|,
name|String
name|val1
parameter_list|,
name|String
name|val2
parameter_list|)
block|{
name|this
argument_list|(
name|op
argument_list|,
operator|new
name|Value
argument_list|(
name|val1
argument_list|)
argument_list|,
operator|new
name|Value
argument_list|(
name|val2
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexQuery
parameter_list|(
name|String
name|val1
parameter_list|,
name|String
name|val2
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|Value
argument_list|(
name|val1
argument_list|)
argument_list|,
operator|new
name|Value
argument_list|(
name|val2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * getOperator returns the operator associated with this query.     *     * @return The operator     */
specifier|public
name|int
name|getOperator
parameter_list|()
block|{
return|return
name|op
return|;
block|}
comment|/**     * getValue returns one of the Values associated with this query.     *     * @param index The Value index     * @return The request Value     */
specifier|public
specifier|final
name|Value
name|getValue
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|vals
index|[
name|index
index|]
return|;
block|}
comment|/**     * getValues returns the Values associated with this query.     *     * @return The Value set     */
specifier|public
name|Value
index|[]
name|getValues
parameter_list|()
block|{
return|return
name|vals
return|;
block|}
comment|/**     * getLength returns the length of the Value set associated with     * this query.     *     * @return The Value set length     */
specifier|public
specifier|final
name|int
name|getLength
parameter_list|()
block|{
return|return
name|vals
operator|.
name|length
return|;
block|}
comment|/**     * testValue tests the specified value for validity against this     * IndexQuery.  The helper classes in org.dbxml.core.indexer.helpers     * should be used for optimized performance.     *     * @param value The Value to compare     * @return Whether or not the value matches     */
specifier|public
name|boolean
name|testValue
parameter_list|(
name|Value
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
comment|// No Comparison (Any)
case|case
name|ANY
case|:
return|return
literal|true
return|;
comment|// Singleton Comparisons
case|case
name|EQ
case|:
return|return
name|value
operator|.
name|equals
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|NEQ
case|:
return|return
operator|!
name|value
operator|.
name|equals
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|GT
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>
literal|0
return|;
case|case
name|GEQ
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>=
literal|0
return|;
case|case
name|LT
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
return|;
case|case
name|LEQ
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|<=
literal|0
return|;
comment|// Range Comparisons
case|case
name|BW
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>=
literal|0
operator|&&
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|1
index|]
argument_list|)
operator|<=
literal|0
return|;
case|case
name|NBW
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|<=
literal|0
operator|||
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|1
index|]
argument_list|)
operator|>=
literal|0
return|;
case|case
name|BWX
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
return|;
case|case
name|NBWX
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
return|;
case|case
name|RANGE
case|:
return|return
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>=
literal|0
operator|&&
name|value
operator|.
name|compareTo
argument_list|(
name|vals
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
return|;
comment|// Set Comparisons
case|case
name|IN
case|:
case|case
name|NIN
case|:
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|vals
argument_list|,
name|value
argument_list|)
operator|>=
literal|0
condition|?
name|op
operator|==
name|IN
else|:
name|op
operator|==
name|NIN
return|;
case|case
name|TRUNC_RIGHT
case|:
return|return
name|value
operator|.
name|startsWith
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|TRUNC_LEFT
case|:
return|return
name|value
operator|.
name|endsWith
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**     * testValue tests the specified value for validity against this     * IndexQuery.  The helper classes in org.dbxml.core.indexer.helpers     * should be used for optimized performance.     *     * @param value The Value to compare     * @return Whether or not the value matches     */
specifier|public
specifier|final
name|boolean
name|testValue
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|testValue
argument_list|(
operator|new
name|Value
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

